<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>泛等结构集合论 (3) 序数的定义及其泛等原理</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">泛等结构集合论 (3) 序数的定义及其泛等原理</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#泛等结构集合论-3-序数的定义及其泛等原理" id="toc-泛等结构集合论-3-序数的定义及其泛等原理">泛等结构集合论 (3) 序数的定义及其泛等原理</a>
  <ul>
  <li><a href="#序关系的一些性质" id="toc-序关系的一些性质">序关系的一些性质</a>
  <ul>
  <li><a href="#命题性" id="toc-命题性">命题性</a></li>
  <li><a href="#反自反性" id="toc-反自反性">反自反性</a></li>
  <li><a href="#传递性" id="toc-传递性">传递性</a></li>
  <li><a href="#外延性" id="toc-外延性">外延性</a></li>
  <li><a href="#良基性" id="toc-良基性">良基性</a></li>
  <li><a href="#良基归纳法" id="toc-良基归纳法">良基归纳法</a></li>
  <li><a href="#良序性" id="toc-良序性">良序性</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a>
  <ul>
  <li><a href="#序数结构" id="toc-序数结构">序数结构</a></li>
  <li><a href="#序数宇宙" id="toc-序数宇宙">序数宇宙</a></li>
  <li><a href="#底序" id="toc-底序">底序</a></li>
  </ul></li>
  <li><a href="#序数等价" id="toc-序数等价">序数等价</a></li>
  <li><a href="#序数的泛等原理" id="toc-序数的泛等原理">序数的泛等原理</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="泛等结构集合论-3-序数的定义及其泛等原理">泛等结构集合论 (3) 序数的定义及其泛等原理</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/USST/blob/main/src/Ordinal/Base.lagda.md">Ordinal.Base.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/USST/Ordinal.Base.html">Ordinal.Base.html</a></p>
</blockquote>
<p>本章将复刻质料集合论的重要概念: 序数.</p>
<pre class="Agda"><a id="385" class="Symbol">{-#</a> <a id="389" class="Keyword">OPTIONS</a> <a id="397" class="Pragma">--cubical</a> <a id="407" class="Pragma">--safe</a> <a id="414" class="Symbol">#-}</a>
<a id="418" class="Symbol">{-#</a> <a id="422" class="Keyword">OPTIONS</a> <a id="430" class="Pragma">--hidden-argument-puns</a> <a id="453" class="Symbol">#-}</a>
<a id="457" class="Keyword">module</a> <a id="464" href="Ordinal.Base.html" class="Module">Ordinal.Base</a> <a id="477" class="Keyword">where</a>
<a id="483" class="Keyword">open</a> <a id="488" class="Keyword">import</a> <a id="495" href="Preliminary.html" class="Module">Preliminary</a>
</pre>
<h2 id="序关系的一些性质">序关系的一些性质</h2>
<p>说白了, 一个序数就是由一个集合以及该集合上的一个满足一定性质的序关系所组成的结构. 我们先定义这个序关系需要满足的性质.</p>
<p>给定类型 <code>A : Type 𝓊</code> 及其上的序关系 <code>_≺_ : A → A → Type 𝓋</code></p>
<pre class="Agda"><a id="646" class="Keyword">module</a> <a id="BinaryRelation"></a><a id="653" href="Ordinal.Base.html#653" class="Module">BinaryRelation</a> <a id="668" class="Symbol">{</a><a id="669" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="671" class="Symbol">:</a> <a id="673" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="678" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="679" class="Symbol">}</a> <a id="681" class="Symbol">(</a><a id="682" href="Ordinal.Base.html#682" class="Bound Operator">_≺_</a> <a id="686" class="Symbol">:</a> <a id="688" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="690" class="Symbol">→</a> <a id="692" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="694" class="Symbol">→</a> <a id="696" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="701" href="Preliminary.html#2698" class="Generalizable">𝓋</a><a id="702" class="Symbol">)</a> <a id="704" class="Keyword">where</a>
</pre>
<h3 id="命题性">命题性</h3>
<p>我们说 <code>_≺_</code> 是一个 <strong>命题 (propositional)</strong> 关系, 当且仅当对任意 <code>x y : A</code>, <code>x ≺ y</code> 是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.Propositional"></a><a id="810" href="Ordinal.Base.html#810" class="Function">Propositional</a> <a id="824" class="Symbol">:</a> <a id="826" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="831" class="Symbol">_</a>
  <a id="835" href="Ordinal.Base.html#810" class="Function">Propositional</a> <a id="849" class="Symbol">=</a> <a id="851" class="Symbol">∀</a> <a id="853" href="Ordinal.Base.html#853" class="Bound">x</a> <a id="855" href="Ordinal.Base.html#855" class="Bound">y</a> <a id="857" class="Symbol">→</a> <a id="859" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="866" class="Symbol">(</a><a id="867" href="Ordinal.Base.html#853" class="Bound">x</a> <a id="869" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="871" href="Ordinal.Base.html#855" class="Bound">y</a><a id="872" class="Symbol">)</a>
</pre>
<p>命题性本身是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropPropositional"></a><a id="902" href="Ordinal.Base.html#902" class="Function">isPropPropositional</a> <a id="922" class="Symbol">:</a> <a id="924" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="931" href="Ordinal.Base.html#810" class="Function">Propositional</a>
  <a id="947" href="Ordinal.Base.html#902" class="Function">isPropPropositional</a> <a id="967" class="Symbol">=</a> <a id="969" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="978" class="Symbol">λ</a> <a id="980" href="Ordinal.Base.html#980" class="Bound">_</a> <a id="982" href="Ordinal.Base.html#982" class="Bound">_</a> <a id="984" class="Symbol">→</a> <a id="986" href="Cubical.Foundations.Prelude.html#18995" class="Function">isPropIsProp</a>
</pre>
<h3 id="反自反性">反自反性</h3>
<p>我们说 <code>_≺_</code> 是一个 <strong>反自反 (irreflexive)</strong> 关系, 当且仅当对任意 <code>x : A</code>, <code>x ⊀ x</code>.</p>
<pre class="Agda">  <a id="BinaryRelation._⊀_"></a><a id="1091" href="Ordinal.Base.html#1091" class="Function Operator">_⊀_</a> <a id="1095" class="Symbol">:</a> <a id="1097" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="1099" class="Symbol">→</a> <a id="1101" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="1103" class="Symbol">→</a> <a id="1105" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1110" href="Ordinal.Base.html#701" class="Bound">𝓋</a>
  <a id="1114" href="Ordinal.Base.html#1114" class="Bound">x</a> <a id="1116" href="Ordinal.Base.html#1091" class="Function Operator">⊀</a> <a id="1118" href="Ordinal.Base.html#1118" class="Bound">y</a> <a id="1120" class="Symbol">=</a> <a id="1122" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="1124" href="Ordinal.Base.html#1114" class="Bound">x</a> <a id="1126" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1128" href="Ordinal.Base.html#1118" class="Bound">y</a>

  <a id="BinaryRelation.Irreflexive"></a><a id="1133" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a> <a id="1145" class="Symbol">:</a> <a id="1147" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1152" class="Symbol">_</a>
  <a id="1156" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a> <a id="1168" class="Symbol">=</a> <a id="1170" class="Symbol">∀</a> <a id="1172" href="Ordinal.Base.html#1172" class="Bound">x</a> <a id="1174" class="Symbol">→</a> <a id="1176" href="Ordinal.Base.html#1172" class="Bound">x</a> <a id="1178" href="Ordinal.Base.html#1091" class="Function Operator">⊀</a> <a id="1180" href="Ordinal.Base.html#1172" class="Bound">x</a>
</pre>
<p>反自反性是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropIrreflexive"></a><a id="1209" href="Ordinal.Base.html#1209" class="Function">isPropIrreflexive</a> <a id="1227" class="Symbol">:</a> <a id="1229" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="1236" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a>
  <a id="1250" href="Ordinal.Base.html#1209" class="Function">isPropIrreflexive</a> <a id="1268" class="Symbol">=</a> <a id="1270" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="1279" class="Symbol">λ</a> <a id="1281" href="Ordinal.Base.html#1281" class="Bound">_</a> <a id="1283" href="Ordinal.Base.html#1283" class="Bound">_</a> <a id="1285" class="Symbol">→</a> <a id="1287" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
</pre>
<h3 id="传递性">传递性</h3>
<p>我们说 <code>_≺_</code> 是一个 <strong>传递 (transitive)</strong> 关系, 当且仅当对任意 <code>x y z : A</code>, <code>x ≺ y</code> 与 <code>y ≺ z</code> 蕴含 <code>x ≺ z</code>.</p>
<pre class="Agda">  <a id="BinaryRelation.Transitive"></a><a id="1409" href="Ordinal.Base.html#1409" class="Function">Transitive</a> <a id="1420" class="Symbol">:</a> <a id="1422" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1427" class="Symbol">_</a>
  <a id="1431" href="Ordinal.Base.html#1409" class="Function">Transitive</a> <a id="1442" class="Symbol">=</a> <a id="1444" class="Symbol">∀</a> <a id="1446" href="Ordinal.Base.html#1446" class="Bound">x</a> <a id="1448" href="Ordinal.Base.html#1448" class="Bound">y</a> <a id="1450" href="Ordinal.Base.html#1450" class="Bound">z</a> <a id="1452" class="Symbol">→</a> <a id="1454" href="Ordinal.Base.html#1446" class="Bound">x</a> <a id="1456" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1458" href="Ordinal.Base.html#1448" class="Bound">y</a> <a id="1460" class="Symbol">→</a> <a id="1462" href="Ordinal.Base.html#1448" class="Bound">y</a> <a id="1464" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1466" href="Ordinal.Base.html#1450" class="Bound">z</a> <a id="1468" class="Symbol">→</a> <a id="1470" href="Ordinal.Base.html#1446" class="Bound">x</a> <a id="1472" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1474" href="Ordinal.Base.html#1450" class="Bound">z</a>
</pre>
<p>如果<code>_≺_</code> 是一个命题关系, 那么传递性是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropTransitive"></a><a id="1521" href="Ordinal.Base.html#1521" class="Function">isPropTransitive</a> <a id="1538" class="Symbol">:</a> <a id="1540" href="Ordinal.Base.html#810" class="Function">Propositional</a> <a id="1554" class="Symbol">→</a> <a id="1556" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="1563" href="Ordinal.Base.html#1409" class="Function">Transitive</a>
  <a id="1576" href="Ordinal.Base.html#1521" class="Function">isPropTransitive</a> <a id="1593" href="Ordinal.Base.html#1593" class="Bound">prop</a> <a id="1598" class="Symbol">=</a> <a id="1600" href="Cubical.Foundations.HLevels.html#16992" class="Function">isPropΠ5</a> <a id="1609" class="Symbol">λ</a> <a id="1611" href="Ordinal.Base.html#1611" class="Bound">_</a> <a id="1613" href="Ordinal.Base.html#1613" class="Bound">_</a> <a id="1615" href="Ordinal.Base.html#1615" class="Bound">_</a> <a id="1617" href="Ordinal.Base.html#1617" class="Bound">_</a> <a id="1619" href="Ordinal.Base.html#1619" class="Bound">_</a> <a id="1621" class="Symbol">→</a> <a id="1623" href="Ordinal.Base.html#1593" class="Bound">prop</a> <a id="1628" class="Symbol">_</a> <a id="1630" class="Symbol">_</a>
</pre>
<h3 id="外延性">外延性</h3>
<p>我们说 <code>_≺_</code> 是一个 <strong>外延 (extensional)</strong> 关系, 当且仅当对任意 <code>x y : A</code>, 如果对任意 <code>z : A</code> 都有 <code>z ≺ x</code> 当且仅当 <code>z ≺ y</code>, 那么 <code>x ≡ y</code>.</p>
<pre class="Agda">  <a id="BinaryRelation.Extensional"></a><a id="1766" href="Ordinal.Base.html#1766" class="Function">Extensional</a> <a id="1778" class="Symbol">:</a> <a id="1780" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1785" class="Symbol">_</a>
  <a id="1789" href="Ordinal.Base.html#1766" class="Function">Extensional</a> <a id="1801" class="Symbol">=</a> <a id="1803" class="Symbol">∀</a> <a id="1805" href="Ordinal.Base.html#1805" class="Bound">x</a> <a id="1807" href="Ordinal.Base.html#1807" class="Bound">y</a> <a id="1809" class="Symbol">→</a> <a id="1811" class="Symbol">(∀</a> <a id="1814" href="Ordinal.Base.html#1814" class="Bound">z</a> <a id="1816" class="Symbol">→</a> <a id="1818" href="Ordinal.Base.html#1814" class="Bound">z</a> <a id="1820" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1822" href="Ordinal.Base.html#1805" class="Bound">x</a> <a id="1824" href="Preliminary.html#14438" class="Function Operator">↔</a> <a id="1826" href="Ordinal.Base.html#1814" class="Bound">z</a> <a id="1828" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="1830" href="Ordinal.Base.html#1807" class="Bound">y</a><a id="1831" class="Symbol">)</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="Ordinal.Base.html#1805" class="Bound">x</a> <a id="1837" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1839" href="Ordinal.Base.html#1807" class="Bound">y</a>
</pre>
<p>如果 <code>A</code> 是集合, 那么外延性是命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropExtensional"></a><a id="1879" href="Ordinal.Base.html#1879" class="Function">isPropExtensional</a> <a id="1897" class="Symbol">:</a> <a id="1899" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="1905" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="1907" class="Symbol">→</a> <a id="1909" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="1916" href="Ordinal.Base.html#1766" class="Function">Extensional</a>
  <a id="1930" href="Ordinal.Base.html#1879" class="Function">isPropExtensional</a> <a id="1948" href="Ordinal.Base.html#1948" class="Bound">A-set</a> <a id="1954" class="Symbol">=</a> <a id="1956" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="1965" class="Symbol">λ</a> <a id="1967" href="Ordinal.Base.html#1967" class="Bound">_</a> <a id="1969" href="Ordinal.Base.html#1969" class="Bound">_</a> <a id="1971" href="Ordinal.Base.html#1971" class="Bound">_</a> <a id="1973" class="Symbol">→</a> <a id="1975" href="Ordinal.Base.html#1948" class="Bound">A-set</a> <a id="1981" class="Symbol">_</a> <a id="1983" class="Symbol">_</a>
</pre>
<p><strong>引理</strong> 如果 <code>_≺_</code> 同时具有命题性和外延性那么 <code>A</code> 是集合.<br />
<strong>证明梗概</strong> 由引理 <code>Collapsible≡→isSet</code>, 只要证明 <code>A</code> 上的相等类型 <code>x ≡ y</code> 可折叠, 就证明了 <code>A</code> 是集合. 可折叠是说能构造 <code>x ≡ y</code> 的自映射 <code>f</code> 且 <code>f</code> 是一个 2-常函数 (<code>∀ x y → f x ≡ f y</code>). 只要用作为自变量的那个 <code>eq : x ≡ y</code> 替换外延性的前提 <code>z ≺ x ↔︎ z ≺ y</code> 就能得到另一个 <code>x ≡ y</code>. 由于 <code>_≺_</code> 是命题, 所以 <code>z ≺ x ↔︎ z ≺ y</code> 是命题, 所以 <code>f</code> 是 2-常函数. ∎</p>
<pre class="Agda">  <a id="2308" class="Keyword">open</a> <a id="2313" class="Keyword">import</a> <a id="2320" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a> <a id="2349" class="Keyword">using</a> <a id="2355" class="Symbol">(</a><a id="2356" href="Cubical.Foundations.Function.html#2864" class="Function">2-Constant</a><a id="2366" class="Symbol">)</a>
  <a id="2370" class="Keyword">open</a> <a id="2375" class="Keyword">import</a> <a id="2382" href="Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a> <a id="2407" class="Keyword">using</a> <a id="2413" class="Symbol">(</a><a id="2414" href="Cubical.Relation.Nullary.Base.html#966" class="Function">Collapsible</a><a id="2425" class="Symbol">;</a> <a id="2427" href="Cubical.Relation.Nullary.Properties.html#4626" class="Function">Collapsible≡→isSet</a><a id="2445" class="Symbol">)</a>

  <a id="BinaryRelation.Extensional→isSet"></a><a id="2450" href="Ordinal.Base.html#2450" class="Function">Extensional→isSet</a> <a id="2468" class="Symbol">:</a> <a id="2470" href="Ordinal.Base.html#810" class="Function">Propositional</a> <a id="2484" class="Symbol">→</a> <a id="2486" href="Ordinal.Base.html#1766" class="Function">Extensional</a> <a id="2498" class="Symbol">→</a> <a id="2500" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="2506" href="Ordinal.Base.html#669" class="Bound">A</a>
  <a id="2510" href="Ordinal.Base.html#2450" class="Function">Extensional→isSet</a> <a id="2528" href="Ordinal.Base.html#2528" class="Bound">prop</a> <a id="2533" href="Ordinal.Base.html#2533" class="Bound">ext</a> <a id="2537" class="Symbol">=</a> <a id="2539" href="Cubical.Relation.Nullary.Properties.html#4626" class="Function">Collapsible≡→isSet</a> <a id="2558" class="Symbol">λ</a> <a id="2560" href="Ordinal.Base.html#2560" class="Bound">x</a> <a id="2562" href="Ordinal.Base.html#2562" class="Bound">y</a> <a id="2564" class="Symbol">→</a> <a id="2566" href="Ordinal.Base.html#2612" class="Function">collapser</a> <a id="2576" href="Ordinal.Base.html#2560" class="Bound">x</a> <a id="2578" href="Ordinal.Base.html#2562" class="Bound">y</a> <a id="2580" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2582" href="Ordinal.Base.html#2731" class="Function">didCollapse</a> <a id="2594" href="Ordinal.Base.html#2560" class="Bound">x</a> <a id="2596" href="Ordinal.Base.html#2562" class="Bound">y</a>
    <a id="2602" class="Keyword">where</a>
    <a id="2612" href="Ordinal.Base.html#2612" class="Function">collapser</a> <a id="2622" class="Symbol">:</a> <a id="2624" class="Symbol">∀</a> <a id="2626" href="Ordinal.Base.html#2626" class="Bound">x</a> <a id="2628" href="Ordinal.Base.html#2628" class="Bound">y</a> <a id="2630" class="Symbol">→</a> <a id="2632" href="Ordinal.Base.html#2626" class="Bound">x</a> <a id="2634" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2636" href="Ordinal.Base.html#2628" class="Bound">y</a> <a id="2638" class="Symbol">→</a> <a id="2640" href="Ordinal.Base.html#2626" class="Bound">x</a> <a id="2642" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2644" href="Ordinal.Base.html#2628" class="Bound">y</a>
    <a id="2650" href="Ordinal.Base.html#2612" class="Function">collapser</a> <a id="2660" href="Ordinal.Base.html#2660" class="Bound">x</a> <a id="2662" href="Ordinal.Base.html#2662" class="Bound">y</a> <a id="2664" href="Ordinal.Base.html#2664" class="Bound">eq</a> <a id="2667" class="Symbol">=</a> <a id="2669" href="Ordinal.Base.html#2533" class="Bound">ext</a> <a id="2673" href="Ordinal.Base.html#2660" class="Bound">x</a> <a id="2675" href="Ordinal.Base.html#2662" class="Bound">y</a> <a id="2677" class="Symbol">λ</a> <a id="2679" href="Ordinal.Base.html#2679" class="Bound">z</a> <a id="2681" class="Symbol">→</a> <a id="2683" class="Symbol">(</a><a id="2684" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="2690" class="Symbol">(</a><a id="2691" href="Ordinal.Base.html#2679" class="Bound">z</a> <a id="2693" href="Ordinal.Base.html#682" class="Bound Operator">≺_</a><a id="2695" class="Symbol">)</a> <a id="2697" href="Ordinal.Base.html#2664" class="Bound">eq</a><a id="2699" class="Symbol">)</a> <a id="2701" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2703" class="Symbol">(</a><a id="2704" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="2710" class="Symbol">(</a><a id="2711" href="Ordinal.Base.html#2679" class="Bound">z</a> <a id="2713" href="Ordinal.Base.html#682" class="Bound Operator">≺_</a><a id="2715" class="Symbol">)</a> <a id="2717" class="Symbol">(</a><a id="2718" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="2722" href="Ordinal.Base.html#2664" class="Bound">eq</a><a id="2724" class="Symbol">))</a>
    <a id="2731" href="Ordinal.Base.html#2731" class="Function">didCollapse</a> <a id="2743" class="Symbol">:</a> <a id="2745" class="Symbol">∀</a> <a id="2747" href="Ordinal.Base.html#2747" class="Bound">x</a> <a id="2749" href="Ordinal.Base.html#2749" class="Bound">y</a> <a id="2751" class="Symbol">→</a> <a id="2753" href="Cubical.Foundations.Function.html#2864" class="Function">2-Constant</a> <a id="2764" class="Symbol">(</a><a id="2765" href="Ordinal.Base.html#2612" class="Function">collapser</a> <a id="2775" href="Ordinal.Base.html#2747" class="Bound">x</a> <a id="2777" href="Ordinal.Base.html#2749" class="Bound">y</a><a id="2778" class="Symbol">)</a>
    <a id="2784" href="Ordinal.Base.html#2731" class="Function">didCollapse</a> <a id="2796" href="Ordinal.Base.html#2796" class="Bound">x</a> <a id="2798" href="Ordinal.Base.html#2798" class="Bound">y</a> <a id="2800" href="Ordinal.Base.html#2800" class="Bound">p</a> <a id="2802" href="Ordinal.Base.html#2802" class="Bound">q</a> <a id="2804" class="Symbol">=</a> <a id="2806" href="Cubical.Foundations.Prelude.html#1430" class="Function">cong</a> <a id="2811" class="Symbol">(</a><a id="2812" href="Ordinal.Base.html#2533" class="Bound">ext</a> <a id="2816" href="Ordinal.Base.html#2796" class="Bound">x</a> <a id="2818" href="Ordinal.Base.html#2798" class="Bound">y</a><a id="2819" class="Symbol">)</a> <a id="2821" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2823" href="Cubical.Foundations.Prelude.html#9928" class="Function">funExt</a> <a id="2830" class="Symbol">λ</a> <a id="2832" href="Ordinal.Base.html#2832" class="Bound">_</a> <a id="2834" class="Symbol">→</a> <a id="2836" href="Preliminary.html#10482" class="Function">Σ≡Prop</a>
      <a id="2849" class="Symbol">(λ</a> <a id="2852" href="Ordinal.Base.html#2852" class="Bound">_</a> <a id="2854" href="Ordinal.Base.html#2854" class="Bound">_</a> <a id="2856" href="Ordinal.Base.html#2856" class="Bound">_</a> <a id="2858" class="Symbol">→</a> <a id="2860" href="Cubical.Foundations.HLevels.html#17810" class="Function">isProp→</a> <a id="2868" class="Symbol">(</a><a id="2869" href="Ordinal.Base.html#2528" class="Bound">prop</a> <a id="2874" class="Symbol">_</a> <a id="2876" class="Symbol">_)</a> <a id="2879" class="Symbol">_</a> <a id="2881" class="Symbol">_)</a>
      <a id="2890" class="Symbol">(</a><a id="2891" href="Cubical.Foundations.Prelude.html#9928" class="Function">funExt</a> <a id="2898" class="Symbol">λ</a> <a id="2900" href="Ordinal.Base.html#2900" class="Bound">_</a> <a id="2902" class="Symbol">→</a> <a id="2904" href="Ordinal.Base.html#2528" class="Bound">prop</a> <a id="2909" class="Symbol">_</a> <a id="2911" class="Symbol">_</a> <a id="2913" class="Symbol">_</a> <a id="2915" class="Symbol">_)</a>
</pre>
<h3 id="良基性">良基性</h3>
<p>我们说在 <code>_≺_</code> 关系下, 一个 <code>x : A</code> <strong>可及 (accessible)</strong>, 当且仅当对任意 <code>y ≺ x</code>, <code>y</code> 也可及.</p>
<pre class="Agda">  <a id="3017" class="Keyword">data</a> <a id="BinaryRelation.Acc"></a><a id="3022" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3026" class="Symbol">(</a><a id="3027" href="Ordinal.Base.html#3027" class="Bound">x</a> <a id="3029" class="Symbol">:</a> <a id="3031" href="Ordinal.Base.html#669" class="Bound">A</a><a id="3032" class="Symbol">)</a> <a id="3034" class="Symbol">:</a> <a id="3036" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3041" class="Symbol">(</a><a id="3042" href="Ordinal.Base.html#678" class="Bound">𝓊</a> <a id="3044" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="3046" href="Ordinal.Base.html#701" class="Bound">𝓋</a><a id="3047" class="Symbol">)</a> <a id="3049" class="Keyword">where</a>
    <a id="BinaryRelation.Acc.acc"></a><a id="3059" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="3063" class="Symbol">:</a> <a id="3065" class="Symbol">(∀</a> <a id="3068" href="Ordinal.Base.html#3068" class="Bound">y</a> <a id="3070" class="Symbol">→</a> <a id="3072" href="Ordinal.Base.html#3068" class="Bound">y</a> <a id="3074" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="3076" href="Ordinal.Base.html#3027" class="Bound">x</a> <a id="3078" class="Symbol">→</a> <a id="3080" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3084" href="Ordinal.Base.html#3068" class="Bound">y</a><a id="3085" class="Symbol">)</a> <a id="3087" class="Symbol">→</a> <a id="3089" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3093" href="Ordinal.Base.html#3027" class="Bound">x</a>
</pre>
<p>我们说 <code>_≺_</code> 是一个 <strong>良基 (well-founded)</strong> 关系, 当且仅当任意 <code>x : A</code> 都可及.</p>
<pre class="Agda">  <a id="BinaryRelation.WellFounded"></a><a id="3171" href="Ordinal.Base.html#3171" class="Function">WellFounded</a> <a id="3183" class="Symbol">:</a> <a id="3185" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3190" class="Symbol">_</a>
  <a id="3194" href="Ordinal.Base.html#3171" class="Function">WellFounded</a> <a id="3206" class="Symbol">=</a> <a id="3208" class="Symbol">∀</a> <a id="3210" href="Ordinal.Base.html#3210" class="Bound">x</a> <a id="3212" class="Symbol">→</a> <a id="3214" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3218" href="Ordinal.Base.html#3210" class="Bound">x</a>
</pre>
<p>可及性是一个命题. 下面的证明中暴露了 cubical 的底层机制, 就是那个间点 <code>i</code>, 以使证明更简洁. 也可以不暴露, 只需证 <code>H₁</code> 等于 <code>H₂</code>, 它们都具有 <code>∀ y → y ≺ x → Acc y</code> 类型. 由归纳假设, <code>Acc y</code> 是命题, 所以这个Π类型也是命题, 所以它的两个项 <code>H₁</code> 与 <code>H₂</code> 相等.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropAcc"></a><a id="3407" href="Ordinal.Base.html#3407" class="Function">isPropAcc</a> <a id="3417" class="Symbol">:</a> <a id="3419" class="Symbol">∀</a> <a id="3421" href="Ordinal.Base.html#3421" class="Bound">x</a> <a id="3423" class="Symbol">→</a> <a id="3425" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3432" class="Symbol">(</a><a id="3433" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3437" href="Ordinal.Base.html#3421" class="Bound">x</a><a id="3438" class="Symbol">)</a>
  <a id="3442" href="Ordinal.Base.html#3407" class="Function">isPropAcc</a> <a id="3452" href="Ordinal.Base.html#3452" class="Bound">x</a> <a id="3454" class="Symbol">(</a><a id="3455" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="3459" href="Ordinal.Base.html#3459" class="Bound">IH₁</a><a id="3462" class="Symbol">)</a> <a id="3464" class="Symbol">(</a><a id="3465" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="3469" href="Ordinal.Base.html#3469" class="Bound">IH₂</a><a id="3472" class="Symbol">)</a> <a id="3474" href="Ordinal.Base.html#3474" class="Bound">i</a> <a id="3476" class="Symbol">=</a> <a id="3478" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="3482" class="Symbol">λ</a> <a id="3484" href="Ordinal.Base.html#3484" class="Bound">y</a> <a id="3486" href="Ordinal.Base.html#3486" class="Bound">y≺x</a> <a id="3490" class="Symbol">→</a> <a id="3492" href="Ordinal.Base.html#3407" class="Function">isPropAcc</a> <a id="3502" href="Ordinal.Base.html#3484" class="Bound">y</a> <a id="3504" class="Symbol">(</a><a id="3505" href="Ordinal.Base.html#3459" class="Bound">IH₁</a> <a id="3509" href="Ordinal.Base.html#3484" class="Bound">y</a> <a id="3511" href="Ordinal.Base.html#3486" class="Bound">y≺x</a><a id="3514" class="Symbol">)</a> <a id="3516" class="Symbol">(</a><a id="3517" href="Ordinal.Base.html#3469" class="Bound">IH₂</a> <a id="3521" href="Ordinal.Base.html#3484" class="Bound">y</a> <a id="3523" href="Ordinal.Base.html#3486" class="Bound">y≺x</a><a id="3526" class="Symbol">)</a> <a id="3528" href="Ordinal.Base.html#3474" class="Bound">i</a>
</pre>
<p>良基性也是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropWellFounded"></a><a id="3557" href="Ordinal.Base.html#3557" class="Function">isPropWellFounded</a> <a id="3575" class="Symbol">:</a> <a id="3577" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3584" href="Ordinal.Base.html#3171" class="Function">WellFounded</a>
  <a id="3598" href="Ordinal.Base.html#3557" class="Function">isPropWellFounded</a> <a id="3616" class="Symbol">=</a> <a id="3618" href="Cubical.Foundations.HLevels.html#16363" class="Function">isPropΠ</a> <a id="3626" class="Symbol">λ</a> <a id="3628" href="Ordinal.Base.html#3628" class="Bound">_</a> <a id="3630" class="Symbol">→</a> <a id="3632" href="Ordinal.Base.html#3407" class="Function">isPropAcc</a> <a id="3642" class="Symbol">_</a>
</pre>
<h3 id="良基归纳法">良基归纳法</h3>
<p>良基归纳法是自然数归纳法的更一般形式, 它说如果对任意 <code>x</code> 我们都能通过证明任意 <code>y ≺ x</code> 有 <code>P y</code> 来证明 <code>P x</code>, 那么任意 <code>x</code> 都有 <code>P x</code>.</p>
<pre class="Agda">  <a id="BinaryRelation.wf-elim"></a><a id="3760" href="Ordinal.Base.html#3760" class="Function">wf-elim</a> <a id="3768" class="Symbol">:</a> <a id="3770" class="Symbol">{</a><a id="3771" href="Ordinal.Base.html#3771" class="Bound">P</a> <a id="3773" class="Symbol">:</a> <a id="3775" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="3777" class="Symbol">→</a> <a id="3779" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3784" href="Preliminary.html#2700" class="Generalizable">𝓌</a><a id="3785" class="Symbol">}</a> <a id="3787" class="Symbol">→</a> <a id="3789" href="Ordinal.Base.html#3171" class="Function">WellFounded</a> <a id="3801" class="Symbol">→</a>
    <a id="3807" class="Symbol">(∀</a> <a id="3810" href="Ordinal.Base.html#3810" class="Bound">x</a> <a id="3812" class="Symbol">→</a> <a id="3814" class="Symbol">(∀</a> <a id="3817" href="Ordinal.Base.html#3817" class="Bound">y</a> <a id="3819" class="Symbol">→</a> <a id="3821" href="Ordinal.Base.html#3817" class="Bound">y</a> <a id="3823" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="3825" href="Ordinal.Base.html#3810" class="Bound">x</a> <a id="3827" class="Symbol">→</a> <a id="3829" href="Ordinal.Base.html#3771" class="Bound">P</a> <a id="3831" href="Ordinal.Base.html#3817" class="Bound">y</a><a id="3832" class="Symbol">)</a> <a id="3834" class="Symbol">→</a> <a id="3836" href="Ordinal.Base.html#3771" class="Bound">P</a> <a id="3838" href="Ordinal.Base.html#3810" class="Bound">x</a><a id="3839" class="Symbol">)</a> <a id="3841" class="Symbol">→</a> <a id="3843" class="Symbol">∀</a> <a id="3845" href="Ordinal.Base.html#3845" class="Bound">x</a> <a id="3847" class="Symbol">→</a> <a id="3849" href="Ordinal.Base.html#3771" class="Bound">P</a> <a id="3851" href="Ordinal.Base.html#3845" class="Bound">x</a>
  <a id="3855" href="Ordinal.Base.html#3760" class="Function">wf-elim</a> <a id="3863" class="Symbol">{_}</a> <a id="3867" class="Symbol">{</a><a id="3868" href="Ordinal.Base.html#3868" class="Bound">P</a><a id="3869" class="Symbol">}</a> <a id="3871" href="Ordinal.Base.html#3871" class="Bound">wf</a> <a id="3874" href="Ordinal.Base.html#3874" class="Bound">H</a> <a id="3876" href="Ordinal.Base.html#3876" class="Bound">x</a> <a id="3878" class="Symbol">=</a> <a id="3880" href="Ordinal.Base.html#3907" class="Function">aux</a> <a id="3884" href="Ordinal.Base.html#3876" class="Bound">x</a> <a id="3886" class="Symbol">(</a><a id="3887" href="Ordinal.Base.html#3871" class="Bound">wf</a> <a id="3890" href="Ordinal.Base.html#3876" class="Bound">x</a><a id="3891" class="Symbol">)</a>
    <a id="3897" class="Keyword">where</a>
    <a id="3907" href="Ordinal.Base.html#3907" class="Function">aux</a> <a id="3911" class="Symbol">:</a> <a id="3913" class="Symbol">∀</a> <a id="3915" href="Ordinal.Base.html#3915" class="Bound">x</a> <a id="3917" class="Symbol">→</a> <a id="3919" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="3923" href="Ordinal.Base.html#3915" class="Bound">x</a> <a id="3925" class="Symbol">→</a> <a id="3927" href="Ordinal.Base.html#3868" class="Bound">P</a> <a id="3929" href="Ordinal.Base.html#3915" class="Bound">x</a>
    <a id="3935" href="Ordinal.Base.html#3907" class="Function">aux</a> <a id="3939" href="Ordinal.Base.html#3939" class="Bound">x</a> <a id="3941" class="Symbol">(</a><a id="3942" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="3946" href="Ordinal.Base.html#3946" class="Bound">IH</a><a id="3948" class="Symbol">)</a> <a id="3950" class="Symbol">=</a> <a id="3952" href="Ordinal.Base.html#3874" class="Bound">H</a> <a id="3954" href="Ordinal.Base.html#3939" class="Bound">x</a> <a id="3956" class="Symbol">λ</a> <a id="3958" href="Ordinal.Base.html#3958" class="Bound">y</a> <a id="3960" href="Ordinal.Base.html#3960" class="Bound">y≺x</a> <a id="3964" class="Symbol">→</a> <a id="3966" href="Ordinal.Base.html#3907" class="Function">aux</a> <a id="3970" href="Ordinal.Base.html#3958" class="Bound">y</a> <a id="3972" class="Symbol">(</a><a id="3973" href="Ordinal.Base.html#3946" class="Bound">IH</a> <a id="3976" href="Ordinal.Base.html#3958" class="Bound">y</a> <a id="3978" href="Ordinal.Base.html#3960" class="Bound">y≺x</a><a id="3981" class="Symbol">)</a>
</pre>
<p>下一章还要用到双参数形式的良基归纳法.</p>
<pre class="Agda">  <a id="BinaryRelation.wf-elim2"></a><a id="4019" href="Ordinal.Base.html#4019" class="Function">wf-elim2</a> <a id="4028" class="Symbol">:</a> <a id="4030" class="Symbol">{</a><a id="4031" href="Ordinal.Base.html#4031" class="Bound">R</a> <a id="4033" class="Symbol">:</a> <a id="4035" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="4037" class="Symbol">→</a> <a id="4039" href="Ordinal.Base.html#669" class="Bound">A</a> <a id="4041" class="Symbol">→</a> <a id="4043" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="4048" href="Preliminary.html#2700" class="Generalizable">𝓌</a><a id="4049" class="Symbol">}</a> <a id="4051" class="Symbol">→</a> <a id="4053" href="Ordinal.Base.html#3171" class="Function">WellFounded</a> <a id="4065" class="Symbol">→</a>
    <a id="4071" class="Symbol">(∀</a> <a id="4074" href="Ordinal.Base.html#4074" class="Bound">x</a> <a id="4076" href="Ordinal.Base.html#4076" class="Bound">y</a> <a id="4078" class="Symbol">→</a> <a id="4080" class="Symbol">(∀</a> <a id="4083" href="Ordinal.Base.html#4083" class="Bound">u</a> <a id="4085" href="Ordinal.Base.html#4085" class="Bound">v</a> <a id="4087" class="Symbol">→</a> <a id="4089" href="Ordinal.Base.html#4083" class="Bound">u</a> <a id="4091" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="4093" href="Ordinal.Base.html#4074" class="Bound">x</a> <a id="4095" class="Symbol">→</a> <a id="4097" href="Ordinal.Base.html#4085" class="Bound">v</a> <a id="4099" href="Ordinal.Base.html#682" class="Bound Operator">≺</a> <a id="4101" href="Ordinal.Base.html#4076" class="Bound">y</a> <a id="4103" class="Symbol">→</a> <a id="4105" href="Ordinal.Base.html#4031" class="Bound">R</a> <a id="4107" href="Ordinal.Base.html#4083" class="Bound">u</a> <a id="4109" href="Ordinal.Base.html#4085" class="Bound">v</a><a id="4110" class="Symbol">)</a> <a id="4112" class="Symbol">→</a> <a id="4114" href="Ordinal.Base.html#4031" class="Bound">R</a> <a id="4116" href="Ordinal.Base.html#4074" class="Bound">x</a> <a id="4118" href="Ordinal.Base.html#4076" class="Bound">y</a><a id="4119" class="Symbol">)</a> <a id="4121" class="Symbol">→</a> <a id="4123" class="Symbol">∀</a> <a id="4125" href="Ordinal.Base.html#4125" class="Bound">x</a> <a id="4127" href="Ordinal.Base.html#4127" class="Bound">y</a> <a id="4129" class="Symbol">→</a> <a id="4131" href="Ordinal.Base.html#4031" class="Bound">R</a> <a id="4133" href="Ordinal.Base.html#4125" class="Bound">x</a> <a id="4135" href="Ordinal.Base.html#4127" class="Bound">y</a>
  <a id="4139" href="Ordinal.Base.html#4019" class="Function">wf-elim2</a> <a id="4148" class="Symbol">{_}</a> <a id="4152" class="Symbol">{</a><a id="4153" href="Ordinal.Base.html#4153" class="Bound">R</a><a id="4154" class="Symbol">}</a> <a id="4156" href="Ordinal.Base.html#4156" class="Bound">wf</a> <a id="4159" href="Ordinal.Base.html#4159" class="Bound">H</a> <a id="4161" href="Ordinal.Base.html#4161" class="Bound">x</a> <a id="4163" href="Ordinal.Base.html#4163" class="Bound">y</a> <a id="4165" class="Symbol">=</a> <a id="4167" href="Ordinal.Base.html#4203" class="Function">aux</a> <a id="4171" href="Ordinal.Base.html#4161" class="Bound">x</a> <a id="4173" href="Ordinal.Base.html#4163" class="Bound">y</a> <a id="4175" class="Symbol">(</a><a id="4176" href="Ordinal.Base.html#4156" class="Bound">wf</a> <a id="4179" href="Ordinal.Base.html#4161" class="Bound">x</a><a id="4180" class="Symbol">)</a> <a id="4182" class="Symbol">(</a><a id="4183" href="Ordinal.Base.html#4156" class="Bound">wf</a> <a id="4186" href="Ordinal.Base.html#4163" class="Bound">y</a><a id="4187" class="Symbol">)</a>
    <a id="4193" class="Keyword">where</a>
    <a id="4203" href="Ordinal.Base.html#4203" class="Function">aux</a> <a id="4207" class="Symbol">:</a> <a id="4209" class="Symbol">∀</a> <a id="4211" href="Ordinal.Base.html#4211" class="Bound">x</a> <a id="4213" href="Ordinal.Base.html#4213" class="Bound">y</a> <a id="4215" class="Symbol">→</a> <a id="4217" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="4221" href="Ordinal.Base.html#4211" class="Bound">x</a> <a id="4223" class="Symbol">→</a> <a id="4225" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="4229" href="Ordinal.Base.html#4213" class="Bound">y</a> <a id="4231" class="Symbol">→</a> <a id="4233" href="Ordinal.Base.html#4153" class="Bound">R</a> <a id="4235" href="Ordinal.Base.html#4211" class="Bound">x</a> <a id="4237" href="Ordinal.Base.html#4213" class="Bound">y</a>
    <a id="4243" href="Ordinal.Base.html#4203" class="Function">aux</a> <a id="4247" href="Ordinal.Base.html#4247" class="Bound">x</a> <a id="4249" href="Ordinal.Base.html#4249" class="Bound">y</a> <a id="4251" class="Symbol">(</a><a id="4252" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="4256" href="Ordinal.Base.html#4256" class="Bound">IHx</a><a id="4259" class="Symbol">)</a> <a id="4261" class="Symbol">(</a><a id="4262" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="4266" href="Ordinal.Base.html#4266" class="Bound">IHy</a><a id="4269" class="Symbol">)</a> <a id="4271" class="Symbol">=</a> <a id="4273" href="Ordinal.Base.html#4159" class="Bound">H</a> <a id="4275" href="Ordinal.Base.html#4247" class="Bound">x</a> <a id="4277" href="Ordinal.Base.html#4249" class="Bound">y</a> <a id="4279" class="Symbol">λ</a> <a id="4281" href="Ordinal.Base.html#4281" class="Bound">u</a> <a id="4283" href="Ordinal.Base.html#4283" class="Bound">v</a> <a id="4285" href="Ordinal.Base.html#4285" class="Bound">u≺x</a> <a id="4289" href="Ordinal.Base.html#4289" class="Bound">v≺y</a> <a id="4293" class="Symbol">→</a> <a id="4295" href="Ordinal.Base.html#4203" class="Function">aux</a> <a id="4299" href="Ordinal.Base.html#4281" class="Bound">u</a> <a id="4301" href="Ordinal.Base.html#4283" class="Bound">v</a> <a id="4303" class="Symbol">(</a><a id="4304" href="Ordinal.Base.html#4256" class="Bound">IHx</a> <a id="4308" href="Ordinal.Base.html#4281" class="Bound">u</a> <a id="4310" href="Ordinal.Base.html#4285" class="Bound">u≺x</a><a id="4313" class="Symbol">)</a> <a id="4315" class="Symbol">(</a><a id="4316" href="Ordinal.Base.html#4266" class="Bound">IHy</a> <a id="4320" href="Ordinal.Base.html#4283" class="Bound">v</a> <a id="4322" href="Ordinal.Base.html#4289" class="Bound">v≺y</a><a id="4325" class="Symbol">)</a>
</pre>
<p>由良基归纳法可以立即证明良基性蕴含反自反性.</p>
<pre class="Agda">  <a id="BinaryRelation.WellFounded→Irreflexive"></a><a id="4366" href="Ordinal.Base.html#4366" class="Function">WellFounded→Irreflexive</a> <a id="4390" class="Symbol">:</a> <a id="4392" href="Ordinal.Base.html#3171" class="Function">WellFounded</a> <a id="4404" class="Symbol">→</a> <a id="4406" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a>
  <a id="4420" href="Ordinal.Base.html#4366" class="Function">WellFounded→Irreflexive</a> <a id="4444" href="Ordinal.Base.html#4444" class="Bound">wf</a> <a id="4447" class="Symbol">=</a> <a id="4449" href="Ordinal.Base.html#3760" class="Function">wf-elim</a> <a id="4457" href="Ordinal.Base.html#4444" class="Bound">wf</a> <a id="4460" class="Symbol">λ</a> <a id="4462" href="Ordinal.Base.html#4462" class="Bound">x</a> <a id="4464" href="Ordinal.Base.html#4464" class="Bound">IH</a> <a id="4467" href="Ordinal.Base.html#4467" class="Bound">x≺x</a> <a id="4471" class="Symbol">→</a> <a id="4473" href="Ordinal.Base.html#4464" class="Bound">IH</a> <a id="4476" href="Ordinal.Base.html#4462" class="Bound">x</a> <a id="4478" href="Ordinal.Base.html#4467" class="Bound">x≺x</a> <a id="4482" href="Ordinal.Base.html#4467" class="Bound">x≺x</a>
</pre>
<h3 id="良序性">良序性</h3>
<p>我们说 <code>_≺_</code> 是一个 <strong>良序 (well-ordered)</strong> 关系, 当且仅当: <code>_≺_</code> 有命题性, 传递性, 外延性和良基性.</p>
<pre class="Agda">  <a id="4583" class="Keyword">record</a> <a id="BinaryRelation.WellOrdered"></a><a id="4590" href="Ordinal.Base.html#4590" class="Record">WellOrdered</a> <a id="4602" class="Symbol">:</a> <a id="4604" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="4609" class="Symbol">(</a><a id="4610" href="Ordinal.Base.html#678" class="Bound">𝓊</a> <a id="4612" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="4614" href="Ordinal.Base.html#701" class="Bound">𝓋</a><a id="4615" class="Symbol">)</a> <a id="4617" class="Keyword">where</a>
    <a id="4627" class="Keyword">constructor</a> <a id="BinaryRelation.mkWellOrdered"></a><a id="4639" href="Ordinal.Base.html#4639" class="InductiveConstructor">mkWellOrdered</a>
    <a id="4657" class="Keyword">field</a>
      <a id="BinaryRelation.WellOrdered.≺-prop"></a><a id="4669" href="Ordinal.Base.html#4669" class="Field">≺-prop</a>    <a id="4679" class="Symbol">:</a> <a id="4681" href="Ordinal.Base.html#810" class="Function">Propositional</a>
      <a id="BinaryRelation.WellOrdered.≺-trans"></a><a id="4701" href="Ordinal.Base.html#4701" class="Field">≺-trans</a>   <a id="4711" class="Symbol">:</a> <a id="4713" href="Ordinal.Base.html#1409" class="Function">Transitive</a>
      <a id="BinaryRelation.WellOrdered.≺-ext"></a><a id="4730" href="Ordinal.Base.html#4730" class="Field">≺-ext</a>     <a id="4740" class="Symbol">:</a> <a id="4742" href="Ordinal.Base.html#1766" class="Function">Extensional</a>
      <a id="BinaryRelation.WellOrdered.≺-wf"></a><a id="4760" href="Ordinal.Base.html#4760" class="Field">≺-wf</a>      <a id="4770" class="Symbol">:</a> <a id="4772" href="Ordinal.Base.html#3171" class="Function">WellFounded</a>
</pre>
<p>良序关系是反自反的, 且其底层类型必是集合, 我们今后称之为<strong>底集 (underlying set)</strong>. 经典数学里面一般是把这里的外延性换成了三歧性, 但在直觉主义中外延性更容易处理. 此外, HoTT Book 也有相应的定义, 见 Def 10.3.17, 它要求 “<code>A</code> 是集合”, 但这不是必须的, Escardó 首先证明了<a href="https://www.cs.bham.ac.uk/~mhe/TypeTopology/Ordinals.Notions.html#8277">这一点</a></p>
<pre class="Agda">    <a id="BinaryRelation.WellOrdered.≺-irrefl"></a><a id="5051" href="Ordinal.Base.html#5051" class="Function">≺-irrefl</a> <a id="5060" class="Symbol">:</a> <a id="5062" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a>
    <a id="5078" href="Ordinal.Base.html#5051" class="Function">≺-irrefl</a> <a id="5087" class="Symbol">=</a> <a id="5089" href="Ordinal.Base.html#4366" class="Function">WellFounded→Irreflexive</a> <a id="5113" href="Ordinal.Base.html#4760" class="Field">≺-wf</a>

    <a id="BinaryRelation.WellOrdered.underlying-set"></a><a id="5123" href="Ordinal.Base.html#5123" class="Function">underlying-set</a> <a id="5138" class="Symbol">:</a> <a id="5140" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="5146" href="Ordinal.Base.html#669" class="Bound">A</a>
    <a id="5152" href="Ordinal.Base.html#5123" class="Function">underlying-set</a> <a id="5167" class="Symbol">=</a> <a id="5169" href="Ordinal.Base.html#2450" class="Function">Extensional→isSet</a> <a id="5187" href="Ordinal.Base.html#4669" class="Field">≺-prop</a> <a id="5194" href="Ordinal.Base.html#4730" class="Field">≺-ext</a>
</pre>
<p>由于良序性里面的每个条件都是命题, 所以良序性也是一个命题.</p>
<pre class="Agda">  <a id="BinaryRelation.isPropWellOrdered"></a><a id="5247" href="Ordinal.Base.html#5247" class="Function">isPropWellOrdered</a> <a id="5265" class="Symbol">:</a> <a id="5267" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5274" href="Ordinal.Base.html#4590" class="Record">WellOrdered</a>
  <a id="5288" href="Ordinal.Base.html#5247" class="Function">isPropWellOrdered</a> <a id="5306" class="Symbol">=</a> <a id="5308" href="Cubical.Foundations.HLevels.html#8859" class="Function">isOfHLevelRetractFromIso</a> <a id="5333" class="Number">1</a> <a id="5335" href="Ordinal.Base.html#5383" class="Function">WellOrderedIsoΣ</a> <a id="5351" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5353" href="Ordinal.Base.html#5459" class="Function">aux</a>
    <a id="5361" class="Keyword">where</a>
    <a id="5371" class="Keyword">unquoteDecl</a> <a id="5383" href="Ordinal.Base.html#5383" class="Function">WellOrderedIsoΣ</a> <a id="5399" class="Symbol">=</a> <a id="5401" href="Cubical.Reflection.RecordEquiv.html#9804" class="Function">declareRecordIsoΣ</a> <a id="5419" href="Ordinal.Base.html#5383" class="Function">WellOrderedIsoΣ</a> <a id="5435" class="Symbol">(</a><a id="5436" class="Keyword">quote</a> <a id="5442" href="Ordinal.Base.html#4590" class="Record">WellOrdered</a><a id="5453" class="Symbol">)</a>
    <a id="5459" href="Ordinal.Base.html#5459" class="Function">aux</a> <a id="5463" class="Symbol">:</a> <a id="5465" class="Symbol">∀</a> <a id="5467" href="Ordinal.Base.html#5467" class="Bound">x</a> <a id="5469" href="Ordinal.Base.html#5469" class="Bound">y</a> <a id="5471" class="Symbol">→</a> <a id="5473" href="Ordinal.Base.html#5467" class="Bound">x</a> <a id="5475" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5477" href="Ordinal.Base.html#5469" class="Bound">y</a>
    <a id="5483" href="Ordinal.Base.html#5459" class="Function">aux</a> <a id="5487" href="Ordinal.Base.html#5487" class="Bound">x</a> <a id="5489" class="Symbol">_</a> <a id="5491" class="Symbol">=</a> <a id="5493" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="5500" class="Symbol">(</a><a id="5501" href="Ordinal.Base.html#902" class="Function">isPropPropositional</a> <a id="5521" class="Symbol">_</a> <a id="5523" class="Symbol">_</a>
            <a id="5537" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5539" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="5546" class="Symbol">(</a><a id="5547" href="Ordinal.Base.html#1521" class="Function">isPropTransitive</a> <a id="5564" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="5571" class="Symbol">_</a> <a id="5573" class="Symbol">_</a>
            <a id="5587" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5589" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="5596" class="Symbol">(</a><a id="5597" href="Ordinal.Base.html#1879" class="Function">isPropExtensional</a> <a id="5615" href="Ordinal.Base.html#5123" class="Function">underlying-set</a> <a id="5630" class="Symbol">_</a> <a id="5632" class="Symbol">_</a>
            <a id="5646" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5648" href="Ordinal.Base.html#3557" class="Function">isPropWellFounded</a> <a id="5666" class="Symbol">_</a> <a id="5668" class="Symbol">_)))</a>
      <a id="5679" class="Keyword">where</a> <a id="5685" class="Keyword">open</a> <a id="5690" href="Ordinal.Base.html#4590" class="Module">WellOrdered</a> <a id="5702" class="Symbol">(</a><a id="5703" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a> <a id="5711" href="Ordinal.Base.html#5383" class="Function">WellOrderedIsoΣ</a> <a id="5727" href="Ordinal.Base.html#5487" class="Bound">x</a><a id="5728" class="Symbol">)</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<p>为了方便 <code>𝒮ᴰ-Record</code> 宏处理, 我们遵循 cubical 库的做法, 先用 record 类型定义序数结构, 然后用Σ类型把序数定义为类型宇宙配备上序数结构.</p>
<h3 id="序数结构">序数结构</h3>
<p>一个类型 <code>A</code> 配备上一个良序 <code>_≺_</code> 就构成了一个序数结构 <code>OrdStr</code>. 注意我们这里让 <code>_≺_</code> 与底集 <code>A</code> 居留于同一宇宙, 这可以让形式更简单, 反正 <code>_≺_</code> 是命题, 而我们有 <code>PR</code> 可以随时调整命题宇宙.</p>
<pre class="Agda"><a id="5973" class="Keyword">record</a> <a id="OrdStr"></a><a id="5980" href="Ordinal.Base.html#5980" class="Record">OrdStr</a> <a id="5987" class="Symbol">(</a><a id="5988" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="5990" class="Symbol">:</a> <a id="5992" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5997" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="5998" class="Symbol">)</a> <a id="6000" class="Symbol">:</a> <a id="6002" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6007" class="Symbol">(</a><a id="6008" href="Ordinal.Base.html#5997" class="Bound">𝓊</a> <a id="6010" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="6011" class="Symbol">)</a> <a id="6013" class="Keyword">where</a>
  <a id="6021" class="Keyword">constructor</a> <a id="mkOrdStr"></a><a id="6033" href="Ordinal.Base.html#6033" class="InductiveConstructor">mkOrdStr</a>
  <a id="6044" class="Keyword">open</a> <a id="6049" href="Ordinal.Base.html#653" class="Module">BinaryRelation</a>
  <a id="6066" class="Keyword">field</a>
    <a id="OrdStr._≺_"></a><a id="6076" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="6080" class="Symbol">:</a> <a id="6082" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="6084" class="Symbol">→</a> <a id="6086" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="6088" class="Symbol">→</a> <a id="6090" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6095" href="Ordinal.Base.html#5997" class="Bound">𝓊</a>
    <a id="OrdStr.≺-wo"></a><a id="6101" href="Ordinal.Base.html#6101" class="Field">≺-wo</a> <a id="6106" class="Symbol">:</a> <a id="6108" href="Ordinal.Base.html#4590" class="Record">WellOrdered</a> <a id="6120" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a>
  <a id="6126" class="Keyword">open</a> <a id="6131" href="Ordinal.Base.html#4590" class="Module">WellOrdered</a> <a id="6143" href="Ordinal.Base.html#6101" class="Field">≺-wo</a> <a id="6148" class="Keyword">public</a>
</pre>
<p>我们有序数底层结构的良基归纳法.</p>
<pre class="Agda">  <a id="OrdStr.elim"></a><a id="6188" href="Ordinal.Base.html#6188" class="Function">elim</a> <a id="6193" class="Symbol">:</a> <a id="6195" class="Symbol">{</a><a id="6196" href="Ordinal.Base.html#6196" class="Bound">P</a> <a id="6198" class="Symbol">:</a> <a id="6200" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="6202" class="Symbol">→</a> <a id="6204" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6209" href="Preliminary.html#2700" class="Generalizable">𝓌</a><a id="6210" class="Symbol">}</a> <a id="6212" class="Symbol">→</a> <a id="6214" class="Symbol">(∀</a> <a id="6217" href="Ordinal.Base.html#6217" class="Bound">x</a> <a id="6219" class="Symbol">→</a> <a id="6221" class="Symbol">(∀</a> <a id="6224" href="Ordinal.Base.html#6224" class="Bound">y</a> <a id="6226" class="Symbol">→</a> <a id="6228" href="Ordinal.Base.html#6224" class="Bound">y</a> <a id="6230" href="Ordinal.Base.html#6076" class="Field Operator">≺</a> <a id="6232" href="Ordinal.Base.html#6217" class="Bound">x</a> <a id="6234" class="Symbol">→</a> <a id="6236" href="Ordinal.Base.html#6196" class="Bound">P</a> <a id="6238" href="Ordinal.Base.html#6224" class="Bound">y</a><a id="6239" class="Symbol">)</a> <a id="6241" class="Symbol">→</a> <a id="6243" href="Ordinal.Base.html#6196" class="Bound">P</a> <a id="6245" href="Ordinal.Base.html#6217" class="Bound">x</a><a id="6246" class="Symbol">)</a> <a id="6248" class="Symbol">→</a> <a id="6250" class="Symbol">∀</a> <a id="6252" href="Ordinal.Base.html#6252" class="Bound">x</a> <a id="6254" class="Symbol">→</a> <a id="6256" href="Ordinal.Base.html#6196" class="Bound">P</a> <a id="6258" href="Ordinal.Base.html#6252" class="Bound">x</a>
  <a id="6262" href="Ordinal.Base.html#6188" class="Function">elim</a> <a id="6267" class="Symbol">=</a> <a id="6269" href="Ordinal.Base.html#3760" class="Function">wf-elim</a> <a id="6277" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="6281" href="Ordinal.Base.html#4760" class="Function">≺-wf</a>

  <a id="OrdStr.elim2"></a><a id="6289" href="Ordinal.Base.html#6289" class="Function">elim2</a> <a id="6295" class="Symbol">:</a> <a id="6297" class="Symbol">{</a><a id="6298" href="Ordinal.Base.html#6298" class="Bound">R</a> <a id="6300" class="Symbol">:</a> <a id="6302" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="6304" class="Symbol">→</a> <a id="6306" href="Ordinal.Base.html#5988" class="Bound">A</a> <a id="6308" class="Symbol">→</a> <a id="6310" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6315" href="Preliminary.html#2700" class="Generalizable">𝓌</a><a id="6316" class="Symbol">}</a> <a id="6318" class="Symbol">→</a> <a id="6320" class="Symbol">(∀</a> <a id="6323" href="Ordinal.Base.html#6323" class="Bound">x</a> <a id="6325" href="Ordinal.Base.html#6325" class="Bound">y</a> <a id="6327" class="Symbol">→</a> <a id="6329" class="Symbol">(∀</a> <a id="6332" href="Ordinal.Base.html#6332" class="Bound">u</a> <a id="6334" href="Ordinal.Base.html#6334" class="Bound">v</a> <a id="6336" class="Symbol">→</a> <a id="6338" href="Ordinal.Base.html#6332" class="Bound">u</a> <a id="6340" href="Ordinal.Base.html#6076" class="Field Operator">≺</a> <a id="6342" href="Ordinal.Base.html#6323" class="Bound">x</a> <a id="6344" class="Symbol">→</a> <a id="6346" href="Ordinal.Base.html#6334" class="Bound">v</a> <a id="6348" href="Ordinal.Base.html#6076" class="Field Operator">≺</a> <a id="6350" href="Ordinal.Base.html#6325" class="Bound">y</a> <a id="6352" class="Symbol">→</a> <a id="6354" href="Ordinal.Base.html#6298" class="Bound">R</a> <a id="6356" href="Ordinal.Base.html#6332" class="Bound">u</a> <a id="6358" href="Ordinal.Base.html#6334" class="Bound">v</a><a id="6359" class="Symbol">)</a> <a id="6361" class="Symbol">→</a> <a id="6363" href="Ordinal.Base.html#6298" class="Bound">R</a> <a id="6365" href="Ordinal.Base.html#6323" class="Bound">x</a> <a id="6367" href="Ordinal.Base.html#6325" class="Bound">y</a><a id="6368" class="Symbol">)</a> <a id="6370" class="Symbol">→</a> <a id="6372" class="Symbol">∀</a> <a id="6374" href="Ordinal.Base.html#6374" class="Bound">x</a> <a id="6376" href="Ordinal.Base.html#6376" class="Bound">y</a> <a id="6378" class="Symbol">→</a> <a id="6380" href="Ordinal.Base.html#6298" class="Bound">R</a> <a id="6382" href="Ordinal.Base.html#6374" class="Bound">x</a> <a id="6384" href="Ordinal.Base.html#6376" class="Bound">y</a>
  <a id="6388" href="Ordinal.Base.html#6289" class="Function">elim2</a> <a id="6394" class="Symbol">=</a> <a id="6396" href="Ordinal.Base.html#4019" class="Function">wf-elim2</a> <a id="6405" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="6409" href="Ordinal.Base.html#4760" class="Function">≺-wf</a>
</pre>
<h3 id="序数宇宙">序数宇宙</h3>
<p>类型宇宙配备上序数结构就构成了序数宇宙 <code>Ord</code>. 注意 <code>Ord</code> 后面跟的 <code>𝓊</code> 指的是底集所在的宇宙, 而 <code>Ord</code> 本身位于 <code>𝓊 ⁺</code> 宇宙.</p>
<pre class="Agda"><a id="Ord"></a><a id="6518" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="6522" class="Symbol">:</a> <a id="6524" class="Symbol">(</a><a id="6525" href="Ordinal.Base.html#6525" class="Bound">𝓊</a> <a id="6527" class="Symbol">:</a> <a id="6529" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="6534" class="Symbol">)</a> <a id="6536" class="Symbol">→</a> <a id="6538" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6543" class="Symbol">(</a><a id="6544" href="Ordinal.Base.html#6525" class="Bound">𝓊</a> <a id="6546" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="6547" class="Symbol">)</a>
<a id="6549" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="6553" href="Ordinal.Base.html#6553" class="Bound">𝓊</a> <a id="6555" class="Symbol">=</a> <a id="6557" href="Cubical.Foundations.Structure.html#398" class="Function">TypeWithStr</a> <a id="6569" href="Ordinal.Base.html#6553" class="Bound">𝓊</a> <a id="6571" href="Ordinal.Base.html#5980" class="Record">OrdStr</a>
</pre>
<p>我们今后都用 α β γ 等符号表示序数.</p>
<pre class="Agda"><a id="6614" class="Keyword">variable</a> <a id="6623" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6625" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="6627" href="Ordinal.Base.html#6627" class="Generalizable">γ</a> <a id="6629" class="Symbol">:</a> <a id="6631" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="6635" href="Preliminary.html#2696" class="Generalizable">𝓊</a>
</pre>
<h3 id="底序">底序</h3>
<p>当同时讨论多个序数中的 <code>≺</code> 关系时, 我们用 <code>x ≺⟨ α ⟩ y</code> 的记法标记 <code>≺</code> 所属的序数. 我们把 <code>≺⟨ α ⟩</code> 叫做 <code>α</code> 的底序, 与底集相对应, 它们共同组成了一个序数的底层结构. 若把 <code>≺</code> 看作”属于”关系, <code>∀ z → z ≺⟨ α ⟩ x → z ≺⟨ α ⟩ y</code> 则可以看作是”包含”关系, 记作 <code>≼</code>. 但要注意这些都只是类比的说法, <code>x</code> 和 <code>y</code> 本身不是集合.</p>
<p>以下代码定义了一个支持 <code>x ≺⟨ α ⟩ y</code> 和 <code>x ≼⟨ α ⟩ y</code> 记法的类型类 (typeclass) <code>Underlying</code>.</p>
<pre class="Agda"><a id="6944" class="Keyword">record</a> <a id="Underlying"></a><a id="6951" href="Ordinal.Base.html#6951" class="Record">Underlying</a> <a id="6962" class="Symbol">{</a><a id="6963" href="Ordinal.Base.html#6963" class="Bound">𝓊</a><a id="6964" class="Symbol">}</a> <a id="6966" class="Symbol">(</a><a id="6967" href="Ordinal.Base.html#6967" class="Bound">O</a> <a id="6969" class="Symbol">:</a> <a id="6971" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6976" class="Symbol">(</a><a id="6977" href="Ordinal.Base.html#6963" class="Bound">𝓊</a> <a id="6979" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="6980" class="Symbol">))</a> <a id="6983" class="Symbol">:</a> <a id="6985" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6990" class="Symbol">(</a><a id="6991" href="Ordinal.Base.html#6963" class="Bound">𝓊</a> <a id="6993" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="6994" class="Symbol">)</a> <a id="6996" class="Keyword">where</a>
  <a id="7004" class="Keyword">field</a>
    <a id="Underlying.underlyingSet"></a><a id="7014" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7028" class="Symbol">:</a> <a id="7030" href="Ordinal.Base.html#6967" class="Bound">O</a> <a id="7032" class="Symbol">→</a> <a id="7034" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7039" href="Ordinal.Base.html#6963" class="Bound">𝓊</a>
    <a id="Underlying.underlyingRel"></a><a id="7045" href="Ordinal.Base.html#7045" class="Field">underlyingRel</a> <a id="7059" class="Symbol">:</a> <a id="7061" class="Symbol">(</a><a id="7062" href="Ordinal.Base.html#7062" class="Bound">α</a> <a id="7064" class="Symbol">:</a> <a id="7066" href="Ordinal.Base.html#6967" class="Bound">O</a><a id="7067" class="Symbol">)</a> <a id="7069" class="Symbol">→</a> <a id="7071" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7085" href="Ordinal.Base.html#7062" class="Bound">α</a> <a id="7087" class="Symbol">→</a> <a id="7089" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7103" href="Ordinal.Base.html#7062" class="Bound">α</a> <a id="7105" class="Symbol">→</a> <a id="7107" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7112" href="Ordinal.Base.html#6963" class="Bound">𝓊</a>
  <a id="7116" class="Keyword">syntax</a> <a id="7123" href="Ordinal.Base.html#7045" class="Field">underlyingRel</a> <a id="7137" class="Bound">α</a> <a id="7139" class="Bound">x</a> <a id="7141" class="Bound">y</a> <a id="7143" class="Symbol">=</a> <a id="7145" class="Bound">x</a> <a id="7147" class="Field">≺⟨</a> <a id="7150" class="Bound">α</a> <a id="7152" class="Field">⟩</a> <a id="7154" class="Bound">y</a>

  <a id="Underlying.underlyingPoRel"></a><a id="7159" href="Ordinal.Base.html#7159" class="Function">underlyingPoRel</a> <a id="7175" class="Symbol">:</a> <a id="7177" class="Symbol">(</a><a id="7178" href="Ordinal.Base.html#7178" class="Bound">α</a> <a id="7180" class="Symbol">:</a> <a id="7182" href="Ordinal.Base.html#6967" class="Bound">O</a><a id="7183" class="Symbol">)</a> <a id="7185" class="Symbol">→</a> <a id="7187" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7201" href="Ordinal.Base.html#7178" class="Bound">α</a> <a id="7203" class="Symbol">→</a> <a id="7205" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7219" href="Ordinal.Base.html#7178" class="Bound">α</a> <a id="7221" class="Symbol">→</a> <a id="7223" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7228" href="Ordinal.Base.html#6963" class="Bound">𝓊</a>
  <a id="7232" href="Ordinal.Base.html#7159" class="Function">underlyingPoRel</a> <a id="7248" href="Ordinal.Base.html#7248" class="Bound">α</a> <a id="7250" href="Ordinal.Base.html#7250" class="Bound">x</a> <a id="7252" href="Ordinal.Base.html#7252" class="Bound">y</a> <a id="7254" class="Symbol">=</a> <a id="7256" class="Symbol">∀</a> <a id="7258" href="Ordinal.Base.html#7258" class="Bound">z</a> <a id="7260" class="Symbol">→</a> <a id="7262" href="Ordinal.Base.html#7258" class="Bound">z</a> <a id="7264" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="7267" href="Ordinal.Base.html#7248" class="Bound">α</a> <a id="7269" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="7271" href="Ordinal.Base.html#7250" class="Bound">x</a> <a id="7273" class="Symbol">→</a> <a id="7275" href="Ordinal.Base.html#7258" class="Bound">z</a> <a id="7277" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="7280" href="Ordinal.Base.html#7248" class="Bound">α</a> <a id="7282" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="7284" href="Ordinal.Base.html#7252" class="Bound">y</a>
  <a id="7288" class="Keyword">syntax</a> <a id="7295" href="Ordinal.Base.html#7159" class="Function">underlyingPoRel</a> <a id="7311" class="Bound">α</a> <a id="7313" class="Bound">x</a> <a id="7315" class="Bound">y</a> <a id="7317" class="Symbol">=</a> <a id="7319" class="Bound">x</a> <a id="7321" class="Function">≼⟨</a> <a id="7324" class="Bound">α</a> <a id="7326" class="Function">⟩</a> <a id="7328" class="Bound">y</a>

<a id="7331" class="Keyword">open</a> <a id="7336" href="Ordinal.Base.html#6951" class="Module">Underlying</a> <a id="7347" class="Symbol">⦃...⦄</a> <a id="7353" class="Keyword">public</a>
</pre>
<p>我们对序数实装 <code>Underlying</code> 类型类.</p>
<pre class="Agda"><a id="7400" class="Keyword">instance</a>
  <a id="underlying"></a><a id="7411" href="Ordinal.Base.html#7411" class="Function">underlying</a> <a id="7422" class="Symbol">:</a> <a id="7424" href="Ordinal.Base.html#6951" class="Record">Underlying</a> <a id="7435" class="Symbol">(</a><a id="7436" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="7440" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="7441" class="Symbol">)</a>
  <a id="7445" href="Ordinal.Base.html#7014" class="Field">underlyingSet</a> <a id="7459" class="Symbol">⦃</a> <a id="7461" href="Ordinal.Base.html#7411" class="Function">underlying</a> <a id="7472" class="Symbol">⦄</a> <a id="7474" class="Symbol">=</a> <a id="7476" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨_⟩</a>
  <a id="7482" href="Ordinal.Base.html#7045" class="Field">underlyingRel</a> <a id="7496" class="Symbol">⦃</a> <a id="7498" href="Ordinal.Base.html#7411" class="Function">underlying</a> <a id="7509" class="Symbol">⦄</a> <a id="7511" class="Symbol">=</a> <a id="7513" href="Ordinal.Base.html#6076" class="Field Operator">OrdStr._≺_</a> <a id="7524" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="7526" href="Cubical.Foundations.Structure.html#556" class="Function">str</a>
</pre>
<h2 id="序数等价">序数等价</h2>
<p>我们说两个序数的底集间的同伦等价 <code>e : A ≃ B</code> 是一个序数等价, 当且仅当 <code>e</code> 保持序关系. 注意这里的”保持序关系”也必须用同伦等价来表达, 今后叫它序等价, 记作 <code>hPres≺</code>, 定义为对任意 <code>x y : A</code> 有 <code>x ≺₁ y</code> 与 <code>f x ≺₂ f y</code> 同伦等价, 其中 <code>≺₁</code> 和 <code>≺₂</code> 分别是 <code>A</code> 和 <code>B</code> 上的序关系, <code>f</code> 是 <code>A ≃ B</code> 的底层函数.</p>
<pre class="Agda"><a id="7760" class="Keyword">module</a> <a id="7767" href="Ordinal.Base.html#7767" class="Module">_</a> <a id="7769" class="Symbol">{</a><a id="7770" href="Ordinal.Base.html#7770" class="Bound">A</a> <a id="7772" class="Symbol">:</a> <a id="7774" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7779" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="7780" class="Symbol">}</a> <a id="7782" class="Symbol">{</a><a id="7783" href="Ordinal.Base.html#7783" class="Bound">B</a> <a id="7785" class="Symbol">:</a> <a id="7787" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7792" href="Preliminary.html#2702" class="Generalizable">𝓊′</a><a id="7794" class="Symbol">}</a> <a id="7796" class="Symbol">(</a><a id="7797" href="Ordinal.Base.html#7797" class="Bound">a</a> <a id="7799" class="Symbol">:</a> <a id="7801" href="Ordinal.Base.html#5980" class="Record">OrdStr</a> <a id="7808" href="Ordinal.Base.html#7770" class="Bound">A</a><a id="7809" class="Symbol">)</a> <a id="7811" class="Symbol">(</a><a id="7812" href="Ordinal.Base.html#7812" class="Bound">f</a> <a id="7814" class="Symbol">:</a> <a id="7816" href="Ordinal.Base.html#7770" class="Bound">A</a> <a id="7818" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="7820" href="Ordinal.Base.html#7783" class="Bound">B</a><a id="7821" class="Symbol">)</a> <a id="7823" class="Symbol">(</a><a id="7824" href="Ordinal.Base.html#7824" class="Bound">b</a> <a id="7826" class="Symbol">:</a> <a id="7828" href="Ordinal.Base.html#5980" class="Record">OrdStr</a> <a id="7835" href="Ordinal.Base.html#7783" class="Bound">B</a><a id="7836" class="Symbol">)</a> <a id="7838" class="Keyword">where</a>

  <a id="7847" class="Keyword">record</a> <a id="7854" href="Ordinal.Base.html#7854" class="Record">IsOrdEquiv</a> <a id="7865" class="Symbol">:</a> <a id="7867" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7872" class="Symbol">(</a><a id="7873" href="Ordinal.Base.html#7779" class="Bound">𝓊</a> <a id="7875" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="7877" href="Ordinal.Base.html#7792" class="Bound">𝓊′</a><a id="7879" class="Symbol">)</a> <a id="7881" class="Keyword">where</a>
    <a id="7891" class="Keyword">constructor</a> <a id="7903" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a>
    <a id="7922" class="Keyword">open</a> <a id="7927" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="7934" href="Ordinal.Base.html#7797" class="Bound">a</a> <a id="7936" class="Keyword">renaming</a> <a id="7945" class="Symbol">(</a><a id="7946" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="7950" class="Symbol">to</a> <a id="7953" class="Field Operator">_≺₁_</a><a id="7957" class="Symbol">)</a>
    <a id="7963" class="Keyword">open</a> <a id="7968" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="7975" href="Ordinal.Base.html#7824" class="Bound">b</a> <a id="7977" class="Keyword">renaming</a> <a id="7986" class="Symbol">(</a><a id="7987" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="7991" class="Symbol">to</a> <a id="7994" class="Field Operator">_≺₂_</a><a id="7998" class="Symbol">)</a>
    <a id="8004" class="Keyword">field</a>
      <a id="8016" href="Ordinal.Base.html#8016" class="Field">hPres≺</a> <a id="8023" class="Symbol">:</a> <a id="8025" class="Symbol">(</a><a id="8026" href="Ordinal.Base.html#8026" class="Bound">x</a> <a id="8028" href="Ordinal.Base.html#8028" class="Bound">y</a> <a id="8030" class="Symbol">:</a> <a id="8032" href="Ordinal.Base.html#7770" class="Bound">A</a><a id="8033" class="Symbol">)</a> <a id="8035" class="Symbol">→</a> <a id="8037" href="Ordinal.Base.html#8026" class="Bound">x</a> <a id="8039" href="Ordinal.Base.html#7953" class="Function Operator">≺₁</a> <a id="8042" href="Ordinal.Base.html#8028" class="Bound">y</a> <a id="8044" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="8046" class="Symbol">(</a><a id="8047" href="Ordinal.Base.html#7812" class="Bound">f</a> <a id="8049" href="Preliminary.html#11646" class="Function Operator">⁺¹</a><a id="8051" class="Symbol">)</a> <a id="8053" href="Ordinal.Base.html#8026" class="Bound">x</a> <a id="8055" href="Ordinal.Base.html#7994" class="Function Operator">≺₂</a> <a id="8058" class="Symbol">(</a><a id="8059" href="Ordinal.Base.html#7812" class="Bound">f</a> <a id="8061" href="Preliminary.html#11646" class="Function Operator">⁺¹</a><a id="8063" class="Symbol">)</a> <a id="8065" href="Ordinal.Base.html#8028" class="Bound">y</a>
</pre>
<p>由同伦等价的命题性, “是序数等价”也是一个命题. 这是很有用的性质, 会在下一章用到.</p>
<pre class="Agda">  <a id="8128" href="Ordinal.Base.html#8128" class="Function">isPropIsOrdEquiv</a> <a id="8145" class="Symbol">:</a> <a id="8147" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="8154" href="Ordinal.Base.html#7854" class="Record">IsOrdEquiv</a>
  <a id="8167" href="Ordinal.Base.html#8128" class="Function">isPropIsOrdEquiv</a> <a id="8184" class="Symbol">=</a> <a id="8186" href="Cubical.Foundations.HLevels.html#8859" class="Function">isOfHLevelRetractFromIso</a> <a id="8211" class="Number">1</a> <a id="8213" href="Ordinal.Base.html#8260" class="Function">IsOrdEquivIsoΣ</a> <a id="8228" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8230" href="Ordinal.Base.html#8333" class="Function">aux</a>
    <a id="8238" class="Keyword">where</a>
    <a id="8248" class="Keyword">unquoteDecl</a> <a id="8260" href="Ordinal.Base.html#8260" class="Function">IsOrdEquivIsoΣ</a> <a id="8275" class="Symbol">=</a> <a id="8277" href="Cubical.Reflection.RecordEquiv.html#9804" class="Function">declareRecordIsoΣ</a> <a id="8295" href="Ordinal.Base.html#8260" class="Function">IsOrdEquivIsoΣ</a> <a id="8310" class="Symbol">(</a><a id="8311" class="Keyword">quote</a> <a id="8317" href="Ordinal.Base.html#7854" class="Record">IsOrdEquiv</a><a id="8327" class="Symbol">)</a>
    <a id="8333" href="Ordinal.Base.html#8333" class="Function">aux</a> <a id="8337" class="Symbol">:</a> <a id="8339" class="Symbol">∀</a> <a id="8341" href="Ordinal.Base.html#8341" class="Bound">x</a> <a id="8343" href="Ordinal.Base.html#8343" class="Bound">y</a> <a id="8345" class="Symbol">→</a> <a id="8347" href="Ordinal.Base.html#8341" class="Bound">x</a> <a id="8349" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="8351" href="Ordinal.Base.html#8343" class="Bound">y</a>
    <a id="8357" href="Ordinal.Base.html#8333" class="Function">aux</a> <a id="8361" class="Symbol">=</a> <a id="8363" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="8372" class="Symbol">λ</a> <a id="8374" href="Ordinal.Base.html#8374" class="Bound">_</a> <a id="8376" href="Ordinal.Base.html#8376" class="Bound">_</a> <a id="8378" class="Symbol">→</a> <a id="8380" href="Cubical.Foundations.HLevels.html#12387" class="Function">isPropΣ</a> <a id="8388" class="Symbol">(</a><a id="8389" href="Cubical.Foundations.HLevels.html#17810" class="Function">isProp→</a> <a id="8397" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8399" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="8406" class="Symbol">_</a> <a id="8408" class="Symbol">_)</a> <a id="8411" class="Symbol">(λ</a> <a id="8414" href="Ordinal.Base.html#8414" class="Bound">_</a> <a id="8416" class="Symbol">→</a> <a id="8418" href="Cubical.Foundations.Equiv.html#1548" class="Function">isPropIsEquiv</a> <a id="8432" class="Symbol">_)</a>
      <a id="8441" class="Keyword">where</a> <a id="8447" class="Keyword">open</a> <a id="8452" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="8459" href="Ordinal.Base.html#7824" class="Bound">b</a>
</pre>
<p>序数间的同伦等价 <code>α ≃ₒ β</code> 定义为保持序关系的底集间同伦等价 <code>A ≃ B</code>.</p>
<pre class="Agda"><a id="_≃ₒ_"></a><a id="8519" href="Ordinal.Base.html#8519" class="Function Operator">_≃ₒ_</a> <a id="8524" class="Symbol">:</a> <a id="8526" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="8530" href="Preliminary.html#2696" class="Generalizable">𝓊</a> <a id="8532" class="Symbol">→</a> <a id="8534" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="8538" href="Preliminary.html#2702" class="Generalizable">𝓊′</a> <a id="8541" class="Symbol">→</a> <a id="8543" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="8548" class="Symbol">(</a><a id="8549" href="Preliminary.html#2696" class="Generalizable">𝓊</a> <a id="8551" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="8553" href="Preliminary.html#2702" class="Generalizable">𝓊′</a><a id="8555" class="Symbol">)</a>
<a id="8557" href="Ordinal.Base.html#8557" class="Bound">α</a> <a id="8559" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="8562" href="Ordinal.Base.html#8562" class="Bound">β</a> <a id="8564" class="Symbol">=</a> <a id="8566" href="Preliminary.html#5452" class="Function">Σ</a> <a id="8568" href="Ordinal.Base.html#8568" class="Bound">f</a> <a id="8570" href="Preliminary.html#5452" class="Function">∶</a> <a id="8572" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="8574" href="Ordinal.Base.html#8557" class="Bound">α</a> <a id="8576" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="8578" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="8580" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="8582" href="Ordinal.Base.html#8562" class="Bound">β</a> <a id="8584" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="8586" href="Preliminary.html#5452" class="Function">,</a> <a id="8588" href="Ordinal.Base.html#7854" class="Record">IsOrdEquiv</a> <a id="8599" class="Symbol">(</a><a id="8600" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="8604" href="Ordinal.Base.html#8557" class="Bound">α</a><a id="8605" class="Symbol">)</a> <a id="8607" href="Ordinal.Base.html#8568" class="Bound">f</a> <a id="8609" class="Symbol">(</a><a id="8610" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="8614" href="Ordinal.Base.html#8562" class="Bound">β</a><a id="8615" class="Symbol">)</a>
</pre>
<p>可以证明序数等价确实是等价关系, 由同伦等价的自反性, 对称性和传递性即得.</p>
<pre class="Agda"><a id="≃ₒ-refl"></a><a id="8670" href="Ordinal.Base.html#8670" class="Function">≃ₒ-refl</a> <a id="8678" class="Symbol">:</a> <a id="8680" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="8682" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="8685" href="Ordinal.Base.html#6623" class="Generalizable">α</a>
<a id="8687" href="Ordinal.Base.html#8670" class="Function">≃ₒ-refl</a> <a id="8695" class="Symbol">=</a> <a id="8697" href="Cubical.Foundations.Equiv.Base.html#1054" class="Function">idEquiv</a> <a id="8705" class="Symbol">_</a> <a id="8707" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8709" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="8724" class="Symbol">λ</a> <a id="8726" href="Ordinal.Base.html#8726" class="Bound">x</a> <a id="8728" href="Ordinal.Base.html#8728" class="Bound">y</a> <a id="8730" class="Symbol">→</a> <a id="8732" href="Cubical.Foundations.Equiv.Base.html#1054" class="Function">idEquiv</a> <a id="8740" class="Symbol">_</a>

<a id="≃ₒ-sym"></a><a id="8743" href="Ordinal.Base.html#8743" class="Function">≃ₒ-sym</a> <a id="8750" class="Symbol">:</a> <a id="8752" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="8754" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="8757" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="8759" class="Symbol">→</a> <a id="8761" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="8763" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="8766" href="Ordinal.Base.html#6623" class="Generalizable">α</a>
<a id="8768" href="Ordinal.Base.html#8743" class="Function">≃ₒ-sym</a> <a id="8775" class="Symbol">{</a><a id="8776" href="Ordinal.Base.html#8776" class="Bound">α</a><a id="8777" class="Symbol">}</a> <a id="8779" class="Symbol">{</a><a id="8780" href="Ordinal.Base.html#8780" class="Bound">β</a><a id="8781" class="Symbol">}</a> <a id="8783" class="Symbol">(</a><a id="8784" href="Ordinal.Base.html#8784" class="Bound">α≃β</a> <a id="8788" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8790" href="Ordinal.Base.html#8790" class="Bound">eqv</a><a id="8793" class="Symbol">)</a> <a id="8795" class="Symbol">=</a> <a id="8797" href="Cubical.Foundations.Equiv.html#3368" class="Function">invEquiv</a> <a id="8806" href="Ordinal.Base.html#8784" class="Bound">α≃β</a> <a id="8810" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a>
  <a id="8814" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="8829" class="Symbol">λ</a> <a id="8831" href="Ordinal.Base.html#8831" class="Bound">x</a> <a id="8833" href="Ordinal.Base.html#8833" class="Bound">y</a> <a id="8835" class="Symbol">→</a> <a id="8837" href="Cubical.Foundations.Equiv.html#3368" class="Function">invEquiv</a> <a id="8846" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a>
    <a id="8852" href="Cubical.Foundations.Prelude.html#9252" class="Function">subst2</a> <a id="8859" class="Symbol">(λ</a> <a id="8862" href="Ordinal.Base.html#8862" class="Bound">u</a> <a id="8864" href="Ordinal.Base.html#8864" class="Bound">v</a> <a id="8866" class="Symbol">→</a> <a id="8868" class="Symbol">_</a> <a id="8870" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="8873" href="Ordinal.Base.html#8776" class="Bound">α</a> <a id="8875" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="8877" class="Symbol">_</a> <a id="8879" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="8881" href="Ordinal.Base.html#8862" class="Bound">u</a> <a id="8883" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="8886" href="Ordinal.Base.html#8780" class="Bound">β</a> <a id="8888" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="8890" href="Ordinal.Base.html#8864" class="Bound">v</a><a id="8891" class="Symbol">)</a>
      <a id="8899" class="Symbol">(</a><a id="8900" href="Cubical.Foundations.Equiv.html#2289" class="Function">secIsEq</a> <a id="8908" class="Symbol">(</a><a id="8909" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="8913" href="Ordinal.Base.html#8784" class="Bound">α≃β</a><a id="8916" class="Symbol">)</a> <a id="8918" href="Ordinal.Base.html#8831" class="Bound">x</a><a id="8919" class="Symbol">)</a> <a id="8921" class="Symbol">(</a><a id="8922" href="Cubical.Foundations.Equiv.html#2289" class="Function">secIsEq</a> <a id="8930" class="Symbol">(</a><a id="8931" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="8935" href="Ordinal.Base.html#8784" class="Bound">α≃β</a><a id="8938" class="Symbol">)</a> <a id="8940" href="Ordinal.Base.html#8833" class="Bound">y</a><a id="8941" class="Symbol">)</a>
      <a id="8949" class="Symbol">(</a><a id="8950" href="Ordinal.Base.html#8016" class="Field">hPres≺</a> <a id="8957" class="Symbol">(</a><a id="8958" href="Ordinal.Base.html#8784" class="Bound">α≃β</a> <a id="8962" href="Preliminary.html#11677" class="Function Operator">⁻¹</a> <a id="8965" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8967" href="Ordinal.Base.html#8831" class="Bound">x</a><a id="8968" class="Symbol">)</a> <a id="8970" class="Symbol">(</a><a id="8971" href="Ordinal.Base.html#8784" class="Bound">α≃β</a> <a id="8975" href="Preliminary.html#11677" class="Function Operator">⁻¹</a> <a id="8978" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8980" href="Ordinal.Base.html#8833" class="Bound">y</a><a id="8981" class="Symbol">))</a>
  <a id="8986" class="Keyword">where</a> <a id="8992" class="Keyword">open</a> <a id="8997" href="Ordinal.Base.html#7854" class="Module">IsOrdEquiv</a> <a id="9008" href="Ordinal.Base.html#8790" class="Bound">eqv</a>

<a id="≃ₒ-trans"></a><a id="9013" href="Ordinal.Base.html#9013" class="Function">≃ₒ-trans</a> <a id="9022" class="Symbol">:</a> <a id="9024" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="9026" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="9029" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="9031" class="Symbol">→</a> <a id="9033" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="9035" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="9038" href="Ordinal.Base.html#6627" class="Generalizable">γ</a> <a id="9040" class="Symbol">→</a> <a id="9042" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="9044" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="9047" href="Ordinal.Base.html#6627" class="Generalizable">γ</a>
<a id="9049" href="Ordinal.Base.html#9013" class="Function">≃ₒ-trans</a> <a id="9058" class="Symbol">(</a><a id="9059" href="Ordinal.Base.html#9059" class="Bound">α≃β</a> <a id="9063" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9065" href="Ordinal.Base.html#9065" class="Bound">eqv₁</a><a id="9069" class="Symbol">)</a> <a id="9071" class="Symbol">(</a><a id="9072" href="Ordinal.Base.html#9072" class="Bound">β≃γ</a> <a id="9076" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9078" href="Ordinal.Base.html#9078" class="Bound">eqv₂</a><a id="9082" class="Symbol">)</a> <a id="9084" class="Symbol">=</a> <a id="9086" href="Cubical.Foundations.Equiv.html#3542" class="Function">compEquiv</a> <a id="9096" href="Ordinal.Base.html#9059" class="Bound">α≃β</a> <a id="9100" href="Ordinal.Base.html#9072" class="Bound">β≃γ</a> <a id="9104" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a>
  <a id="9108" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="9123" class="Symbol">λ</a> <a id="9125" href="Ordinal.Base.html#9125" class="Bound">x</a> <a id="9127" href="Ordinal.Base.html#9127" class="Bound">y</a> <a id="9129" class="Symbol">→</a> <a id="9131" href="Cubical.Foundations.Equiv.html#3542" class="Function">compEquiv</a>
    <a id="9145" class="Symbol">(</a><a id="9146" href="Ordinal.Base.html#8016" class="Field">hPres≺</a> <a id="9153" href="Ordinal.Base.html#9065" class="Bound">eqv₁</a> <a id="9158" href="Ordinal.Base.html#9125" class="Bound">x</a> <a id="9160" href="Ordinal.Base.html#9127" class="Bound">y</a><a id="9161" class="Symbol">)</a> <a id="9163" class="Symbol">(</a><a id="9164" href="Ordinal.Base.html#8016" class="Field">hPres≺</a> <a id="9171" href="Ordinal.Base.html#9078" class="Bound">eqv₂</a> <a id="9176" class="Symbol">(</a><a id="9177" href="Ordinal.Base.html#9059" class="Bound">α≃β</a> <a id="9181" href="Preliminary.html#11646" class="Function Operator">⁺¹</a> <a id="9184" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9186" href="Ordinal.Base.html#9125" class="Bound">x</a><a id="9187" class="Symbol">)</a> <a id="9189" class="Symbol">(</a><a id="9190" href="Ordinal.Base.html#9059" class="Bound">α≃β</a> <a id="9194" href="Preliminary.html#11646" class="Function Operator">⁺¹</a> <a id="9197" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9199" href="Ordinal.Base.html#9127" class="Bound">y</a><a id="9200" class="Symbol">))</a>
  <a id="9205" class="Keyword">where</a> <a id="9211" class="Keyword">open</a> <a id="9216" href="Ordinal.Base.html#7854" class="Module">IsOrdEquiv</a>
</pre>
<h2 id="序数的泛等原理">序数的泛等原理</h2>
<p>我们使用宏 <code>𝒮ᴰ-Record</code> 得到序数的泛等原理. 不需要深究其语法, 只需认为它是一种 boilerplate (样板代码), 在 cubical 的代数模块里面也被大量使用. 简而言之, 这段代码说, 序数包括两个”字段”, 一个是 <code>_≺_</code>, 它被同伦等价保持了, 再一个是 <code>≺-wo</code>, 它是个命题, 不影响结构. 这样就可以用 <code>𝒮ᴰ-Record</code> 拿到 <code>𝒮ᴰ-Ord : DUARel ...</code> 这一串东西.</p>
<pre class="Agda"><a id="𝒮ᴰ-Ord"></a><a id="9471" href="Ordinal.Base.html#9471" class="Function">𝒮ᴰ-Ord</a> <a id="9478" class="Symbol">:</a> <a id="9480" href="Cubical.Displayed.Base.html#1242" class="Record">DUARel</a> <a id="9487" class="Symbol">(</a><a id="9488" href="Cubical.Displayed.Universe.html#489" class="Function">𝒮-Univ</a> <a id="9495" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="9496" class="Symbol">)</a> <a id="9498" href="Ordinal.Base.html#5980" class="Record">OrdStr</a> <a id="9505" href="Preliminary.html#2696" class="Generalizable">𝓊</a>
<a id="9507" href="Ordinal.Base.html#9471" class="Function">𝒮ᴰ-Ord</a> <a id="9514" class="Symbol">=</a> <a id="9516" href="Cubical.Displayed.Record.html#8411" class="Macro">𝒮ᴰ-Record</a> <a id="9526" class="Symbol">(</a><a id="9527" href="Cubical.Displayed.Universe.html#489" class="Function">𝒮-Univ</a> <a id="9534" class="Symbol">_)</a> <a id="9537" href="Ordinal.Base.html#7854" class="Record">IsOrdEquiv</a>
  <a id="9550" class="Symbol">(</a><a id="9551" href="Cubical.Displayed.Record.html#2560" class="InductiveConstructor">fields:</a>
    <a id="9563" href="Cubical.Displayed.Record.html#3005" class="InductiveConstructor Operator">data[</a> <a id="9569" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a> <a id="9573" href="Cubical.Displayed.Record.html#3005" class="InductiveConstructor Operator">∣</a> <a id="9575" href="Cubical.Displayed.Auto.html#11888" class="Macro">autoDUARel</a> <a id="9586" class="Symbol">_</a> <a id="9588" class="Symbol">_</a> <a id="9590" href="Cubical.Displayed.Record.html#3005" class="InductiveConstructor Operator">∣</a> <a id="9592" href="Ordinal.Base.html#8016" class="Field">hPres≺</a> <a id="9599" href="Cubical.Displayed.Record.html#3005" class="InductiveConstructor Operator">]</a>
    <a id="9605" href="Cubical.Displayed.Record.html#3727" class="InductiveConstructor Operator">prop[</a> <a id="9611" href="Ordinal.Base.html#6101" class="Field">≺-wo</a> <a id="9616" href="Cubical.Displayed.Record.html#3727" class="InductiveConstructor Operator">∣</a> <a id="9618" class="Symbol">(λ</a> <a id="9621" href="Ordinal.Base.html#9621" class="Bound">_</a> <a id="9623" href="Ordinal.Base.html#9623" class="Bound">_</a> <a id="9625" class="Symbol">→</a> <a id="9627" href="Ordinal.Base.html#5247" class="Function">isPropWellOrdered</a> <a id="9645" class="Symbol">_)</a> <a id="9648" href="Cubical.Displayed.Record.html#3727" class="InductiveConstructor Operator">]</a><a id="9649" class="Symbol">)</a>
  <a id="9653" class="Keyword">where</a>
  <a id="9661" class="Keyword">open</a> <a id="9666" href="Ordinal.Base.html#5980" class="Module">OrdStr</a>
  <a id="9675" class="Keyword">open</a> <a id="9680" href="Ordinal.Base.html#7854" class="Module">IsOrdEquiv</a>
  <a id="9693" class="Keyword">open</a> <a id="9698" href="Ordinal.Base.html#653" class="Module">BinaryRelation</a>
</pre>
<p>然后就可以用 <code>∫</code> 从 <code>𝒮ᴰ-Ord</code> 中取出序数的泛等原理: 两个序数的等价等价于它们的相等.</p>
<pre class="Agda"><a id="OrdPath"></a><a id="9778" href="Ordinal.Base.html#9778" class="Function">OrdPath</a> <a id="9786" class="Symbol">:</a> <a id="9788" class="Symbol">(</a><a id="9789" href="Ordinal.Base.html#9789" class="Bound">α</a> <a id="9791" href="Ordinal.Base.html#9791" class="Bound">β</a> <a id="9793" class="Symbol">:</a> <a id="9795" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="9799" href="Preliminary.html#2696" class="Generalizable">𝓊</a><a id="9800" class="Symbol">)</a> <a id="9802" class="Symbol">→</a> <a id="9804" class="Symbol">(</a><a id="9805" href="Ordinal.Base.html#9789" class="Bound">α</a> <a id="9807" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="9810" href="Ordinal.Base.html#9791" class="Bound">β</a><a id="9811" class="Symbol">)</a> <a id="9813" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="9815" class="Symbol">(</a><a id="9816" href="Ordinal.Base.html#9789" class="Bound">α</a> <a id="9818" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9820" href="Ordinal.Base.html#9791" class="Bound">β</a><a id="9821" class="Symbol">)</a>
<a id="9823" href="Ordinal.Base.html#9778" class="Function">OrdPath</a> <a id="9831" class="Symbol">=</a> <a id="9833" href="Cubical.Displayed.Base.html#2148" class="Function">∫</a> <a id="9835" href="Ordinal.Base.html#9471" class="Function">𝒮ᴰ-Ord</a> <a id="9842" class="Symbol">.</a><a id="9843" href="Cubical.Displayed.Base.html#580" class="Field">UARel.ua</a>
</pre>
<p>有了序数的泛等原理之后, 就可以通过找到两个序数间保持 <code>_≺_</code> 关系的同伦等价来证明它们相等. 这体现了泛等基础的好处, 我们不需要商掉某个等价关系, 也不用像质料集合论那样用超限归纳证明两个同构的序数外延相等.</p>
<pre class="Agda"><a id="≃ₒ→≡"></a><a id="9975" href="Ordinal.Base.html#9975" class="Function">≃ₒ→≡</a> <a id="9980" class="Symbol">:</a> <a id="9982" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="9984" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="9987" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="9989" class="Symbol">→</a> <a id="9991" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="9993" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9995" href="Ordinal.Base.html#6625" class="Generalizable">β</a>
<a id="9997" href="Ordinal.Base.html#9975" class="Function">≃ₒ→≡</a> <a id="10002" class="Symbol">=</a> <a id="10004" href="Ordinal.Base.html#9778" class="Function">OrdPath</a> <a id="10012" class="Symbol">_</a> <a id="10014" class="Symbol">_</a> <a id="10016" href="Preliminary.html#11646" class="Function Operator">⁺¹</a>

<a id="≡→≃ₒ"></a><a id="10020" href="Ordinal.Base.html#10020" class="Function">≡→≃ₒ</a> <a id="10025" class="Symbol">:</a> <a id="10027" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="10029" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="10031" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="10033" class="Symbol">→</a> <a id="10035" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="10037" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="10040" href="Ordinal.Base.html#6625" class="Generalizable">β</a>
<a id="10042" href="Ordinal.Base.html#10020" class="Function">≡→≃ₒ</a> <a id="10047" class="Symbol">=</a> <a id="10049" href="Ordinal.Base.html#9778" class="Function">OrdPath</a> <a id="10057" class="Symbol">_</a> <a id="10059" class="Symbol">_</a> <a id="10061" href="Preliminary.html#11677" class="Function Operator">⁻¹</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
