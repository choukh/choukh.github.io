<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>泛等结构集合论 (4) 序数的定义</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">泛等结构集合论 (4) 序数的定义</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#泛等结构集合论-4-序数的定义" id="toc-泛等结构集合论-4-序数的定义">泛等结构集合论 (4) 序数的定义</a>
  <ul>
  <li><a href="#序关系的一些性质" id="toc-序关系的一些性质">序关系的一些性质</a>
  <ul>
  <li><a href="#反自反性" id="toc-反自反性">反自反性</a></li>
  <li><a href="#传递性" id="toc-传递性">传递性</a></li>
  </ul></li>
  <li><a href="#外延性" id="toc-外延性">外延性</a>
  <ul>
  <li><a href="#良基性" id="toc-良基性">良基性</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a>
  <ul>
  <li><a href="#序数性" id="toc-序数性">序数性</a></li>
  <li><a href="#序数结构" id="toc-序数结构">序数结构</a></li>
  <li><a href="#序数宇宙" id="toc-序数宇宙">序数宇宙</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="泛等结构集合论-4-序数的定义">泛等结构集合论 (4) 序数的定义</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/USST/blob/main/src/Ordinal/Base.lagda.md">Base.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/USST/Ordinal.Base.html">Base.html</a></p>
</blockquote>
<p>本章将复刻质料集合论的重要概念: 序数.</p>
<pre class="Agda"><a id="307" class="Symbol">{-#</a> <a id="311" class="Keyword">OPTIONS</a> <a id="319" class="Pragma">--cubical</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>
<a id="340" class="Keyword">module</a> <a id="347" href="Ordinal.Base.html" class="Module">Ordinal.Base</a> <a id="360" class="Keyword">where</a>

<a id="367" class="Keyword">open</a> <a id="372" class="Keyword">import</a> <a id="379" href="Preliminary.html" class="Module">Preliminary</a>
<a id="391" class="Keyword">open</a> <a id="396" class="Keyword">import</a> <a id="403" href="Order.html" class="Module">Order</a>
</pre>
<h2 id="序关系的一些性质">序关系的一些性质</h2>
<p>说白了, 一个序数就是由一个集合以及该集合上的一个满足一定性质的序关系所组成的结构. 我们先定义这个序关系需要满足的性质.</p>
<p>给定类型 <code>A : Type ℓ</code> 及其上的序关系 <code>_&lt;_ : A → A → Type ℓ′</code></p>
<pre class="Agda"><a id="549" class="Keyword">module</a> <a id="556" href="Ordinal.Base.html#556" class="Module">_</a> <a id="558" class="Symbol">{</a><a id="559" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="561" class="Symbol">:</a> <a id="563" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="568" href="Preliminary.html#2600" class="Generalizable">ℓ</a><a id="569" class="Symbol">}</a> <a id="571" class="Symbol">(</a><a id="572" href="Ordinal.Base.html#572" class="Bound Operator">_&lt;_</a> <a id="576" class="Symbol">:</a> <a id="578" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="580" class="Symbol">→</a> <a id="582" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="584" class="Symbol">→</a> <a id="586" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="591" href="Preliminary.html#2608" class="Generalizable">ℓ′</a><a id="593" class="Symbol">)</a> <a id="595" class="Keyword">where</a>
</pre>
<h3 id="反自反性">反自反性</h3>
<p>我们说 <code>_&lt;_</code> 是一个 <strong>反自反 (irreflexive)</strong> 关系, 当且仅当对任意 <code>x : A</code>, <code>x ≮ x</code>.</p>
<pre class="Agda">  <a id="693" href="Ordinal.Base.html#693" class="Function Operator">_≮_</a> <a id="697" class="Symbol">:</a> <a id="699" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="701" class="Symbol">→</a> <a id="703" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="705" class="Symbol">→</a> <a id="707" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="712" href="Ordinal.Base.html#591" class="Bound">ℓ′</a>
  <a id="717" href="Ordinal.Base.html#717" class="Bound">x</a> <a id="719" href="Ordinal.Base.html#693" class="Function Operator">≮</a> <a id="721" href="Ordinal.Base.html#721" class="Bound">y</a> <a id="723" class="Symbol">=</a> <a id="725" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="727" href="Ordinal.Base.html#717" class="Bound">x</a> <a id="729" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="731" href="Ordinal.Base.html#721" class="Bound">y</a>

  <a id="736" href="Ordinal.Base.html#736" class="Function">Irreflexive</a> <a id="748" class="Symbol">:</a> <a id="750" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="755" class="Symbol">_</a>
  <a id="759" href="Ordinal.Base.html#736" class="Function">Irreflexive</a> <a id="771" class="Symbol">=</a> <a id="773" class="Symbol">∀</a> <a id="775" href="Ordinal.Base.html#775" class="Bound">x</a> <a id="777" class="Symbol">→</a> <a id="779" href="Ordinal.Base.html#775" class="Bound">x</a> <a id="781" href="Ordinal.Base.html#693" class="Function Operator">≮</a> <a id="783" href="Ordinal.Base.html#775" class="Bound">x</a>
</pre>
<p>反自反性是一个命题.</p>
<pre class="Agda">  <a id="812" href="Ordinal.Base.html#812" class="Function">isPropIrreflexive</a> <a id="830" class="Symbol">:</a> <a id="832" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="839" href="Ordinal.Base.html#736" class="Function">Irreflexive</a>
  <a id="853" href="Ordinal.Base.html#812" class="Function">isPropIrreflexive</a> <a id="871" class="Symbol">=</a> <a id="873" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="882" class="Symbol">λ</a> <a id="884" href="Ordinal.Base.html#884" class="Bound">_</a> <a id="886" href="Ordinal.Base.html#886" class="Bound">_</a> <a id="888" class="Symbol">→</a> <a id="890" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
</pre>
<h3 id="传递性">传递性</h3>
<p>我们说 <code>_&lt;_</code> 是一个 <strong>传递 (transitive)</strong> 关系, 当且仅当对任意 <code>x y z : A</code>, <code>x &lt; y</code> 与 <code>y &lt; z</code> 蕴含 <code>x &lt; z</code>.</p>
<pre class="Agda">  <a id="1012" href="Ordinal.Base.html#1012" class="Function">Transitive</a> <a id="1023" class="Symbol">:</a> <a id="1025" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1030" class="Symbol">_</a>
  <a id="1034" href="Ordinal.Base.html#1012" class="Function">Transitive</a> <a id="1045" class="Symbol">=</a> <a id="1047" class="Symbol">∀</a> <a id="1049" href="Ordinal.Base.html#1049" class="Bound">x</a> <a id="1051" href="Ordinal.Base.html#1051" class="Bound">y</a> <a id="1053" href="Ordinal.Base.html#1053" class="Bound">z</a> <a id="1055" class="Symbol">→</a> <a id="1057" href="Ordinal.Base.html#1049" class="Bound">x</a> <a id="1059" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1061" href="Ordinal.Base.html#1051" class="Bound">y</a> <a id="1063" class="Symbol">→</a> <a id="1065" href="Ordinal.Base.html#1051" class="Bound">y</a> <a id="1067" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1069" href="Ordinal.Base.html#1053" class="Bound">z</a> <a id="1071" class="Symbol">→</a> <a id="1073" href="Ordinal.Base.html#1049" class="Bound">x</a> <a id="1075" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1077" href="Ordinal.Base.html#1053" class="Bound">z</a>
</pre>
<p>如果<code>_&lt;_</code> 是一个命题关系, 那么传递性是一个命题.</p>
<pre class="Agda">  <a id="1124" href="Ordinal.Base.html#1124" class="Function">isPropTransitive</a> <a id="1141" class="Symbol">:</a> <a id="1143" href="Order.html#596" class="Function">Propositional</a> <a id="1157" href="Ordinal.Base.html#572" class="Bound Operator">_&lt;_</a> <a id="1161" class="Symbol">→</a> <a id="1163" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="1170" href="Ordinal.Base.html#1012" class="Function">Transitive</a>
  <a id="1183" href="Ordinal.Base.html#1124" class="Function">isPropTransitive</a> <a id="1200" href="Ordinal.Base.html#1200" class="Bound">prop</a> <a id="1205" class="Symbol">=</a> <a id="1207" href="Cubical.Foundations.HLevels.html#16992" class="Function">isPropΠ5</a> <a id="1216" class="Symbol">λ</a> <a id="1218" href="Ordinal.Base.html#1218" class="Bound">_</a> <a id="1220" href="Ordinal.Base.html#1220" class="Bound">_</a> <a id="1222" href="Ordinal.Base.html#1222" class="Bound">_</a> <a id="1224" href="Ordinal.Base.html#1224" class="Bound">_</a> <a id="1226" href="Ordinal.Base.html#1226" class="Bound">_</a> <a id="1228" class="Symbol">→</a> <a id="1230" href="Ordinal.Base.html#1200" class="Bound">prop</a> <a id="1235" class="Symbol">_</a> <a id="1237" class="Symbol">_</a>
</pre>
<h2 id="外延性">外延性</h2>
<p>我们说 <code>_&lt;_</code> 是一个 <strong>外延 (extensional)</strong> 关系, 当且仅当对任意 <code>x y : A</code>, 如果对任意 <code>z : A</code> 都有 <code>z &lt; x</code> 当且仅当 <code>z &lt; y</code>, 那么 <code>x ≡ y</code>.</p>
<pre class="Agda">  <a id="1372" href="Ordinal.Base.html#1372" class="Function">Extensional</a> <a id="1384" class="Symbol">:</a> <a id="1386" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1391" class="Symbol">_</a>
  <a id="1395" href="Ordinal.Base.html#1372" class="Function">Extensional</a> <a id="1407" class="Symbol">=</a> <a id="1409" class="Symbol">∀</a> <a id="1411" href="Ordinal.Base.html#1411" class="Bound">x</a> <a id="1413" href="Ordinal.Base.html#1413" class="Bound">y</a> <a id="1415" class="Symbol">→</a> <a id="1417" class="Symbol">(∀</a> <a id="1420" href="Ordinal.Base.html#1420" class="Bound">z</a> <a id="1422" class="Symbol">→</a> <a id="1424" href="Ordinal.Base.html#1420" class="Bound">z</a> <a id="1426" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1428" href="Ordinal.Base.html#1411" class="Bound">x</a> <a id="1430" href="Preliminary.html#12015" class="Function Operator">↔</a> <a id="1432" href="Ordinal.Base.html#1420" class="Bound">z</a> <a id="1434" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1436" href="Ordinal.Base.html#1413" class="Bound">y</a><a id="1437" class="Symbol">)</a> <a id="1439" class="Symbol">→</a> <a id="1441" href="Ordinal.Base.html#1411" class="Bound">x</a> <a id="1443" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1445" href="Ordinal.Base.html#1413" class="Bound">y</a>
</pre>
<p>如果 <code>A</code> 是集合, 那么外延性是命题.</p>
<pre class="Agda">  <a id="1485" href="Ordinal.Base.html#1485" class="Function">isPropExtensional</a> <a id="1503" class="Symbol">:</a> <a id="1505" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="1511" href="Ordinal.Base.html#559" class="Bound">A</a> <a id="1513" class="Symbol">→</a> <a id="1515" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="1522" href="Ordinal.Base.html#1372" class="Function">Extensional</a>
  <a id="1536" href="Ordinal.Base.html#1485" class="Function">isPropExtensional</a> <a id="1554" href="Ordinal.Base.html#1554" class="Bound">A-set</a> <a id="1560" class="Symbol">=</a> <a id="1562" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="1571" class="Symbol">λ</a> <a id="1573" href="Ordinal.Base.html#1573" class="Bound">_</a> <a id="1575" href="Ordinal.Base.html#1575" class="Bound">_</a> <a id="1577" href="Ordinal.Base.html#1577" class="Bound">_</a> <a id="1579" class="Symbol">→</a> <a id="1581" href="Preliminary.html#9444" class="Function">transportIsProp</a> <a id="1597" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1599" href="Ordinal.Base.html#1554" class="Bound">A-set</a> <a id="1605" class="Symbol">_</a> <a id="1607" class="Symbol">_</a>
</pre>
<h3 id="良基性">良基性</h3>
<p>我们说在 <code>_&lt;_</code> 关系下, 一个 <code>x : A</code> <strong>可及 (accessible)</strong>, 当且仅当对任意 <code>y &lt; x</code>, <code>y</code> 也可及.</p>
<pre class="Agda">  <a id="1708" class="Keyword">data</a> <a id="1713" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="1717" class="Symbol">(</a><a id="1718" href="Ordinal.Base.html#1718" class="Bound">x</a> <a id="1720" class="Symbol">:</a> <a id="1722" href="Ordinal.Base.html#559" class="Bound">A</a><a id="1723" class="Symbol">)</a> <a id="1725" class="Symbol">:</a> <a id="1727" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1732" class="Symbol">(</a><a id="1733" href="Ordinal.Base.html#568" class="Bound">ℓ</a> <a id="1735" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="1737" href="Ordinal.Base.html#591" class="Bound">ℓ′</a><a id="1739" class="Symbol">)</a> <a id="1741" class="Keyword">where</a>
    <a id="1751" href="Ordinal.Base.html#1751" class="InductiveConstructor">acc</a> <a id="1755" class="Symbol">:</a> <a id="1757" class="Symbol">(∀</a> <a id="1760" href="Ordinal.Base.html#1760" class="Bound">y</a> <a id="1762" class="Symbol">→</a> <a id="1764" href="Ordinal.Base.html#1760" class="Bound">y</a> <a id="1766" href="Ordinal.Base.html#572" class="Bound Operator">&lt;</a> <a id="1768" href="Ordinal.Base.html#1718" class="Bound">x</a> <a id="1770" class="Symbol">→</a> <a id="1772" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="1776" href="Ordinal.Base.html#1760" class="Bound">y</a><a id="1777" class="Symbol">)</a> <a id="1779" class="Symbol">→</a> <a id="1781" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="1785" href="Ordinal.Base.html#1718" class="Bound">x</a>
</pre>
<p>我们说 <code>_&lt;_</code> 是一个 <strong>良基 (well-founded)</strong> 关系, 当且仅当任意 <code>x : A</code> 都可及.</p>
<pre class="Agda">  <a id="1863" href="Ordinal.Base.html#1863" class="Function">WellFounded</a> <a id="1875" class="Symbol">:</a> <a id="1877" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1882" class="Symbol">_</a>
  <a id="1886" href="Ordinal.Base.html#1863" class="Function">WellFounded</a> <a id="1898" class="Symbol">=</a> <a id="1900" class="Symbol">∀</a> <a id="1902" href="Ordinal.Base.html#1902" class="Bound">x</a> <a id="1904" class="Symbol">→</a> <a id="1906" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="1910" href="Ordinal.Base.html#1902" class="Bound">x</a>
</pre>
<p>可及性是一个命题. 下面的证明中暴露了 cubical 的底层机制, 就是那个 <code>i</code>, 以使证明更简洁. 也可以不暴露, 只需证 <code>H₁</code> 等于 <code>H₂</code>, 它们都具有 <code>∀ y → y &lt; x → Acc y</code> 类型. 由归纳假设, <code>Acc y</code> 是命题, 所以这个Π类型也是命题, 所以它的两个项 <code>H₁</code> 与 <code>H₂</code> 相等.</p>
<pre class="Agda">  <a id="2097" href="Ordinal.Base.html#2097" class="Function">isPropAcc</a> <a id="2107" class="Symbol">:</a> <a id="2109" class="Symbol">∀</a> <a id="2111" href="Ordinal.Base.html#2111" class="Bound">x</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="2122" class="Symbol">(</a><a id="2123" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="2127" href="Ordinal.Base.html#2111" class="Bound">x</a><a id="2128" class="Symbol">)</a>
  <a id="2132" href="Ordinal.Base.html#2097" class="Function">isPropAcc</a> <a id="2142" href="Ordinal.Base.html#2142" class="Bound">x</a> <a id="2144" class="Symbol">(</a><a id="2145" href="Ordinal.Base.html#1751" class="InductiveConstructor">acc</a> <a id="2149" href="Ordinal.Base.html#2149" class="Bound">H₁</a><a id="2151" class="Symbol">)</a> <a id="2153" class="Symbol">(</a><a id="2154" href="Ordinal.Base.html#1751" class="InductiveConstructor">acc</a> <a id="2158" href="Ordinal.Base.html#2158" class="Bound">H₂</a><a id="2160" class="Symbol">)</a> <a id="2162" href="Ordinal.Base.html#2162" class="Bound">i</a> <a id="2164" class="Symbol">=</a> <a id="2166" href="Ordinal.Base.html#1751" class="InductiveConstructor">acc</a> <a id="2170" class="Symbol">λ</a> <a id="2172" href="Ordinal.Base.html#2172" class="Bound">y</a> <a id="2174" href="Ordinal.Base.html#2174" class="Bound">y&lt;x</a> <a id="2178" class="Symbol">→</a> <a id="2180" href="Ordinal.Base.html#2097" class="Function">isPropAcc</a> <a id="2190" href="Ordinal.Base.html#2172" class="Bound">y</a> <a id="2192" class="Symbol">(</a><a id="2193" href="Ordinal.Base.html#2149" class="Bound">H₁</a> <a id="2196" href="Ordinal.Base.html#2172" class="Bound">y</a> <a id="2198" href="Ordinal.Base.html#2174" class="Bound">y&lt;x</a><a id="2201" class="Symbol">)</a> <a id="2203" class="Symbol">(</a><a id="2204" href="Ordinal.Base.html#2158" class="Bound">H₂</a> <a id="2207" href="Ordinal.Base.html#2172" class="Bound">y</a> <a id="2209" href="Ordinal.Base.html#2174" class="Bound">y&lt;x</a><a id="2212" class="Symbol">)</a> <a id="2214" href="Ordinal.Base.html#2162" class="Bound">i</a>
</pre>
<p>良基性也是一个命题.</p>
<pre class="Agda">  <a id="2243" href="Ordinal.Base.html#2243" class="Function">isPropWellFounded</a> <a id="2261" class="Symbol">:</a> <a id="2263" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="2270" href="Ordinal.Base.html#1863" class="Function">WellFounded</a>
  <a id="2284" href="Ordinal.Base.html#2243" class="Function">isPropWellFounded</a> <a id="2302" class="Symbol">=</a> <a id="2304" href="Cubical.Foundations.HLevels.html#16363" class="Function">isPropΠ</a> <a id="2312" class="Symbol">λ</a> <a id="2314" href="Ordinal.Base.html#2314" class="Bound">_</a> <a id="2316" class="Symbol">→</a> <a id="2318" href="Ordinal.Base.html#2097" class="Function">isPropAcc</a> <a id="2328" class="Symbol">_</a>
</pre>
<p>良基性蕴含反自反性. 只需证对任意可及的 <code>x</code> 都有 <code>x ≮ x</code>, 显然成立.</p>
<pre class="Agda">  <a id="2389" href="Ordinal.Base.html#2389" class="Function">Acc→Irreflexive</a> <a id="2405" class="Symbol">:</a> <a id="2407" class="Symbol">∀</a> <a id="2409" href="Ordinal.Base.html#2409" class="Bound">x</a> <a id="2411" class="Symbol">→</a> <a id="2413" href="Ordinal.Base.html#1713" class="Datatype">Acc</a> <a id="2417" href="Ordinal.Base.html#2409" class="Bound">x</a> <a id="2419" class="Symbol">→</a> <a id="2421" href="Ordinal.Base.html#2409" class="Bound">x</a> <a id="2423" href="Ordinal.Base.html#693" class="Function Operator">≮</a> <a id="2425" href="Ordinal.Base.html#2409" class="Bound">x</a>
  <a id="2429" href="Ordinal.Base.html#2389" class="Function">Acc→Irreflexive</a> <a id="2445" href="Ordinal.Base.html#2445" class="Bound">x</a> <a id="2447" class="Symbol">(</a><a id="2448" href="Ordinal.Base.html#1751" class="InductiveConstructor">acc</a> <a id="2452" href="Ordinal.Base.html#2452" class="Bound">H</a><a id="2453" class="Symbol">)</a> <a id="2455" href="Ordinal.Base.html#2455" class="Bound">x&lt;x</a> <a id="2459" class="Symbol">=</a> <a id="2461" href="Ordinal.Base.html#2389" class="Function">Acc→Irreflexive</a> <a id="2477" href="Ordinal.Base.html#2445" class="Bound">x</a> <a id="2479" class="Symbol">(</a><a id="2480" href="Ordinal.Base.html#2452" class="Bound">H</a> <a id="2482" href="Ordinal.Base.html#2445" class="Bound">x</a> <a id="2484" href="Ordinal.Base.html#2455" class="Bound">x&lt;x</a><a id="2487" class="Symbol">)</a> <a id="2489" href="Ordinal.Base.html#2455" class="Bound">x&lt;x</a>

  <a id="2496" href="Ordinal.Base.html#2496" class="Function">WellFounded→Irreflexive</a> <a id="2520" class="Symbol">:</a> <a id="2522" href="Ordinal.Base.html#1863" class="Function">WellFounded</a> <a id="2534" class="Symbol">→</a> <a id="2536" href="Ordinal.Base.html#736" class="Function">Irreflexive</a>
  <a id="2550" href="Ordinal.Base.html#2496" class="Function">WellFounded→Irreflexive</a> <a id="2574" href="Ordinal.Base.html#2574" class="Bound">wf</a> <a id="2577" href="Ordinal.Base.html#2577" class="Bound">x</a> <a id="2579" class="Symbol">=</a> <a id="2581" href="Ordinal.Base.html#2389" class="Function">Acc→Irreflexive</a> <a id="2597" href="Ordinal.Base.html#2577" class="Bound">x</a> <a id="2599" class="Symbol">(</a><a id="2600" href="Ordinal.Base.html#2574" class="Bound">wf</a> <a id="2603" href="Ordinal.Base.html#2577" class="Bound">x</a><a id="2604" class="Symbol">)</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<h3 id="序数性">序数性</h3>
<p>我们说类型 <code>A</code> 和其上的序关系 <code>_&lt;_</code> 构成一个 <strong>序数 (ordinal)</strong>, 记作 <code>IsOrdinal A _&lt;_</code>, 当且仅当它们满足: <code>A</code> 是集合且 <code>_&lt;_</code> 有命题性, 传递性, 外延性和良基性. 因为良基性蕴含反自反性, 所以 <code>_&lt;_</code> 也有反自反性.</p>
<pre class="Agda"><a id="2783" class="Keyword">record</a> <a id="IsOrdinal"></a><a id="2790" href="Ordinal.Base.html#2790" class="Record">IsOrdinal</a> <a id="2800" class="Symbol">(</a><a id="2801" href="Ordinal.Base.html#2801" class="Bound">A</a> <a id="2803" class="Symbol">:</a> <a id="2805" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="2810" href="Preliminary.html#2600" class="Generalizable">ℓ</a><a id="2811" class="Symbol">)</a> <a id="2813" class="Symbol">(</a><a id="2814" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a> <a id="2818" class="Symbol">:</a> <a id="2820" href="Ordinal.Base.html#2801" class="Bound">A</a> <a id="2822" class="Symbol">→</a> <a id="2824" href="Ordinal.Base.html#2801" class="Bound">A</a> <a id="2826" class="Symbol">→</a> <a id="2828" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="2833" href="Preliminary.html#2608" class="Generalizable">ℓ′</a><a id="2835" class="Symbol">)</a> <a id="2837" class="Symbol">:</a> <a id="2839" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="2844" class="Symbol">(</a><a id="2845" href="Ordinal.Base.html#2810" class="Bound">ℓ</a> <a id="2847" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2849" href="Ordinal.Base.html#2833" class="Bound">ℓ′</a><a id="2851" class="Symbol">)</a> <a id="2853" class="Keyword">where</a>
  <a id="2861" class="Keyword">constructor</a> <a id="mkIsOrdinal"></a><a id="2873" href="Ordinal.Base.html#2873" class="InductiveConstructor">mkIsOrdinal</a>
  <a id="2887" class="Keyword">field</a>
    <a id="IsOrdinal.ord-set"></a><a id="2897" href="Ordinal.Base.html#2897" class="Field">ord-set</a>   <a id="2907" class="Symbol">:</a> <a id="2909" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="2915" href="Ordinal.Base.html#2801" class="Bound">A</a>
    <a id="IsOrdinal.&lt;-order"></a><a id="2921" href="Ordinal.Base.html#2921" class="Field">&lt;-order</a>   <a id="2931" class="Symbol">:</a> <a id="2933" href="Order.html#827" class="Record">IsOrder</a> <a id="2941" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a>
    <a id="IsOrdinal.&lt;-trans"></a><a id="2949" href="Ordinal.Base.html#2949" class="Field">&lt;-trans</a>   <a id="2959" class="Symbol">:</a> <a id="2961" href="Ordinal.Base.html#1012" class="Function">Transitive</a> <a id="2972" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a>
    <a id="IsOrdinal.&lt;-ext"></a><a id="2980" href="Ordinal.Base.html#2980" class="Field">&lt;-ext</a>     <a id="2990" class="Symbol">:</a> <a id="2992" href="Ordinal.Base.html#1372" class="Function">Extensional</a> <a id="3004" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a>
    <a id="IsOrdinal.&lt;-wf"></a><a id="3012" href="Ordinal.Base.html#3012" class="Field">&lt;-wf</a>      <a id="3022" class="Symbol">:</a> <a id="3024" href="Ordinal.Base.html#1863" class="Function">WellFounded</a> <a id="3036" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a>

  <a id="IsOrdinal.&lt;-irrefl"></a><a id="3043" href="Ordinal.Base.html#3043" class="Function">&lt;-irrefl</a> <a id="3052" class="Symbol">:</a> <a id="3054" href="Ordinal.Base.html#736" class="Function">Irreflexive</a> <a id="3066" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a>
  <a id="3072" href="Ordinal.Base.html#3043" class="Function">&lt;-irrefl</a> <a id="3081" class="Symbol">=</a> <a id="3083" href="Ordinal.Base.html#2496" class="Function">WellFounded→Irreflexive</a> <a id="3107" href="Ordinal.Base.html#2814" class="Bound Operator">_&lt;_</a> <a id="3111" href="Ordinal.Base.html#3012" class="Field">&lt;-wf</a>

  <a id="3119" class="Keyword">open</a> <a id="3124" href="Order.html#827" class="Module">IsOrder</a> <a id="3132" href="Ordinal.Base.html#2921" class="Field">&lt;-order</a> <a id="3140" class="Keyword">public</a>
</pre>
<p>由于序数性里面的每个条件都是命题, 所以序数性也是一个命题.</p>
<pre class="Agda"><a id="3192" class="Keyword">unquoteDecl</a> <a id="IsOrdinalIsoΣ"></a><a id="3204" href="Ordinal.Base.html#3204" class="Function">IsOrdinalIsoΣ</a> <a id="3218" class="Symbol">=</a> <a id="3220" href="Cubical.Reflection.RecordEquiv.html#9804" class="Function">declareRecordIsoΣ</a> <a id="3238" href="Ordinal.Base.html#3204" class="Function">IsOrdinalIsoΣ</a> <a id="3252" class="Symbol">(</a><a id="3253" class="Keyword">quote</a> <a id="3259" href="Ordinal.Base.html#2790" class="Record">IsOrdinal</a><a id="3268" class="Symbol">)</a>

<a id="isPropIsOrdinal"></a><a id="3271" href="Ordinal.Base.html#3271" class="Function">isPropIsOrdinal</a> <a id="3287" class="Symbol">:</a> <a id="3289" class="Symbol">(</a><a id="3290" href="Ordinal.Base.html#3290" class="Bound">A</a> <a id="3292" class="Symbol">:</a> <a id="3294" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3299" href="Preliminary.html#2600" class="Generalizable">ℓ</a><a id="3300" class="Symbol">)</a> <a id="3302" class="Symbol">(</a><a id="3303" href="Ordinal.Base.html#3303" class="Bound Operator">_&lt;_</a> <a id="3307" class="Symbol">:</a> <a id="3309" href="Ordinal.Base.html#3290" class="Bound">A</a> <a id="3311" class="Symbol">→</a> <a id="3313" href="Ordinal.Base.html#3290" class="Bound">A</a> <a id="3315" class="Symbol">→</a> <a id="3317" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3322" href="Preliminary.html#2608" class="Generalizable">ℓ′</a><a id="3324" class="Symbol">)</a> <a id="3326" class="Symbol">→</a> <a id="3328" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3335" class="Symbol">(</a><a id="3336" href="Ordinal.Base.html#2790" class="Record">IsOrdinal</a> <a id="3346" href="Ordinal.Base.html#3290" class="Bound">A</a> <a id="3348" href="Ordinal.Base.html#3303" class="Bound Operator">_&lt;_</a><a id="3351" class="Symbol">)</a>
<a id="3353" href="Ordinal.Base.html#3271" class="Function">isPropIsOrdinal</a> <a id="3369" href="Ordinal.Base.html#3369" class="Bound">A</a> <a id="3371" href="Ordinal.Base.html#3371" class="Bound Operator">_&lt;_</a> <a id="3375" class="Symbol">=</a> <a id="3377" href="Cubical.Foundations.HLevels.html#8859" class="Function">isOfHLevelRetractFromIso</a> <a id="3402" class="Number">1</a> <a id="3404" href="Ordinal.Base.html#3204" class="Function">IsOrdinalIsoΣ</a> <a id="3418" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a>
  <a id="3422" href="Cubical.Foundations.HLevels.html#12387" class="Function">isPropΣ</a> <a id="3430" class="Symbol">(</a><a id="3431" href="Order.html#688" class="Function">isPropPropositional</a> <a id="3451" class="Symbol">_)</a> <a id="3454" class="Symbol">λ</a> <a id="3456" href="Ordinal.Base.html#3456" class="Bound">ord-set</a> <a id="3464" class="Symbol">→</a>
  <a id="3468" href="Cubical.Foundations.HLevels.html#12387" class="Function">isPropΣ</a> <a id="3476" href="Order.html#1035" class="Function">isPropIsOrder</a> <a id="3490" class="Symbol">λ</a> <a id="3492" href="Ordinal.Base.html#3492" class="Bound">isOrder</a> <a id="3500" class="Symbol">→</a> <a id="3502" class="Keyword">let</a> <a id="3506" class="Keyword">open</a> <a id="3511" href="Order.html#827" class="Module">IsOrder</a> <a id="3519" href="Ordinal.Base.html#3492" class="Bound">isOrder</a> <a id="3527" class="Keyword">in</a> <a id="3530" href="Cubical.Foundations.HLevels.html#13430" class="Function">isProp×2</a>
    <a id="3543" class="Symbol">(</a><a id="3544" href="Ordinal.Base.html#1124" class="Function">isPropTransitive</a> <a id="3561" class="Symbol">_</a> <a id="3563" href="Order.html#930" class="Field">order-prop</a><a id="3573" class="Symbol">)</a>
    <a id="3579" class="Symbol">(</a><a id="3580" href="Ordinal.Base.html#1485" class="Function">isPropExtensional</a> <a id="3598" class="Symbol">_</a> <a id="3600" href="Ordinal.Base.html#3456" class="Bound">ord-set</a><a id="3607" class="Symbol">)</a>
    <a id="3613" class="Symbol">(</a><a id="3614" href="Ordinal.Base.html#2243" class="Function">isPropWellFounded</a> <a id="3632" class="Symbol">_)</a>
</pre>
<h3 id="序数结构">序数结构</h3>
<p>一个类型 <code>A</code> 配备上满足序数性的序关系 <code>_&lt;_</code> 就构成了一个序数结构 <code>OrdianlStr</code>.</p>
<pre class="Agda"><a id="3712" class="Keyword">record</a> <a id="OrdianlStr"></a><a id="3719" href="Ordinal.Base.html#3719" class="Record">OrdianlStr</a> <a id="3730" class="Symbol">(</a><a id="3731" href="Ordinal.Base.html#3731" class="Bound">ℓ′</a> <a id="3734" class="Symbol">:</a> <a id="3736" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="3741" class="Symbol">)</a> <a id="3743" class="Symbol">(</a><a id="3744" href="Ordinal.Base.html#3744" class="Bound">A</a> <a id="3746" class="Symbol">:</a> <a id="3748" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3753" href="Preliminary.html#2600" class="Generalizable">ℓ</a><a id="3754" class="Symbol">)</a> <a id="3756" class="Symbol">:</a> <a id="3758" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3763" class="Symbol">(</a><a id="3764" href="Ordinal.Base.html#3753" class="Bound">ℓ</a> <a id="3766" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="3768" href="Agda.Primitive.html#931" class="Primitive">ℓ-suc</a> <a id="3774" href="Ordinal.Base.html#3731" class="Bound">ℓ′</a><a id="3776" class="Symbol">)</a> <a id="3778" class="Keyword">where</a>
  <a id="3786" class="Keyword">constructor</a> <a id="mkOrdianlStr"></a><a id="3798" href="Ordinal.Base.html#3798" class="InductiveConstructor">mkOrdianlStr</a>
  <a id="3813" class="Keyword">field</a>
    <a id="OrdianlStr._&lt;_"></a><a id="3823" href="Ordinal.Base.html#3823" class="Field Operator">_&lt;_</a> <a id="3827" class="Symbol">:</a> <a id="3829" href="Ordinal.Base.html#3744" class="Bound">A</a> <a id="3831" class="Symbol">→</a> <a id="3833" href="Ordinal.Base.html#3744" class="Bound">A</a> <a id="3835" class="Symbol">→</a> <a id="3837" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3842" href="Ordinal.Base.html#3731" class="Bound">ℓ′</a>
    <a id="OrdianlStr.isOrdinal"></a><a id="3849" href="Ordinal.Base.html#3849" class="Field">isOrdinal</a> <a id="3859" class="Symbol">:</a> <a id="3861" href="Ordinal.Base.html#2790" class="Record">IsOrdinal</a> <a id="3871" href="Ordinal.Base.html#3744" class="Bound">A</a> <a id="3873" href="Ordinal.Base.html#3823" class="Field Operator">_&lt;_</a>
  <a id="3879" class="Keyword">open</a> <a id="3884" href="Ordinal.Base.html#2790" class="Module">IsOrdinal</a> <a id="3894" href="Ordinal.Base.html#3849" class="Field">isOrdinal</a> <a id="3904" class="Keyword">public</a>
</pre>
<h3 id="序数宇宙">序数宇宙</h3>
<p>序数宇宙 <code>Ordinal</code> 定义为类型宇宙配备上序数结构.</p>
<pre class="Agda"><a id="Ordinal"></a><a id="3966" href="Ordinal.Base.html#3966" class="Function">Ordinal</a> <a id="3974" class="Symbol">:</a> <a id="3976" class="Symbol">(</a><a id="3977" href="Ordinal.Base.html#3977" class="Bound">ℓ</a> <a id="3979" href="Ordinal.Base.html#3979" class="Bound">ℓ′</a> <a id="3982" class="Symbol">:</a> <a id="3984" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="3989" class="Symbol">)</a> <a id="3991" class="Symbol">→</a> <a id="3993" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3998" class="Symbol">_</a>
<a id="4000" href="Ordinal.Base.html#3966" class="Function">Ordinal</a> <a id="4008" href="Ordinal.Base.html#4008" class="Bound">ℓ</a> <a id="4010" href="Ordinal.Base.html#4010" class="Bound">ℓ′</a> <a id="4013" class="Symbol">=</a> <a id="4015" href="Cubical.Foundations.Structure.html#398" class="Function">TypeWithStr</a> <a id="4027" href="Ordinal.Base.html#4008" class="Bound">ℓ</a> <a id="4029" class="Symbol">(</a><a id="4030" href="Ordinal.Base.html#3719" class="Record">OrdianlStr</a> <a id="4041" href="Ordinal.Base.html#4010" class="Bound">ℓ′</a><a id="4043" class="Symbol">)</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
