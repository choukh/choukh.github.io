<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>泛等结构集合论 (5) 吃自己:序数宇宙也是序数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">泛等结构集合论 (5) 吃自己:序数宇宙也是序数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#泛等结构集合论-5-吃自己-序数宇宙也是序数" id="toc-泛等结构集合论-5-吃自己-序数宇宙也是序数">泛等结构集合论 (5) 吃自己: 序数宇宙也是序数</a>
  <ul>
  <li><a href="#前段" id="toc-前段">前段</a>
  <ul>
  <li><a href="#前段嵌入" id="toc-前段嵌入">前段嵌入</a></li>
  <li><a href="#单射性" id="toc-单射性">单射性</a></li>
  <li><a href="#前段的重要性质" id="toc-前段的重要性质">前段的重要性质</a></li>
  </ul></li>
  <li><a href="#严格序" id="toc-严格序">严格序</a>
  <ul>
  <li><a href="#性质" id="toc-性质">性质</a></li>
  </ul></li>
  <li><a href="#吃自己" id="toc-吃自己">吃自己</a></li>
  <li><a href="#布拉利-福尔蒂悖论" id="toc-布拉利-福尔蒂悖论">布拉利-福尔蒂悖论</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="泛等结构集合论-5-吃自己-序数宇宙也是序数">泛等结构集合论 (5) 吃自己: 序数宇宙也是序数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/USST/blob/main/src/Ordinal/OrdInOrd.lagda.md">Ordinal.OrdInOrd.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/USST/Ordinal.OrdInOrd.html">Ordinal.OrdInOrd.html</a></p>
</blockquote>
<pre class="Agda"><a id="332" class="Symbol">{-#</a> <a id="336" class="Keyword">OPTIONS</a> <a id="344" class="Pragma">--cubical</a> <a id="354" class="Pragma">--safe</a> <a id="361" class="Symbol">#-}</a>
<a id="365" class="Symbol">{-#</a> <a id="369" class="Keyword">OPTIONS</a> <a id="377" class="Pragma">--lossy-unification</a> <a id="397" class="Pragma">--hidden-argument-puns</a> <a id="420" class="Symbol">#-}</a>
<a id="424" class="Keyword">module</a> <a id="431" href="Ordinal.OrdInOrd.html" class="Module">Ordinal.OrdInOrd</a> <a id="448" class="Keyword">where</a>
<a id="454" class="Keyword">open</a> <a id="459" class="Keyword">import</a> <a id="466" href="Preliminary.html" class="Module">Preliminary</a>
<a id="478" class="Keyword">open</a> <a id="483" class="Keyword">import</a> <a id="490" href="Ordinal.Base.html" class="Module">Ordinal.Base</a>
<a id="503" class="Keyword">open</a> <a id="508" class="Keyword">import</a> <a id="515" href="Ordinal.Order.html" class="Module">Ordinal.Order</a>
</pre>
<h2 id="前段">前段</h2>
<p>前段是指序数 <code>α</code> 的底集 <code>⟨ α ⟩</code> 里小于某个上界 <code>a</code> 的那些元素, 它们具有类型</p>
<p><code>B = Σ ⟨ α ⟩ (_≺ a)</code></p>
<p>且 <code>B</code> 也构成了一个序数, 记作 <code>α ↓ a</code>.</p>
<pre class="Agda"><a id="650" class="Keyword">infix</a> <a id="656" class="Number">21</a> <a id="659" href="Ordinal.OrdInOrd.html#663" class="Function Operator">_↓_</a>
<a id="_↓_"></a><a id="663" href="Ordinal.OrdInOrd.html#663" class="Function Operator">_↓_</a> <a id="667" class="Symbol">:</a> <a id="669" class="Symbol">(</a><a id="670" href="Ordinal.OrdInOrd.html#670" class="Bound">α</a> <a id="672" class="Symbol">:</a> <a id="674" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="678" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="679" class="Symbol">)</a> <a id="681" class="Symbol">→</a> <a id="683" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="685" href="Ordinal.OrdInOrd.html#670" class="Bound">α</a> <a id="687" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="689" class="Symbol">→</a> <a id="691" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="695" href="Preliminary.html#2692" class="Generalizable">𝓊</a>
<a id="697" href="Ordinal.OrdInOrd.html#697" class="Bound">α</a> <a id="699" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="701" href="Ordinal.OrdInOrd.html#701" class="Bound">a</a> <a id="703" class="Symbol">=</a> <a id="705" href="Ordinal.OrdInOrd.html#746" class="Function">B</a> <a id="707" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="709" href="Ordinal.OrdInOrd.html#1012" class="Function">strB</a>
  <a id="716" class="Keyword">where</a>
  <a id="724" class="Keyword">open</a> <a id="729" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="736" class="Symbol">(</a><a id="737" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="741" href="Ordinal.OrdInOrd.html#697" class="Bound">α</a><a id="742" class="Symbol">)</a>
  <a id="746" href="Ordinal.OrdInOrd.html#746" class="Function">B</a> <a id="748" class="Symbol">:</a> <a id="750" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="755" class="Symbol">_</a>
  <a id="759" href="Ordinal.OrdInOrd.html#746" class="Function">B</a> <a id="761" class="Symbol">=</a> <a id="763" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="765" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="767" href="Ordinal.OrdInOrd.html#697" class="Bound">α</a> <a id="769" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="771" class="Symbol">(</a><a id="772" href="Ordinal.Base.html#6076" class="Function Operator">_≺</a> <a id="775" href="Ordinal.OrdInOrd.html#701" class="Bound">a</a><a id="776" class="Symbol">)</a>
</pre>
<p>为了完成前段 <code>α ↓ a</code> 的构造, 我们还需要说明 <code>B</code> 具有序数结构 <code>strB</code>. 首先取原序数 <code>α</code> 的底序 <code>_≺_</code> 作为新序数 <code>α ↓ a</code> 的底序, 记作 <code>≺′</code>.</p>
<pre class="Agda">  <a id="890" href="Ordinal.OrdInOrd.html#890" class="Function Operator">_≺′_</a> <a id="895" class="Symbol">:</a> <a id="897" href="Ordinal.OrdInOrd.html#746" class="Function">B</a> <a id="899" class="Symbol">→</a> <a id="901" href="Ordinal.OrdInOrd.html#746" class="Function">B</a> <a id="903" class="Symbol">→</a> <a id="905" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="910" class="Symbol">_</a>
  <a id="914" class="Symbol">(</a><a id="915" href="Ordinal.OrdInOrd.html#915" class="Bound">x</a> <a id="917" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="919" class="Symbol">_)</a> <a id="922" href="Ordinal.OrdInOrd.html#890" class="Function Operator">≺′</a> <a id="925" class="Symbol">(</a><a id="926" href="Ordinal.OrdInOrd.html#926" class="Bound">y</a> <a id="928" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="930" class="Symbol">_)</a> <a id="933" class="Symbol">=</a> <a id="935" href="Ordinal.OrdInOrd.html#915" class="Bound">x</a> <a id="937" href="Ordinal.Base.html#6076" class="Function Operator">≺</a> <a id="939" href="Ordinal.OrdInOrd.html#926" class="Bound">y</a>
</pre>
<p>我们需要说明 <code>≺′</code> 也是良序, 即满足命题性, 传递性, 外延性和良基性. 其中命题性和传递性是显然的.</p>
<pre class="Agda">  <a id="1012" href="Ordinal.OrdInOrd.html#1012" class="Function">strB</a> <a id="1017" class="Symbol">:</a> <a id="1019" href="Ordinal.Base.html#5980" class="Record">OrdStr</a> <a id="1026" href="Ordinal.OrdInOrd.html#746" class="Function">B</a>
  <a id="1030" href="Ordinal.OrdInOrd.html#1012" class="Function">strB</a> <a id="1035" class="Symbol">=</a> <a id="1037" href="Ordinal.Base.html#6033" class="InductiveConstructor">mkOrdStr</a> <a id="1046" href="Ordinal.OrdInOrd.html#890" class="Function Operator">_≺′_</a> <a id="1051" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1053" href="Ordinal.Base.html#4639" class="InductiveConstructor">mkWellOrdered</a>
    <a id="1071" class="Comment">{- 命题性 -}</a> <a id="1081" class="Symbol">(λ</a> <a id="1084" href="Ordinal.OrdInOrd.html#1084" class="Bound">_</a> <a id="1086" href="Ordinal.OrdInOrd.html#1086" class="Bound">_</a> <a id="1088" class="Symbol">→</a> <a id="1090" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="1097" class="Symbol">_</a> <a id="1099" class="Symbol">_)</a>
    <a id="1106" class="Comment">{- 传递性 -}</a> <a id="1116" class="Symbol">(λ</a> <a id="1119" href="Ordinal.OrdInOrd.html#1119" class="Bound">_</a> <a id="1121" href="Ordinal.OrdInOrd.html#1121" class="Bound">_</a> <a id="1123" href="Ordinal.OrdInOrd.html#1123" class="Bound">_</a> <a id="1125" href="Ordinal.OrdInOrd.html#1125" class="Bound">x&lt;y</a> <a id="1129" href="Ordinal.OrdInOrd.html#1129" class="Bound">y&lt;z</a> <a id="1133" class="Symbol">→</a> <a id="1135" href="Ordinal.Base.html#4701" class="Function">≺-trans</a> <a id="1143" class="Symbol">_</a> <a id="1145" class="Symbol">_</a> <a id="1147" class="Symbol">_</a> <a id="1149" href="Ordinal.OrdInOrd.html#1125" class="Bound">x&lt;y</a> <a id="1153" href="Ordinal.OrdInOrd.html#1129" class="Bound">y&lt;z</a><a id="1156" class="Symbol">)</a>
</pre>
<p>对于外延性, 要证两个前段元素 <code>(x , x≺a)</code> 和 <code>(y , y≺a)</code> 相等. 已知前提 <code>H</code>, 它说对任意 <code>z ≺ a</code> 有 <code>z ≺ x ↔︎ z ≺ y</code>. 由于前段元素是依值配对, 且右边是命题, 只需证它们的左边相等. 用原序数 <code>α</code> 的底序 <code>_≺_</code> 的外延性 <code>≺-ext</code>, 要证 <code>x ≼ y</code> 且 <code>y ≼ x</code>. 假设 <code>z ≺ x</code>, 由传递性都有 <code>z ≺ a</code>, 由 <code>H</code> 即证 <code>z ≺ y</code>. 假设 <code>z ≺ y</code> 同理可证 <code>z ≺ x</code>.</p>
<pre class="Agda">    <a id="1424" class="Comment">{- 外延性 -}</a> <a id="1434" class="Symbol">(λ</a> <a id="1437" class="Symbol">(</a><a id="1438" href="Ordinal.OrdInOrd.html#1438" class="Bound">x</a> <a id="1440" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1442" href="Ordinal.OrdInOrd.html#1442" class="Bound">x≺a</a><a id="1445" class="Symbol">)</a> <a id="1447" class="Symbol">(</a><a id="1448" href="Ordinal.OrdInOrd.html#1448" class="Bound">y</a> <a id="1450" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1452" href="Ordinal.OrdInOrd.html#1452" class="Bound">y≺a</a><a id="1455" class="Symbol">)</a> <a id="1457" href="Ordinal.OrdInOrd.html#1457" class="Bound">H</a> <a id="1459" class="Symbol">→</a> <a id="1461" href="Preliminary.html#9778" class="Function">Σ≡Prop</a>
      <a id="1474" class="Symbol">(λ</a> <a id="1477" href="Ordinal.OrdInOrd.html#1477" class="Bound">_</a> <a id="1479" class="Symbol">→</a> <a id="1481" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="1488" class="Symbol">_</a> <a id="1490" class="Symbol">_)</a>
      <a id="1499" class="Symbol">(</a><a id="1500" href="Ordinal.Base.html#4730" class="Function">≺-ext</a> <a id="1506" href="Ordinal.OrdInOrd.html#1438" class="Bound">x</a> <a id="1508" href="Ordinal.OrdInOrd.html#1448" class="Bound">y</a> <a id="1510" class="Symbol">λ</a> <a id="1512" href="Ordinal.OrdInOrd.html#1512" class="Bound">z</a> <a id="1514" class="Symbol">→</a> <a id="1516" class="Symbol">(λ</a> <a id="1519" href="Ordinal.OrdInOrd.html#1519" class="Bound">z≺x</a> <a id="1523" class="Symbol">→</a> <a id="1525" href="Ordinal.OrdInOrd.html#1457" class="Bound">H</a> <a id="1527" class="Symbol">(</a><a id="1528" href="Ordinal.OrdInOrd.html#1512" class="Bound">z</a> <a id="1530" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1532" href="Ordinal.Base.html#4701" class="Function">≺-trans</a> <a id="1540" href="Ordinal.OrdInOrd.html#1512" class="Bound">z</a> <a id="1542" href="Ordinal.OrdInOrd.html#1438" class="Bound">x</a> <a id="1544" href="Ordinal.OrdInOrd.html#701" class="Bound">a</a> <a id="1546" href="Ordinal.OrdInOrd.html#1519" class="Bound">z≺x</a> <a id="1550" href="Ordinal.OrdInOrd.html#1442" class="Bound">x≺a</a><a id="1553" class="Symbol">)</a> <a id="1555" class="Symbol">.</a><a id="1556" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1560" href="Ordinal.OrdInOrd.html#1519" class="Bound">z≺x</a><a id="1563" class="Symbol">)</a>
                     <a id="1586" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1588" class="Symbol">(λ</a> <a id="1591" href="Ordinal.OrdInOrd.html#1591" class="Bound">z≺y</a> <a id="1595" class="Symbol">→</a> <a id="1597" href="Ordinal.OrdInOrd.html#1457" class="Bound">H</a> <a id="1599" class="Symbol">(</a><a id="1600" href="Ordinal.OrdInOrd.html#1512" class="Bound">z</a> <a id="1602" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1604" href="Ordinal.Base.html#4701" class="Function">≺-trans</a> <a id="1612" href="Ordinal.OrdInOrd.html#1512" class="Bound">z</a> <a id="1614" href="Ordinal.OrdInOrd.html#1448" class="Bound">y</a> <a id="1616" href="Ordinal.OrdInOrd.html#701" class="Bound">a</a> <a id="1618" href="Ordinal.OrdInOrd.html#1591" class="Bound">z≺y</a> <a id="1622" href="Ordinal.OrdInOrd.html#1452" class="Bound">y≺a</a><a id="1625" class="Symbol">)</a> <a id="1627" class="Symbol">.</a><a id="1628" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="1632" href="Ordinal.OrdInOrd.html#1591" class="Bound">z≺y</a><a id="1635" class="Symbol">)))</a>
</pre>
<p>良基性的证明代码写起来相当简短, 但自然语言说起来比较绕. 我们要证任意前段元素 <code>(x , x ≺ a)</code> 在 <code>_≺′_</code> 关系下可及. 由良基归纳法, 有归纳假设: 对任意 <code>y ≺ x</code>, <code>(y , y ≺ a)</code> 可及. 现在要证 <code>(x , x ≺ a)</code>, 由可及的构造子 <code>acc</code>, 即证对任意 <code>(y , y ≺ a)</code>, 如果 <code>y ≺ x</code>, 那么 <code>(y , y ≺ a)</code> 可及. 由归纳假设即证.</p>
<pre class="Agda">    <a id="1872" class="Comment">{- 良基性 -}</a> <a id="1882" class="Symbol">(</a><a id="1883" href="Cubical.Foundations.Function.html#1613" class="Function">uncurry</a> <a id="1891" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1893" href="Ordinal.Base.html#6188" class="Function">elim</a> <a id="1898" class="Symbol">λ</a> <a id="1900" href="Ordinal.OrdInOrd.html#1900" class="Bound">x</a> <a id="1902" href="Ordinal.OrdInOrd.html#1902" class="Bound">IH</a> <a id="1905" href="Ordinal.OrdInOrd.html#1905" class="Bound">x≺a</a> <a id="1909" class="Symbol">→</a> <a id="1911" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="1915" class="Symbol">λ</a> <a id="1917" class="Symbol">(</a><a id="1918" href="Ordinal.OrdInOrd.html#1918" class="Bound">y</a> <a id="1920" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1922" href="Ordinal.OrdInOrd.html#1922" class="Bound">y≺a</a><a id="1925" class="Symbol">)</a> <a id="1927" href="Ordinal.OrdInOrd.html#1927" class="Bound">y≺x</a> <a id="1931" class="Symbol">→</a> <a id="1933" href="Ordinal.OrdInOrd.html#1902" class="Bound">IH</a> <a id="1936" href="Ordinal.OrdInOrd.html#1918" class="Bound">y</a> <a id="1938" href="Ordinal.OrdInOrd.html#1927" class="Bound">y≺x</a> <a id="1942" href="Ordinal.OrdInOrd.html#1922" class="Bound">y≺a</a><a id="1945" class="Symbol">)</a>
      <a id="1953" class="Keyword">where</a> <a id="1959" class="Keyword">open</a> <a id="1964" href="Ordinal.Base.html#653" class="Module">BinaryRelation</a>
</pre>
<h3 id="前段嵌入">前段嵌入</h3>
<p>现在, 隐式给定序数 <code>α</code> 以及它的底集元素 <code>a</code>.</p>
<pre class="Agda"><a id="2032" class="Keyword">module</a> <a id="2039" href="Ordinal.OrdInOrd.html#2039" class="Module">_</a> <a id="2041" class="Symbol">{</a><a id="2042" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2044" class="Symbol">:</a> <a id="2046" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="2050" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="2051" class="Symbol">}</a> <a id="2053" class="Symbol">{</a><a id="2054" href="Ordinal.OrdInOrd.html#2054" class="Bound">a</a> <a id="2056" class="Symbol">:</a> <a id="2058" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2060" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2062" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="2063" class="Symbol">}</a> <a id="2065" class="Keyword">where</a>
  <a id="2073" class="Keyword">open</a> <a id="2078" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="2090" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a><a id="2091" class="Symbol">)</a>
</pre>
<p>我们知道 <code>α ↓ a</code> 的底集元素是依值配对, 考虑其左右投影.</p>
<p>左投影 <code>fst</code> 是前段 <code>α ↓ a</code> 底集到 <code>α</code> 底集的典范映射, 我们记为 <code>↑</code>, 并叫它前段嵌入.</p>
<pre class="Agda">  <a id="2202" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="2204" class="Symbol">:</a> <a id="2206" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2208" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2210" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="2212" href="Ordinal.OrdInOrd.html#2054" class="Bound">a</a> <a id="2214" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="2216" class="Symbol">→</a> <a id="2218" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2220" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2222" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a>
  <a id="2226" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="2228" class="Symbol">=</a> <a id="2230" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
</pre>
<p>而右投影 <code>snd</code> 则可以取得 <code>↑ x ≺ a</code> 的证据, 说明前段元素 <code>x</code> 嵌入回原序数后不会超过 <code>a</code>.</p>
<pre class="Agda">  <a id="2310" href="Ordinal.OrdInOrd.html#2310" class="Function">↑-bounded</a> <a id="2320" class="Symbol">:</a> <a id="2322" class="Symbol">(</a><a id="2323" href="Ordinal.OrdInOrd.html#2323" class="Bound">x</a> <a id="2325" class="Symbol">:</a> <a id="2327" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2329" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2331" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="2333" href="Ordinal.OrdInOrd.html#2054" class="Bound">a</a> <a id="2335" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="2336" class="Symbol">)</a> <a id="2338" class="Symbol">→</a> <a id="2340" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="2342" href="Ordinal.OrdInOrd.html#2323" class="Bound">x</a> <a id="2344" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2347" href="Ordinal.OrdInOrd.html#2042" class="Bound">α</a> <a id="2349" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2351" href="Ordinal.OrdInOrd.html#2054" class="Bound">a</a>
  <a id="2355" href="Ordinal.OrdInOrd.html#2310" class="Function">↑-bounded</a> <a id="2365" class="Symbol">=</a> <a id="2367" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>
</pre>
<p>不难证明前段嵌入 <code>↑</code> 确实是一个序数嵌入.</p>
<pre class="Agda">  <a id="2411" href="Ordinal.OrdInOrd.html#2411" class="Function">↑-ordEmbed</a> <a id="2422" class="Symbol">:</a> <a id="2424" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="2435" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a>
  <a id="2439" href="Ordinal.OrdInOrd.html#2411" class="Function">↑-ordEmbed</a> <a id="2450" class="Symbol">=</a> <a id="2452" href="Ordinal.Order.html#683" class="InductiveConstructor">mkIsOrdEmbed</a> <a id="2465" class="Symbol">(λ</a> <a id="2468" href="Ordinal.OrdInOrd.html#2468" class="Bound">_</a> <a id="2470" href="Ordinal.OrdInOrd.html#2470" class="Bound">_</a> <a id="2472" class="Symbol">→</a> <a id="2474" href="Cubical.Foundations.Function.html#468" class="Function">idfun</a> <a id="2480" class="Symbol">_)</a>
    <a id="2487" class="Symbol">λ</a> <a id="2489" class="Symbol">{</a> <a id="2491" href="Ordinal.OrdInOrd.html#2491" class="Bound">b</a> <a id="2493" class="Symbol">(</a><a id="2494" href="Ordinal.OrdInOrd.html#2494" class="Bound">a′</a> <a id="2497" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2499" href="Ordinal.OrdInOrd.html#2499" class="Bound">a′≺a</a><a id="2503" class="Symbol">)</a> <a id="2505" href="Ordinal.OrdInOrd.html#2505" class="Bound">b≺a′</a> <a id="2510" class="Symbol">→</a> <a id="2512" class="Symbol">(</a><a id="2513" href="Ordinal.OrdInOrd.html#2491" class="Bound">b</a> <a id="2515" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2517" href="Ordinal.Base.html#4701" class="Function">≺-trans</a> <a id="2525" class="Symbol">_</a> <a id="2527" class="Symbol">_</a> <a id="2529" class="Symbol">_</a> <a id="2531" href="Ordinal.OrdInOrd.html#2505" class="Bound">b≺a′</a> <a id="2536" href="Ordinal.OrdInOrd.html#2499" class="Bound">a′≺a</a><a id="2540" class="Symbol">)</a> <a id="2542" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2544" href="Ordinal.OrdInOrd.html#2505" class="Bound">b≺a′</a> <a id="2549" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2551" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a> <a id="2556" class="Symbol">}</a>
</pre>
<p>前段嵌入 <code>↑</code> 配合上其序数嵌入性质 <code>↑-ordEmbed</code> 即是 <code>α ↓ a ≤ α</code> 的证明.</p>
<pre class="Agda"><a id="↓≤"></a><a id="2625" href="Ordinal.OrdInOrd.html#2625" class="Function">↓≤</a> <a id="2628" class="Symbol">:</a> <a id="2630" class="Symbol">{</a><a id="2631" href="Ordinal.OrdInOrd.html#2631" class="Bound">a</a> <a id="2633" class="Symbol">:</a> <a id="2635" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2637" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="2639" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="2640" class="Symbol">}</a> <a id="2642" class="Symbol">→</a> <a id="2644" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="2646" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="2648" href="Ordinal.OrdInOrd.html#2631" class="Bound">a</a> <a id="2650" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="2652" href="Ordinal.Base.html#6623" class="Generalizable">α</a>
<a id="2654" href="Ordinal.OrdInOrd.html#2625" class="Function">↓≤</a> <a id="2657" class="Symbol">=</a> <a id="2659" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="2661" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2663" href="Ordinal.OrdInOrd.html#2411" class="Function">↑-ordEmbed</a>
</pre>
<h3 id="单射性">单射性</h3>
<p><strong>引理</strong> 前段的 <code>≤</code> 关系反映它们上界的 <code>≼</code> 关系.<br />
<strong>证明</strong> 假设 <code>α</code> 的两个前段满足 <code>α ↓ a ≤ α ↓ b</code>, 且有 <code>z ≺ a</code> 要证 <code>z ≺ b</code>. 从 <code>≤</code> 关系的证据中可以解构出序数嵌入 <code>f</code>, 它与前段嵌入的复合也是序数嵌入. 由序数嵌入的唯一性, <code>↑ ∘ f ≡ ↑</code>. 两边同时应用前段 <code>(z , z ≺ a)</code> 可得</p>
<p><code>↑ (f $ z , z≺a) ≡ z</code></p>
<p>以此改写目标即证</p>
<p><code>↑ (f $ z , z≺a) ≺ b</code>.</p>
<p>由于 <code>(f $ z , z≺a)</code> 是一个 <code>α ↓ b</code> 前段, 它显然 <code>≺ b</code>. ∎</p>
<pre class="Agda"><a id="↓-reflects-≼"></a><a id="2994" href="Ordinal.OrdInOrd.html#2994" class="Function">↓-reflects-≼</a> <a id="3007" class="Symbol">:</a> <a id="3009" class="Symbol">(</a><a id="3010" href="Ordinal.OrdInOrd.html#3010" class="Bound">a</a> <a id="3012" href="Ordinal.OrdInOrd.html#3012" class="Bound">b</a> <a id="3014" class="Symbol">:</a> <a id="3016" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3018" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3020" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="3021" class="Symbol">)</a> <a id="3023" class="Symbol">→</a> <a id="3025" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3027" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3029" href="Ordinal.OrdInOrd.html#3010" class="Bound">a</a> <a id="3031" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="3033" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3035" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3037" href="Ordinal.OrdInOrd.html#3012" class="Bound">b</a> <a id="3039" class="Symbol">→</a> <a id="3041" href="Ordinal.OrdInOrd.html#3010" class="Bound">a</a> <a id="3043" href="Ordinal.Base.html#7159" class="Function">≼⟨</a> <a id="3046" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3048" href="Ordinal.Base.html#7159" class="Function">⟩</a> <a id="3050" href="Ordinal.OrdInOrd.html#3012" class="Bound">b</a>
<a id="3052" href="Ordinal.OrdInOrd.html#2994" class="Function">↓-reflects-≼</a> <a id="3065" class="Symbol">{</a><a id="3066" href="Ordinal.OrdInOrd.html#3066" class="Bound">α</a><a id="3067" class="Symbol">}</a> <a id="3069" href="Ordinal.OrdInOrd.html#3069" class="Bound">a</a> <a id="3071" href="Ordinal.OrdInOrd.html#3071" class="Bound">b</a> <a id="3073" href="Ordinal.OrdInOrd.html#3073" class="Bound">le</a><a id="3075" class="Symbol">@(</a><a id="3077" href="Ordinal.OrdInOrd.html#3077" class="Bound">f</a> <a id="3079" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3081" href="Ordinal.OrdInOrd.html#3081" class="Bound">f-ordEmb</a><a id="3089" class="Symbol">)</a> <a id="3091" href="Ordinal.OrdInOrd.html#3091" class="Bound">z</a> <a id="3093" href="Ordinal.OrdInOrd.html#3093" class="Bound">z≺a</a> <a id="3097" class="Symbol">=</a>
  <a id="3101" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="3107" class="Symbol">(λ</a> <a id="3110" href="Ordinal.OrdInOrd.html#3110" class="Bound">-</a> <a id="3112" class="Symbol">→</a> <a id="3114" href="Ordinal.OrdInOrd.html#3110" class="Bound">-</a> <a id="3116" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="3119" href="Ordinal.OrdInOrd.html#3066" class="Bound">α</a> <a id="3121" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="3123" href="Ordinal.OrdInOrd.html#3071" class="Bound">b</a><a id="3124" class="Symbol">)</a> <a id="3126" href="Ordinal.OrdInOrd.html#3256" class="Function">↑fz≡z</a> <a id="3132" class="Symbol">(</a><a id="3133" href="Ordinal.OrdInOrd.html#2310" class="Function">↑-bounded</a> <a id="3143" class="Symbol">(</a><a id="3144" href="Ordinal.OrdInOrd.html#3077" class="Bound">f</a> <a id="3146" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3148" href="Ordinal.OrdInOrd.html#3091" class="Bound">z</a> <a id="3150" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3152" href="Ordinal.OrdInOrd.html#3093" class="Bound">z≺a</a><a id="3155" class="Symbol">))</a>
  <a id="3160" class="Keyword">where</a>
  <a id="3168" href="Ordinal.OrdInOrd.html#3168" class="Function">↑∘f≡↑</a> <a id="3174" class="Symbol">:</a> <a id="3176" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="3178" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="3180" href="Ordinal.OrdInOrd.html#3077" class="Bound">f</a> <a id="3182" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3184" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a>
  <a id="3188" href="Ordinal.OrdInOrd.html#3168" class="Function">↑∘f≡↑</a> <a id="3194" class="Symbol">=</a> <a id="3196" href="Ordinal.Order.html#3785" class="Function">ordEmbed-unique</a> <a id="3212" class="Symbol">(</a><a id="3213" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="3215" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="3217" href="Ordinal.OrdInOrd.html#3077" class="Bound">f</a><a id="3218" class="Symbol">)</a> <a id="3220" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="3222" class="Symbol">(</a><a id="3223" href="Ordinal.Order.html#6179" class="Function">≤-trans</a> <a id="3231" href="Ordinal.OrdInOrd.html#3073" class="Bound">le</a> <a id="3234" href="Ordinal.OrdInOrd.html#2625" class="Function">↓≤</a> <a id="3237" class="Symbol">.</a><a id="3238" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="3241" class="Symbol">)</a> <a id="3243" href="Ordinal.OrdInOrd.html#2411" class="Function">↑-ordEmbed</a>
  <a id="3256" href="Ordinal.OrdInOrd.html#3256" class="Function">↑fz≡z</a> <a id="3262" class="Symbol">:</a> <a id="3264" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="3266" class="Symbol">(</a><a id="3267" href="Ordinal.OrdInOrd.html#3077" class="Bound">f</a> <a id="3269" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3271" href="Ordinal.OrdInOrd.html#3091" class="Bound">z</a> <a id="3273" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3275" href="Ordinal.OrdInOrd.html#3093" class="Bound">z≺a</a><a id="3278" class="Symbol">)</a> <a id="3280" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3282" href="Ordinal.OrdInOrd.html#3091" class="Bound">z</a>
  <a id="3286" href="Ordinal.OrdInOrd.html#3256" class="Function">↑fz≡z</a> <a id="3292" class="Symbol">=</a> <a id="3294" href="Cubical.Foundations.Prelude.html#10535" class="Function">funExt⁻</a> <a id="3302" href="Ordinal.OrdInOrd.html#3168" class="Function">↑∘f≡↑</a> <a id="3308" class="Symbol">(</a><a id="3309" href="Ordinal.OrdInOrd.html#3091" class="Bound">z</a> <a id="3311" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3313" href="Ordinal.OrdInOrd.html#3093" class="Bound">z≺a</a><a id="3316" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 前段构造具有单射性, 即两个前段相等蕴含它们的上界相等.<br />
<strong>证明</strong> 用底序 <code>_≺_</code> 的外延性. 我们只证一边: <code>z ≺ a → z ≺ b</code>. 只需将前提 <code>α ↓ a ≡ α ↓ b</code> 弱化到 <code>α ↓ a ≤ α ↓ b</code>, 用上一条引理反映出 <code>a ≼ b</code> 即证. ∎</p>
<pre class="Agda"><a id="↓-inj"></a><a id="3485" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="3491" class="Symbol">:</a> <a id="3493" class="Symbol">{</a><a id="3494" href="Ordinal.OrdInOrd.html#3494" class="Bound">a</a> <a id="3496" href="Ordinal.OrdInOrd.html#3496" class="Bound">b</a> <a id="3498" class="Symbol">:</a> <a id="3500" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3502" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3504" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="3505" class="Symbol">}</a> <a id="3507" class="Symbol">→</a> <a id="3509" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3511" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3513" href="Ordinal.OrdInOrd.html#3494" class="Bound">a</a> <a id="3515" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3517" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="3519" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3521" href="Ordinal.OrdInOrd.html#3496" class="Bound">b</a> <a id="3523" class="Symbol">→</a> <a id="3525" href="Ordinal.OrdInOrd.html#3494" class="Bound">a</a> <a id="3527" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3529" href="Ordinal.OrdInOrd.html#3496" class="Bound">b</a>
<a id="3531" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="3537" class="Symbol">{</a><a id="3538" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a><a id="3539" class="Symbol">}</a> <a id="3541" class="Symbol">{</a><a id="3542" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a><a id="3543" class="Symbol">}</a> <a id="3545" class="Symbol">{</a><a id="3546" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a><a id="3547" class="Symbol">}</a> <a id="3549" href="Ordinal.OrdInOrd.html#3549" class="Bound">eq</a> <a id="3552" class="Symbol">=</a> <a id="3554" href="Ordinal.Base.html#4730" class="Function">≺-ext</a> <a id="3560" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a> <a id="3562" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a> <a id="3564" class="Symbol">λ</a> <a id="3566" href="Ordinal.OrdInOrd.html#3566" class="Bound">z</a> <a id="3568" class="Symbol">→</a> <a id="3570" href="Ordinal.OrdInOrd.html#2994" class="Function">↓-reflects-≼</a> <a id="3583" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a> <a id="3585" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a> <a id="3587" href="Ordinal.OrdInOrd.html#3648" class="Function">H₁</a> <a id="3590" href="Ordinal.OrdInOrd.html#3566" class="Bound">z</a> <a id="3592" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3594" href="Ordinal.OrdInOrd.html#2994" class="Function">↓-reflects-≼</a> <a id="3607" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a> <a id="3609" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a> <a id="3611" href="Ordinal.OrdInOrd.html#3718" class="Function">H₂</a> <a id="3614" href="Ordinal.OrdInOrd.html#3566" class="Bound">z</a>
  <a id="3618" class="Keyword">where</a>
  <a id="3626" class="Keyword">open</a> <a id="3631" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="3638" class="Symbol">(</a><a id="3639" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="3643" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a><a id="3644" class="Symbol">)</a>
  <a id="3648" href="Ordinal.OrdInOrd.html#3648" class="Function">H₁</a> <a id="3651" class="Symbol">:</a> <a id="3653" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3655" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3657" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a> <a id="3659" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="3661" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3663" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3665" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a>
  <a id="3669" href="Ordinal.OrdInOrd.html#3648" class="Function">H₁</a> <a id="3672" class="Symbol">=</a> <a id="3674" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="3680" class="Symbol">(λ</a> <a id="3683" href="Ordinal.OrdInOrd.html#3683" class="Bound">-</a> <a id="3685" class="Symbol">→</a> <a id="3687" class="Symbol">(</a><a id="3688" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3690" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3692" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a><a id="3693" class="Symbol">)</a> <a id="3695" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="3697" href="Ordinal.OrdInOrd.html#3683" class="Bound">-</a><a id="3698" class="Symbol">)</a> <a id="3700" href="Ordinal.OrdInOrd.html#3549" class="Bound">eq</a>       <a id="3709" href="Ordinal.Order.html#6039" class="Function">≤-refl</a>
  <a id="3718" href="Ordinal.OrdInOrd.html#3718" class="Function">H₂</a> <a id="3721" class="Symbol">:</a> <a id="3723" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3725" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3727" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a> <a id="3729" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="3731" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3733" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3735" href="Ordinal.OrdInOrd.html#3542" class="Bound">a</a>
  <a id="3739" href="Ordinal.OrdInOrd.html#3718" class="Function">H₂</a> <a id="3742" class="Symbol">=</a> <a id="3744" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="3750" class="Symbol">(λ</a> <a id="3753" href="Ordinal.OrdInOrd.html#3753" class="Bound">-</a> <a id="3755" class="Symbol">→</a> <a id="3757" class="Symbol">(</a><a id="3758" href="Ordinal.OrdInOrd.html#3538" class="Bound">α</a> <a id="3760" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="3762" href="Ordinal.OrdInOrd.html#3546" class="Bound">b</a><a id="3763" class="Symbol">)</a> <a id="3765" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="3767" href="Ordinal.OrdInOrd.html#3753" class="Bound">-</a><a id="3768" class="Symbol">)</a> <a id="3770" class="Symbol">(</a><a id="3771" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="3775" href="Ordinal.OrdInOrd.html#3549" class="Bound">eq</a><a id="3777" class="Symbol">)</a> <a id="3779" href="Ordinal.Order.html#6039" class="Function">≤-refl</a>
</pre>
<h3 id="前段的重要性质">前段的重要性质</h3>
<p>下面是前段的一个重要性质, 它将不同序数的前段联系起来.</p>
<p><strong>引理</strong> 序数 <code>α</code> 的 <code>a</code> 前段等价于被 <code>α</code> 通过某 <code>f</code> 所嵌入的另一个序数 <code>β</code> 的 <code>f a</code> 前段.<br />
<strong>证明</strong> 给定 <code>α</code> 到 <code>β</code> 的序数嵌入 <code>f</code> 以及 <code>α</code> 的底集元素 <code>a</code>, 要证 <code>α ↓ a ≃ₒ β ↓ (f a)</code>. 需要分别证明它们的底集等价且底序等价.</p>
<ul>
<li>对于底集的等价, 我们构造同构来证明.
<ul>
<li>正映射使用 <code>f</code> 及其保序性 <code>pres≺</code> 将 <code>(x , x≺a)</code> 映射到 <code>(f x , pres≺ _ _ x≺a)</code>.</li>
<li>逆映射由 <code>f</code> 的”形成前段”性质 <code>formsInitSeg</code> 得到. 它对任意 <code>(y , y≺fa)</code> 都给出了一个 <code>(x , x≺a)</code>.</li>
<li>两个方向的互逆性均由 <code>formsInitSeg</code> 的右分量可得.</li>
</ul></li>
</ul>
<pre class="Agda"><a id="↓≃ₒ↓"></a><a id="4215" href="Ordinal.OrdInOrd.html#4215" class="Function">↓≃ₒ↓</a> <a id="4220" class="Symbol">:</a> <a id="4222" class="Symbol">(</a><a id="4223" href="Ordinal.OrdInOrd.html#4223" class="Bound">(</a><a id="4224" href="Ordinal.OrdInOrd.html#4224" class="Bound">f</a> <a id="4226" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4228" href="Ordinal.OrdInOrd.html#4223" class="Bound">_)</a> <a id="4231" class="Symbol">:</a> <a id="4233" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="4235" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="4237" href="Ordinal.Base.html#6625" class="Generalizable">β</a><a id="4238" class="Symbol">)</a> <a id="4240" class="Symbol">(</a><a id="4241" href="Ordinal.OrdInOrd.html#4241" class="Bound">a</a> <a id="4243" class="Symbol">:</a> <a id="4245" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4247" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="4249" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="4250" class="Symbol">)</a> <a id="4252" class="Symbol">→</a> <a id="4254" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="4256" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="4258" href="Ordinal.OrdInOrd.html#4241" class="Bound">a</a> <a id="4260" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="4263" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="4265" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="4267" class="Symbol">(</a><a id="4268" href="Ordinal.OrdInOrd.html#4224" class="Bound">f</a> <a id="4270" href="Ordinal.OrdInOrd.html#4241" class="Bound">a</a><a id="4271" class="Symbol">)</a>
<a id="4273" href="Ordinal.OrdInOrd.html#4215" class="Function">↓≃ₒ↓</a> <a id="4278" class="Symbol">{</a><a id="4279" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a><a id="4280" class="Symbol">}</a> <a id="4282" class="Symbol">{</a><a id="4283" href="Ordinal.OrdInOrd.html#4283" class="Bound">β</a><a id="4284" class="Symbol">}</a> <a id="4286" class="Symbol">(</a><a id="4287" href="Ordinal.OrdInOrd.html#4287" class="Bound">f</a> <a id="4289" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4291" href="Ordinal.OrdInOrd.html#4291" class="Bound">emb</a><a id="4294" class="Symbol">)</a> <a id="4296" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="4298" class="Symbol">=</a> <a id="4300" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="4311" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4313" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4315" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="4330" class="Symbol">λ</a> <a id="4332" href="Ordinal.OrdInOrd.html#4332" class="Bound">x</a> <a id="4334" href="Ordinal.OrdInOrd.html#4334" class="Bound">y</a> <a id="4336" class="Symbol">→</a> <a id="4338" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="4349" class="Symbol">(</a><a id="4350" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="4352" href="Ordinal.OrdInOrd.html#4332" class="Bound">x</a> <a id="4354" href="Ordinal.OrdInOrd.html#4334" class="Bound">y</a><a id="4355" class="Symbol">)</a>
  <a id="4359" class="Keyword">where</a>
  <a id="4367" class="Keyword">open</a> <a id="4372" href="Ordinal.Base.html#5980" class="Module">OrdStr</a>
  <a id="4381" class="Keyword">open</a> <a id="4386" href="Ordinal.Order.html#593" class="Module">IsOrdEmbed</a> <a id="4397" href="Ordinal.OrdInOrd.html#4291" class="Bound">emb</a>
  <a id="4403" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4405" class="Symbol">:</a> <a id="4407" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="4411" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4413" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a> <a id="4415" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="4417" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="4419" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="4421" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4423" href="Ordinal.OrdInOrd.html#4283" class="Bound">β</a> <a id="4425" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="4427" href="Ordinal.OrdInOrd.html#4287" class="Bound">f</a> <a id="4429" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="4431" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a>
  <a id="4435" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a>       <a id="4449" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4451" class="Symbol">(</a><a id="4452" href="Ordinal.OrdInOrd.html#4452" class="Bound">x</a> <a id="4454" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4456" href="Ordinal.OrdInOrd.html#4456" class="Bound">x≺a</a><a id="4459" class="Symbol">)</a> <a id="4461" class="Symbol">=</a> <a id="4463" href="Ordinal.OrdInOrd.html#4287" class="Bound">f</a> <a id="4465" href="Ordinal.OrdInOrd.html#4452" class="Bound">x</a> <a id="4467" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4469" href="Ordinal.Order.html#996" class="Function">pres≺</a> <a id="4475" class="Symbol">_</a> <a id="4477" class="Symbol">_</a> <a id="4479" href="Ordinal.OrdInOrd.html#4456" class="Bound">x≺a</a>
  <a id="4485" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a>       <a id="4499" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4501" class="Symbol">(</a><a id="4502" href="Ordinal.OrdInOrd.html#4502" class="Bound">y</a> <a id="4504" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4506" href="Ordinal.OrdInOrd.html#4506" class="Bound">y≺fa</a><a id="4510" class="Symbol">)</a> <a id="4512" class="Symbol">=</a> <a id="4514" class="Keyword">let</a> <a id="4518" class="Symbol">(</a><a id="4519" href="Ordinal.OrdInOrd.html#4519" class="Bound">x</a> <a id="4521" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4523" href="Ordinal.OrdInOrd.html#4523" class="Bound">x≺a</a> <a id="4527" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4529" class="Symbol">_)</a> <a id="4532" class="Symbol">=</a> <a id="4534" href="Ordinal.Order.html#1047" class="Function">formsInitSeg</a> <a id="4547" class="Symbol">_</a> <a id="4549" class="Symbol">_</a> <a id="4551" href="Ordinal.OrdInOrd.html#4506" class="Bound">y≺fa</a> <a id="4556" class="Keyword">in</a> <a id="4559" href="Ordinal.OrdInOrd.html#4519" class="Bound">x</a> <a id="4561" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4563" href="Ordinal.OrdInOrd.html#4523" class="Bound">x≺a</a>
  <a id="4569" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a>   <a id="4583" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4585" class="Symbol">(</a><a id="4586" href="Ordinal.OrdInOrd.html#4586" class="Bound">x</a> <a id="4588" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4590" href="Ordinal.OrdInOrd.html#4590" class="Bound">x≺a</a><a id="4593" class="Symbol">)</a> <a id="4595" class="Symbol">=</a> <a id="4597" class="Keyword">let</a> <a id="4601" class="Symbol">(_</a> <a id="4604" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4606" class="Symbol">_</a> <a id="4608" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4610" href="Ordinal.OrdInOrd.html#4610" class="Bound">fw≡fx</a><a id="4615" class="Symbol">)</a> <a id="4617" class="Symbol">=</a> <a id="4619" href="Ordinal.Order.html#1047" class="Function">formsInitSeg</a> <a id="4632" class="Symbol">_</a> <a id="4634" class="Symbol">_</a> <a id="4636" class="Symbol">(</a><a id="4637" href="Ordinal.Order.html#996" class="Function">pres≺</a> <a id="4643" class="Symbol">_</a> <a id="4645" class="Symbol">_</a> <a id="4647" href="Ordinal.OrdInOrd.html#4590" class="Bound">x≺a</a><a id="4650" class="Symbol">)</a> <a id="4652" class="Keyword">in</a>
    <a id="4659" href="Preliminary.html#9778" class="Function">Σ≡Prop</a> <a id="4666" class="Symbol">(λ</a> <a id="4669" href="Ordinal.OrdInOrd.html#4669" class="Bound">_</a> <a id="4671" class="Symbol">→</a> <a id="4673" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="4680" class="Symbol">(</a><a id="4681" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4685" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a><a id="4686" class="Symbol">)</a> <a id="4688" class="Symbol">_</a> <a id="4690" class="Symbol">_)</a> <a id="4693" class="Symbol">(</a><a id="4694" href="Ordinal.Order.html#1467" class="Function">inj</a> <a id="4698" href="Ordinal.OrdInOrd.html#4610" class="Bound">fw≡fx</a><a id="4703" class="Symbol">)</a>
  <a id="4707" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a>  <a id="4721" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="4723" class="Symbol">(</a><a id="4724" href="Ordinal.OrdInOrd.html#4724" class="Bound">y</a> <a id="4726" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4728" href="Ordinal.OrdInOrd.html#4728" class="Bound">y≺fa</a><a id="4732" class="Symbol">)</a> <a id="4734" class="Symbol">=</a> <a id="4736" class="Keyword">let</a> <a id="4740" class="Symbol">(_</a> <a id="4743" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4745" class="Symbol">_</a> <a id="4747" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4749" href="Ordinal.OrdInOrd.html#4749" class="Bound">fx≡y</a><a id="4753" class="Symbol">)</a> <a id="4755" class="Symbol">=</a> <a id="4757" href="Ordinal.Order.html#1047" class="Function">formsInitSeg</a> <a id="4770" class="Symbol">_</a> <a id="4772" class="Symbol">_</a> <a id="4774" href="Ordinal.OrdInOrd.html#4728" class="Bound">y≺fa</a> <a id="4779" class="Keyword">in</a>
    <a id="4786" href="Preliminary.html#9778" class="Function">Σ≡Prop</a> <a id="4793" class="Symbol">(λ</a> <a id="4796" href="Ordinal.OrdInOrd.html#4796" class="Bound">_</a> <a id="4798" class="Symbol">→</a> <a id="4800" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="4807" class="Symbol">(</a><a id="4808" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4812" href="Ordinal.OrdInOrd.html#4283" class="Bound">β</a><a id="4813" class="Symbol">)</a> <a id="4815" class="Symbol">_</a> <a id="4817" class="Symbol">_)</a> <a id="4820" href="Ordinal.OrdInOrd.html#4749" class="Bound">fx≡y</a>
</pre>
<ul>
<li>对于底序的等价, 我们同样构造同构来证明.
<ul>
<li>正映射都 <code>f</code> 的保序性 <code>pres≺</code> 得到.</li>
<li>逆映射由 <code>f</code> 的”形成前段”性质 <code>formsInitSeg</code> 得到.</li>
<li>两个方向的互逆性均由 <code>_≺_</code> 的命题性得到.</li>
</ul></li>
</ul>
<pre class="Agda">  <a id="4966" class="Keyword">module</a> <a id="4973" href="Ordinal.OrdInOrd.html#4973" class="Module">_</a> <a id="4975" class="Symbol">(</a><a id="4976" href="Ordinal.OrdInOrd.html#4976" class="Bound">u</a><a id="4977" class="Symbol">@(</a><a id="4979" href="Ordinal.OrdInOrd.html#4979" class="Bound">x</a> <a id="4981" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4983" href="Ordinal.OrdInOrd.html#4983" class="Bound">x≺a</a><a id="4986" class="Symbol">)</a> <a id="4988" href="Ordinal.OrdInOrd.html#4988" class="Bound">v</a><a id="4989" class="Symbol">@(</a><a id="4991" href="Ordinal.OrdInOrd.html#4991" class="Bound">y</a> <a id="4993" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4995" href="Ordinal.OrdInOrd.html#4995" class="Bound">y≺fa</a><a id="4999" class="Symbol">)</a> <a id="5001" class="Symbol">:</a> <a id="5003" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5005" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a> <a id="5007" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5009" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="5011" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="5012" class="Symbol">)</a> <a id="5014" class="Keyword">where</a>
    <a id="5024" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="5026" class="Symbol">:</a> <a id="5028" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="5032" class="Symbol">(</a><a id="5033" href="Ordinal.OrdInOrd.html#4976" class="Bound">u</a> <a id="5035" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="5038" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a> <a id="5040" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5042" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="5044" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="5046" href="Ordinal.OrdInOrd.html#4988" class="Bound">v</a><a id="5047" class="Symbol">)</a> <a id="5049" class="Symbol">(</a><a id="5050" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="5058" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="5060" href="Ordinal.OrdInOrd.html#4976" class="Bound">u</a> <a id="5062" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="5065" href="Ordinal.OrdInOrd.html#4283" class="Bound">β</a> <a id="5067" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5069" href="Ordinal.OrdInOrd.html#4287" class="Bound">f</a> <a id="5071" href="Ordinal.OrdInOrd.html#4296" class="Bound">a</a> <a id="5073" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="5075" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="5083" href="Ordinal.OrdInOrd.html#4403" class="Function">i</a> <a id="5085" href="Ordinal.OrdInOrd.html#4988" class="Bound">v</a><a id="5086" class="Symbol">)</a>
    <a id="5092" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a>       <a id="5106" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="5108" class="Symbol">=</a> <a id="5110" href="Ordinal.Order.html#996" class="Function">pres≺</a> <a id="5116" href="Ordinal.OrdInOrd.html#4979" class="Bound">x</a> <a id="5118" href="Ordinal.OrdInOrd.html#4991" class="Bound">y</a>
    <a id="5124" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a>       <a id="5138" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="5140" href="Ordinal.OrdInOrd.html#5140" class="Bound">H</a> <a id="5142" class="Symbol">=</a> <a id="5144" class="Keyword">let</a> <a id="5148" class="Symbol">(</a><a id="5149" href="Ordinal.OrdInOrd.html#5149" class="Bound">w</a> <a id="5151" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5153" href="Ordinal.OrdInOrd.html#5153" class="Bound">w≺y</a> <a id="5157" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5159" href="Ordinal.OrdInOrd.html#5159" class="Bound">fw≡fx</a><a id="5164" class="Symbol">)</a> <a id="5166" class="Symbol">=</a> <a id="5168" href="Ordinal.Order.html#1047" class="Function">formsInitSeg</a> <a id="5181" class="Symbol">(</a><a id="5182" href="Ordinal.OrdInOrd.html#4287" class="Bound">f</a> <a id="5184" href="Ordinal.OrdInOrd.html#4979" class="Bound">x</a><a id="5185" class="Symbol">)</a> <a id="5187" href="Ordinal.OrdInOrd.html#4991" class="Bound">y</a> <a id="5189" href="Ordinal.OrdInOrd.html#5140" class="Bound">H</a> <a id="5191" class="Keyword">in</a>
      <a id="5200" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="5206" class="Symbol">(λ</a> <a id="5209" href="Ordinal.OrdInOrd.html#5209" class="Bound">-</a> <a id="5211" class="Symbol">→</a> <a id="5213" href="Ordinal.OrdInOrd.html#5209" class="Bound">-</a> <a id="5215" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="5218" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a> <a id="5220" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="5222" href="Ordinal.OrdInOrd.html#4991" class="Bound">y</a><a id="5223" class="Symbol">)</a> <a id="5225" class="Symbol">(</a><a id="5226" href="Ordinal.Order.html#1467" class="Function">inj</a> <a id="5230" href="Ordinal.OrdInOrd.html#5159" class="Bound">fw≡fx</a><a id="5235" class="Symbol">)</a> <a id="5237" href="Ordinal.OrdInOrd.html#5153" class="Bound">w≺y</a>
    <a id="5245" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a>   <a id="5259" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="5261" class="Symbol">_</a> <a id="5263" class="Symbol">=</a> <a id="5265" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="5272" class="Symbol">(</a><a id="5273" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5277" href="Ordinal.OrdInOrd.html#4279" class="Bound">α</a><a id="5278" class="Symbol">)</a> <a id="5280" class="Symbol">_</a> <a id="5282" class="Symbol">_</a> <a id="5284" class="Symbol">_</a> <a id="5286" class="Symbol">_</a>
    <a id="5292" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a>  <a id="5306" href="Ordinal.OrdInOrd.html#5024" class="Function">j</a> <a id="5308" class="Symbol">_</a> <a id="5310" class="Symbol">=</a> <a id="5312" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="5319" class="Symbol">(</a><a id="5320" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5324" href="Ordinal.OrdInOrd.html#4283" class="Bound">β</a><a id="5325" class="Symbol">)</a> <a id="5327" class="Symbol">_</a> <a id="5329" class="Symbol">_</a> <a id="5331" class="Symbol">_</a> <a id="5333" class="Symbol">_</a>
</pre>
<p><strong>推论</strong> 序数 <code>α</code> 的 <code>a</code> 前段<strong>等于</strong>被 <code>α</code> 通过某 <code>f</code> 所嵌入的另一个序数 <code>β</code> 的 <code>f a</code> 前段.<br />
<strong>证明</strong> 由上一条引理结合序数的泛等原理即证. ∎</p>
<pre class="Agda"><a id="↓≡↓"></a><a id="5447" href="Ordinal.OrdInOrd.html#5447" class="Function">↓≡↓</a> <a id="5451" class="Symbol">:</a> <a id="5453" class="Symbol">(</a><a id="5454" href="Ordinal.OrdInOrd.html#5454" class="Bound">(</a><a id="5455" href="Ordinal.OrdInOrd.html#5455" class="Bound">f</a> <a id="5457" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5459" href="Ordinal.OrdInOrd.html#5454" class="Bound">_)</a> <a id="5462" class="Symbol">:</a> <a id="5464" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5466" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="5468" href="Ordinal.Base.html#6625" class="Generalizable">β</a><a id="5469" class="Symbol">)</a> <a id="5471" class="Symbol">{</a><a id="5472" href="Ordinal.OrdInOrd.html#5472" class="Bound">a</a> <a id="5474" class="Symbol">:</a> <a id="5476" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5478" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5480" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="5481" class="Symbol">}</a> <a id="5483" class="Symbol">→</a> <a id="5485" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5487" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5489" href="Ordinal.OrdInOrd.html#5472" class="Bound">a</a> <a id="5491" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5493" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="5495" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5497" class="Symbol">(</a><a id="5498" href="Ordinal.OrdInOrd.html#5455" class="Bound">f</a> <a id="5500" href="Ordinal.OrdInOrd.html#5472" class="Bound">a</a><a id="5501" class="Symbol">)</a>
<a id="5503" href="Ordinal.OrdInOrd.html#5447" class="Function">↓≡↓</a> <a id="5507" href="Ordinal.OrdInOrd.html#5507" class="Bound">f</a> <a id="5509" class="Symbol">{</a><a id="5510" href="Ordinal.OrdInOrd.html#5510" class="Bound">a</a><a id="5511" class="Symbol">}</a> <a id="5513" class="Symbol">=</a> <a id="5515" href="Ordinal.Base.html#9975" class="Function">≃ₒ→≡</a> <a id="5520" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5522" href="Ordinal.OrdInOrd.html#4215" class="Function">↓≃ₒ↓</a> <a id="5527" href="Ordinal.OrdInOrd.html#5507" class="Bound">f</a> <a id="5529" href="Ordinal.OrdInOrd.html#5510" class="Bound">a</a>
</pre>
<p><strong>推论</strong> 对序数取两次前段等于取一次较短前段. <strong>证明</strong> 由上一条引理结合 <code>↓≤</code> 即证. ∎</p>
<pre class="Agda"><a id="↓↓-red"></a><a id="5598" href="Ordinal.OrdInOrd.html#5598" class="Function">↓↓-red</a> <a id="5605" class="Symbol">:</a> <a id="5607" class="Symbol">{</a><a id="5608" href="Ordinal.OrdInOrd.html#5608" class="Bound">a</a> <a id="5610" href="Ordinal.OrdInOrd.html#5610" class="Bound">b</a> <a id="5612" class="Symbol">:</a> <a id="5614" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5616" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5618" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="5619" class="Symbol">}</a> <a id="5621" class="Symbol">{</a><a id="5622" href="Ordinal.OrdInOrd.html#5622" class="Bound">a≺b</a> <a id="5626" class="Symbol">:</a> <a id="5628" href="Ordinal.OrdInOrd.html#5608" class="Bound">a</a> <a id="5630" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="5633" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5635" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="5637" href="Ordinal.OrdInOrd.html#5610" class="Bound">b</a><a id="5638" class="Symbol">}</a> <a id="5640" class="Symbol">→</a> <a id="5642" class="Symbol">(</a><a id="5643" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5645" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5647" href="Ordinal.OrdInOrd.html#5610" class="Bound">b</a><a id="5648" class="Symbol">)</a> <a id="5650" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5652" class="Symbol">(</a><a id="5653" href="Ordinal.OrdInOrd.html#5608" class="Bound">a</a> <a id="5655" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5657" href="Ordinal.OrdInOrd.html#5622" class="Bound">a≺b</a><a id="5660" class="Symbol">)</a> <a id="5662" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5664" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5666" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5668" href="Ordinal.OrdInOrd.html#5608" class="Bound">a</a>
<a id="5670" href="Ordinal.OrdInOrd.html#5598" class="Function">↓↓-red</a> <a id="5677" class="Symbol">=</a> <a id="5679" href="Ordinal.OrdInOrd.html#5447" class="Function">↓≡↓</a> <a id="5683" href="Ordinal.OrdInOrd.html#2625" class="Function">↓≤</a>
</pre>
<h2 id="严格序">严格序</h2>
<p>完善了前段的概念之后我们终于可以定义序数之间的严格序.</p>
<p>我们说 <code>α &lt; β</code> 当且仅当存在 <code>β</code> 的一个前段 <code>β ↓ b</code> 等于 <code>α</code>. 注意这里说的”存在”在形式上是用Σ类型来表达的, 我们后面将证明 <code>_&lt;_</code> 具有命题性, 而不需要对它做命题截断.</p>
<pre class="Agda"><a id="_&lt;_"></a><a id="5841" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;_</a> <a id="5845" class="Symbol">:</a> <a id="5847" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5851" href="Preliminary.html#2692" class="Generalizable">𝓊</a> <a id="5853" class="Symbol">→</a> <a id="5855" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5859" href="Preliminary.html#2692" class="Generalizable">𝓊</a> <a id="5861" class="Symbol">→</a> <a id="5863" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5868" class="Symbol">(</a><a id="5869" href="Preliminary.html#2692" class="Generalizable">𝓊</a> <a id="5871" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="5872" class="Symbol">)</a>
<a id="5874" href="Ordinal.OrdInOrd.html#5874" class="Bound">α</a> <a id="5876" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="5878" href="Ordinal.OrdInOrd.html#5878" class="Bound">β</a> <a id="5880" class="Symbol">=</a> <a id="5882" href="Preliminary.html#5407" class="Function">Σ</a> <a id="5884" href="Ordinal.OrdInOrd.html#5884" class="Bound">b</a> <a id="5886" href="Preliminary.html#5407" class="Function">∶</a> <a id="5888" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5890" href="Ordinal.OrdInOrd.html#5878" class="Bound">β</a> <a id="5892" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="5894" href="Preliminary.html#5407" class="Function">,</a> <a id="5896" href="Ordinal.OrdInOrd.html#5878" class="Bound">β</a> <a id="5898" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="5900" href="Ordinal.OrdInOrd.html#5884" class="Bound">b</a> <a id="5902" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5904" href="Ordinal.OrdInOrd.html#5874" class="Bound">α</a>
</pre>
<p>如所期待的那样, <code>_&lt;_</code> 可以弱化到 <code>_≤_</code>, 只需简单的改写即得.</p>
<pre class="Agda"><a id="&lt;→≤"></a><a id="5959" href="Ordinal.OrdInOrd.html#5959" class="Function">&lt;→≤</a> <a id="5963" class="Symbol">:</a> <a id="5965" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5967" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="5969" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="5971" class="Symbol">→</a> <a id="5973" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="5975" href="Ordinal.Order.html#5661" class="Function Operator">≤</a> <a id="5977" href="Ordinal.Base.html#6625" class="Generalizable">β</a>
<a id="5979" href="Ordinal.OrdInOrd.html#5959" class="Function">&lt;→≤</a> <a id="5983" class="Symbol">{</a><a id="5984" href="Ordinal.OrdInOrd.html#5984" class="Bound">β</a><a id="5985" class="Symbol">}</a> <a id="5987" class="Symbol">(</a><a id="5988" href="Ordinal.OrdInOrd.html#5988" class="Bound">b</a> <a id="5990" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5992" href="Ordinal.OrdInOrd.html#5992" class="Bound">β↓b≡α</a><a id="5997" class="Symbol">)</a> <a id="5999" class="Symbol">=</a> <a id="6001" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="6007" class="Symbol">(</a><a id="6008" href="Ordinal.Order.html#5661" class="Function Operator">_≤</a> <a id="6011" href="Ordinal.OrdInOrd.html#5984" class="Bound">β</a><a id="6012" class="Symbol">)</a> <a id="6014" href="Ordinal.OrdInOrd.html#5992" class="Bound">β↓b≡α</a> <a id="6020" href="Ordinal.OrdInOrd.html#2625" class="Function">↓≤</a>
</pre>
<p>下面是引理 <code>↓≤</code> 的加强版, 由严格序的定义即得.</p>
<pre class="Agda"><a id="↓&lt;"></a><a id="6065" href="Ordinal.OrdInOrd.html#6065" class="Function">↓&lt;</a> <a id="6068" class="Symbol">:</a> <a id="6070" class="Symbol">{</a><a id="6071" href="Ordinal.OrdInOrd.html#6071" class="Bound">a</a> <a id="6073" class="Symbol">:</a> <a id="6075" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6077" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6079" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="6080" class="Symbol">}</a> <a id="6082" class="Symbol">→</a> <a id="6084" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6086" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6088" href="Ordinal.OrdInOrd.html#6071" class="Bound">a</a> <a id="6090" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="6092" href="Ordinal.Base.html#6623" class="Generalizable">α</a>
<a id="6094" href="Ordinal.OrdInOrd.html#6065" class="Function">↓&lt;</a> <a id="6097" class="Symbol">{</a><a id="6098" href="Ordinal.OrdInOrd.html#6098" class="Bound">a</a><a id="6099" class="Symbol">}</a> <a id="6101" class="Symbol">=</a> <a id="6103" href="Ordinal.OrdInOrd.html#6098" class="Bound">a</a> <a id="6105" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6107" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
</pre>
<p>下面是 <code>↓-reflects-≼</code> 的严格序版本.</p>
<p><strong>引理</strong> 前段的 <code>&lt;</code> 关系反映它们上界的 <code>≺</code> 关系.<br />
<strong>证明</strong> 假设 <code>α</code> 的两个前段满足 <code>α ↓ a &lt; α ↓ b</code>, 要证 <code>a ≺ b</code>. 严格序的证据承诺了 <code>α ↓ b</code> 底集的一个元素 <code>c</code> 满足</p>
<p><code>(α ↓ b) ↓ c ≡ α ↓ a</code></p>
<p>由前段的重要性质有</p>
<p><code>(α ↓ b) ↓ c ≡ α ↓ ↑ c</code></p>
<p>传递得</p>
<p><code>α ↓ ↑ c ≡ α ↓ a</code></p>
<p>由前段构造的单射性得 <code>↑ c ≡ a</code>. 由此改写目标即证 <code>↑ c ≺ b</code>. 由于 <code>c</code> 是 <code>α ↓ b</code> 的底集元素, 显然有 <code>↑ c ≺ b</code>. ∎</p>
<pre class="Agda"><a id="↓-reflects-≺"></a><a id="6440" href="Ordinal.OrdInOrd.html#6440" class="Function">↓-reflects-≺</a> <a id="6453" class="Symbol">:</a> <a id="6455" class="Symbol">(</a><a id="6456" href="Ordinal.OrdInOrd.html#6456" class="Bound">a</a> <a id="6458" href="Ordinal.OrdInOrd.html#6458" class="Bound">b</a> <a id="6460" class="Symbol">:</a> <a id="6462" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6464" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6466" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="6467" class="Symbol">)</a> <a id="6469" class="Symbol">→</a> <a id="6471" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6473" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6475" href="Ordinal.OrdInOrd.html#6456" class="Bound">a</a> <a id="6477" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="6479" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6481" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6483" href="Ordinal.OrdInOrd.html#6458" class="Bound">b</a> <a id="6485" class="Symbol">→</a> <a id="6487" href="Ordinal.OrdInOrd.html#6456" class="Bound">a</a> <a id="6489" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6492" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6494" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6496" href="Ordinal.OrdInOrd.html#6458" class="Bound">b</a>
<a id="6498" href="Ordinal.OrdInOrd.html#6440" class="Function">↓-reflects-≺</a> <a id="6511" class="Symbol">{</a><a id="6512" href="Ordinal.OrdInOrd.html#6512" class="Bound">α</a><a id="6513" class="Symbol">}</a> <a id="6515" href="Ordinal.OrdInOrd.html#6515" class="Bound">a</a> <a id="6517" href="Ordinal.OrdInOrd.html#6517" class="Bound">b</a> <a id="6519" href="Ordinal.OrdInOrd.html#6519" class="Bound">↓&lt;↓</a> <a id="6523" class="Symbol">=</a> <a id="6525" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="6531" class="Symbol">(λ</a> <a id="6534" href="Ordinal.OrdInOrd.html#6534" class="Bound">a</a> <a id="6536" class="Symbol">→</a> <a id="6538" href="Ordinal.OrdInOrd.html#6534" class="Bound">a</a> <a id="6540" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6543" href="Ordinal.OrdInOrd.html#6512" class="Bound">α</a> <a id="6545" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6547" href="Ordinal.OrdInOrd.html#6517" class="Bound">b</a><a id="6548" class="Symbol">)</a> <a id="6550" class="Symbol">(</a><a id="6551" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="6557" href="Ordinal.OrdInOrd.html#6616" class="Function">eq</a><a id="6559" class="Symbol">)</a> <a id="6561" class="Symbol">(</a><a id="6562" href="Ordinal.OrdInOrd.html#2310" class="Function">↑-bounded</a> <a id="6572" href="Ordinal.OrdInOrd.html#6585" class="Function">c</a><a id="6573" class="Symbol">)</a>
  <a id="6577" class="Keyword">where</a>
  <a id="6585" href="Ordinal.OrdInOrd.html#6585" class="Function">c</a> <a id="6587" class="Symbol">:</a> <a id="6589" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6591" href="Ordinal.OrdInOrd.html#6512" class="Bound">α</a> <a id="6593" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6595" href="Ordinal.OrdInOrd.html#6517" class="Bound">b</a> <a id="6597" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a>
  <a id="6601" href="Ordinal.OrdInOrd.html#6585" class="Function">c</a> <a id="6603" class="Symbol">=</a> <a id="6605" href="Ordinal.OrdInOrd.html#6519" class="Bound">↓&lt;↓</a> <a id="6609" class="Symbol">.</a><a id="6610" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="6616" href="Ordinal.OrdInOrd.html#6616" class="Function">eq</a> <a id="6619" class="Symbol">:</a> <a id="6621" href="Ordinal.OrdInOrd.html#6512" class="Bound">α</a> <a id="6623" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6625" href="Ordinal.OrdInOrd.html#2202" class="Function">↑</a> <a id="6627" href="Ordinal.OrdInOrd.html#6585" class="Function">c</a> <a id="6629" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6631" href="Ordinal.OrdInOrd.html#6512" class="Bound">α</a> <a id="6633" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6635" href="Ordinal.OrdInOrd.html#6515" class="Bound">a</a>
  <a id="6639" href="Ordinal.OrdInOrd.html#6616" class="Function">eq</a> <a id="6642" class="Symbol">=</a> <a id="6644" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="6648" href="Ordinal.OrdInOrd.html#5598" class="Function">↓↓-red</a> <a id="6655" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="6657" href="Ordinal.OrdInOrd.html#6519" class="Bound">↓&lt;↓</a> <a id="6661" class="Symbol">.</a><a id="6662" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>
</pre>
<p><strong>引理</strong> 前段保持它们上界的 <code>≺</code> 关系.<br />
<strong>证明</strong> 假设 <code>a ≺ b</code>, 要证 <code>α ↓ a &lt; α ↓ b</code>. 由前段的重要性质, 有前段元素 <code>(a , a≺b)</code> 满足</p>
<p><code>(α ↓ b) ↓ (a , a≺b) ≡ α ↓ a</code></p>
<p>此即 <code>&lt;</code> 关系的证据. ∎</p>
<pre class="Agda"><a id="↓-preserves-≺"></a><a id="6825" href="Ordinal.OrdInOrd.html#6825" class="Function">↓-preserves-≺</a> <a id="6839" class="Symbol">:</a> <a id="6841" class="Symbol">(</a><a id="6842" href="Ordinal.OrdInOrd.html#6842" class="Bound">a</a> <a id="6844" href="Ordinal.OrdInOrd.html#6844" class="Bound">b</a> <a id="6846" class="Symbol">:</a> <a id="6848" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6850" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6852" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="6853" class="Symbol">)</a> <a id="6855" class="Symbol">→</a> <a id="6857" href="Ordinal.OrdInOrd.html#6842" class="Bound">a</a> <a id="6859" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6862" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6864" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6866" href="Ordinal.OrdInOrd.html#6844" class="Bound">b</a> <a id="6868" class="Symbol">→</a> <a id="6870" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6872" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6874" href="Ordinal.OrdInOrd.html#6842" class="Bound">a</a> <a id="6876" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="6878" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6880" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="6882" href="Ordinal.OrdInOrd.html#6844" class="Bound">b</a>
<a id="6884" href="Ordinal.OrdInOrd.html#6825" class="Function">↓-preserves-≺</a> <a id="6898" href="Ordinal.OrdInOrd.html#6898" class="Bound">a</a> <a id="6900" href="Ordinal.OrdInOrd.html#6900" class="Bound">b</a> <a id="6902" href="Ordinal.OrdInOrd.html#6902" class="Bound">a≺b</a> <a id="6906" class="Symbol">=</a> <a id="6908" class="Symbol">(</a><a id="6909" href="Ordinal.OrdInOrd.html#6898" class="Bound">a</a> <a id="6911" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6913" href="Ordinal.OrdInOrd.html#6902" class="Bound">a≺b</a><a id="6916" class="Symbol">)</a> <a id="6918" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6920" href="Ordinal.OrdInOrd.html#5598" class="Function">↓↓-red</a>
</pre>
<h3 id="性质">性质</h3>
<p>给定宇宙 <code>𝓊</code> 上的 <code>_&lt;_</code> 关系.</p>
<pre class="Agda"><a id="6971" class="Keyword">module</a> <a id="6978" href="Ordinal.OrdInOrd.html#6978" class="Module">_</a> <a id="6980" class="Symbol">{</a><a id="6981" href="Ordinal.OrdInOrd.html#6981" class="Bound">𝓊</a><a id="6982" class="Symbol">}</a> <a id="6984" class="Keyword">where</a>
  <a id="6992" class="Keyword">open</a> <a id="6997" href="Ordinal.Base.html#653" class="Module">BinaryRelation</a> <a id="7012" class="Symbol">(</a><a id="7013" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;_</a> <a id="7017" class="Symbol">{</a><a id="7018" href="Ordinal.OrdInOrd.html#6981" class="Bound">𝓊</a><a id="7019" class="Symbol">})</a>
</pre>
<p><strong>引理</strong> <code>_&lt;_</code> 具有命题性.<br />
<strong>证明</strong> 要证 <code>α &lt; β</code> 的两个证据相等, 即证两个依值配对 <code>(b₁ , eq₁)</code> 和 <code>(b₂ , eq₂)</code> 相等. 其中右边具有类型</p>
<p><code>eq₁ : β ↓ b₁ ≡ α</code> 以及</p>
<p><code>eq₂ : β ↓ b₂ ≡ α</code></p>
<p>由序数宇宙的集合性, 只要证明依值配对的左边相等, 右边就相等. 由 <code>eq₁</code> 和 <code>eq₂</code> 传递可得</p>
<p><code>β ↓ b₁ ≡ β ↓ b₂</code></p>
<p>再由前段构造的单射性即得 <code>b₁ ≡ b₂</code>. ∎</p>
<pre class="Agda">  <a id="7281" href="Ordinal.OrdInOrd.html#7281" class="Function">&lt;-prop</a> <a id="7288" class="Symbol">:</a> <a id="7290" href="Ordinal.Base.html#810" class="Function">Propositional</a>
  <a id="7306" href="Ordinal.OrdInOrd.html#7281" class="Function">&lt;-prop</a> <a id="7313" class="Symbol">_</a> <a id="7315" class="Symbol">_</a> <a id="7317" class="Symbol">(</a><a id="7318" href="Ordinal.OrdInOrd.html#7318" class="Bound">b₁</a> <a id="7321" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7323" href="Ordinal.OrdInOrd.html#7323" class="Bound">eq₁</a><a id="7326" class="Symbol">)</a> <a id="7328" class="Symbol">(</a><a id="7329" href="Ordinal.OrdInOrd.html#7329" class="Bound">b₂</a> <a id="7332" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7334" href="Ordinal.OrdInOrd.html#7334" class="Bound">eq₂</a><a id="7337" class="Symbol">)</a> <a id="7339" class="Symbol">=</a> <a id="7341" href="Preliminary.html#9778" class="Function">Σ≡Prop</a> <a id="7348" class="Symbol">(λ</a> <a id="7351" href="Ordinal.OrdInOrd.html#7351" class="Symbol">_</a> <a id="7353" class="Symbol">→</a> <a id="7355" href="Ordinal.Order.html#5388" class="Function">isSetOrd</a> <a id="7364" class="Symbol">_</a> <a id="7366" class="Symbol">_)</a> <a id="7369" class="Symbol">(</a><a id="7370" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="7376" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7378" href="Ordinal.OrdInOrd.html#7323" class="Bound">eq₁</a> <a id="7382" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="7384" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="7388" href="Ordinal.OrdInOrd.html#7334" class="Bound">eq₂</a><a id="7391" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> <code>_&lt;_</code> 具有传递性.<br />
<strong>证明</strong> 假设 <code>α &lt; β</code> 和 <code>β &lt; γ</code>, 要证 <code>α &lt; γ</code>. 解构 <code>α &lt; β</code> 的证据有 <code>(b , β↓b≡α)</code>, 用右边改写目标即证 <code>β ↓ b &lt; γ</code>.</p>
<p>将 <code>β &lt; γ</code> 弱化为 <code>β ≤ γ</code>, 拿到它们之间的序数嵌入并应用到 <code>b</code>, 将所得记为 <code>c</code>, 它就是目标所要求的 <code>γ</code> 上界, 只要证</p>
<p><code>γ ↓ c ≡ β ↓ b</code></p>
<p>左右对调可以看出它是前段重要性质 <code>↓≡↓</code> 的实例, 因为满足其前提要求 <code>β ≤ γ</code> 且 <code>c</code> 为 <code>b</code> 的嵌入所得. ∎</p>
<pre class="Agda">  <a id="7689" href="Ordinal.OrdInOrd.html#7689" class="Function">&lt;-trans</a> <a id="7697" class="Symbol">:</a> <a id="7699" href="Ordinal.Base.html#1409" class="Function">Transitive</a>
  <a id="7712" href="Ordinal.OrdInOrd.html#7689" class="Function">&lt;-trans</a> <a id="7720" href="Ordinal.OrdInOrd.html#7720" class="Bound">α</a> <a id="7722" href="Ordinal.OrdInOrd.html#7722" class="Bound">β</a> <a id="7724" href="Ordinal.OrdInOrd.html#7724" class="Bound">γ</a> <a id="7726" class="Symbol">(</a><a id="7727" href="Ordinal.OrdInOrd.html#7727" class="Bound">b</a> <a id="7729" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7731" href="Ordinal.OrdInOrd.html#7731" class="Bound">β↓b≡α</a><a id="7736" class="Symbol">)</a> <a id="7738" href="Ordinal.OrdInOrd.html#7738" class="Bound">β&lt;γ</a> <a id="7742" class="Symbol">=</a> <a id="7744" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="7750" class="Symbol">(</a><a id="7751" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;</a> <a id="7754" href="Ordinal.OrdInOrd.html#7724" class="Bound">γ</a><a id="7755" class="Symbol">)</a> <a id="7757" href="Ordinal.OrdInOrd.html#7731" class="Bound">β↓b≡α</a> <a id="7763" href="Ordinal.OrdInOrd.html#7783" class="Function">β↓b&lt;γ</a>
    <a id="7773" class="Keyword">where</a>
    <a id="7783" href="Ordinal.OrdInOrd.html#7783" class="Function">β↓b&lt;γ</a> <a id="7789" class="Symbol">:</a> <a id="7791" class="Symbol">(</a><a id="7792" href="Ordinal.OrdInOrd.html#7722" class="Bound">β</a> <a id="7794" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="7796" href="Ordinal.OrdInOrd.html#7727" class="Bound">b</a><a id="7797" class="Symbol">)</a> <a id="7799" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="7801" href="Ordinal.OrdInOrd.html#7724" class="Bound">γ</a>
    <a id="7807" href="Ordinal.OrdInOrd.html#7783" class="Function">β↓b&lt;γ</a> <a id="7813" class="Symbol">=</a> <a id="7815" href="Ordinal.OrdInOrd.html#5959" class="Function">&lt;→≤</a> <a id="7819" href="Ordinal.OrdInOrd.html#7738" class="Bound">β&lt;γ</a> <a id="7823" class="Symbol">.</a><a id="7824" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="7828" href="Ordinal.OrdInOrd.html#7727" class="Bound">b</a> <a id="7830" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7832" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="7836" class="Symbol">(</a><a id="7837" href="Ordinal.OrdInOrd.html#5447" class="Function">↓≡↓</a> <a id="7841" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7843" href="Ordinal.OrdInOrd.html#5959" class="Function">&lt;→≤</a> <a id="7847" href="Ordinal.OrdInOrd.html#7738" class="Bound">β&lt;γ</a><a id="7850" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> <code>_&lt;_</code> 具有外延性.<br />
<strong>证明</strong> 假设对任意 <code>z</code> 都有 <code>z &lt; α ↔︎ z &lt; β</code>, 要证 <code>α ≡ β</code>. 用序数的泛等原理转化为证明 <code>α</code> 与 <code>β</code> 同构, 分别要证它们的底集同构且底序同构.</p>
<p>由前提和引理 <code>↓&lt;</code> 我们有 <code>f : α ↓ a &lt; β</code> 且 <code>g : β ↓ b &lt; α</code>, 满足</p>
<p><code>f₂ a : β ↓ (f₁ a) ≡ α ↓ a</code> 以及</p>
<p><code>g₂ b : α ↓ (g₁ b) ≡ β ↓ b</code></p>
<p>其中 <code>f₁</code> 和 <code>f₂</code> 指 <code>fst ∘ f</code> 和 <code>snd ∘ f</code>, 对 <code>g</code> 亦同.</p>
<p><code>f₁</code> 和 <code>g₁</code> 即是 <code>⟨ α ⟩</code> 到 <code>⟨ β ⟩</code> 的正映射和逆映射. 互逆性结合 <code>f₂</code>, <code>g₂</code> 与前段构造的单射性可证.</p>
<pre class="Agda">  <a id="8226" href="Ordinal.OrdInOrd.html#8226" class="Function">&lt;-ext</a> <a id="8232" class="Symbol">:</a> <a id="8234" href="Ordinal.Base.html#1766" class="Function">Extensional</a>
  <a id="8248" href="Ordinal.OrdInOrd.html#8226" class="Function">&lt;-ext</a> <a id="8254" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a> <a id="8256" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a> <a id="8258" href="Ordinal.OrdInOrd.html#8258" class="Bound">H</a> <a id="8260" class="Symbol">=</a> <a id="8262" href="Ordinal.Base.html#9975" class="Function">≃ₒ→≡</a> <a id="8267" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8269" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="8280" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8282" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8284" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="8299" class="Symbol">λ</a> <a id="8301" href="Ordinal.OrdInOrd.html#8301" class="Bound">x</a> <a id="8303" href="Ordinal.OrdInOrd.html#8303" class="Bound">y</a> <a id="8305" class="Symbol">→</a> <a id="8307" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="8318" class="Symbol">(</a><a id="8319" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="8321" href="Ordinal.OrdInOrd.html#8301" class="Bound">x</a> <a id="8323" href="Ordinal.OrdInOrd.html#8303" class="Bound">y</a><a id="8324" class="Symbol">)</a>
    <a id="8330" class="Keyword">where</a>
    <a id="8340" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8342" class="Symbol">:</a> <a id="8344" class="Symbol">∀</a> <a id="8346" href="Ordinal.OrdInOrd.html#8346" class="Bound">a</a> <a id="8348" class="Symbol">→</a> <a id="8350" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a> <a id="8352" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="8354" href="Ordinal.OrdInOrd.html#8346" class="Bound">a</a> <a id="8356" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="8358" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a>
    <a id="8364" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8366" href="Ordinal.OrdInOrd.html#8366" class="Bound">a</a> <a id="8368" class="Symbol">=</a> <a id="8370" href="Ordinal.OrdInOrd.html#8258" class="Bound">H</a> <a id="8372" class="Symbol">_</a> <a id="8374" class="Symbol">.</a><a id="8375" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="8379" href="Ordinal.OrdInOrd.html#6065" class="Function">↓&lt;</a>
    <a id="8386" href="Ordinal.OrdInOrd.html#8386" class="Function">g</a> <a id="8388" class="Symbol">:</a> <a id="8390" class="Symbol">∀</a> <a id="8392" href="Ordinal.OrdInOrd.html#8392" class="Bound">b</a> <a id="8394" class="Symbol">→</a> <a id="8396" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a> <a id="8398" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="8400" href="Ordinal.OrdInOrd.html#8392" class="Bound">b</a> <a id="8402" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="8404" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a>
    <a id="8410" href="Ordinal.OrdInOrd.html#8386" class="Function">g</a> <a id="8412" href="Ordinal.OrdInOrd.html#8412" class="Bound">b</a> <a id="8414" class="Symbol">=</a> <a id="8416" href="Ordinal.OrdInOrd.html#8258" class="Bound">H</a> <a id="8418" class="Symbol">_</a> <a id="8420" class="Symbol">.</a><a id="8421" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="8425" href="Ordinal.OrdInOrd.html#6065" class="Function">↓&lt;</a>
    <a id="8432" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8434" class="Symbol">:</a> <a id="8436" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="8440" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="8442" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a> <a id="8444" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="8446" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="8448" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a> <a id="8450" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a>
    <a id="8456" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a>       <a id="8470" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8472" class="Symbol">=</a> <a id="8474" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="8478" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="8480" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a>
    <a id="8486" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a>       <a id="8500" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8502" class="Symbol">=</a> <a id="8504" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="8508" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="8510" href="Ordinal.OrdInOrd.html#8386" class="Function">g</a>
    <a id="8516" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a>   <a id="8530" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8532" href="Ordinal.OrdInOrd.html#8532" class="Bound">a</a> <a id="8534" class="Symbol">=</a> <a id="8536" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="8542" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8544" href="Ordinal.OrdInOrd.html#8386" class="Function">g</a> <a id="8546" class="Symbol">_</a> <a id="8548" class="Symbol">.</a><a id="8549" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="8553" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="8555" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8557" class="Symbol">_</a> <a id="8559" class="Symbol">.</a><a id="8560" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>
    <a id="8568" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a>  <a id="8582" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8584" href="Ordinal.OrdInOrd.html#8584" class="Bound">b</a> <a id="8586" class="Symbol">=</a> <a id="8588" href="Ordinal.OrdInOrd.html#3485" class="Function">↓-inj</a> <a id="8594" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8596" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8598" class="Symbol">_</a> <a id="8600" class="Symbol">.</a><a id="8601" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="8605" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="8607" href="Ordinal.OrdInOrd.html#8386" class="Function">g</a> <a id="8609" class="Symbol">_</a> <a id="8611" class="Symbol">.</a><a id="8612" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>
</pre>
<p>对于底序的同构, 我们要建立 <code>≺⟨ α ⟩</code> 与 <code>≺⟨ β ⟩</code> 的同构. 无论正映射还是逆映射, 将一边输入到 <code>↓-preserves-≺</code>, 并用 <code>f₂</code> 和 <code>g₂</code> 改写成适用于 <code>↓-reflects-≺</code> 的形式, 再输入到它即得另一边. 互逆性由 <code>≺</code> 的命题性可证. ∎</p>
<pre class="Agda">    <a id="8783" class="Keyword">module</a> <a id="8790" href="Ordinal.OrdInOrd.html#8790" class="Symbol">_</a> <a id="8792" href="Ordinal.OrdInOrd.html#8792" class="Bound">x</a> <a id="8794" href="Ordinal.OrdInOrd.html#8794" class="Bound">y</a> <a id="8796" class="Keyword">where</a>
      <a id="8808" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="8810" class="Symbol">:</a> <a id="8812" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="8816" class="Symbol">(</a><a id="8817" href="Ordinal.OrdInOrd.html#8792" class="Bound">x</a> <a id="8819" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="8822" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a> <a id="8824" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="8826" href="Ordinal.OrdInOrd.html#8794" class="Bound">y</a><a id="8827" class="Symbol">)</a> <a id="8829" class="Symbol">(</a><a id="8830" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="8838" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8840" href="Ordinal.OrdInOrd.html#8792" class="Bound">x</a> <a id="8842" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="8845" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a> <a id="8847" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="8849" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="8857" href="Ordinal.OrdInOrd.html#8432" class="Function">i</a> <a id="8859" href="Ordinal.OrdInOrd.html#8794" class="Bound">y</a><a id="8860" class="Symbol">)</a>
      <a id="8868" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a>       <a id="8882" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="8884" href="Ordinal.OrdInOrd.html#8884" class="Bound">H</a> <a id="8886" class="Symbol">=</a> <a id="8888" href="Ordinal.OrdInOrd.html#6440" class="Function">↓-reflects-≺</a> <a id="8901" class="Symbol">_</a> <a id="8903" class="Symbol">_</a> <a id="8905" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8907" href="Cubical.Foundations.Prelude.html#9252" class="Function">subst2</a> <a id="8914" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;_</a> <a id="8918" class="Symbol">(</a><a id="8919" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="8923" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8925" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8927" href="Ordinal.OrdInOrd.html#8792" class="Bound">x</a> <a id="8929" class="Symbol">.</a><a id="8930" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="8933" class="Symbol">)</a> <a id="8935" class="Symbol">(</a><a id="8936" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="8940" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8942" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="8944" href="Ordinal.OrdInOrd.html#8794" class="Bound">y</a> <a id="8946" class="Symbol">.</a><a id="8947" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="8950" class="Symbol">)</a> <a id="8952" class="Symbol">(</a><a id="8953" href="Ordinal.OrdInOrd.html#6825" class="Function">↓-preserves-≺</a> <a id="8967" class="Symbol">_</a> <a id="8969" class="Symbol">_</a> <a id="8971" href="Ordinal.OrdInOrd.html#8884" class="Bound">H</a><a id="8972" class="Symbol">)</a>
      <a id="8980" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a>       <a id="8994" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="8996" href="Ordinal.OrdInOrd.html#8996" class="Bound">H</a> <a id="8998" class="Symbol">=</a> <a id="9000" href="Ordinal.OrdInOrd.html#6440" class="Function">↓-reflects-≺</a> <a id="9013" class="Symbol">_</a> <a id="9015" class="Symbol">_</a> <a id="9017" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9019" href="Cubical.Foundations.Prelude.html#9252" class="Function">subst2</a> <a id="9026" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;_</a> <a id="9030" class="Symbol">(</a><a id="9031" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="9033" href="Ordinal.OrdInOrd.html#8792" class="Bound">x</a> <a id="9035" class="Symbol">.</a><a id="9036" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="9039" class="Symbol">)</a>       <a id="9047" class="Symbol">(</a><a id="9048" href="Ordinal.OrdInOrd.html#8340" class="Function">f</a> <a id="9050" href="Ordinal.OrdInOrd.html#8794" class="Bound">y</a> <a id="9052" class="Symbol">.</a><a id="9053" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="9056" class="Symbol">)</a>       <a id="9064" class="Symbol">(</a><a id="9065" href="Ordinal.OrdInOrd.html#6825" class="Function">↓-preserves-≺</a> <a id="9079" class="Symbol">_</a> <a id="9081" class="Symbol">_</a> <a id="9083" href="Ordinal.OrdInOrd.html#8996" class="Bound">H</a><a id="9084" class="Symbol">)</a>
      <a id="9092" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a>   <a id="9106" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="9108" class="Symbol">_</a> <a id="9110" class="Symbol">=</a> <a id="9112" href="Ordinal.Base.html#4669" class="Function">OrdStr.≺-prop</a> <a id="9126" class="Symbol">(</a><a id="9127" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="9131" href="Ordinal.OrdInOrd.html#8254" class="Bound">α</a><a id="9132" class="Symbol">)</a> <a id="9134" class="Symbol">_</a> <a id="9136" class="Symbol">_</a> <a id="9138" class="Symbol">_</a> <a id="9140" class="Symbol">_</a>
      <a id="9148" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a>  <a id="9162" href="Ordinal.OrdInOrd.html#8808" class="Function">j</a> <a id="9164" class="Symbol">_</a> <a id="9166" class="Symbol">=</a> <a id="9168" href="Ordinal.Base.html#4669" class="Function">OrdStr.≺-prop</a> <a id="9182" class="Symbol">(</a><a id="9183" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="9187" href="Ordinal.OrdInOrd.html#8256" class="Bound">β</a><a id="9188" class="Symbol">)</a> <a id="9190" class="Symbol">_</a> <a id="9192" class="Symbol">_</a> <a id="9194" class="Symbol">_</a> <a id="9196" class="Symbol">_</a>
</pre>
<p><strong>引理</strong> <code>_&lt;_</code> 具有良基性.<br />
<strong>证明</strong> 要证任意 <code>α</code> 在 <code>_&lt;_</code> 关系下可及. 由可及的构造子 <code>acc</code>, 即证对任意 <code>β &lt; α</code>, <code>β</code> 可及. 目标可以改写为证任意 <code>α ↓ a</code> 都可及.</p>
<pre class="Agda">  <a id="9329" href="Ordinal.OrdInOrd.html#9329" class="Function">&lt;-wf</a> <a id="9334" class="Symbol">:</a> <a id="9336" href="Ordinal.Base.html#3171" class="Function">WellFounded</a>
  <a id="9350" href="Ordinal.OrdInOrd.html#9329" class="Function">&lt;-wf</a> <a id="9355" href="Ordinal.OrdInOrd.html#9355" class="Bound">α</a> <a id="9357" class="Symbol">=</a> <a id="9359" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="9363" class="Symbol">λ</a> <a id="9365" href="Ordinal.OrdInOrd.html#9365" class="Bound">β</a> <a id="9367" class="Symbol">(</a><a id="9368" href="Ordinal.OrdInOrd.html#9368" class="Bound">a</a> <a id="9370" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9372" href="Ordinal.OrdInOrd.html#9372" class="Bound">α↓a≡β</a><a id="9377" class="Symbol">)</a> <a id="9379" class="Symbol">→</a> <a id="9381" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="9387" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="9391" href="Ordinal.OrdInOrd.html#9372" class="Bound">α↓a≡β</a> <a id="9397" class="Symbol">(</a><a id="9398" href="Ordinal.OrdInOrd.html#9444" class="Function">Acc↓</a> <a id="9403" href="Ordinal.OrdInOrd.html#9368" class="Bound">a</a><a id="9404" class="Symbol">)</a>
    <a id="9410" class="Keyword">where</a>
    <a id="9420" class="Keyword">open</a> <a id="9425" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="9432" class="Symbol">(</a><a id="9433" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="9437" href="Ordinal.OrdInOrd.html#9355" class="Bound">α</a><a id="9438" class="Symbol">)</a>
    <a id="9444" href="Ordinal.OrdInOrd.html#9444" class="Function">Acc↓</a> <a id="9449" class="Symbol">:</a> <a id="9451" class="Symbol">(</a><a id="9452" href="Ordinal.OrdInOrd.html#9452" class="Bound">a</a> <a id="9454" class="Symbol">:</a> <a id="9456" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="9458" href="Ordinal.OrdInOrd.html#9355" class="Bound">α</a> <a id="9460" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="9461" class="Symbol">)</a> <a id="9463" class="Symbol">→</a> <a id="9465" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="9469" class="Symbol">(</a><a id="9470" href="Ordinal.OrdInOrd.html#9355" class="Bound">α</a> <a id="9472" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="9474" href="Ordinal.OrdInOrd.html#9452" class="Bound">a</a><a id="9475" class="Symbol">)</a>
</pre>
<p>由良基归纳法, 有归纳假设: 对任意 <code>b ≺ a</code>, <code>α ↓ b</code> 可及. 现在要证 <code>α ↓ a</code>, 由可及的构造子 <code>acc</code>, 即证对任意 <code>β &lt; α ↓ a</code>, <code>β</code> 可及.</p>
<p><code>β &lt; α ↓ a</code> 说明有 <code>b ≺ a</code> 满足</p>
<p><code>α ↓ a ↓ b ≡ β</code>, 消掉一个 <code>↓</code> 有</p>
<p><code>α ↓ b ≡ β</code></p>
<p>由此改写目标, 即证 <code>α ↓ b</code> 可及. 由归纳假设即证. ∎</p>
<pre class="Agda">    <a id="9696" href="Ordinal.OrdInOrd.html#9444" class="Function">Acc↓</a> <a id="9701" class="Symbol">=</a> <a id="9703" href="Ordinal.Base.html#6188" class="Function">elim</a> <a id="9708" class="Symbol">λ</a> <a id="9710" href="Ordinal.OrdInOrd.html#9710" class="Bound">a</a> <a id="9712" href="Ordinal.OrdInOrd.html#9712" class="Bound">IH</a> <a id="9715" class="Symbol">→</a> <a id="9717" href="Ordinal.Base.html#3059" class="InductiveConstructor">acc</a> <a id="9721" class="Symbol">λ</a> <a id="9723" href="Ordinal.OrdInOrd.html#9723" class="Bound">β</a> <a id="9725" class="Symbol">((</a><a id="9727" href="Ordinal.OrdInOrd.html#9727" class="Bound">b</a> <a id="9729" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9731" href="Ordinal.OrdInOrd.html#9731" class="Bound">b≺a</a><a id="9734" class="Symbol">)</a> <a id="9736" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9738" href="Ordinal.OrdInOrd.html#9738" class="Bound">α↓a↓b≡β</a><a id="9745" class="Symbol">)</a> <a id="9747" class="Symbol">→</a>
      <a id="9755" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="9761" href="Ordinal.Base.html#3022" class="Datatype">Acc</a> <a id="9765" class="Symbol">(</a><a id="9766" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="9770" href="Ordinal.OrdInOrd.html#5598" class="Function">↓↓-red</a> <a id="9777" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="9779" href="Ordinal.OrdInOrd.html#9738" class="Bound">α↓a↓b≡β</a><a id="9786" class="Symbol">)</a> <a id="9788" class="Symbol">(</a><a id="9789" href="Ordinal.OrdInOrd.html#9712" class="Bound">IH</a> <a id="9792" href="Ordinal.OrdInOrd.html#9727" class="Bound">b</a> <a id="9794" href="Ordinal.OrdInOrd.html#9731" class="Bound">b≺a</a><a id="9797" class="Symbol">)</a>
</pre>
<p><code>_&lt;_</code> 的良基性蕴含其反自反性.</p>
<pre class="Agda">  <a id="9834" href="Ordinal.OrdInOrd.html#9834" class="Function">&lt;-irrefl</a> <a id="9843" class="Symbol">:</a> <a id="9845" href="Ordinal.Base.html#1133" class="Function">Irreflexive</a>
  <a id="9859" href="Ordinal.OrdInOrd.html#9834" class="Function">&lt;-irrefl</a> <a id="9868" class="Symbol">=</a> <a id="9870" href="Ordinal.Base.html#4366" class="Function">WellFounded→Irreflexive</a> <a id="9894" href="Ordinal.OrdInOrd.html#9329" class="Function">&lt;-wf</a>
</pre>
<p><code>_&lt;_</code> 的命题, 传递, 外延和良基性说明它是一个良序关系.</p>
<pre class="Agda">  <a id="9948" href="Ordinal.OrdInOrd.html#9948" class="Function">&lt;-wo</a> <a id="9953" class="Symbol">:</a> <a id="9955" href="Ordinal.Base.html#4590" class="Record">WellOrdered</a>
  <a id="9969" href="Ordinal.OrdInOrd.html#9948" class="Function">&lt;-wo</a> <a id="9974" class="Symbol">=</a> <a id="9976" href="Ordinal.Base.html#4639" class="InductiveConstructor">mkWellOrdered</a> <a id="9990" href="Ordinal.OrdInOrd.html#7281" class="Function">&lt;-prop</a> <a id="9997" href="Ordinal.OrdInOrd.html#7689" class="Function">&lt;-trans</a> <a id="10005" href="Ordinal.OrdInOrd.html#8226" class="Function">&lt;-ext</a> <a id="10011" href="Ordinal.OrdInOrd.html#9329" class="Function">&lt;-wf</a>
</pre>
<h2 id="吃自己">吃自己</h2>
<p>序数宇宙 <code>Ord 𝓊</code> 配合上其上的良序 <code>_&lt;_</code> 说明它本身也构成一个序数, 我们记作 <code>Ω</code>, 它位于 <code>Ord (𝓊 ⁺)</code> 序数宇宙.</p>
<pre class="Agda"><a id="Ω"></a><a id="10112" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="10114" class="Symbol">:</a> <a id="10116" class="Symbol">∀</a> <a id="10118" class="Symbol">{</a><a id="10119" href="Ordinal.OrdInOrd.html#10119" class="Bound">𝓊</a><a id="10120" class="Symbol">}</a> <a id="10122" class="Symbol">→</a> <a id="10124" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="10128" class="Symbol">(</a><a id="10129" href="Ordinal.OrdInOrd.html#10119" class="Bound">𝓊</a> <a id="10131" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="10132" class="Symbol">)</a>
<a id="10134" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="10136" class="Symbol">{</a><a id="10137" href="Ordinal.OrdInOrd.html#10137" class="Bound">𝓊</a><a id="10138" class="Symbol">}</a> <a id="10140" class="Symbol">=</a> <a id="10142" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="10146" href="Ordinal.OrdInOrd.html#10137" class="Bound">𝓊</a> <a id="10148" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10150" href="Ordinal.Base.html#6033" class="InductiveConstructor">mkOrdStr</a> <a id="10159" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">_&lt;_</a> <a id="10163" href="Ordinal.OrdInOrd.html#9948" class="Function">&lt;-wo</a>
</pre>
<p>序数 <code>Ω</code> 的底集 <code>⟨ Ω ⟩</code> 即序数宇宙 <code>Ord 𝓊</code>. 这两种记法可以互换使用.</p>
<pre class="Agda"><a id="10229" href="Ordinal.OrdInOrd.html#10229" class="Function">_</a> <a id="10231" class="Symbol">:</a> <a id="10233" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="10235" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="10237" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="10239" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="10241" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="10245" href="Preliminary.html#2692" class="Generalizable">𝓊</a>
<a id="10247" class="Symbol">_</a> <a id="10249" class="Symbol">=</a> <a id="10251" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
</pre>
<p>集合论中有结论说”序数是比它小的所有序数所组成的集合”, 以下定理是在类型论中的对应物.</p>
<p><strong>定理</strong> 序数 <code>α</code> 等价于 <code>Ω</code> 的 <code>α</code> 前段.<br />
<strong>证明</strong> 与 <code>↓≃ₒ↓</code> 和 <code>&lt;-ext</code> 的证明类似地, 我们分别证明底集同构且底序同构.</p>
<ul>
<li>底集的同构构造如下
<ul>
<li>正映射: 将 <code>a : ⟨ α ⟩</code> 映射到 <code>(α ↓ a , ↓&lt;) : ⟨ Ω ↓ α ⟩</code> 即可. (其中 <code>↓&lt;</code> 具有 <code>(a , refl)</code> 的形式)</li>
<li>逆映射: <code>⟨ Ω ↓ α ⟩</code> 的项是三元组 <code>(β , a , α↓a≡β)</code>, 取第二分量即可.</li>
<li>左互逆性: 计算即得.</li>
<li>右互逆性: 取第三分量 <code>α↓a≡β</code> 即得.</li>
</ul></li>
</ul>
<pre class="Agda"><a id="α≃Ω↓α"></a><a id="10602" href="Ordinal.OrdInOrd.html#10602" class="Function">α≃Ω↓α</a> <a id="10608" class="Symbol">:</a> <a id="10610" class="Symbol">{</a><a id="10611" href="Ordinal.OrdInOrd.html#10611" class="Bound">α</a> <a id="10613" class="Symbol">:</a> <a id="10615" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="10619" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="10620" class="Symbol">}</a> <a id="10622" class="Symbol">→</a> <a id="10624" href="Ordinal.OrdInOrd.html#10611" class="Bound">α</a> <a id="10626" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="10629" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="10631" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="10633" href="Ordinal.OrdInOrd.html#10611" class="Bound">α</a>
<a id="10635" href="Ordinal.OrdInOrd.html#10602" class="Function">α≃Ω↓α</a> <a id="10641" class="Symbol">{</a><a id="10642" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a><a id="10643" class="Symbol">}</a> <a id="10645" class="Symbol">=</a> <a id="10647" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="10658" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10660" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10662" href="Ordinal.Base.html#7903" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="10677" class="Symbol">λ</a> <a id="10679" href="Ordinal.OrdInOrd.html#10679" class="Bound">x</a> <a id="10681" href="Ordinal.OrdInOrd.html#10681" class="Bound">y</a> <a id="10683" class="Symbol">→</a> <a id="10685" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="10696" class="Symbol">(</a><a id="10697" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="10699" href="Ordinal.OrdInOrd.html#10679" class="Bound">x</a> <a id="10701" href="Ordinal.OrdInOrd.html#10681" class="Bound">y</a><a id="10702" class="Symbol">)</a>
  <a id="10706" class="Keyword">where</a>
  <a id="10714" class="Keyword">open</a> <a id="10719" href="Ordinal.Base.html#5980" class="Module">OrdStr</a>
  <a id="10728" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10730" class="Symbol">:</a> <a id="10732" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="10736" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="10738" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a> <a id="10740" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="10742" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="10744" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="10746" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="10748" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a> <a id="10750" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a>
  <a id="10754" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="10762" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10764" href="Ordinal.OrdInOrd.html#10764" class="Bound">a</a> <a id="10766" class="Symbol">=</a> <a id="10768" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a> <a id="10770" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="10772" href="Ordinal.OrdInOrd.html#10764" class="Bound">a</a> <a id="10774" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10776" href="Ordinal.OrdInOrd.html#6065" class="Function">↓&lt;</a>
  <a id="10781" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a> <a id="10789" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10791" class="Symbol">(</a><a id="10792" href="Ordinal.OrdInOrd.html#10792" class="Bound">β</a> <a id="10794" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10796" href="Ordinal.OrdInOrd.html#10796" class="Bound">a</a> <a id="10798" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10800" href="Ordinal.OrdInOrd.html#10800" class="Bound">α↓a≡β</a><a id="10805" class="Symbol">)</a> <a id="10807" class="Symbol">=</a> <a id="10809" href="Ordinal.OrdInOrd.html#10796" class="Bound">a</a>
  <a id="10813" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a> <a id="10825" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10827" class="Symbol">_</a> <a id="10829" class="Symbol">=</a> <a id="10831" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
  <a id="10838" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a> <a id="10851" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="10853" class="Symbol">(</a><a id="10854" href="Ordinal.OrdInOrd.html#10854" class="Bound">β</a> <a id="10856" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10858" href="Ordinal.OrdInOrd.html#10858" class="Bound">a</a> <a id="10860" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10862" href="Ordinal.OrdInOrd.html#10862" class="Bound">α↓a≡β</a><a id="10867" class="Symbol">)</a> <a id="10869" class="Symbol">=</a> <a id="10871" href="Preliminary.html#9778" class="Function">Σ≡Prop</a> <a id="10878" class="Symbol">(λ</a> <a id="10881" href="Ordinal.OrdInOrd.html#10881" class="Bound">_</a> <a id="10883" class="Symbol">→</a> <a id="10885" href="Ordinal.OrdInOrd.html#7281" class="Function">&lt;-prop</a> <a id="10892" class="Symbol">_</a> <a id="10894" class="Symbol">_)</a> <a id="10897" href="Ordinal.OrdInOrd.html#10862" class="Bound">α↓a≡β</a>
</pre>
<p>底序同构的正映射和逆映射正好由 <code>↓-preserves-≺</code> 和 <code>↓-reflects-≺</code> 提供. 互逆性由 <code>≺</code> 的命题性即证.</p>
<pre class="Agda">  <a id="10989" class="Keyword">module</a> <a id="10996" href="Ordinal.OrdInOrd.html#10996" class="Module">_</a> <a id="10998" href="Ordinal.OrdInOrd.html#10998" class="Bound">x</a> <a id="11000" href="Ordinal.OrdInOrd.html#11000" class="Bound">y</a> <a id="11002" class="Keyword">where</a>
    <a id="11012" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="11014" class="Symbol">:</a> <a id="11016" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="11020" class="Symbol">(</a><a id="11021" href="Ordinal.OrdInOrd.html#10998" class="Bound">x</a> <a id="11023" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="11026" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a> <a id="11028" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="11030" href="Ordinal.OrdInOrd.html#11000" class="Bound">y</a><a id="11031" class="Symbol">)</a> <a id="11033" class="Symbol">(</a><a id="11034" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="11042" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="11044" href="Ordinal.OrdInOrd.html#10998" class="Bound">x</a> <a id="11046" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="11049" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="11051" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="11053" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a> <a id="11055" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="11057" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="11065" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="11067" href="Ordinal.OrdInOrd.html#11000" class="Bound">y</a><a id="11068" class="Symbol">)</a>
    <a id="11074" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a>       <a id="11088" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="11090" class="Symbol">=</a> <a id="11092" href="Ordinal.OrdInOrd.html#6825" class="Function">↓-preserves-≺</a> <a id="11106" class="Symbol">_</a> <a id="11108" class="Symbol">_</a>
    <a id="11114" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a>       <a id="11128" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="11130" class="Symbol">=</a> <a id="11132" href="Ordinal.OrdInOrd.html#6440" class="Function">↓-reflects-≺</a> <a id="11145" class="Symbol">_</a> <a id="11147" class="Symbol">_</a>
    <a id="11153" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a>   <a id="11167" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="11169" class="Symbol">_</a> <a id="11171" class="Symbol">=</a> <a id="11173" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="11180" class="Symbol">(</a><a id="11181" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="11185" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a><a id="11186" class="Symbol">)</a> <a id="11188" class="Symbol">_</a> <a id="11190" class="Symbol">_</a> <a id="11192" class="Symbol">_</a> <a id="11194" class="Symbol">_</a>
    <a id="11200" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a>  <a id="11214" href="Ordinal.OrdInOrd.html#11012" class="Function">j</a> <a id="11216" class="Symbol">_</a> <a id="11218" class="Symbol">=</a> <a id="11220" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="11227" class="Symbol">(</a><a id="11228" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="11232" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="11234" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="11236" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="11238" href="Ordinal.OrdInOrd.html#10642" class="Bound">α</a><a id="11239" class="Symbol">)</a> <a id="11241" class="Symbol">(</a><a id="11242" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="11250" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="11252" href="Ordinal.OrdInOrd.html#10998" class="Bound">x</a><a id="11253" class="Symbol">)</a> <a id="11255" class="Symbol">(</a><a id="11256" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a> <a id="11264" href="Ordinal.OrdInOrd.html#10728" class="Function">i</a> <a id="11266" href="Ordinal.OrdInOrd.html#11000" class="Bound">y</a><a id="11267" class="Symbol">)</a> <a id="11269" class="Symbol">_</a> <a id="11271" class="Symbol">_</a>
</pre>
<h2 id="布拉利-福尔蒂悖论">布拉利-福尔蒂悖论</h2>
<p>布拉利-福尔蒂悖论又叫最大序数悖论, 是朴素集合论中发现的第一个悖论, 比罗素悖论还早. 它说</p>
<blockquote>
<p>设Ord是所有序数的集合, 那么Ord对应一个序数Ω, 它比Ord里面的序数都大. 又Ω也在Ord中, 有 Ω &lt; Ω, 违反 &lt; 的反自反性</p>
</blockquote>
<p>ZFC 集合论的解决方案是说 Ord 不是集合. 类型论中的解决方案则是宇宙分层, Ω 不在 Ord 𝓊 中, 而在 Ord (𝓊 ⁺) 中, 对应于以下定理.</p>
<p><strong>定理</strong> <code>Ω</code> 不与其中的任意 <code>α</code> 等价.<br />
<strong>证明</strong> 假设存在 <code>α</code> 满足 <code>α ≃ₒ Ω</code>, 由上一条定理有 <code>α ≃ₒ Ω ↓ α</code>, 都等价的对称性和传递性有 <code>Ω ↓ α ≡ Ω</code>, 因此 <code>Ω &lt; Ω</code>, 违反 <code>&lt;</code> 的反自反性. ∎</p>
<pre class="Agda"><a id="Burali-Forti"></a><a id="11641" href="Ordinal.OrdInOrd.html#11641" class="Function">Burali-Forti</a> <a id="11654" class="Symbol">:</a> <a id="11656" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="11658" class="Symbol">(</a><a id="11659" href="Preliminary.html#5407" class="Function">Σ</a> <a id="11661" href="Ordinal.OrdInOrd.html#11661" class="Bound">α</a> <a id="11663" href="Preliminary.html#5407" class="Function">∶</a> <a id="11665" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="11667" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="11669" class="Symbol">{</a><a id="11670" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="11671" class="Symbol">}</a> <a id="11673" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="11675" href="Preliminary.html#5407" class="Function">,</a> <a id="11677" href="Ordinal.OrdInOrd.html#11661" class="Bound">α</a> <a id="11679" href="Ordinal.Base.html#8519" class="Function Operator">≃ₒ</a> <a id="11682" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a><a id="11683" class="Symbol">)</a>
<a id="11685" href="Ordinal.OrdInOrd.html#11641" class="Function">Burali-Forti</a> <a id="11698" class="Symbol">(</a><a id="11699" href="Ordinal.OrdInOrd.html#11699" class="Bound">α</a> <a id="11701" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11703" href="Ordinal.OrdInOrd.html#11703" class="Bound">f</a><a id="11704" class="Symbol">)</a> <a id="11706" class="Symbol">=</a> <a id="11708" href="Ordinal.OrdInOrd.html#9834" class="Function">&lt;-irrefl</a> <a id="11717" class="Symbol">_</a> <a id="11719" href="Ordinal.OrdInOrd.html#11790" class="Function">Ω&lt;Ω</a>
  <a id="11725" class="Keyword">where</a>
  <a id="11733" href="Ordinal.OrdInOrd.html#11733" class="Function">eq</a> <a id="11736" class="Symbol">:</a> <a id="11738" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="11740" href="Ordinal.OrdInOrd.html#663" class="Function Operator">↓</a> <a id="11742" href="Ordinal.OrdInOrd.html#11699" class="Bound">α</a> <a id="11744" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="11746" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a>
  <a id="11750" href="Ordinal.OrdInOrd.html#11733" class="Function">eq</a> <a id="11753" class="Symbol">=</a> <a id="11755" href="Ordinal.Base.html#9975" class="Function">≃ₒ→≡</a> <a id="11760" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="11762" href="Ordinal.Base.html#9013" class="Function">≃ₒ-trans</a> <a id="11771" class="Symbol">(</a><a id="11772" href="Ordinal.Base.html#8743" class="Function">≃ₒ-sym</a> <a id="11779" href="Ordinal.OrdInOrd.html#10602" class="Function">α≃Ω↓α</a><a id="11784" class="Symbol">)</a> <a id="11786" href="Ordinal.OrdInOrd.html#11703" class="Bound">f</a>
  <a id="11790" href="Ordinal.OrdInOrd.html#11790" class="Function">Ω&lt;Ω</a> <a id="11794" class="Symbol">:</a> <a id="11796" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a> <a id="11798" href="Ordinal.OrdInOrd.html#5841" class="Function Operator">&lt;</a> <a id="11800" href="Ordinal.OrdInOrd.html#10112" class="Function">Ω</a>
  <a id="11804" href="Ordinal.OrdInOrd.html#11790" class="Function">Ω&lt;Ω</a> <a id="11808" class="Symbol">=</a> <a id="11810" href="Ordinal.OrdInOrd.html#11699" class="Bound">α</a> <a id="11812" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11814" href="Ordinal.OrdInOrd.html#11733" class="Function">eq</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
