---
title: 泛等结构集合论 (2) CH → LEM
zhihu-tags: Agda, 数理逻辑, 集合论
zhihu-url: https://zhuanlan.zhihu.com/p/643217740
---

# 泛等结构集合论 (2) CH → LEM

> 交流Q群: 893531731  
> 本文源码: [CH→LEM.lagda.md](https://github.com/choukh/USST/blob/main/src/CH→LEM.lagda.md)  
> 高亮渲染: [CH→LEM.html](https://choukh.github.io/USST/CH→LEM.html)  

我们导入前置知识, 并全局假设 `PR`. 我们来证明在直觉主义中连续统假设蕴含排中律.

<pre class="Agda"><a id="372" class="Symbol">{-#</a> <a id="376" class="Keyword">OPTIONS</a> <a id="384" class="Pragma">--cubical</a> <a id="394" class="Pragma">--safe</a> <a id="401" class="Symbol">#-}</a>
<a id="405" class="Keyword">open</a> <a id="410" class="Keyword">import</a> <a id="417" href="Preliminary.html" class="Module">Preliminary</a>
<a id="429" class="Keyword">module</a> <a id="436" href="CH%25E2%2586%2592LEM.html" class="Module">CH→LEM</a> <a id="443" class="Symbol">⦃</a> <a id="445" href="CH%25E2%2586%2592LEM.html#445" class="Bound">_</a> <a id="447" class="Symbol">:</a> <a id="449" href="Preliminary.html#10353" class="Function">PR</a> <a id="452" class="Symbol">⦄</a> <a id="454" class="Keyword">where</a>
</pre>
## 康托尔定理

首先我们复刻集合论的基本结果: 康托尔定理. 它可以在直觉主义中证明.

**定理** 任意类型都不能被自己的幂集单射.

<pre class="Agda"><a id="Cantor-≰"></a><a id="545" href="CH%25E2%2586%2592LEM.html#545" class="Function">Cantor-≰</a> <a id="554" class="Symbol">:</a> <a id="556" class="Symbol">(</a><a id="557" href="CH%25E2%2586%2592LEM.html#557" class="Bound">X</a> <a id="559" class="Symbol">:</a> <a id="561" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="566" href="Preliminary.html#2567" class="Generalizable">ℓ</a><a id="567" class="Symbol">)</a> <a id="569" class="Symbol">→</a> <a id="571" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="573" href="CH%25E2%2586%2592LEM.html#557" class="Bound">X</a> <a id="575" href="Preliminary.html#12711" class="Function Operator">≰</a> <a id="577" href="CH%25E2%2586%2592LEM.html#557" class="Bound">X</a>
</pre>
**证明** 用归谬法, 假设有 `ℙ X` 到 `X` 的单射函数 `f`, 要推出矛盾. 证明思路跟集合论中的一样. 我们用对角线法构造一个集合 `A : ℙ X`, 使得 `f A ∈ A` 当且仅当 `f A ∉ A`, 从而违反无矛盾律.

<pre class="Agda"><a id="718" href="CH%25E2%2586%2592LEM.html#545" class="Function">Cantor-≰</a> <a id="727" href="CH%25E2%2586%2592LEM.html#727" class="Bound">X</a> <a id="729" class="Symbol">(</a><a id="730" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="732" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="734" href="CH%25E2%2586%2592LEM.html#734" class="Bound">f-inj</a><a id="739" class="Symbol">)</a> <a id="741" class="Symbol">=</a> <a id="743" href="Preliminary.html#10718" class="Function">noncontradiction</a> <a id="760" href="CH%25E2%2586%2592LEM.html#1248" class="Function">∈→∉</a> <a id="764" href="CH%25E2%2586%2592LEM.html#1450" class="Function">∉→∈</a>
  <a id="770" class="Keyword">where</a>
</pre>
这个对角线集 `A` 是这么一个集合, 对于它里面的任意 `x`, 只要这个 `x` 等于某个 `f B`, 那么 `x` 就不在这个 `B` 里面. 这句话形式化为一个Π类型, 它最终指向空类型, 而空类型是命题, 所以这个Π类型也是命题, 从而这句话良好地定义了 `X` 的一个子集.

注意这个Π类型 (全称量化) 提升了宇宙等级, 它比 `X` 高一个宇宙, 我们要用 `PR` 把它压下来. 可能可以使用宇宙多态的 `ℙ` 使得子集可以位于不同的宇宙, 从而不需要 `PR` 也应该可以证明康托尔定理. 但这会增加整个形式化的复杂度, 而且后续章节有必须使用 `PR` 的地方, 所以我们就干脆全局假设了 `PR`.

<pre class="Agda">  <a id="1106" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1108" class="Symbol">:</a> <a id="1110" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="1112" href="CH%25E2%2586%2592LEM.html#727" class="Bound">X</a>
  <a id="1116" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1118" href="CH%25E2%2586%2592LEM.html#1118" class="Bound">x</a> <a id="1120" class="Symbol">=</a> <a id="1122" href="Preliminary.html#10078" class="Field">Resize</a> <a id="1129" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1131" class="Symbol">(∀</a> <a id="1134" href="CH%25E2%2586%2592LEM.html#1134" class="Bound">B</a> <a id="1136" class="Symbol">→</a> <a id="1138" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1140" href="CH%25E2%2586%2592LEM.html#1134" class="Bound">B</a> <a id="1142" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1144" href="CH%25E2%2586%2592LEM.html#1118" class="Bound">x</a> <a id="1146" class="Symbol">→</a> <a id="1148" href="CH%25E2%2586%2592LEM.html#1118" class="Bound">x</a> <a id="1150" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="1152" href="CH%25E2%2586%2592LEM.html#1134" class="Bound">B</a><a id="1153" class="Symbol">)</a> <a id="1155" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1157" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="1166" class="Symbol">λ</a> <a id="1168" href="CH%25E2%2586%2592LEM.html#1168" class="Bound">_</a> <a id="1170" href="CH%25E2%2586%2592LEM.html#1170" class="Bound">_</a> <a id="1172" href="CH%25E2%2586%2592LEM.html#1172" class="Bound">_</a> <a id="1174" class="Symbol">→</a> <a id="1176" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
</pre>
一旦对角线集 `A` 构造完成, 由定义立即有 `f A ∈ A` 蕴含 `f A ∉ A`.

<pre class="Agda">  <a id="1248" href="CH%25E2%2586%2592LEM.html#1248" class="Function">∈→∉</a> <a id="1252" class="Symbol">:</a> <a id="1254" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1256" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1258" href="Cubical.Foundations.Powerset.html#772" class="Function Operator">∈</a> <a id="1260" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1262" class="Symbol">→</a> <a id="1264" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1266" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1268" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="1270" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a>
  <a id="1274" href="CH%25E2%2586%2592LEM.html#1248" class="Function">∈→∉</a> <a id="1278" href="CH%25E2%2586%2592LEM.html#1278" class="Bound">fA∈A</a> <a id="1283" class="Symbol">=</a> <a id="1285" href="Preliminary.html#10160" class="Field">unresize</a> <a id="1294" href="CH%25E2%2586%2592LEM.html#1278" class="Bound">fA∈A</a> <a id="1299" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1301" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
另一方面, 假设 `f A ∉ A`, 要证 `f A ∈ A`. 即假设有一个 `B` 满足 `f B ≡ f A`, 要证 `f A ∉ B`. 由 `f` 的单射性可知 `A ≡ B`, 用它改写前提 `f A ∉ A` 右边的 `A` 即证. ∎

<pre class="Agda">  <a id="1450" href="CH%25E2%2586%2592LEM.html#1450" class="Function">∉→∈</a> <a id="1454" class="Symbol">:</a> <a id="1456" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1458" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1460" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="1462" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1464" class="Symbol">→</a> <a id="1466" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1468" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1470" href="Cubical.Foundations.Powerset.html#772" class="Function Operator">∈</a> <a id="1472" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a>
  <a id="1476" href="CH%25E2%2586%2592LEM.html#1450" class="Function">∉→∈</a> <a id="1480" href="CH%25E2%2586%2592LEM.html#1480" class="Bound">fA∉A</a> <a id="1485" class="Symbol">=</a> <a id="1487" href="Preliminary.html#10110" class="Field">resize</a> <a id="1494" class="Symbol">λ</a> <a id="1496" href="CH%25E2%2586%2592LEM.html#1496" class="Bound">B</a> <a id="1498" href="CH%25E2%2586%2592LEM.html#1498" class="Bound">fB≡</a> <a id="1502" class="Symbol">→</a> <a id="1504" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="1514" class="Symbol">(</a><a id="1515" href="CH%25E2%2586%2592LEM.html#730" class="Bound">f</a> <a id="1517" href="CH%25E2%2586%2592LEM.html#1106" class="Function">A</a> <a id="1519" href="Preliminary.html#9558" class="Function Operator">∉_</a><a id="1521" class="Symbol">)</a> <a id="1523" class="Symbol">(</a><a id="1524" href="CH%25E2%2586%2592LEM.html#734" class="Bound">f-inj</a> <a id="1530" class="Symbol">(</a><a id="1531" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="1535" href="CH%25E2%2586%2592LEM.html#1498" class="Bound">fB≡</a><a id="1538" class="Symbol">))</a> <a id="1541" href="CH%25E2%2586%2592LEM.html#1480" class="Bound">fA∉A</a>
</pre>
## 单集

现在固定一个集合 `X`.

<pre class="Agda"><a id="1581" class="Keyword">module</a> <a id="Lemmas"></a><a id="1588" href="CH%25E2%2586%2592LEM.html#1588" class="Module">Lemmas</a> <a id="1595" class="Symbol">(</a><a id="1596" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="1598" class="Symbol">:</a> <a id="1600" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1605" href="Preliminary.html#2567" class="Generalizable">ℓ</a><a id="1606" class="Symbol">)</a> <a id="1608" class="Symbol">(</a><a id="1609" href="CH%25E2%2586%2592LEM.html#1609" class="Bound">X-set</a> <a id="1615" class="Symbol">:</a> <a id="1617" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="1623" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a><a id="1624" class="Symbol">)</a> <a id="1626" class="Keyword">where</a>
</pre>
由 `X` 的某个项 `x` 所构成的单集 `｛ x ｝ : ℙ X` 定义为谓词 `x ≡_`. `X` 的集合性保证了 `x ≡_` 是一个谓词.

<pre class="Agda">  <a id="1724" class="Keyword">opaque</a>
    <a id="Lemmas.｛_｝"></a><a id="1735" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛_｝</a> <a id="1739" class="Symbol">:</a> <a id="1741" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="1743" class="Symbol">→</a> <a id="1745" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="1747" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a>
    <a id="1753" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="1755" href="CH%25E2%2586%2592LEM.html#1755" class="Bound">x</a> <a id="1757" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a> <a id="1759" href="CH%25E2%2586%2592LEM.html#1759" class="Bound">y</a> <a id="1761" class="Symbol">=</a> <a id="1763" class="Symbol">(</a><a id="1764" href="CH%25E2%2586%2592LEM.html#1755" class="Bound">x</a> <a id="1766" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1768" href="CH%25E2%2586%2592LEM.html#1759" class="Bound">y</a><a id="1769" class="Symbol">)</a> <a id="1771" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1773" href="Preliminary.html#9069" class="Function">transportIsProp</a> <a id="1789" class="Symbol">(</a><a id="1790" href="CH%25E2%2586%2592LEM.html#1609" class="Bound">X-set</a> <a id="1796" class="Symbol">_</a> <a id="1798" class="Symbol">_)</a>
</pre>
由 `_≡_` 的基本性质可以证明单集构造 `｛_｝` 具有单射性.

<pre class="Agda">    <a id="Lemmas.｛｝-inj"></a><a id="1854" href="CH%25E2%2586%2592LEM.html#1854" class="Function">｛｝-inj</a> <a id="1861" class="Symbol">:</a> <a id="1863" class="Symbol">{</a><a id="1864" href="CH%25E2%2586%2592LEM.html#1864" class="Bound">x</a> <a id="1866" href="CH%25E2%2586%2592LEM.html#1866" class="Bound">y</a> <a id="1868" class="Symbol">:</a> <a id="1870" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a><a id="1871" class="Symbol">}</a> <a id="1873" class="Symbol">→</a> <a id="1875" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="1877" href="CH%25E2%2586%2592LEM.html#1864" class="Bound">x</a> <a id="1879" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a> <a id="1881" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1883" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="1885" href="CH%25E2%2586%2592LEM.html#1866" class="Bound">y</a> <a id="1887" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a> <a id="1889" class="Symbol">→</a> <a id="1891" href="CH%25E2%2586%2592LEM.html#1864" class="Bound">x</a> <a id="1893" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1895" href="CH%25E2%2586%2592LEM.html#1866" class="Bound">y</a>
    <a id="1901" href="CH%25E2%2586%2592LEM.html#1854" class="Function">｛｝-inj</a> <a id="1908" class="Symbol">{</a><a id="1909" href="CH%25E2%2586%2592LEM.html#1909" class="Bound">x</a><a id="1910" class="Symbol">}</a> <a id="1912" class="Symbol">{</a><a id="1913" href="CH%25E2%2586%2592LEM.html#1913" class="Bound">y</a><a id="1914" class="Symbol">}</a> <a id="1916" href="CH%25E2%2586%2592LEM.html#1916" class="Bound">H</a> <a id="1918" class="Symbol">=</a> <a id="1920" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="1930" class="Symbol">(</a><a id="1931" href="Cubical.Foundations.Function.html#468" class="Function">idfun</a> <a id="1937" class="Symbol">_)</a> <a id="1940" class="Symbol">(</a><a id="1941" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="1945" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1947" href="Cubical.Data.Equality.Base.html#675" class="Function">ap</a> <a id="1950" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="1954" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="1956" href="Cubical.Data.Equality.Conversion.html#2697" class="Function">happly</a> <a id="1963" href="CH%25E2%2586%2592LEM.html#1916" class="Bound">H</a> <a id="1965" href="CH%25E2%2586%2592LEM.html#1913" class="Bound">y</a><a id="1966" class="Symbol">)</a> <a id="1968" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
我们说一个 `A : ℙ X` 是单集, 当且仅当它等于某个 `｛ x ｝`.

<pre class="Agda">  <a id="Lemmas.is｛｝"></a><a id="2029" href="CH%25E2%2586%2592LEM.html#2029" class="Function">is｛｝</a> <a id="2034" class="Symbol">:</a> <a id="2036" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2038" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="2040" class="Symbol">→</a> <a id="2042" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="2047" class="Symbol">_</a>
  <a id="2051" href="CH%25E2%2586%2592LEM.html#2029" class="Function">is｛｝</a> <a id="2056" href="CH%25E2%2586%2592LEM.html#2056" class="Bound">A</a> <a id="2058" class="Symbol">=</a> <a id="2060" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="2063" href="CH%25E2%2586%2592LEM.html#2063" class="Bound">x</a> <a id="2065" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="2067" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="2069" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="2071" href="CH%25E2%2586%2592LEM.html#2056" class="Bound">A</a> <a id="2073" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2075" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="2077" href="CH%25E2%2586%2592LEM.html#2063" class="Bound">x</a> <a id="2079" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a>
</pre>
注意尽管这里用的是Σ类型, 我们仍然能证明 "是单集" 是一个谓词, 因为见证 `A` 是单集的那个 `x` 唯一. 不过后面不需要用到这一结论.

<pre class="Agda">  <a id="Lemmas.isPropIs｛｝"></a><a id="2171" href="CH%25E2%2586%2592LEM.html#2171" class="Function">isPropIs｛｝</a> <a id="2182" class="Symbol">:</a> <a id="2184" class="Symbol">(</a><a id="2185" href="CH%25E2%2586%2592LEM.html#2185" class="Bound">A</a> <a id="2187" class="Symbol">:</a> <a id="2189" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2191" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a><a id="2192" class="Symbol">)</a> <a id="2194" class="Symbol">→</a> <a id="2196" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="2203" class="Symbol">(</a><a id="2204" href="CH%25E2%2586%2592LEM.html#2029" class="Function">is｛｝</a> <a id="2209" href="CH%25E2%2586%2592LEM.html#2185" class="Bound">A</a><a id="2210" class="Symbol">)</a>
  <a id="2214" href="CH%25E2%2586%2592LEM.html#2171" class="Function">isPropIs｛｝</a> <a id="2225" href="CH%25E2%2586%2592LEM.html#2225" class="Bound">A</a> <a id="2227" class="Symbol">(</a><a id="2228" href="CH%25E2%2586%2592LEM.html#2228" class="Bound">x₁</a> <a id="2231" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2233" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2237" class="Symbol">)</a> <a id="2239" class="Symbol">(</a><a id="2240" href="CH%25E2%2586%2592LEM.html#2240" class="Bound">x₂</a> <a id="2243" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2245" href="CH%25E2%2586%2592LEM.html#2245" class="Bound">eq</a><a id="2247" class="Symbol">)</a> <a id="2249" class="Symbol">=</a> <a id="2251" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="2260" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2262" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a>
    <a id="2273" class="Symbol">(λ</a> <a id="2276" href="CH%25E2%2586%2592LEM.html#2276" class="Bound">_</a> <a id="2278" class="Symbol">→</a> <a id="2280" href="Cubical.Data.Equality.Conversion.html#5222" class="Function">isPropPathToIsProp</a> <a id="2299" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2301" href="Preliminary.html#9069" class="Function">transportIsProp</a> <a id="2317" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2319" href="Cubical.Foundations.HLevels.html#17906" class="Function">isSetΠ</a> <a id="2326" class="Symbol">(λ</a> <a id="2329" href="CH%25E2%2586%2592LEM.html#2329" class="Bound">_</a> <a id="2331" class="Symbol">→</a> <a id="2333" href="Cubical.Foundations.HLevels.html#22223" class="Function">isSetHProp</a><a id="2343" class="Symbol">)</a> <a id="2345" class="Symbol">_</a> <a id="2347" class="Symbol">_)</a> <a id="2350" class="Symbol">(</a><a id="2351" href="CH%25E2%2586%2592LEM.html#1854" class="Function">｛｝-inj</a> <a id="2358" href="CH%25E2%2586%2592LEM.html#2245" class="Bound">eq</a><a id="2360" class="Symbol">)</a>
</pre>
接着我们证明康托尔定理的一个变体, 说 `ℙ X` 的自嵌入一定射到了单集之外. 我们能实际构造出这个非单集, 用的还是对角线法, 证明的结构与 `Cantor-≰` 非常类似, 这里不再赘述.

<pre class="Agda">  <a id="Lemmas.Cantor-beyond｛｝"></a><a id="2476" href="CH%25E2%2586%2592LEM.html#2476" class="Function">Cantor-beyond｛｝</a> <a id="2492" class="Symbol">:</a> <a id="2494" class="Symbol">(</a><a id="2495" href="CH%25E2%2586%2592LEM.html#2495" class="Bound">f</a> <a id="2497" class="Symbol">:</a> <a id="2499" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2501" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="2503" class="Symbol">→</a> <a id="2505" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2507" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a><a id="2508" class="Symbol">)</a> <a id="2510" class="Symbol">→</a> <a id="2512" href="Preliminary.html#12578" class="Function">injective</a> <a id="2522" href="CH%25E2%2586%2592LEM.html#2495" class="Bound">f</a> <a id="2524" class="Symbol">→</a> <a id="2526" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="2529" href="CH%25E2%2586%2592LEM.html#2529" class="Bound">A</a> <a id="2531" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="2533" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2535" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="2537" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="2539" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="2541" href="CH%25E2%2586%2592LEM.html#2029" class="Function">is｛｝</a> <a id="2546" class="Symbol">(</a><a id="2547" href="CH%25E2%2586%2592LEM.html#2495" class="Bound">f</a> <a id="2549" href="CH%25E2%2586%2592LEM.html#2529" class="Bound">A</a><a id="2550" class="Symbol">)</a>
  <a id="2554" href="CH%25E2%2586%2592LEM.html#2476" class="Function">Cantor-beyond｛｝</a> <a id="2570" href="CH%25E2%2586%2592LEM.html#2570" class="Bound">f</a> <a id="2572" href="CH%25E2%2586%2592LEM.html#2572" class="Bound">f-inj</a> <a id="2578" class="Symbol">=</a> <a id="2580" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2582" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2584" class="Symbol">λ</a> <a id="2586" class="Symbol">(</a><a id="2587" href="CH%25E2%2586%2592LEM.html#2587" class="Bound">x</a> <a id="2589" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2591" href="CH%25E2%2586%2592LEM.html#2591" class="Bound">fA≡</a><a id="2594" class="Symbol">)</a> <a id="2596" class="Symbol">→</a> <a id="2598" href="Preliminary.html#10718" class="Function">noncontradiction</a> <a id="2615" class="Symbol">(</a><a id="2616" href="CH%25E2%2586%2592LEM.html#2741" class="Function">∈→∉</a> <a id="2620" href="CH%25E2%2586%2592LEM.html#2587" class="Bound">x</a> <a id="2622" href="CH%25E2%2586%2592LEM.html#2591" class="Bound">fA≡</a><a id="2625" class="Symbol">)</a> <a id="2627" class="Symbol">(</a><a id="2628" href="CH%25E2%2586%2592LEM.html#2826" class="Function">∉→∈</a> <a id="2632" href="CH%25E2%2586%2592LEM.html#2587" class="Bound">x</a> <a id="2634" href="CH%25E2%2586%2592LEM.html#2591" class="Bound">fA≡</a><a id="2637" class="Symbol">)</a>
    <a id="2643" class="Keyword">where</a>
    <a id="2653" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2655" class="Symbol">:</a> <a id="2657" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="2659" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a>
    <a id="2665" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2667" href="CH%25E2%2586%2592LEM.html#2667" class="Bound">x</a> <a id="2669" class="Symbol">=</a> <a id="2671" href="Preliminary.html#10078" class="Field">Resize</a> <a id="2678" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2680" class="Symbol">(∀</a> <a id="2683" href="CH%25E2%2586%2592LEM.html#2683" class="Bound">B</a> <a id="2685" class="Symbol">→</a> <a id="2687" href="CH%25E2%2586%2592LEM.html#2570" class="Bound">f</a> <a id="2689" href="CH%25E2%2586%2592LEM.html#2683" class="Bound">B</a> <a id="2691" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2693" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="2695" href="CH%25E2%2586%2592LEM.html#2667" class="Bound">x</a> <a id="2697" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a> <a id="2699" class="Symbol">→</a> <a id="2701" href="CH%25E2%2586%2592LEM.html#2667" class="Bound">x</a> <a id="2703" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="2705" href="CH%25E2%2586%2592LEM.html#2683" class="Bound">B</a><a id="2706" class="Symbol">)</a> <a id="2708" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2710" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="2719" class="Symbol">λ</a> <a id="2721" href="CH%25E2%2586%2592LEM.html#2721" class="Bound">_</a> <a id="2723" href="CH%25E2%2586%2592LEM.html#2723" class="Bound">_</a> <a id="2725" href="CH%25E2%2586%2592LEM.html#2725" class="Bound">_</a> <a id="2727" class="Symbol">→</a> <a id="2729" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
    <a id="2741" href="CH%25E2%2586%2592LEM.html#2741" class="Function">∈→∉</a> <a id="2745" class="Symbol">:</a> <a id="2747" class="Symbol">∀</a> <a id="2749" href="CH%25E2%2586%2592LEM.html#2749" class="Bound">x</a> <a id="2751" class="Symbol">→</a> <a id="2753" class="Symbol">(</a><a id="2754" href="CH%25E2%2586%2592LEM.html#2570" class="Bound">f</a> <a id="2756" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2758" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2760" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="2762" href="CH%25E2%2586%2592LEM.html#2749" class="Bound">x</a> <a id="2764" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a><a id="2765" class="Symbol">)</a> <a id="2767" class="Symbol">→</a> <a id="2769" href="CH%25E2%2586%2592LEM.html#2749" class="Bound">x</a> <a id="2771" href="Cubical.Foundations.Powerset.html#772" class="Function Operator">∈</a> <a id="2773" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2775" class="Symbol">→</a> <a id="2777" href="CH%25E2%2586%2592LEM.html#2749" class="Bound">x</a> <a id="2779" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="2781" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a>
    <a id="2787" href="CH%25E2%2586%2592LEM.html#2741" class="Function">∈→∉</a> <a id="2791" href="CH%25E2%2586%2592LEM.html#2791" class="Bound">x</a> <a id="2793" href="CH%25E2%2586%2592LEM.html#2793" class="Bound">fA≡</a> <a id="2797" href="CH%25E2%2586%2592LEM.html#2797" class="Bound">x∈A</a> <a id="2801" class="Symbol">=</a> <a id="2803" href="Preliminary.html#10160" class="Field">unresize</a> <a id="2812" href="CH%25E2%2586%2592LEM.html#2797" class="Bound">x∈A</a> <a id="2816" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2818" href="CH%25E2%2586%2592LEM.html#2793" class="Bound">fA≡</a>
    <a id="2826" href="CH%25E2%2586%2592LEM.html#2826" class="Function">∉→∈</a> <a id="2830" class="Symbol">:</a> <a id="2832" class="Symbol">∀</a> <a id="2834" href="CH%25E2%2586%2592LEM.html#2834" class="Bound">x</a> <a id="2836" class="Symbol">→</a> <a id="2838" class="Symbol">(</a><a id="2839" href="CH%25E2%2586%2592LEM.html#2570" class="Bound">f</a> <a id="2841" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2843" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2845" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="2847" href="CH%25E2%2586%2592LEM.html#2834" class="Bound">x</a> <a id="2849" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a><a id="2850" class="Symbol">)</a> <a id="2852" class="Symbol">→</a> <a id="2854" href="CH%25E2%2586%2592LEM.html#2834" class="Bound">x</a> <a id="2856" href="Preliminary.html#9558" class="Function Operator">∉</a> <a id="2858" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a> <a id="2860" class="Symbol">→</a> <a id="2862" href="CH%25E2%2586%2592LEM.html#2834" class="Bound">x</a> <a id="2864" href="Cubical.Foundations.Powerset.html#772" class="Function Operator">∈</a> <a id="2866" href="CH%25E2%2586%2592LEM.html#2653" class="Function">A</a>
    <a id="2872" href="CH%25E2%2586%2592LEM.html#2826" class="Function">∉→∈</a> <a id="2876" href="CH%25E2%2586%2592LEM.html#2876" class="Bound">x</a> <a id="2878" href="CH%25E2%2586%2592LEM.html#2878" class="Bound">fA≡</a> <a id="2882" href="CH%25E2%2586%2592LEM.html#2882" class="Bound">x∉A</a> <a id="2886" class="Symbol">=</a> <a id="2888" href="Preliminary.html#10110" class="Field">resize</a> <a id="2895" class="Symbol">λ</a> <a id="2897" href="CH%25E2%2586%2592LEM.html#2897" class="Bound">B</a> <a id="2899" href="CH%25E2%2586%2592LEM.html#2899" class="Bound">fB≡</a> <a id="2903" class="Symbol">→</a> <a id="2905" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="2915" class="Symbol">(</a><a id="2916" href="CH%25E2%2586%2592LEM.html#2876" class="Bound">x</a> <a id="2918" href="Preliminary.html#9558" class="Function Operator">∉_</a><a id="2920" class="Symbol">)</a> <a id="2922" class="Symbol">(</a><a id="2923" href="CH%25E2%2586%2592LEM.html#2572" class="Bound">f-inj</a> <a id="2929" class="Symbol">(</a><a id="2930" href="CH%25E2%2586%2592LEM.html#2878" class="Bound">fA≡</a> <a id="2934" href="Cubical.Data.Equality.Base.html#754" class="Function Operator">∙</a> <a id="2936" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="2940" href="CH%25E2%2586%2592LEM.html#2899" class="Bound">fB≡</a><a id="2943" class="Symbol">))</a> <a id="2946" href="CH%25E2%2586%2592LEM.html#2882" class="Bound">x∉A</a>
</pre>
## 关键构造

现在, 在之前固定的集合 `X` 的基础上再固定一个类型 `P`. 这个 `P` 将对应于排中律所谈论的那个 `P`.

<pre class="Agda">  <a id="3035" class="Keyword">module</a> <a id="3042" href="CH%25E2%2586%2592LEM.html#3042" class="Module">_</a> <a id="3044" class="Symbol">(</a><a id="3045" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a> <a id="3047" class="Symbol">:</a> <a id="3049" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3054" href="Preliminary.html#2569" class="Generalizable">ℓ′</a><a id="3056" class="Symbol">)</a> <a id="3058" class="Keyword">where</a>
</pre>
接下来是一个关键构造. 我们构造类型 `Y`, 使得其项是 `X` 的满足以下**任一**条件的子集.

- 是单集
- `P` 可判定

<pre class="Agda">    <a id="3151" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="3153" class="Symbol">:</a> <a id="3155" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3160" class="Symbol">(</a><a id="3161" href="Agda.Primitive.html#931" class="Primitive">ℓ-suc</a> <a id="3167" href="CH%25E2%2586%2592LEM.html#1605" class="Bound">ℓ</a> <a id="3169" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="3171" href="CH%25E2%2586%2592LEM.html#3054" class="Bound">ℓ′</a><a id="3173" class="Symbol">)</a>
    <a id="3179" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="3181" class="Symbol">=</a> <a id="3183" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3186" href="CH%25E2%2586%2592LEM.html#3186" class="Bound">A</a> <a id="3188" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3190" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="3192" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="3194" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3196" class="Symbol">(</a><a id="3197" href="CH%25E2%2586%2592LEM.html#2029" class="Function">is｛｝</a> <a id="3202" href="CH%25E2%2586%2592LEM.html#3186" class="Bound">A</a> <a id="3204" href="Preliminary.html#11002" class="Function Operator">∨</a> <a id="3206" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a> <a id="3210" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a><a id="3211" class="Symbol">)</a>
</pre>
首先, 不难证明, `Y` 是一个集合. 因为它作为一个Σ类型, 左边是 `A` 的子集, 右边是一个谓词.

<pre class="Agda">    <a id="3286" href="CH%25E2%2586%2592LEM.html#3286" class="Function">isSetY</a> <a id="3293" class="Symbol">:</a> <a id="3295" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="3301" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a>
    <a id="3307" href="CH%25E2%2586%2592LEM.html#3286" class="Function">isSetY</a> <a id="3314" class="Symbol">=</a> <a id="3316" href="Cubical.Foundations.HLevels.html#12848" class="Function">isSetΣ</a> <a id="3323" href="Cubical.Foundations.Powerset.html#704" class="Function">isSetℙ</a> <a id="3330" class="Symbol">λ</a> <a id="3332" href="CH%25E2%2586%2592LEM.html#3332" class="Bound">_</a> <a id="3334" class="Symbol">→</a> <a id="3336" href="Cubical.Foundations.Prelude.html#18523" class="Function">isProp→isSet</a> <a id="3349" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
</pre>
接下来是3个显然的事实.

1. `X` 单射到 `Y`, 只需将 `x` 映射到 `｛ x ｝` 即可.

<pre class="Agda">    <a id="3429" href="CH%25E2%2586%2592LEM.html#3429" class="Function">X≤Y</a> <a id="3433" class="Symbol">:</a> <a id="3435" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="3437" href="Preliminary.html#12650" class="Function Operator">≤</a> <a id="3439" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a>
    <a id="3445" href="CH%25E2%2586%2592LEM.html#3429" class="Function">X≤Y</a> <a id="3449" class="Symbol">=</a> <a id="3451" class="Symbol">(λ</a> <a id="3454" href="CH%25E2%2586%2592LEM.html#3454" class="Bound">x</a> <a id="3456" class="Symbol">→</a> <a id="3458" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｛</a> <a id="3460" href="CH%25E2%2586%2592LEM.html#3454" class="Bound">x</a> <a id="3462" href="CH%25E2%2586%2592LEM.html#1735" class="Function Operator">｝</a> <a id="3464" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3466" href="Preliminary.html#11106" class="Function">inl</a> <a id="3470" class="Symbol">(</a><a id="3471" href="CH%25E2%2586%2592LEM.html#3454" class="Bound">x</a> <a id="3473" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3475" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="3479" class="Symbol">))</a> <a id="3482" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3484" href="CH%25E2%2586%2592LEM.html#1854" class="Function">｛｝-inj</a> <a id="3491" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="3493" class="Symbol">(</a><a id="3494" href="Cubical.Data.Equality.Base.html#675" class="Function">ap</a> <a id="3497" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a><a id="3500" class="Symbol">)</a>
</pre>
2. `Y` 单射到 `ℙ X`, 因为 `Y` 的项都是 `X` 的满足某些条件的子集.

<pre class="Agda">    <a id="3566" href="CH%25E2%2586%2592LEM.html#3566" class="Function">Y≤ℙX</a> <a id="3571" class="Symbol">:</a> <a id="3573" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="3575" href="Preliminary.html#12650" class="Function Operator">≤</a> <a id="3577" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="3579" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a>
    <a id="3585" href="CH%25E2%2586%2592LEM.html#3566" class="Function">Y≤ℙX</a> <a id="3590" class="Symbol">=</a> <a id="3592" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="3596" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3598" class="Symbol">λ</a> <a id="3600" href="CH%25E2%2586%2592LEM.html#3600" class="Bound">fst-eq</a> <a id="3607" class="Symbol">→</a> <a id="3609" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a> <a id="3616" class="Symbol">(λ</a> <a id="3619" href="CH%25E2%2586%2592LEM.html#3619" class="Bound">_</a> <a id="3621" class="Symbol">→</a> <a id="3623" href="Cubical.Data.Equality.PropositionalTruncation.html#592" class="Function">squash₁Eq</a><a id="3632" class="Symbol">)</a> <a id="3634" href="CH%25E2%2586%2592LEM.html#3600" class="Bound">fst-eq</a>
</pre>
3. 如果 `P` 可判定, 那么 `ℙ X` 单射到 `Y`, 因为这时 `X` 的所有子集都满足 `P` 可判定, 都会包括在 `Y` 里面.

<pre class="Agda">    <a id="3733" href="CH%25E2%2586%2592LEM.html#3733" class="Function">dec→ℙX≤Y</a> <a id="3742" class="Symbol">:</a> <a id="3744" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a> <a id="3748" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a> <a id="3750" class="Symbol">→</a> <a id="3752" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="3754" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="3756" href="Preliminary.html#12650" class="Function Operator">≤</a> <a id="3758" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a>
    <a id="3764" href="CH%25E2%2586%2592LEM.html#3733" class="Function">dec→ℙX≤Y</a> <a id="3773" href="CH%25E2%2586%2592LEM.html#3773" class="Bound">P-dec</a> <a id="3779" class="Symbol">=</a> <a id="3781" class="Symbol">(λ</a> <a id="3784" href="CH%25E2%2586%2592LEM.html#3784" class="Bound">A</a> <a id="3786" class="Symbol">→</a> <a id="3788" href="CH%25E2%2586%2592LEM.html#3784" class="Bound">A</a> <a id="3790" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3792" href="Preliminary.html#11144" class="Function">inr</a> <a id="3796" href="CH%25E2%2586%2592LEM.html#3773" class="Bound">P-dec</a><a id="3801" class="Symbol">)</a> <a id="3803" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3805" href="Cubical.Data.Equality.Base.html#675" class="Function">ap</a> <a id="3808" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a>
</pre>
**引理** 如果 `P` 是命题且 `ℙ X` 单射到 `Y`, 那么 `P` 可判定.  
**证明** 给定 `ℙ X` 到 `Y` 的单射 `f`, 这样 `fst ∘ f` 则是 `ℙ X` 到 `ℙ X` 的单射. 由康托尔定理的变体 `Cantor-beyond｛｝`, 我们可以拿到一个 `A : ℙ X` 满足 `f A : Y` 非单集, 那么由 `Y` 的定义, 只能有 `P` 可判定. ∎

<pre class="Agda">    <a id="4038" href="CH%25E2%2586%2592LEM.html#4038" class="Function">ℙX≤Y→dec</a> <a id="4047" class="Symbol">:</a> <a id="4049" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="4056" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a> <a id="4058" class="Symbol">→</a> <a id="4060" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="4062" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="4064" href="Preliminary.html#12650" class="Function Operator">≤</a> <a id="4066" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="4068" class="Symbol">→</a> <a id="4070" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a> <a id="4074" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a>
    <a id="4080" href="CH%25E2%2586%2592LEM.html#4038" class="Function">ℙX≤Y→dec</a> <a id="4089" href="CH%25E2%2586%2592LEM.html#4089" class="Bound">P-prop</a> <a id="4096" href="CH%25E2%2586%2592LEM.html#4096" class="Bound">ℙX≤Y</a> <a id="4101" class="Keyword">with</a> <a id="4106" href="CH%25E2%2586%2592LEM.html#4096" class="Bound">ℙX≤Y</a>
    <a id="4115" class="Symbol">...</a> <a id="4119" class="Symbol">|</a> <a id="4121" class="Symbol">(</a><a id="4122" href="CH%25E2%2586%2592LEM.html#4122" class="Bound">f</a> <a id="4124" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4126" href="CH%25E2%2586%2592LEM.html#4126" class="Bound">f-inj</a><a id="4131" class="Symbol">)</a> <a id="4133" class="Keyword">with</a> <a id="4138" href="CH%25E2%2586%2592LEM.html#2476" class="Function">Cantor-beyond｛｝</a> <a id="4154" class="Symbol">(</a><a id="4155" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="4159" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="4161" href="CH%25E2%2586%2592LEM.html#4122" class="Bound">f</a><a id="4162" class="Symbol">)</a> <a id="4164" class="Symbol">(</a><a id="4165" href="CH%25E2%2586%2592LEM.html#4126" class="Bound">f-inj</a> <a id="4171" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="4173" class="Symbol">(</a><a id="4174" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a> <a id="4181" class="Symbol">λ</a> <a id="4183" href="CH%25E2%2586%2592LEM.html#4183" class="Bound">_</a> <a id="4185" class="Symbol">→</a> <a id="4187" href="Cubical.Data.Equality.PropositionalTruncation.html#592" class="Function">squash₁Eq</a><a id="4196" class="Symbol">))</a>
    <a id="4203" class="Symbol">...</a> <a id="4207" class="Symbol">|</a> <a id="4209" class="Symbol">(</a><a id="4210" href="CH%25E2%2586%2592LEM.html#4210" class="Bound">A</a> <a id="4212" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4214" href="CH%25E2%2586%2592LEM.html#4214" class="Bound">¬sing</a><a id="4219" class="Symbol">)</a> <a id="4221" class="Keyword">with</a> <a id="4226" class="Bound">f</a> <a id="4228" href="CH%25E2%2586%2592LEM.html#4210" class="Bound">A</a>
    <a id="4234" class="Symbol">...</a> <a id="4238" class="Symbol">|</a> <a id="4240" class="Symbol">(</a><a id="4241" href="CH%25E2%2586%2592LEM.html#4241" class="Bound">fA</a> <a id="4244" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4246" href="CH%25E2%2586%2592LEM.html#4246" class="Bound">sing∨dec</a><a id="4254" class="Symbol">)</a> <a id="4256" class="Symbol">=</a> <a id="4258" href="Preliminary.html#7992" class="Function">∥∥-rec</a> <a id="4265" class="Symbol">(</a><a id="4266" href="Cubical.Relation.Nullary.Properties.html#1969" class="Function">isPropDec</a> <a id="4276" class="Bound">P-prop</a><a id="4282" class="Symbol">)</a>
      <a id="4290" class="Symbol">(λ</a> <a id="4293" class="Symbol">{</a> <a id="4295" class="Symbol">(</a><a id="4296" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">_⊎_.inl</a> <a id="4304" href="CH%25E2%2586%2592LEM.html#4304" class="Bound">sing</a><a id="4308" class="Symbol">)</a> <a id="4310" class="Symbol">→</a> <a id="4312" href="Cubical.Data.Empty.Base.html#187" class="Function">⊥-rec</a> <a id="4318" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4320" class="Bound">¬sing</a> <a id="4326" href="CH%25E2%2586%2592LEM.html#4304" class="Bound">sing</a>
          <a id="4341" class="Symbol">;</a> <a id="4343" class="Symbol">(</a><a id="4344" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">_⊎_.inr</a> <a id="4352" href="CH%25E2%2586%2592LEM.html#4352" class="Bound">dec</a><a id="4355" class="Symbol">)</a> <a id="4357" class="Symbol">→</a> <a id="4359" href="CH%25E2%2586%2592LEM.html#4352" class="Bound">dec</a> <a id="4363" class="Symbol">})</a>
      <a id="4372" href="CH%25E2%2586%2592LEM.html#4246" class="Bound">sing∨dec</a>
</pre>
这说明了当 `P` 是命题的时候, `Dec P` 与 `ℙ X ≤ Y` 逻辑等价. 因为 `P` 是任意给定的, 那么只要证明了用这个 `P` 构造的 `Y` 满足 `ℙ X ≤ Y`, 就证明了排中律.

此外, 由于 `X` 也是任意给定的, 我们令 `X = ℕ`, 那么 `ℙ ℕ ≤ Y` 正是 `CH` 所承诺的结论, 只要有 `X ≤ Y`, `Y ≰ X` 以及 `Y ≤ ℙ X`. 第一个和第三个在上面已证, 我们只差 `Y ≰ X`. 这是核心一步.

## 核心步骤

我们用上一条引理, 结合康托尔定理, 证明 `Y` 不能单射到 `X`.

**引理** `Y` 不能单射到 `X`.  
**证明** 用归谬法, 假设 `Y ≤ X`, 要推出矛盾. 由前置知识我们知道 `P` 的可判定性不可辩驳, 那么我们只要证明 `P` 不可判定就能得到矛盾. 再用归谬法, 假设 `P` 可判定, 要推出矛盾. 这时我们有前提 "`P` 可判定" 且 `Y ≤ X`. 由上一条引理, `P` 可判定意味着 `ℙ X ≤ Y`. 又 `Y ≤ X`, 由 `≤` 的传递性有 `P X ≤ X`, 与康托尔定理矛盾. ∎

<pre class="Agda">    <a id="4923" href="CH%25E2%2586%2592LEM.html#4923" class="Function">Y≰X</a> <a id="4927" class="Symbol">:</a> <a id="4929" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="4931" href="Preliminary.html#12711" class="Function Operator">≰</a> <a id="4933" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a>
    <a id="4939" href="CH%25E2%2586%2592LEM.html#4923" class="Function">Y≰X</a> <a id="4943" href="CH%25E2%2586%2592LEM.html#4943" class="Bound">Y≤X</a><a id="4946" class="Symbol">@(</a><a id="4948" href="CH%25E2%2586%2592LEM.html#4948" class="Bound">f</a> <a id="4950" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4952" href="CH%25E2%2586%2592LEM.html#4952" class="Bound">f-inj</a><a id="4957" class="Symbol">)</a> <a id="4959" class="Symbol">=</a> <a id="4961" href="Preliminary.html#11832" class="Function">DecNonEmpty</a> <a id="4973" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a> <a id="4975" class="Symbol">λ</a> <a id="4977" href="CH%25E2%2586%2592LEM.html#4977" class="Bound">P-dec</a> <a id="4983" class="Symbol">→</a> <a id="4985" href="CH%25E2%2586%2592LEM.html#545" class="Function">Cantor-≰</a> <a id="4994" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="4996" class="Symbol">(</a><a id="4997" href="Preliminary.html#12834" class="Function">≤-trans</a> <a id="5005" class="Symbol">(</a><a id="5006" href="CH%25E2%2586%2592LEM.html#3733" class="Function">dec→ℙX≤Y</a> <a id="5015" href="CH%25E2%2586%2592LEM.html#4977" class="Bound">P-dec</a><a id="5020" class="Symbol">)</a> <a id="5022" href="CH%25E2%2586%2592LEM.html#4943" class="Bound">Y≤X</a><a id="5025" class="Symbol">)</a>
</pre>
有了这个引理, 接下来的两条引理就是自明的了. 只是要注意命题截断的一些技术细节. `CH` 将给我们 `≤` 的命题截断, 由于最终目标 `Dec P` 也是命题, 可以用 `∥∥-rec` 消掉这个截断.

<pre class="Agda">    <a id="5150" href="CH%25E2%2586%2592LEM.html#5150" class="Function">isCHType→ℙX≤Y</a> <a id="5164" class="Symbol">:</a> <a id="5166" href="Preliminary.html#13187" class="Function">isCHType</a> <a id="5175" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="5177" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="5179" class="Symbol">→</a> <a id="5181" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="5183" href="Cubical.Foundations.Powerset.html#657" class="Function">ℙ</a> <a id="5185" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="5187" href="Preliminary.html#12650" class="Function Operator">≤</a> <a id="5189" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="5191" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
    <a id="5198" href="CH%25E2%2586%2592LEM.html#5150" class="Function">isCHType→ℙX≤Y</a> <a id="5212" href="CH%25E2%2586%2592LEM.html#5212" class="Bound">ch-type</a> <a id="5220" class="Symbol">=</a> <a id="5222" href="CH%25E2%2586%2592LEM.html#5212" class="Bound">ch-type</a> <a id="5230" class="Symbol">(</a><a id="5231" href="CH%25E2%2586%2592LEM.html#3429" class="Function">X≤Y</a> <a id="5235" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5237" href="CH%25E2%2586%2592LEM.html#4923" class="Function">Y≰X</a><a id="5240" class="Symbol">)</a> <a id="5242" href="CH%25E2%2586%2592LEM.html#3566" class="Function">Y≤ℙX</a>

    <a id="5252" href="CH%25E2%2586%2592LEM.html#5252" class="Function">isCHType→lem</a> <a id="5265" class="Symbol">:</a> <a id="5267" href="Preliminary.html#13187" class="Function">isCHType</a> <a id="5276" href="CH%25E2%2586%2592LEM.html#1596" class="Bound">X</a> <a id="5278" href="CH%25E2%2586%2592LEM.html#3151" class="Function">Y</a> <a id="5280" class="Symbol">→</a> <a id="5282" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5289" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a> <a id="5291" class="Symbol">→</a> <a id="5293" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a> <a id="5297" href="CH%25E2%2586%2592LEM.html#3045" class="Bound">P</a>
    <a id="5303" href="CH%25E2%2586%2592LEM.html#5252" class="Function">isCHType→lem</a> <a id="5316" href="CH%25E2%2586%2592LEM.html#5316" class="Bound">ch-type</a> <a id="5324" href="CH%25E2%2586%2592LEM.html#5324" class="Bound">P-prop</a> <a id="5331" class="Symbol">=</a> <a id="5333" href="Preliminary.html#7992" class="Function">∥∥-rec</a> <a id="5340" class="Symbol">(</a><a id="5341" href="Cubical.Relation.Nullary.Properties.html#1969" class="Function">isPropDec</a> <a id="5351" href="CH%25E2%2586%2592LEM.html#5324" class="Bound">P-prop</a><a id="5357" class="Symbol">)</a> <a id="5359" class="Symbol">(</a><a id="5360" href="CH%25E2%2586%2592LEM.html#4038" class="Function">ℙX≤Y→dec</a> <a id="5369" href="CH%25E2%2586%2592LEM.html#5324" class="Bound">P-prop</a><a id="5375" class="Symbol">)</a> <a id="5377" class="Symbol">(</a><a id="5378" href="CH%25E2%2586%2592LEM.html#5150" class="Function">isCHType→ℙX≤Y</a> <a id="5392" href="CH%25E2%2586%2592LEM.html#5316" class="Bound">ch-type</a><a id="5399" class="Symbol">)</a>
</pre>
## 结论

**定理** 如果 `CH` 在任意宇宙成立, 那么 `LEM` 在任意宇宙成立.  
**证明** 要证任意命题 `P` 可判定. 令 `Y` 为满足以下**任一**条件的自然数子集所组成的集合:

- 是单集
- `P` 可判定

由前几小节的讨论可知 `Y` 满足 `CH` 的前提 `ℕ < Y ≤ ℙ ℕ`, 于是可以得到 `CH` 所承诺的 `ℙ ℕ` 到 `Y` 的单射. 但是由康托尔定理的一个变体, `ℙ ℕ` 必然要单射到非单集的子集, 所以 `Y` 并不只有单集, 所以只能有 `P` 可判定. ∎

<pre class="Agda"><a id="CH→LEM"></a><a id="5683" href="CH%25E2%2586%2592LEM.html#5683" class="Function">CH→LEM</a> <a id="5690" class="Symbol">:</a> <a id="5692" class="Symbol">(∀</a> <a id="5695" href="CH%25E2%2586%2592LEM.html#5695" class="Bound">ℓ</a> <a id="5697" class="Symbol">→</a> <a id="5699" href="Preliminary.html#13271" class="Function">CH</a> <a id="5702" href="CH%25E2%2586%2592LEM.html#5695" class="Bound">ℓ</a><a id="5703" class="Symbol">)</a> <a id="5705" class="Symbol">→</a> <a id="5707" class="Symbol">(∀</a> <a id="5710" href="CH%25E2%2586%2592LEM.html#5710" class="Bound">ℓ</a> <a id="5712" class="Symbol">→</a> <a id="5714" href="Preliminary.html#11568" class="Function">LEM</a> <a id="5718" href="CH%25E2%2586%2592LEM.html#5710" class="Bound">ℓ</a><a id="5719" class="Symbol">)</a>
<a id="5721" href="CH%25E2%2586%2592LEM.html#5683" class="Function">CH→LEM</a> <a id="5728" href="CH%25E2%2586%2592LEM.html#5728" class="Bound">ch</a> <a id="5731" href="CH%25E2%2586%2592LEM.html#5731" class="Bound">ℓ</a> <a id="5733" href="CH%25E2%2586%2592LEM.html#5733" class="Bound">P</a> <a id="5735" class="Symbol">=</a> <a id="5737" href="CH%25E2%2586%2592LEM.html#5252" class="Function">isCHType→lem</a> <a id="5750" class="Symbol">_</a> <a id="5752" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5754" href="CH%25E2%2586%2592LEM.html#5728" class="Bound">ch</a> <a id="5757" class="Symbol">_</a> <a id="5759" class="Symbol">_</a> <a id="5761" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5763" href="CH%25E2%2586%2592LEM.html#3286" class="Function">isSetY</a> <a id="5770" class="Symbol">_</a>
  <a id="5774" class="Keyword">where</a> <a id="5780" class="Keyword">open</a> <a id="5785" href="CH%25E2%2586%2592LEM.html#1588" class="Module">Lemmas</a> <a id="5792" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5794" href="Cubical.Data.Nat.Properties.html#3705" class="Function">isSetℕ</a>
</pre>