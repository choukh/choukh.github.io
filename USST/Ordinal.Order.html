<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>泛等结构集合论 (4) 序数的序</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">泛等结构集合论 (4) 序数的序</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#泛等结构集合论-4-序数的序" id="toc-泛等结构集合论-4-序数的序">泛等结构集合论 (4) 序数的序</a>
  <ul>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a>
  <ul>
  <li><a href="#单射性" id="toc-单射性">单射性</a></li>
  <li><a href="#命题性" id="toc-命题性">命题性</a></li>
  <li><a href="#唯一性" id="toc-唯一性">唯一性</a></li>
  </ul></li>
  <li><a href="#非严格序" id="toc-非严格序">非严格序</a>
  <ul>
  <li><a href="#性质" id="toc-性质">性质</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="泛等结构集合论-4-序数的序">泛等结构集合论 (4) 序数的序</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/USST/blob/main/src/Ordinal/Order.lagda.md">Ordinal.Order.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/USST/Ordinal.Order.html">Ordinal.Order.html</a></p>
</blockquote>
<pre class="Agda"><a id="353" class="Symbol">{-#</a> <a id="357" class="Keyword">OPTIONS</a> <a id="365" class="Pragma">--cubical</a> <a id="375" class="Pragma">--safe</a> <a id="382" class="Symbol">#-}</a>
<a id="386" class="Symbol">{-#</a> <a id="390" class="Keyword">OPTIONS</a> <a id="398" class="Pragma">--lossy-unification</a> <a id="418" class="Pragma">--hidden-argument-puns</a> <a id="441" class="Symbol">#-}</a>
<a id="445" class="Keyword">module</a> <a id="452" href="Ordinal.Order.html" class="Module">Ordinal.Order</a> <a id="466" class="Keyword">where</a>
<a id="472" class="Keyword">open</a> <a id="477" class="Keyword">import</a> <a id="484" href="Preliminary.html" class="Module">Preliminary</a>
<a id="496" class="Keyword">open</a> <a id="501" class="Keyword">import</a> <a id="508" href="Ordinal.Base.html" class="Module">Ordinal.Base</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们说序数底集间的一个映射是序数嵌入, 当且仅当它保序, 且它的像能形成一个前段.</p>
<pre class="Agda"><a id="586" class="Keyword">record</a> <a id="IsOrdEmbed"></a><a id="593" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="604" class="Symbol">{</a><a id="605" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="607" class="Symbol">:</a> <a id="609" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="613" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="614" class="Symbol">}</a> <a id="616" class="Symbol">{</a><a id="617" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="619" class="Symbol">:</a> <a id="621" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="625" href="Preliminary.html#2694" class="Generalizable">𝓋</a><a id="626" class="Symbol">}</a> <a id="628" class="Symbol">(</a><a id="629" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="631" class="Symbol">:</a> <a id="633" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="635" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="637" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="639" class="Symbol">→</a> <a id="641" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="643" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="645" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="646" class="Symbol">)</a> <a id="648" class="Symbol">:</a> <a id="650" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="655" class="Symbol">(</a><a id="656" href="Ordinal.Order.html#613" class="Bound">𝓊</a> <a id="658" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="660" href="Ordinal.Order.html#625" class="Bound">𝓋</a><a id="661" class="Symbol">)</a> <a id="663" class="Keyword">where</a>
  <a id="671" class="Keyword">constructor</a> <a id="mkIsOrdEmbed"></a><a id="683" href="Ordinal.Order.html#683" class="InductiveConstructor">mkIsOrdEmbed</a>
</pre>
<p>保序性 <code>pres≺</code> 很简单, 它就是上一章序等价 <code>hPres≺</code> 的弱化版. “形成前段” <code>formsInitSeg</code> 这一性质的直观可以参考下图. 它说只要一个底集元素被射到, 那么比它小的元素都会被射到, 也就是映射的像能形成 <code>≺</code> 的一个前段.</p>
<pre class="string"><code>... a   ... ≺₁ ... a′  ...  
    |              |  
  f |            f |  
    ↓              ↓  
... f a ... ≺₂ ... f a′ ...  </code></pre>
<pre class="Agda">  <a id="987" class="Keyword">field</a>
    <a id="IsOrdEmbed.pres≺"></a><a id="997" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="1003" class="Symbol">:</a> <a id="1005" class="Symbol">∀</a> <a id="1007" href="Ordinal.Order.html#1007" class="Bound">a</a> <a id="1009" href="Ordinal.Order.html#1009" class="Bound">a′</a> <a id="1012" class="Symbol">→</a> <a id="1014" href="Ordinal.Order.html#1007" class="Bound">a</a> <a id="1016" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1019" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1021" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1023" href="Ordinal.Order.html#1009" class="Bound">a′</a> <a id="1026" class="Symbol">→</a> <a id="1028" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1030" href="Ordinal.Order.html#1007" class="Bound">a</a> <a id="1032" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1035" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="1037" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1039" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1041" href="Ordinal.Order.html#1009" class="Bound">a′</a>
    <a id="IsOrdEmbed.formsInitSeg"></a><a id="1048" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="1061" class="Symbol">:</a> <a id="1063" class="Symbol">∀</a> <a id="1065" href="Ordinal.Order.html#1065" class="Bound">b</a> <a id="1067" href="Ordinal.Order.html#1067" class="Bound">a′</a> <a id="1070" class="Symbol">→</a> <a id="1072" href="Ordinal.Order.html#1065" class="Bound">b</a> <a id="1074" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1077" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="1079" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1081" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1083" href="Ordinal.Order.html#1067" class="Bound">a′</a> <a id="1086" class="Symbol">→</a> <a id="1088" href="Preliminary.html#5407" class="Function">Σ</a> <a id="1090" href="Ordinal.Order.html#1090" class="Bound">a</a> <a id="1092" href="Preliminary.html#5407" class="Function">∶</a> <a id="1094" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="1096" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1098" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="1100" href="Preliminary.html#5407" class="Function">,</a> <a id="1102" href="Ordinal.Order.html#1090" class="Bound">a</a> <a id="1104" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1107" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1109" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1111" href="Ordinal.Order.html#1067" class="Bound">a′</a> <a id="1114" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="1116" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1118" href="Ordinal.Order.html#1090" class="Bound">a</a> <a id="1120" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1122" href="Ordinal.Order.html#1065" class="Bound">b</a>
</pre>
<h3 id="单射性">单射性</h3>
<p><strong>引理</strong> 序数嵌入是单射.<br />
<strong>证明</strong> 用双参数形式的良基归纳法 <code>elim2</code>, 拿到归纳假设 <code>IH : ∀ u v → u ≺ x → v ≺ y → f u ≡ f v → u ≡ v</code>, 要证 <code>f x ≡ f y → x ≡ y</code>. 用 <code>≺</code> 的外延性, 要证两种对称的情况 <code>p</code> 和 <code>q</code>, 我们只证 <code>p : ∀ z → z ≺ x → z ≺ y</code>. 由 <code>z ≺ x</code> 及嵌入的保序性有 <code>f z ≺ f x ≡ f y</code>. 由于嵌入能形成前段, 必有一个 <code>w</code> 满足 <code>w ≺ y</code> 且 <code>f w ≡ f z</code>. 再结合归纳假设有 <code>w ≡ z</code>, 改写目标即证 <code>w ≺ y</code>, 此乃前提. ∎</p>
<pre class="Agda">  <a id="IsOrdEmbed.inj"></a><a id="1468" href="Ordinal.Order.html#1468" class="Function">inj</a> <a id="1472" class="Symbol">:</a> <a id="1474" href="Preliminary.html#10154" class="Function">injective</a> <a id="1484" href="Ordinal.Order.html#629" class="Bound">f</a>
  <a id="1488" href="Ordinal.Order.html#1468" class="Function">inj</a> <a id="1492" class="Symbol">=</a> <a id="1494" href="Ordinal.Base.html#6289" class="Function">elim2</a> <a id="1500" href="Ordinal.Order.html#1568" class="Function">aux</a> <a id="1504" class="Symbol">_</a> <a id="1506" class="Symbol">_</a>
    <a id="1512" class="Keyword">where</a>
    <a id="1522" class="Keyword">open</a> <a id="1527" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="1534" class="Symbol">(</a><a id="1535" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="1539" href="Ordinal.Order.html#605" class="Bound">α</a><a id="1540" class="Symbol">)</a> <a id="1542" class="Keyword">using</a> <a id="1548" class="Symbol">(</a><a id="1549" href="Ordinal.Base.html#4730" class="Function">≺-ext</a><a id="1554" class="Symbol">;</a> <a id="1556" href="Ordinal.Base.html#6289" class="Function">elim2</a><a id="1561" class="Symbol">)</a>

    <a id="1568" href="Ordinal.Order.html#1568" class="Function">aux</a> <a id="1572" class="Symbol">:</a> <a id="1574" class="Symbol">∀</a> <a id="1576" href="Ordinal.Order.html#1576" class="Bound">x</a> <a id="1578" href="Ordinal.Order.html#1578" class="Bound">y</a> <a id="1580" class="Symbol">→</a> <a id="1582" class="Symbol">(∀</a> <a id="1585" href="Ordinal.Order.html#1585" class="Bound">u</a> <a id="1587" href="Ordinal.Order.html#1587" class="Bound">v</a> <a id="1589" class="Symbol">→</a> <a id="1591" href="Ordinal.Order.html#1585" class="Bound">u</a> <a id="1593" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1596" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1598" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1600" href="Ordinal.Order.html#1576" class="Bound">x</a> <a id="1602" class="Symbol">→</a> <a id="1604" href="Ordinal.Order.html#1587" class="Bound">v</a> <a id="1606" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1609" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1611" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1613" href="Ordinal.Order.html#1578" class="Bound">y</a> <a id="1615" class="Symbol">→</a> <a id="1617" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1619" href="Ordinal.Order.html#1585" class="Bound">u</a> <a id="1621" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1623" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1625" href="Ordinal.Order.html#1587" class="Bound">v</a> <a id="1627" class="Symbol">→</a> <a id="1629" href="Ordinal.Order.html#1585" class="Bound">u</a> <a id="1631" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1633" href="Ordinal.Order.html#1587" class="Bound">v</a><a id="1634" class="Symbol">)</a> <a id="1636" class="Symbol">→</a> <a id="1638" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1640" href="Ordinal.Order.html#1576" class="Bound">x</a> <a id="1642" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1644" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1646" href="Ordinal.Order.html#1578" class="Bound">y</a> <a id="1648" class="Symbol">→</a> <a id="1650" href="Ordinal.Order.html#1576" class="Bound">x</a> <a id="1652" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1654" href="Ordinal.Order.html#1578" class="Bound">y</a>
    <a id="1660" href="Ordinal.Order.html#1568" class="Function">aux</a> <a id="1664" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="1666" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="1668" href="Ordinal.Order.html#1668" class="Bound">IH</a> <a id="1671" href="Ordinal.Order.html#1671" class="Bound">fx≡fy</a> <a id="1677" class="Symbol">=</a> <a id="1679" href="Ordinal.Base.html#4730" class="Function">≺-ext</a> <a id="1685" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="1687" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="1689" class="Symbol">λ</a> <a id="1691" href="Ordinal.Order.html#1691" class="Bound">z</a> <a id="1693" class="Symbol">→</a> <a id="1695" href="Ordinal.Order.html#1723" class="Function">p</a> <a id="1697" href="Ordinal.Order.html#1691" class="Bound">z</a> <a id="1699" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1701" href="Ordinal.Order.html#2156" class="Function">q</a> <a id="1703" href="Ordinal.Order.html#1691" class="Bound">z</a>
      <a id="1711" class="Keyword">where</a>
      <a id="1723" href="Ordinal.Order.html#1723" class="Function">p</a> <a id="1725" class="Symbol">:</a> <a id="1727" class="Symbol">∀</a> <a id="1729" href="Ordinal.Order.html#1729" class="Bound">z</a> <a id="1731" class="Symbol">→</a> <a id="1733" href="Ordinal.Order.html#1729" class="Bound">z</a> <a id="1735" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1738" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1740" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1742" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="1744" class="Symbol">→</a> <a id="1746" href="Ordinal.Order.html#1729" class="Bound">z</a> <a id="1748" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1751" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1753" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1755" href="Ordinal.Order.html#1666" class="Bound">y</a>
      <a id="1763" href="Ordinal.Order.html#1723" class="Function">p</a> <a id="1765" href="Ordinal.Order.html#1765" class="Bound">z</a> <a id="1767" href="Ordinal.Order.html#1767" class="Bound">z≺x</a> <a id="1771" class="Symbol">=</a> <a id="1773" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="1779" class="Symbol">(λ</a> <a id="1782" href="Ordinal.Order.html#1782" class="Bound">-</a> <a id="1784" class="Symbol">→</a> <a id="1786" href="Ordinal.Order.html#1782" class="Bound">-</a> <a id="1788" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1791" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1793" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1795" href="Ordinal.Order.html#1666" class="Bound">y</a><a id="1796" class="Symbol">)</a> <a id="1798" href="Ordinal.Order.html#2091" class="Function">w≡z</a> <a id="1802" href="Ordinal.Order.html#2035" class="Function">w≺y</a>
        <a id="1814" class="Keyword">where</a>
        <a id="1828" href="Ordinal.Order.html#1828" class="Function">fz≺fy</a> <a id="1834" class="Symbol">:</a> <a id="1836" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1838" href="Ordinal.Order.html#1765" class="Bound">z</a> <a id="1840" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1843" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="1845" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1847" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1849" href="Ordinal.Order.html#1666" class="Bound">y</a>
        <a id="1859" href="Ordinal.Order.html#1828" class="Function">fz≺fy</a> <a id="1865" class="Symbol">=</a> <a id="1867" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="1873" class="Symbol">(λ</a> <a id="1876" href="Ordinal.Order.html#1876" class="Bound">-</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1882" href="Ordinal.Order.html#1765" class="Bound">z</a> <a id="1884" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1887" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="1889" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1891" href="Ordinal.Order.html#1876" class="Bound">-</a><a id="1892" class="Symbol">)</a> <a id="1894" href="Ordinal.Order.html#1671" class="Bound">fx≡fy</a> <a id="1900" class="Symbol">(</a><a id="1901" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="1907" href="Ordinal.Order.html#1765" class="Bound">z</a> <a id="1909" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="1911" href="Ordinal.Order.html#1767" class="Bound">z≺x</a><a id="1914" class="Symbol">)</a>
        <a id="1924" href="Ordinal.Order.html#1924" class="Function">Σw</a> <a id="1927" class="Symbol">:</a> <a id="1929" href="Preliminary.html#5407" class="Function">Σ</a> <a id="1931" href="Ordinal.Order.html#1931" class="Bound">w</a> <a id="1933" href="Preliminary.html#5407" class="Function">∶</a> <a id="1935" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="1937" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1939" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="1941" href="Preliminary.html#5407" class="Function">,</a> <a id="1943" class="Symbol">(</a><a id="1944" href="Ordinal.Order.html#1931" class="Bound">w</a> <a id="1946" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="1949" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="1951" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="1953" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="1955" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="1957" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1959" href="Ordinal.Order.html#1931" class="Bound">w</a> <a id="1961" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1963" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1965" href="Ordinal.Order.html#1765" class="Bound">z</a><a id="1966" class="Symbol">)</a>
        <a id="1976" href="Ordinal.Order.html#1924" class="Function">Σw</a> <a id="1979" class="Symbol">=</a> <a id="1981" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="1994" class="Symbol">(</a><a id="1995" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="1997" href="Ordinal.Order.html#1765" class="Bound">z</a><a id="1998" class="Symbol">)</a> <a id="2000" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="2002" href="Ordinal.Order.html#1828" class="Function">fz≺fy</a>
        <a id="2016" href="Ordinal.Order.html#2016" class="Function">w</a> <a id="2018" class="Symbol">=</a> <a id="2020" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2024" href="Ordinal.Order.html#1924" class="Function">Σw</a>
        <a id="2035" href="Ordinal.Order.html#2035" class="Function">w≺y</a> <a id="2039" class="Symbol">=</a> <a id="2041" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2045" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2047" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2051" href="Ordinal.Order.html#1924" class="Function">Σw</a>
        <a id="2062" href="Ordinal.Order.html#2062" class="Function">fw≡fz</a> <a id="2068" class="Symbol">=</a> <a id="2070" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2074" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2076" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2080" href="Ordinal.Order.html#1924" class="Function">Σw</a>
        <a id="2091" href="Ordinal.Order.html#2091" class="Function">w≡z</a> <a id="2095" class="Symbol">:</a> <a id="2097" href="Ordinal.Order.html#2016" class="Function">w</a> <a id="2099" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2101" href="Ordinal.Order.html#1765" class="Bound">z</a>
        <a id="2111" href="Ordinal.Order.html#2091" class="Function">w≡z</a> <a id="2115" class="Symbol">=</a> <a id="2117" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="2121" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2123" href="Ordinal.Order.html#1668" class="Bound">IH</a> <a id="2126" href="Ordinal.Order.html#1765" class="Bound">z</a> <a id="2128" href="Ordinal.Order.html#2016" class="Function">w</a> <a id="2130" href="Ordinal.Order.html#1767" class="Bound">z≺x</a> <a id="2134" href="Ordinal.Order.html#2035" class="Function">w≺y</a> <a id="2138" class="Symbol">(</a><a id="2139" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="2143" href="Ordinal.Order.html#2062" class="Function">fw≡fz</a><a id="2148" class="Symbol">)</a>
      <a id="2156" href="Ordinal.Order.html#2156" class="Function">q</a> <a id="2158" class="Symbol">:</a> <a id="2160" class="Symbol">∀</a> <a id="2162" href="Ordinal.Order.html#2162" class="Bound">z</a> <a id="2164" class="Symbol">→</a> <a id="2166" href="Ordinal.Order.html#2162" class="Bound">z</a> <a id="2168" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2171" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2173" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2175" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="2177" class="Symbol">→</a> <a id="2179" href="Ordinal.Order.html#2162" class="Bound">z</a> <a id="2181" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2184" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2186" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2188" href="Ordinal.Order.html#1664" class="Bound">x</a>
      <a id="2196" href="Ordinal.Order.html#2156" class="Function">q</a> <a id="2198" href="Ordinal.Order.html#2198" class="Bound">z</a> <a id="2200" href="Ordinal.Order.html#2200" class="Bound">z≺y</a> <a id="2204" class="Symbol">=</a> <a id="2206" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="2212" class="Symbol">(λ</a> <a id="2215" href="Ordinal.Order.html#2215" class="Bound">-</a> <a id="2217" class="Symbol">→</a> <a id="2219" href="Ordinal.Order.html#2215" class="Bound">-</a> <a id="2221" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2224" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2226" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2228" href="Ordinal.Order.html#1664" class="Bound">x</a><a id="2229" class="Symbol">)</a> <a id="2231" href="Ordinal.Order.html#2530" class="Function">w≡z</a> <a id="2235" href="Ordinal.Order.html#2474" class="Function">w≺x</a>
        <a id="2247" class="Keyword">where</a>
        <a id="2261" href="Ordinal.Order.html#2261" class="Function">fz≺fx</a> <a id="2267" class="Symbol">:</a> <a id="2269" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2271" href="Ordinal.Order.html#2198" class="Bound">z</a> <a id="2273" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2276" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="2278" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2280" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2282" href="Ordinal.Order.html#1664" class="Bound">x</a>
        <a id="2292" href="Ordinal.Order.html#2261" class="Function">fz≺fx</a> <a id="2298" class="Symbol">=</a> <a id="2300" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="2306" class="Symbol">(λ</a> <a id="2309" href="Ordinal.Order.html#2309" class="Bound">-</a> <a id="2311" class="Symbol">→</a> <a id="2313" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2315" href="Ordinal.Order.html#2198" class="Bound">z</a> <a id="2317" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2320" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="2322" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2324" href="Ordinal.Order.html#2309" class="Bound">-</a><a id="2325" class="Symbol">)</a> <a id="2327" class="Symbol">(</a><a id="2328" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="2332" href="Ordinal.Order.html#1671" class="Bound">fx≡fy</a><a id="2337" class="Symbol">)</a> <a id="2339" class="Symbol">(</a><a id="2340" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="2346" href="Ordinal.Order.html#2198" class="Bound">z</a> <a id="2348" href="Ordinal.Order.html#1666" class="Bound">y</a> <a id="2350" href="Ordinal.Order.html#2200" class="Bound">z≺y</a><a id="2353" class="Symbol">)</a>
        <a id="2363" href="Ordinal.Order.html#2363" class="Function">Σw</a> <a id="2366" class="Symbol">:</a> <a id="2368" href="Preliminary.html#5407" class="Function">Σ</a> <a id="2370" href="Ordinal.Order.html#2370" class="Bound">w</a> <a id="2372" href="Preliminary.html#5407" class="Function">∶</a> <a id="2374" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2376" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2378" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="2380" href="Preliminary.html#5407" class="Function">,</a> <a id="2382" class="Symbol">(</a><a id="2383" href="Ordinal.Order.html#2370" class="Bound">w</a> <a id="2385" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2388" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2390" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2392" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="2394" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="2396" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2398" href="Ordinal.Order.html#2370" class="Bound">w</a> <a id="2400" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2402" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2404" href="Ordinal.Order.html#2198" class="Bound">z</a><a id="2405" class="Symbol">)</a>
        <a id="2415" href="Ordinal.Order.html#2363" class="Function">Σw</a> <a id="2418" class="Symbol">=</a> <a id="2420" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="2433" class="Symbol">(</a><a id="2434" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2436" href="Ordinal.Order.html#2198" class="Bound">z</a><a id="2437" class="Symbol">)</a> <a id="2439" href="Ordinal.Order.html#1664" class="Bound">x</a> <a id="2441" href="Ordinal.Order.html#2261" class="Function">fz≺fx</a>
        <a id="2455" href="Ordinal.Order.html#2455" class="Function">w</a> <a id="2457" class="Symbol">=</a> <a id="2459" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2463" href="Ordinal.Order.html#2363" class="Function">Σw</a>
        <a id="2474" href="Ordinal.Order.html#2474" class="Function">w≺x</a> <a id="2478" class="Symbol">=</a> <a id="2480" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2484" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2486" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2490" href="Ordinal.Order.html#2363" class="Function">Σw</a>
        <a id="2501" href="Ordinal.Order.html#2501" class="Function">fw≡fz</a> <a id="2507" class="Symbol">=</a> <a id="2509" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2513" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2515" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2519" href="Ordinal.Order.html#2363" class="Function">Σw</a>
        <a id="2530" href="Ordinal.Order.html#2530" class="Function">w≡z</a> <a id="2534" class="Symbol">:</a> <a id="2536" href="Ordinal.Order.html#2455" class="Function">w</a> <a id="2538" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2540" href="Ordinal.Order.html#2198" class="Bound">z</a>
        <a id="2550" href="Ordinal.Order.html#2530" class="Function">w≡z</a> <a id="2554" class="Symbol">=</a> <a id="2556" href="Ordinal.Order.html#1668" class="Bound">IH</a> <a id="2559" href="Ordinal.Order.html#2455" class="Function">w</a> <a id="2561" href="Ordinal.Order.html#2198" class="Bound">z</a> <a id="2563" href="Ordinal.Order.html#2474" class="Function">w≺x</a> <a id="2567" href="Ordinal.Order.html#2200" class="Bound">z≺y</a> <a id="2571" href="Ordinal.Order.html#2501" class="Function">fw≡fz</a>
</pre>
<h3 id="命题性">命题性</h3>
<p>易证保序性是命题.</p>
<pre class="Agda">  <a id="IsOrdEmbed.isPropPres≺"></a><a id="2612" href="Ordinal.Order.html#2612" class="Function">isPropPres≺</a> <a id="2624" class="Symbol">:</a> <a id="2626" class="Symbol">∀</a> <a id="2628" href="Ordinal.Order.html#2628" class="Bound">a</a> <a id="2630" href="Ordinal.Order.html#2630" class="Bound">a′</a> <a id="2633" class="Symbol">→</a> <a id="2635" href="Ordinal.Order.html#2628" class="Bound">a</a> <a id="2637" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2640" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2642" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2644" href="Ordinal.Order.html#2630" class="Bound">a′</a> <a id="2647" class="Symbol">→</a> <a id="2649" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="2656" class="Symbol">(</a><a id="2657" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2659" href="Ordinal.Order.html#2628" class="Bound">a</a> <a id="2661" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2664" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="2666" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2668" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2670" href="Ordinal.Order.html#2630" class="Bound">a′</a><a id="2672" class="Symbol">)</a>
  <a id="2676" href="Ordinal.Order.html#2612" class="Function">isPropPres≺</a> <a id="2688" class="Symbol">_</a> <a id="2690" class="Symbol">_</a> <a id="2692" class="Symbol">_</a> <a id="2694" class="Symbol">=</a> <a id="2696" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="2703" class="Symbol">_</a> <a id="2705" class="Symbol">_</a>
    <a id="2711" class="Keyword">where</a> <a id="2717" class="Keyword">open</a> <a id="2722" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="2729" class="Symbol">(</a><a id="2730" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="2734" href="Ordinal.Order.html#617" class="Bound">β</a><a id="2735" class="Symbol">)</a> <a id="2737" class="Keyword">using</a> <a id="2743" class="Symbol">(</a><a id="2744" href="Ordinal.Base.html#4669" class="Function">≺-prop</a><a id="2750" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> “形成前段”是命题, 尽管没有截断.<br />
<strong>证明</strong> 由于前段性是命题, 只需证 <code>b</code> 对应的 <code>α</code> 前段唯一. 假设有两个这样的前段, 分别有端点 <code>x</code> 和 <code>y</code> 被 <code>f</code> 射到 <code>b</code>, 由嵌入的单射性 <code>x ≡ y</code>. ∎</p>
<pre class="Agda">  <a id="IsOrdEmbed.isPropFormsInitSeg"></a><a id="2896" href="Ordinal.Order.html#2896" class="Function">isPropFormsInitSeg</a> <a id="2915" class="Symbol">:</a> <a id="2917" class="Symbol">∀</a> <a id="2919" href="Ordinal.Order.html#2919" class="Bound">b</a> <a id="2921" href="Ordinal.Order.html#2921" class="Bound">a′</a> <a id="2924" class="Symbol">→</a> <a id="2926" href="Ordinal.Order.html#2919" class="Bound">b</a> <a id="2928" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2931" href="Ordinal.Order.html#617" class="Bound">β</a> <a id="2933" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2935" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2937" href="Ordinal.Order.html#2921" class="Bound">a′</a> <a id="2940" class="Symbol">→</a> <a id="2942" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="2949" class="Symbol">(</a><a id="2950" href="Preliminary.html#5407" class="Function">Σ</a> <a id="2952" href="Ordinal.Order.html#2952" class="Bound">a</a> <a id="2954" href="Preliminary.html#5407" class="Function">∶</a> <a id="2956" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2958" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2960" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="2962" href="Preliminary.html#5407" class="Function">,</a> <a id="2964" class="Symbol">(</a><a id="2965" href="Ordinal.Order.html#2952" class="Bound">a</a> <a id="2967" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="2970" href="Ordinal.Order.html#605" class="Bound">α</a> <a id="2972" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="2974" href="Ordinal.Order.html#2921" class="Bound">a′</a><a id="2976" class="Symbol">)</a> <a id="2978" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="2980" class="Symbol">(</a><a id="2981" href="Ordinal.Order.html#629" class="Bound">f</a> <a id="2983" href="Ordinal.Order.html#2952" class="Bound">a</a> <a id="2985" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2987" href="Ordinal.Order.html#2919" class="Bound">b</a><a id="2988" class="Symbol">))</a>
  <a id="2993" href="Ordinal.Order.html#2896" class="Function">isPropFormsInitSeg</a> <a id="3012" href="Ordinal.Order.html#3012" class="Bound">b</a> <a id="3014" href="Ordinal.Order.html#3014" class="Bound">a′</a> <a id="3017" href="Ordinal.Order.html#3017" class="Bound">b≺fa′</a> <a id="3023" class="Symbol">(</a><a id="3024" href="Ordinal.Order.html#3024" class="Bound">x</a> <a id="3026" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3028" href="Ordinal.Order.html#3028" class="Bound">x≺a′</a> <a id="3033" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3035" href="Ordinal.Order.html#3035" class="Bound">fx≡b</a><a id="3039" class="Symbol">)</a> <a id="3041" class="Symbol">(</a><a id="3042" href="Ordinal.Order.html#3042" class="Bound">y</a> <a id="3044" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3046" href="Ordinal.Order.html#3046" class="Bound">y≺a′</a> <a id="3051" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3053" href="Ordinal.Order.html#3053" class="Bound">fy≡b</a><a id="3057" class="Symbol">)</a> <a id="3059" class="Symbol">=</a> <a id="3061" href="Preliminary.html#9778" class="Function">Σ≡Prop</a>
    <a id="3072" class="Symbol">(λ</a> <a id="3075" href="Ordinal.Order.html#3075" class="Bound">_</a> <a id="3077" class="Symbol">→</a> <a id="3079" href="Cubical.Foundations.HLevels.html#13315" class="Function">isProp×</a> <a id="3087" class="Symbol">(</a><a id="3088" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="3095" class="Symbol">_</a> <a id="3097" class="Symbol">_)</a> <a id="3100" class="Symbol">(</a><a id="3101" href="Ordinal.Base.html#5123" class="Function">underlying-set</a> <a id="3116" class="Symbol">_</a> <a id="3118" class="Symbol">_))</a>
    <a id="3126" class="Symbol">(</a><a id="3127" href="Ordinal.Order.html#1468" class="Function">inj</a> <a id="3131" class="Symbol">(</a><a id="3132" href="Ordinal.Order.html#3035" class="Bound">fx≡b</a> <a id="3137" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="3139" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="3143" href="Ordinal.Order.html#3053" class="Bound">fy≡b</a><a id="3147" class="Symbol">))</a>
    <a id="3154" class="Keyword">where</a>
    <a id="3164" class="Keyword">open</a> <a id="3169" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="3176" class="Symbol">(</a><a id="3177" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="3181" href="Ordinal.Order.html#605" class="Bound">α</a><a id="3182" class="Symbol">)</a> <a id="3184" class="Keyword">using</a> <a id="3190" class="Symbol">(</a><a id="3191" href="Ordinal.Base.html#4669" class="Function">≺-prop</a><a id="3197" class="Symbol">)</a>
    <a id="3203" class="Keyword">open</a> <a id="3208" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="3215" class="Symbol">(</a><a id="3216" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="3220" href="Ordinal.Order.html#617" class="Bound">β</a><a id="3221" class="Symbol">)</a> <a id="3223" class="Keyword">using</a> <a id="3229" class="Symbol">(</a><a id="3230" href="Ordinal.Base.html#5123" class="Function">underlying-set</a><a id="3244" class="Symbol">)</a>
</pre>
<p>于是嵌入性是命题.</p>
<pre class="Agda"><a id="isPropIsOrdEmbed"></a><a id="3270" href="Ordinal.Order.html#3270" class="Function">isPropIsOrdEmbed</a> <a id="3287" class="Symbol">:</a> <a id="3289" class="Symbol">{</a><a id="3290" href="Ordinal.Order.html#3290" class="Bound">α</a> <a id="3292" class="Symbol">:</a> <a id="3294" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="3298" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="3299" class="Symbol">}</a> <a id="3301" class="Symbol">{</a><a id="3302" href="Ordinal.Order.html#3302" class="Bound">β</a> <a id="3304" class="Symbol">:</a> <a id="3306" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="3310" href="Preliminary.html#2694" class="Generalizable">𝓋</a><a id="3311" class="Symbol">}</a> <a id="3313" class="Symbol">(</a><a id="3314" href="Ordinal.Order.html#3314" class="Bound">f</a> <a id="3316" class="Symbol">:</a> <a id="3318" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3320" href="Ordinal.Order.html#3290" class="Bound">α</a> <a id="3322" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="3324" class="Symbol">→</a> <a id="3326" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3328" href="Ordinal.Order.html#3302" class="Bound">β</a> <a id="3330" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="3331" class="Symbol">)</a> <a id="3333" class="Symbol">→</a> <a id="3335" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3342" class="Symbol">(</a><a id="3343" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="3354" href="Ordinal.Order.html#3314" class="Bound">f</a><a id="3355" class="Symbol">)</a>
<a id="3357" href="Ordinal.Order.html#3270" class="Function">isPropIsOrdEmbed</a> <a id="3374" class="Symbol">{</a><a id="3375" href="Ordinal.Order.html#3375" class="Bound">α</a><a id="3376" class="Symbol">}</a> <a id="3378" class="Symbol">{</a><a id="3379" href="Ordinal.Order.html#3379" class="Bound">β</a><a id="3380" class="Symbol">}</a> <a id="3382" href="Ordinal.Order.html#3382" class="Bound">f</a> <a id="3384" class="Symbol">=</a> <a id="3386" href="Cubical.Foundations.HLevels.html#8859" class="Function">isOfHLevelRetractFromIso</a> <a id="3411" class="Number">1</a> <a id="3413" href="Ordinal.Order.html#3456" class="Function">IsOrdEmbedIsoΣ</a> <a id="3428" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3430" href="Ordinal.Order.html#3527" class="Function">aux</a>
  <a id="3436" class="Keyword">where</a>
  <a id="3444" class="Keyword">unquoteDecl</a> <a id="3456" href="Ordinal.Order.html#3456" class="Function">IsOrdEmbedIsoΣ</a> <a id="3471" class="Symbol">=</a> <a id="3473" href="Cubical.Reflection.RecordEquiv.html#9804" class="Function">declareRecordIsoΣ</a> <a id="3491" href="Ordinal.Order.html#3456" class="Function">IsOrdEmbedIsoΣ</a> <a id="3506" class="Symbol">(</a><a id="3507" class="Keyword">quote</a> <a id="3513" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a><a id="3523" class="Symbol">)</a>
  <a id="3527" href="Ordinal.Order.html#3527" class="Function">aux</a> <a id="3531" class="Symbol">:</a> <a id="3533" class="Symbol">∀</a> <a id="3535" href="Ordinal.Order.html#3535" class="Bound">x</a> <a id="3537" href="Ordinal.Order.html#3537" class="Bound">y</a> <a id="3539" class="Symbol">→</a> <a id="3541" href="Ordinal.Order.html#3535" class="Bound">x</a> <a id="3543" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3545" href="Ordinal.Order.html#3537" class="Bound">y</a>
  <a id="3549" href="Ordinal.Order.html#3527" class="Function">aux</a> <a id="3553" href="Ordinal.Order.html#3553" class="Bound">x</a> <a id="3555" class="Symbol">_</a> <a id="3557" class="Symbol">=</a> <a id="3559" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="3566" class="Symbol">(</a><a id="3567" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="3576" href="Ordinal.Order.html#2612" class="Function">isPropPres≺</a> <a id="3588" class="Symbol">_</a> <a id="3590" class="Symbol">_</a> <a id="3592" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3594" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="3603" href="Ordinal.Order.html#2896" class="Function">isPropFormsInitSeg</a> <a id="3622" class="Symbol">_</a> <a id="3624" class="Symbol">_)</a>
    <a id="3631" class="Keyword">where</a> <a id="3637" class="Keyword">open</a> <a id="3642" href="Ordinal.Order.html#593" class="Module">IsOrdEmbed</a> <a id="3653" class="Symbol">{</a><a id="3654" class="Argument">α</a> <a id="3656" class="Symbol">=</a> <a id="3658" href="Ordinal.Order.html#3375" class="Bound">α</a><a id="3659" class="Symbol">}</a> <a id="3661" class="Symbol">{</a><a id="3662" href="Ordinal.Order.html#3379" class="Bound">β</a><a id="3663" class="Symbol">}</a> <a id="3665" class="Symbol">(</a><a id="3666" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a> <a id="3674" href="Ordinal.Order.html#3456" class="Function">IsOrdEmbedIsoΣ</a> <a id="3689" href="Ordinal.Order.html#3553" class="Bound">x</a><a id="3690" class="Symbol">)</a>
</pre>
<h3 id="唯一性">唯一性</h3>
<p><strong>引理</strong> 给定两个序数, 它们之间的嵌入唯一.<br />
<strong>证明</strong> 用函数的外延性以及底序的外延性, 使用与嵌入的单射性的证明类似的改写即证. ∎</p>
<pre class="Agda"><a id="ordEmbed-unique"></a><a id="3786" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="3802" class="Symbol">:</a> <a id="3804" class="Symbol">{</a><a id="3805" href="Ordinal.Order.html#3805" class="Bound">α</a> <a id="3807" class="Symbol">:</a> <a id="3809" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="3813" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="3814" class="Symbol">}</a> <a id="3816" class="Symbol">{</a><a id="3817" href="Ordinal.Order.html#3817" class="Bound">β</a> <a id="3819" class="Symbol">:</a> <a id="3821" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="3825" href="Preliminary.html#2698" class="Generalizable">𝓊′</a><a id="3827" class="Symbol">}</a>
  <a id="3831" class="Symbol">(</a><a id="3832" href="Ordinal.Order.html#3832" class="Bound">f</a> <a id="3834" href="Ordinal.Order.html#3834" class="Bound">g</a> <a id="3836" class="Symbol">:</a> <a id="3838" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3840" href="Ordinal.Order.html#3805" class="Bound">α</a> <a id="3842" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="3844" class="Symbol">→</a> <a id="3846" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3848" href="Ordinal.Order.html#3817" class="Bound">β</a> <a id="3850" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="3851" class="Symbol">)</a> <a id="3853" class="Symbol">→</a> <a id="3855" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="3866" href="Ordinal.Order.html#3832" class="Bound">f</a> <a id="3868" class="Symbol">→</a> <a id="3870" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="3881" href="Ordinal.Order.html#3834" class="Bound">g</a> <a id="3883" class="Symbol">→</a> <a id="3885" href="Ordinal.Order.html#3832" class="Bound">f</a> <a id="3887" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3889" href="Ordinal.Order.html#3834" class="Bound">g</a>
<a id="3891" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="3907" class="Symbol">{</a><a id="3908" href="Ordinal.Order.html#3908" class="Bound">α</a><a id="3909" class="Symbol">}</a> <a id="3911" class="Symbol">{</a><a id="3912" href="Ordinal.Order.html#3912" class="Bound">β</a><a id="3913" class="Symbol">}</a> <a id="3915" href="Ordinal.Order.html#3915" class="Bound">f</a> <a id="3917" href="Ordinal.Order.html#3917" class="Bound">g</a> <a id="3919" href="Ordinal.Order.html#3919" class="Bound">f-emb</a> <a id="3925" href="Ordinal.Order.html#3925" class="Bound">g-emb</a> <a id="3931" class="Symbol">=</a>
  <a id="3935" href="Cubical.Foundations.Prelude.html#9928" class="Function">funExt</a> <a id="3942" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3944" href="Ordinal.Base.html#6188" class="Function">elim</a> <a id="3949" class="Symbol">λ</a> <a id="3951" href="Ordinal.Order.html#3951" class="Bound">x</a> <a id="3953" href="Ordinal.Order.html#3953" class="Bound">IH</a> <a id="3956" class="Symbol">→</a> <a id="3958" href="Ordinal.Base.html#4730" class="Function">≺-ext</a> <a id="3964" class="Symbol">(</a><a id="3965" href="Ordinal.Order.html#3915" class="Bound">f</a> <a id="3967" href="Ordinal.Order.html#3951" class="Bound">x</a><a id="3968" class="Symbol">)</a> <a id="3970" class="Symbol">(</a><a id="3971" href="Ordinal.Order.html#3917" class="Bound">g</a> <a id="3973" href="Ordinal.Order.html#3951" class="Bound">x</a><a id="3974" class="Symbol">)</a> <a id="3976" class="Symbol">λ</a> <a id="3978" href="Ordinal.Order.html#3978" class="Bound">z</a> <a id="3980" class="Symbol">→</a>
    <a id="3986" class="Symbol">(λ</a> <a id="3989" href="Ordinal.Order.html#3989" class="Bound">z≺fx</a> <a id="3994" class="Symbol">→</a> <a id="3996" class="Keyword">let</a> <a id="4000" class="Symbol">(</a><a id="4001" href="Ordinal.Order.html#4001" class="Bound">a</a> <a id="4003" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4005" href="Ordinal.Order.html#4005" class="Bound">a≺x</a> <a id="4009" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4011" href="Ordinal.Order.html#4011" class="Bound">fa≡z</a><a id="4015" class="Symbol">)</a> <a id="4017" class="Symbol">=</a> <a id="4019" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="4032" href="Ordinal.Order.html#3919" class="Bound">f-emb</a> <a id="4038" href="Ordinal.Order.html#3978" class="Bound">z</a> <a id="4040" href="Ordinal.Order.html#3951" class="Bound">x</a> <a id="4042" href="Ordinal.Order.html#3989" class="Bound">z≺fx</a> <a id="4047" class="Keyword">in</a>
      <a id="4056" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="4062" class="Symbol">(</a><a id="4063" href="Ordinal.Base.html#6076" class="Function Operator">_≺</a> <a id="4066" href="Ordinal.Order.html#3917" class="Bound">g</a> <a id="4068" href="Ordinal.Order.html#3951" class="Bound">x</a><a id="4069" class="Symbol">)</a> <a id="4071" class="Symbol">(</a><a id="4072" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="4076" class="Symbol">(</a><a id="4077" href="Ordinal.Order.html#3953" class="Bound">IH</a> <a id="4080" href="Ordinal.Order.html#4001" class="Bound">a</a> <a id="4082" href="Ordinal.Order.html#4005" class="Bound">a≺x</a><a id="4085" class="Symbol">)</a> <a id="4087" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="4089" href="Ordinal.Order.html#4011" class="Bound">fa≡z</a><a id="4093" class="Symbol">)</a> <a id="4095" class="Symbol">(</a><a id="4096" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="4102" href="Ordinal.Order.html#3925" class="Bound">g-emb</a> <a id="4108" href="Ordinal.Order.html#4001" class="Bound">a</a> <a id="4110" href="Ordinal.Order.html#3951" class="Bound">x</a> <a id="4112" href="Ordinal.Order.html#4005" class="Bound">a≺x</a><a id="4115" class="Symbol">))</a>
  <a id="4120" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4122" class="Symbol">(λ</a> <a id="4125" href="Ordinal.Order.html#4125" class="Bound">z≺gx</a> <a id="4130" class="Symbol">→</a> <a id="4132" class="Keyword">let</a> <a id="4136" class="Symbol">(</a><a id="4137" href="Ordinal.Order.html#4137" class="Bound">a</a> <a id="4139" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4141" href="Ordinal.Order.html#4141" class="Bound">a≺x</a> <a id="4145" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4147" href="Ordinal.Order.html#4147" class="Bound">ga≡z</a><a id="4151" class="Symbol">)</a> <a id="4153" class="Symbol">=</a> <a id="4155" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="4168" href="Ordinal.Order.html#3925" class="Bound">g-emb</a> <a id="4174" href="Ordinal.Order.html#3978" class="Bound">z</a> <a id="4176" href="Ordinal.Order.html#3951" class="Bound">x</a> <a id="4178" href="Ordinal.Order.html#4125" class="Bound">z≺gx</a> <a id="4183" class="Keyword">in</a>
      <a id="4192" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="4198" class="Symbol">(</a><a id="4199" href="Ordinal.Base.html#6076" class="Function Operator">_≺</a> <a id="4202" href="Ordinal.Order.html#3915" class="Bound">f</a> <a id="4204" href="Ordinal.Order.html#3951" class="Bound">x</a><a id="4205" class="Symbol">)</a> <a id="4207" class="Symbol">(</a><a id="4208" href="Ordinal.Order.html#3953" class="Bound">IH</a> <a id="4211" href="Ordinal.Order.html#4137" class="Bound">a</a> <a id="4213" href="Ordinal.Order.html#4141" class="Bound">a≺x</a> <a id="4217" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="4219" href="Ordinal.Order.html#4147" class="Bound">ga≡z</a><a id="4223" class="Symbol">)</a> <a id="4225" class="Symbol">(</a><a id="4226" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="4232" href="Ordinal.Order.html#3919" class="Bound">f-emb</a> <a id="4238" href="Ordinal.Order.html#4137" class="Bound">a</a> <a id="4240" href="Ordinal.Order.html#3951" class="Bound">x</a> <a id="4242" href="Ordinal.Order.html#4141" class="Bound">a≺x</a><a id="4245" class="Symbol">))</a>
  <a id="4250" class="Keyword">where</a> <a id="4256" class="Keyword">open</a> <a id="4261" href="Ordinal.Order.html#593" class="Module">IsOrdEmbed</a>
        <a id="4280" class="Keyword">open</a> <a id="4285" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="4292" class="Symbol">(</a><a id="4293" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4297" href="Ordinal.Order.html#3908" class="Bound">α</a><a id="4298" class="Symbol">)</a> <a id="4300" class="Keyword">using</a> <a id="4306" class="Symbol">(</a><a id="4307" href="Ordinal.Base.html#6188" class="Function">elim</a><a id="4311" class="Symbol">)</a>
        <a id="4321" class="Keyword">open</a> <a id="4326" href="Ordinal.Base.html#5980" class="Module">OrdStr</a> <a id="4333" class="Symbol">(</a><a id="4334" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4338" href="Ordinal.Order.html#3912" class="Bound">β</a><a id="4339" class="Symbol">)</a> <a id="4341" class="Keyword">using</a> <a id="4347" class="Symbol">(</a><a id="4348" href="Ordinal.Base.html#4730" class="Function">≺-ext</a><a id="4353" class="Symbol">;</a> <a id="4355" href="Ordinal.Base.html#6076" class="Field Operator">_≺_</a><a id="4358" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 序数等价也是一个序数嵌入.<br />
<strong>证明</strong> 要证序数等价的底层函数 <code>f</code> 保序且形成前段. 保序性即 <code>hPres≺</code> 的底层函数. 对任意 <code>b ≺ f a′</code>, 有 <code>f (f⁻¹ b) ≡ b</code>, 改写可得 <code>f (f⁻¹ b) ≺ f a′</code>, 再用 <code>hPres≺⁻¹</code> 即得 <code>(f⁻¹ b) ≺ a′</code>. 于是 <code>f⁻¹ b</code> 就是”形成前段”条件所要求的 <code>a</code>. ∎</p>
<pre class="Agda"><a id="IsOrdEquiv→IsOrdEmbed"></a><a id="4576" href="Ordinal.Order.html#4576" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="4598" class="Symbol">:</a> <a id="4600" class="Symbol">(</a><a id="4601" href="Ordinal.Order.html#4601" class="Bound">f</a> <a id="4603" class="Symbol">:</a> <a id="4605" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4607" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="4609" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="4611" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="4613" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4615" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="4617" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="4618" class="Symbol">)</a> <a id="4620" class="Symbol">→</a> <a id="4622" href="Ordinal.Base.html#7845" class="Record">IsOrdEquiv</a> <a id="4633" class="Symbol">(</a><a id="4634" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4638" href="Ordinal.Base.html#6623" class="Generalizable">α</a><a id="4639" class="Symbol">)</a> <a id="4641" href="Ordinal.Order.html#4601" class="Bound">f</a> <a id="4643" class="Symbol">(</a><a id="4644" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4648" href="Ordinal.Base.html#6625" class="Generalizable">β</a><a id="4649" class="Symbol">)</a> <a id="4651" class="Symbol">→</a> <a id="4653" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a> <a id="4664" class="Symbol">(</a><a id="4665" href="Ordinal.Order.html#4601" class="Bound">f</a> <a id="4667" href="Preliminary.html#11018" class="Function Operator">⁺¹</a><a id="4669" class="Symbol">)</a>
<a id="4671" href="Ordinal.Order.html#4576" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="4693" class="Symbol">{</a><a id="4694" href="Ordinal.Order.html#4694" class="Bound">β</a><a id="4695" class="Symbol">}</a> <a id="4697" href="Ordinal.Order.html#4697" class="Bound">f</a> <a id="4699" href="Ordinal.Order.html#4699" class="Bound">ordEquiv</a> <a id="4708" class="Symbol">=</a> <a id="4710" href="Ordinal.Order.html#683" class="InductiveConstructor">mkIsOrdEmbed</a>
  <a id="4725" class="Symbol">(λ</a> <a id="4728" href="Ordinal.Order.html#4728" class="Bound">a</a> <a id="4730" href="Ordinal.Order.html#4730" class="Bound">a′</a> <a id="4733" class="Symbol">→</a> <a id="4735" href="Ordinal.Base.html#8007" class="Field">hPres≺</a> <a id="4742" href="Ordinal.Order.html#4728" class="Bound">a</a> <a id="4744" href="Ordinal.Order.html#4730" class="Bound">a′</a> <a id="4747" href="Preliminary.html#11018" class="Function Operator">⁺¹</a><a id="4749" class="Symbol">)</a>
  <a id="4753" class="Symbol">(λ</a> <a id="4756" href="Ordinal.Order.html#4756" class="Bound">b</a> <a id="4758" href="Ordinal.Order.html#4758" class="Bound">a′</a> <a id="4761" href="Ordinal.Order.html#4761" class="Bound">b≺fa′</a> <a id="4767" class="Symbol">→</a> <a id="4769" class="Symbol">(</a><a id="4770" href="Ordinal.Order.html#4697" class="Bound">f</a> <a id="4772" href="Preliminary.html#11049" class="Function Operator">⁻¹</a><a id="4774" class="Symbol">)</a> <a id="4776" href="Ordinal.Order.html#4756" class="Bound">b</a>
    <a id="4782" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4784" class="Symbol">(</a><a id="4785" href="Ordinal.Base.html#8007" class="Field">hPres≺</a> <a id="4792" class="Symbol">_</a> <a id="4794" href="Ordinal.Order.html#4758" class="Bound">a′</a> <a id="4797" href="Preliminary.html#11049" class="Function Operator">⁻¹</a><a id="4799" class="Symbol">)</a> <a id="4801" class="Symbol">(</a><a id="4802" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="4808" class="Symbol">(λ</a> <a id="4811" href="Ordinal.Order.html#4811" class="Bound">-</a> <a id="4813" class="Symbol">→</a> <a id="4815" href="Ordinal.Order.html#4811" class="Bound">-</a> <a id="4817" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="4820" href="Ordinal.Order.html#4694" class="Bound">β</a> <a id="4822" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="4824" class="Symbol">_)</a> <a id="4827" class="Symbol">(</a><a id="4828" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="4832" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4834" href="Cubical.Foundations.Equiv.html#2289" class="Function">secIsEq</a> <a id="4842" class="Symbol">(</a><a id="4843" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="4847" href="Ordinal.Order.html#4697" class="Bound">f</a><a id="4848" class="Symbol">)</a> <a id="4850" href="Ordinal.Order.html#4756" class="Bound">b</a><a id="4851" class="Symbol">)</a> <a id="4853" href="Ordinal.Order.html#4761" class="Bound">b≺fa′</a><a id="4858" class="Symbol">)</a>
    <a id="4864" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4866" href="Cubical.Foundations.Equiv.html#2289" class="Function">secIsEq</a> <a id="4874" class="Symbol">(</a><a id="4875" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="4879" href="Ordinal.Order.html#4697" class="Bound">f</a><a id="4880" class="Symbol">)</a> <a id="4882" href="Ordinal.Order.html#4756" class="Bound">b</a><a id="4883" class="Symbol">)</a>
  <a id="4887" class="Keyword">where</a> <a id="4893" class="Keyword">open</a> <a id="4898" href="Ordinal.Base.html#7845" class="Module">IsOrdEquiv</a> <a id="4909" href="Ordinal.Order.html#4699" class="Bound">ordEquiv</a>
</pre>
<p><strong>引理</strong> 给定两个序数, 它们之间的序数等价唯一.<br />
<strong>证明</strong> 由于”是序数等价”是命题, 只需证该等价的底层函数唯一. 又序数等价也是序数嵌入, 由序数嵌入的唯一性得证. ∎</p>
<pre class="Agda"><a id="isPropOrdEquiv"></a><a id="5026" href="Ordinal.Order.html#5026" class="Function">isPropOrdEquiv</a> <a id="5041" class="Symbol">:</a> <a id="5043" class="Symbol">(</a><a id="5044" href="Ordinal.Order.html#5044" class="Bound">α</a> <a id="5046" class="Symbol">:</a> <a id="5048" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5052" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="5053" class="Symbol">)</a> <a id="5055" class="Symbol">(</a><a id="5056" href="Ordinal.Order.html#5056" class="Bound">β</a> <a id="5058" class="Symbol">:</a> <a id="5060" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5064" href="Preliminary.html#2698" class="Generalizable">𝓊′</a><a id="5066" class="Symbol">)</a> <a id="5068" class="Symbol">→</a> <a id="5070" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5077" class="Symbol">(</a><a id="5078" href="Ordinal.Order.html#5044" class="Bound">α</a> <a id="5080" href="Ordinal.Base.html#8510" class="Function Operator">≃ₒ</a> <a id="5083" href="Ordinal.Order.html#5056" class="Bound">β</a><a id="5084" class="Symbol">)</a>
<a id="5086" href="Ordinal.Order.html#5026" class="Function">isPropOrdEquiv</a> <a id="5101" href="Ordinal.Order.html#5101" class="Bound">α</a> <a id="5103" href="Ordinal.Order.html#5103" class="Bound">β</a> <a id="5105" class="Symbol">(</a><a id="5106" href="Ordinal.Order.html#5106" class="Bound">f</a> <a id="5108" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5110" href="Ordinal.Order.html#5110" class="Bound">f-ordEquiv</a><a id="5120" class="Symbol">)</a> <a id="5122" class="Symbol">(</a><a id="5123" href="Ordinal.Order.html#5123" class="Bound">g</a> <a id="5125" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5127" href="Ordinal.Order.html#5127" class="Bound">g-ordEquiv</a><a id="5137" class="Symbol">)</a> <a id="5139" class="Symbol">=</a> <a id="5141" href="Preliminary.html#9778" class="Function">Σ≡Prop</a>
  <a id="5150" class="Symbol">(λ</a> <a id="5153" href="Ordinal.Order.html#5153" class="Bound">_</a> <a id="5155" class="Symbol">→</a> <a id="5157" href="Ordinal.Base.html#8119" class="Function">isPropIsOrdEquiv</a> <a id="5174" class="Symbol">_</a> <a id="5176" class="Symbol">_</a> <a id="5178" class="Symbol">_)</a>
  <a id="5183" class="Symbol">(</a><a id="5184" href="Cubical.Foundations.Equiv.html#1981" class="Function">equivEq</a> <a id="5192" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5194" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="5210" class="Symbol">(</a><a id="5211" href="Ordinal.Order.html#5106" class="Bound">f</a> <a id="5213" href="Preliminary.html#11018" class="Function Operator">⁺¹</a><a id="5215" class="Symbol">)</a> <a id="5217" class="Symbol">(</a><a id="5218" href="Ordinal.Order.html#5123" class="Bound">g</a> <a id="5220" href="Preliminary.html#11018" class="Function Operator">⁺¹</a><a id="5222" class="Symbol">)</a>
    <a id="5228" class="Symbol">(</a><a id="5229" href="Ordinal.Order.html#4576" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="5251" href="Ordinal.Order.html#5106" class="Bound">f</a> <a id="5253" href="Ordinal.Order.html#5110" class="Bound">f-ordEquiv</a><a id="5263" class="Symbol">)</a>
    <a id="5269" class="Symbol">(</a><a id="5270" href="Ordinal.Order.html#4576" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="5292" href="Ordinal.Order.html#5123" class="Bound">g</a> <a id="5294" href="Ordinal.Order.html#5127" class="Bound">g-ordEquiv</a><a id="5304" class="Symbol">))</a>
</pre>
<p><strong>推论</strong> 序数宇宙是集合.<br />
<strong>证明</strong> 即证两个序数的相等是命题, 由序数的泛等原理, 这等价于证两个序数间的等价唯一. ∎</p>
<pre class="Agda"><a id="isSetOrd"></a><a id="5389" href="Ordinal.Order.html#5389" class="Function">isSetOrd</a> <a id="5398" class="Symbol">:</a> <a id="5400" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="5406" class="Symbol">(</a><a id="5407" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5411" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="5412" class="Symbol">)</a>
<a id="5414" href="Ordinal.Order.html#5389" class="Function">isSetOrd</a> <a id="5423" href="Ordinal.Order.html#5423" class="Bound">α</a> <a id="5425" href="Ordinal.Order.html#5425" class="Bound">β</a> <a id="5427" class="Symbol">=</a> <a id="5429" class="Symbol">(</a><a id="5430" href="Ordinal.Order.html#5490" class="Function">equiv</a> <a id="5436" href="Preliminary.html#11018" class="Function Operator">⁺¹</a><a id="5438" class="Symbol">)</a> <a id="5440" class="Symbol">(</a><a id="5441" href="Cubical.Foundations.HLevels.html#22399" class="Function">isOfHLevelLift</a> <a id="5456" class="Number">1</a> <a id="5458" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5460" href="Ordinal.Order.html#5026" class="Function">isPropOrdEquiv</a> <a id="5475" href="Ordinal.Order.html#5423" class="Bound">α</a> <a id="5477" href="Ordinal.Order.html#5425" class="Bound">β</a><a id="5478" class="Symbol">)</a>
  <a id="5482" class="Keyword">where</a>
  <a id="5490" href="Ordinal.Order.html#5490" class="Function">equiv</a> <a id="5496" class="Symbol">:</a> <a id="5498" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5505" class="Symbol">(</a><a id="5506" href="Cubical.Foundations.Prelude.html#19323" class="Record">Lift</a> <a id="5511" class="Symbol">(</a><a id="5512" href="Ordinal.Order.html#5423" class="Bound">α</a> <a id="5514" href="Ordinal.Base.html#8510" class="Function Operator">≃ₒ</a> <a id="5517" href="Ordinal.Order.html#5425" class="Bound">β</a><a id="5518" class="Symbol">))</a> <a id="5521" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="5523" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5530" class="Symbol">(</a><a id="5531" href="Ordinal.Order.html#5423" class="Bound">α</a> <a id="5533" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5535" href="Ordinal.Order.html#5425" class="Bound">β</a><a id="5536" class="Symbol">)</a>
  <a id="5540" href="Ordinal.Order.html#5490" class="Function">equiv</a> <a id="5546" class="Symbol">=</a> <a id="5548" href="Cubical.Foundations.Equiv.Properties.html#6158" class="Function">cong≃</a> <a id="5554" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5561" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5563" href="Cubical.Foundations.Equiv.html#3542" class="Function">compEquiv</a> <a id="5573" class="Symbol">(</a><a id="5574" href="Cubical.Foundations.Equiv.html#3368" class="Function">invEquiv</a> <a id="5583" href="Cubical.Foundations.Equiv.html#5297" class="Function">LiftEquiv</a><a id="5592" class="Symbol">)</a> <a id="5594" class="Symbol">(</a><a id="5595" href="Ordinal.Base.html#9769" class="Function">OrdPath</a> <a id="5603" href="Ordinal.Order.html#5423" class="Bound">α</a> <a id="5605" href="Ordinal.Order.html#5425" class="Bound">β</a><a id="5606" class="Symbol">)</a>
</pre>
<h2 id="非严格序">非严格序</h2>
<p>序数之间的非严格序 <code>_≤_</code> 定义为它们之间的嵌入的全体.</p>
<pre class="Agda"><a id="_≤_"></a><a id="5662" href="Ordinal.Order.html#5662" class="Function Operator">_≤_</a> <a id="5666" class="Symbol">:</a> <a id="5668" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5672" href="Preliminary.html#2692" class="Generalizable">𝓊</a> <a id="5674" class="Symbol">→</a> <a id="5676" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5680" href="Preliminary.html#2694" class="Generalizable">𝓋</a> <a id="5682" class="Symbol">→</a> <a id="5684" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5689" class="Symbol">(</a><a id="5690" href="Preliminary.html#2692" class="Generalizable">𝓊</a> <a id="5692" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="5694" href="Preliminary.html#2694" class="Generalizable">𝓋</a><a id="5695" class="Symbol">)</a>
<a id="5697" href="Ordinal.Order.html#5697" class="Bound">α</a> <a id="5699" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="5701" href="Ordinal.Order.html#5701" class="Bound">β</a> <a id="5703" class="Symbol">=</a> <a id="5705" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="5707" class="Symbol">(</a><a id="5708" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5710" href="Ordinal.Order.html#5697" class="Bound">α</a> <a id="5712" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="5714" class="Symbol">→</a> <a id="5716" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5718" href="Ordinal.Order.html#5701" class="Bound">β</a> <a id="5720" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="5721" class="Symbol">)</a> <a id="5723" href="Ordinal.Order.html#593" class="Record">IsOrdEmbed</a>
</pre>
<p>因为嵌入是唯一的, 所以 <code>_≤_</code> 是命题.</p>
<pre class="Agda"><a id="≤-prop"></a><a id="5772" href="Ordinal.Order.html#5772" class="Function">≤-prop</a> <a id="5779" class="Symbol">:</a> <a id="5781" class="Symbol">(</a><a id="5782" href="Ordinal.Order.html#5782" class="Bound">α</a> <a id="5784" class="Symbol">:</a> <a id="5786" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5790" href="Preliminary.html#2692" class="Generalizable">𝓊</a><a id="5791" class="Symbol">)</a> <a id="5793" class="Symbol">(</a><a id="5794" href="Ordinal.Order.html#5794" class="Bound">β</a> <a id="5796" class="Symbol">:</a> <a id="5798" href="Ordinal.Base.html#6518" class="Function">Ord</a> <a id="5802" href="Preliminary.html#2694" class="Generalizable">𝓋</a><a id="5803" class="Symbol">)</a> <a id="5805" class="Symbol">→</a> <a id="5807" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="5814" class="Symbol">(</a><a id="5815" href="Ordinal.Order.html#5782" class="Bound">α</a> <a id="5817" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="5819" href="Ordinal.Order.html#5794" class="Bound">β</a><a id="5820" class="Symbol">)</a>
<a id="5822" href="Ordinal.Order.html#5772" class="Function">≤-prop</a> <a id="5829" href="Ordinal.Order.html#5829" class="Bound">α</a> <a id="5831" href="Ordinal.Order.html#5831" class="Bound">β</a> <a id="5833" class="Symbol">(</a><a id="5834" href="Ordinal.Order.html#5834" class="Bound">f</a> <a id="5836" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5838" href="Ordinal.Order.html#5838" class="Bound">f-emb</a><a id="5843" class="Symbol">)</a> <a id="5845" class="Symbol">(</a><a id="5846" href="Ordinal.Order.html#5846" class="Bound">g</a> <a id="5848" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5850" href="Ordinal.Order.html#5850" class="Bound">g-emb</a><a id="5855" class="Symbol">)</a> <a id="5857" class="Symbol">=</a> <a id="5859" href="Preliminary.html#9778" class="Function">Σ≡Prop</a> <a id="5866" href="Ordinal.Order.html#3270" class="Function">isPropIsOrdEmbed</a>
  <a id="5885" class="Symbol">(</a><a id="5886" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="5902" href="Ordinal.Order.html#5834" class="Bound">f</a> <a id="5904" href="Ordinal.Order.html#5846" class="Bound">g</a> <a id="5906" href="Ordinal.Order.html#5838" class="Bound">f-emb</a> <a id="5912" href="Ordinal.Order.html#5850" class="Bound">g-emb</a><a id="5917" class="Symbol">)</a>
</pre>
<p>我们会在下一章定义了前段序数之后再定义严格序.</p>
<h3 id="性质">性质</h3>
<p>我们证明 <code>≤</code> 确实是我们期望的非严格偏序, 即要证它满足自反, 传递, 和反对称性.</p>
<p><code>≤</code> 满足自反性, 因为恒等函数满足序数嵌入的条件.</p>
<pre class="Agda"><a id="≤-refl"></a><a id="6040" href="Ordinal.Order.html#6040" class="Function">≤-refl</a> <a id="6047" class="Symbol">:</a> <a id="6049" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6051" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6053" href="Ordinal.Base.html#6623" class="Generalizable">α</a>
<a id="6055" href="Ordinal.Order.html#6040" class="Function">≤-refl</a> <a id="6062" class="Symbol">=</a> <a id="6064" href="Cubical.Foundations.Function.html#468" class="Function">idfun</a> <a id="6070" class="Symbol">_</a> <a id="6072" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6074" href="Ordinal.Order.html#683" class="InductiveConstructor">mkIsOrdEmbed</a> <a id="6087" class="Symbol">(λ</a> <a id="6090" href="Ordinal.Order.html#6090" class="Bound">a</a> <a id="6092" href="Ordinal.Order.html#6092" class="Bound">a′</a> <a id="6095" href="Ordinal.Order.html#6095" class="Bound">a≺a′</a> <a id="6100" class="Symbol">→</a> <a id="6102" href="Ordinal.Order.html#6095" class="Bound">a≺a′</a><a id="6106" class="Symbol">)</a> <a id="6108" class="Symbol">λ</a> <a id="6110" href="Ordinal.Order.html#6110" class="Bound">b</a> <a id="6112" href="Ordinal.Order.html#6112" class="Bound">a′</a> <a id="6115" href="Ordinal.Order.html#6115" class="Bound">b≺a′</a> <a id="6120" class="Symbol">→</a> <a id="6122" href="Ordinal.Order.html#6110" class="Bound">b</a> <a id="6124" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6126" href="Ordinal.Order.html#6115" class="Bound">b≺a′</a> <a id="6131" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6133" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
</pre>
<p><code>≤</code> 满足传递性, 因为复合函数满足序数嵌入的条件.</p>
<pre class="Agda"><a id="≤-trans"></a><a id="6180" href="Ordinal.Order.html#6180" class="Function">≤-trans</a> <a id="6188" class="Symbol">:</a> <a id="6190" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6192" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6194" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="6196" class="Symbol">→</a> <a id="6198" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="6200" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6202" href="Ordinal.Base.html#6627" class="Generalizable">γ</a> <a id="6204" class="Symbol">→</a> <a id="6206" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6208" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6210" href="Ordinal.Base.html#6627" class="Generalizable">γ</a>
<a id="6212" href="Ordinal.Order.html#6180" class="Function">≤-trans</a> <a id="6220" class="Symbol">{</a><a id="6221" href="Ordinal.Order.html#6221" class="Bound">α</a><a id="6222" class="Symbol">}</a> <a id="6224" class="Symbol">{</a><a id="6225" href="Ordinal.Order.html#6225" class="Bound">β</a><a id="6226" class="Symbol">}</a> <a id="6228" class="Symbol">{</a><a id="6229" href="Ordinal.Order.html#6229" class="Bound">γ</a><a id="6230" class="Symbol">}</a> <a id="6232" class="Symbol">(</a><a id="6233" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6235" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6237" href="Ordinal.Order.html#6237" class="Bound">f-emb</a><a id="6242" class="Symbol">)</a> <a id="6244" class="Symbol">(</a><a id="6245" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6247" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6249" href="Ordinal.Order.html#6249" class="Bound">g-emb</a><a id="6254" class="Symbol">)</a> <a id="6256" class="Symbol">=</a> <a id="6258" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6260" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="6262" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6264" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6266" href="Ordinal.Order.html#683" class="InductiveConstructor">mkIsOrdEmbed</a>
  <a id="6281" class="Symbol">(λ</a> <a id="6284" href="Ordinal.Order.html#6284" class="Bound">a</a> <a id="6286" href="Ordinal.Order.html#6286" class="Bound">a′</a> <a id="6289" href="Ordinal.Order.html#6289" class="Bound">a≺a′</a> <a id="6294" class="Symbol">→</a> <a id="6296" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="6302" href="Ordinal.Order.html#6249" class="Bound">g-emb</a> <a id="6308" class="Symbol">(</a><a id="6309" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6311" href="Ordinal.Order.html#6284" class="Bound">a</a><a id="6312" class="Symbol">)</a> <a id="6314" class="Symbol">(</a><a id="6315" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6317" href="Ordinal.Order.html#6286" class="Bound">a′</a><a id="6319" class="Symbol">)</a> <a id="6321" class="Symbol">(</a><a id="6322" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="6328" href="Ordinal.Order.html#6237" class="Bound">f-emb</a> <a id="6334" href="Ordinal.Order.html#6284" class="Bound">a</a> <a id="6336" href="Ordinal.Order.html#6286" class="Bound">a′</a> <a id="6339" href="Ordinal.Order.html#6289" class="Bound">a≺a′</a><a id="6343" class="Symbol">))</a> <a id="6346" href="Ordinal.Order.html#6378" class="Function">aux</a>
  <a id="6352" class="Keyword">where</a>
  <a id="6360" class="Keyword">open</a> <a id="6365" href="Ordinal.Order.html#593" class="Module">IsOrdEmbed</a>
  <a id="6378" href="Ordinal.Order.html#6378" class="Function">aux</a> <a id="6382" class="Symbol">:</a> <a id="6384" class="Symbol">∀</a> <a id="6386" href="Ordinal.Order.html#6386" class="Bound">c</a> <a id="6388" href="Ordinal.Order.html#6388" class="Bound">a′</a> <a id="6391" class="Symbol">→</a> <a id="6393" href="Ordinal.Order.html#6386" class="Bound">c</a> <a id="6395" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6398" href="Ordinal.Order.html#6229" class="Bound">γ</a> <a id="6400" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6402" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6404" class="Symbol">(</a><a id="6405" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6407" href="Ordinal.Order.html#6388" class="Bound">a′</a><a id="6409" class="Symbol">)</a> <a id="6411" class="Symbol">→</a> <a id="6413" href="Preliminary.html#5407" class="Function">Σ</a> <a id="6415" href="Ordinal.Order.html#6415" class="Bound">a</a> <a id="6417" href="Preliminary.html#5407" class="Function">∶</a> <a id="6419" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6421" href="Ordinal.Order.html#6221" class="Bound">α</a> <a id="6423" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="6425" href="Preliminary.html#5407" class="Function">,</a> <a id="6427" href="Ordinal.Order.html#6415" class="Bound">a</a> <a id="6429" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6432" href="Ordinal.Order.html#6221" class="Bound">α</a> <a id="6434" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6436" href="Ordinal.Order.html#6388" class="Bound">a′</a> <a id="6439" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="6441" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6443" class="Symbol">(</a><a id="6444" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6446" href="Ordinal.Order.html#6415" class="Bound">a</a><a id="6447" class="Symbol">)</a> <a id="6449" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6451" href="Ordinal.Order.html#6386" class="Bound">c</a>
  <a id="6455" href="Ordinal.Order.html#6378" class="Function">aux</a> <a id="6459" href="Ordinal.Order.html#6459" class="Bound">c</a> <a id="6461" href="Ordinal.Order.html#6461" class="Bound">a′</a> <a id="6464" href="Ordinal.Order.html#6464" class="Bound">c≺gfa</a> <a id="6470" class="Symbol">=</a> <a id="6472" href="Ordinal.Order.html#6638" class="Function">Σa</a> <a id="6475" class="Symbol">.</a><a id="6476" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="6480" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6482" href="Ordinal.Order.html#6638" class="Function">Σa</a> <a id="6485" class="Symbol">.</a><a id="6486" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="6490" class="Symbol">.</a><a id="6491" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="6495" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6497" href="Cubical.Foundations.Prelude.html#1430" class="Function">cong</a> <a id="6502" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6504" class="Symbol">(</a><a id="6505" href="Ordinal.Order.html#6638" class="Function">Σa</a> <a id="6508" class="Symbol">.</a><a id="6509" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="6513" class="Symbol">.</a><a id="6514" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="6517" class="Symbol">)</a> <a id="6519" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="6521" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6524" class="Symbol">.</a><a id="6525" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="6529" class="Symbol">.</a><a id="6530" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>
    <a id="6538" class="Keyword">where</a>
    <a id="6548" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6551" class="Symbol">:</a> <a id="6553" href="Preliminary.html#5407" class="Function">Σ</a> <a id="6555" href="Ordinal.Order.html#6555" class="Bound">b</a> <a id="6557" href="Preliminary.html#5407" class="Function">∶</a> <a id="6559" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6561" href="Ordinal.Order.html#6225" class="Bound">β</a> <a id="6563" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="6565" href="Preliminary.html#5407" class="Function">,</a> <a id="6567" href="Ordinal.Order.html#6555" class="Bound">b</a> <a id="6569" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6572" href="Ordinal.Order.html#6225" class="Bound">β</a> <a id="6574" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6576" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6578" href="Ordinal.Order.html#6461" class="Bound">a′</a> <a id="6581" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="6583" href="Ordinal.Order.html#6245" class="Bound">g</a> <a id="6585" href="Ordinal.Order.html#6555" class="Bound">b</a> <a id="6587" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6589" href="Ordinal.Order.html#6459" class="Bound">c</a>
    <a id="6595" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6598" class="Symbol">=</a> <a id="6600" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="6613" href="Ordinal.Order.html#6249" class="Bound">g-emb</a> <a id="6619" href="Ordinal.Order.html#6459" class="Bound">c</a> <a id="6621" class="Symbol">(</a><a id="6622" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6624" href="Ordinal.Order.html#6461" class="Bound">a′</a><a id="6626" class="Symbol">)</a> <a id="6628" href="Ordinal.Order.html#6464" class="Bound">c≺gfa</a>
    <a id="6638" href="Ordinal.Order.html#6638" class="Function">Σa</a> <a id="6641" class="Symbol">:</a> <a id="6643" href="Preliminary.html#5407" class="Function">Σ</a> <a id="6645" href="Ordinal.Order.html#6645" class="Bound">a</a> <a id="6647" href="Preliminary.html#5407" class="Function">∶</a> <a id="6649" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6651" href="Ordinal.Order.html#6221" class="Bound">α</a> <a id="6653" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="6655" href="Preliminary.html#5407" class="Function">,</a> <a id="6657" href="Ordinal.Order.html#6645" class="Bound">a</a> <a id="6659" href="Ordinal.Base.html#7045" class="Field">≺⟨</a> <a id="6662" href="Ordinal.Order.html#6221" class="Bound">α</a> <a id="6664" href="Ordinal.Base.html#7045" class="Field">⟩</a> <a id="6666" href="Ordinal.Order.html#6461" class="Bound">a′</a> <a id="6669" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="6671" href="Ordinal.Order.html#6233" class="Bound">f</a> <a id="6673" href="Ordinal.Order.html#6645" class="Bound">a</a> <a id="6675" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6677" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6680" class="Symbol">.</a><a id="6681" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
    <a id="6689" href="Ordinal.Order.html#6638" class="Function">Σa</a> <a id="6692" class="Symbol">=</a> <a id="6694" href="Ordinal.Order.html#1048" class="Field">formsInitSeg</a> <a id="6707" href="Ordinal.Order.html#6237" class="Bound">f-emb</a> <a id="6713" class="Symbol">(</a><a id="6714" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6717" class="Symbol">.</a><a id="6718" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="6721" class="Symbol">)</a> <a id="6723" href="Ordinal.Order.html#6461" class="Bound">a′</a> <a id="6726" class="Symbol">(</a><a id="6727" href="Ordinal.Order.html#6548" class="Function">Σb</a> <a id="6730" class="Symbol">.</a><a id="6731" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="6735" class="Symbol">.</a><a id="6736" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="6739" class="Symbol">)</a>
</pre>
<p>为了证明 <code>≤</code> 反对称, 我们先证双向嵌入蕴含等价, 再用泛等原理换到 <code>≡</code>.</p>
<p><strong>引理</strong> 双向嵌入蕴含等价.<br />
<strong>证明</strong> 两个方向的序数嵌入正好充当了序数等价的正映射和逆映射, 并且序数嵌入的唯一性保证了这两个映射是互逆的. 两个方向的序数嵌入的保序性正当提供了序等价的正映射和逆映射, 并且底序的命题性保证了它们是互逆的. ∎</p>
<pre class="Agda"><a id="≤-antisym-≃ₒ"></a><a id="6929" href="Ordinal.Order.html#6929" class="Function">≤-antisym-≃ₒ</a> <a id="6942" class="Symbol">:</a> <a id="6944" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6946" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6948" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="6950" class="Symbol">→</a> <a id="6952" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="6954" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="6956" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6958" class="Symbol">→</a> <a id="6960" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="6962" href="Ordinal.Base.html#8510" class="Function Operator">≃ₒ</a> <a id="6965" href="Ordinal.Base.html#6625" class="Generalizable">β</a>
<a id="6967" href="Ordinal.Order.html#6929" class="Function">≤-antisym-≃ₒ</a> <a id="6980" class="Symbol">{</a><a id="6981" href="Ordinal.Order.html#6981" class="Bound">α</a><a id="6982" class="Symbol">}</a> <a id="6984" class="Symbol">{</a><a id="6985" href="Ordinal.Order.html#6985" class="Bound">β</a><a id="6986" class="Symbol">}</a> <a id="6988" href="Ordinal.Order.html#6988" class="Bound">α≤β</a><a id="6991" class="Symbol">@(</a><a id="6993" href="Ordinal.Order.html#6993" class="Bound">f</a> <a id="6995" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6997" href="Ordinal.Order.html#6997" class="Bound">f-emb</a><a id="7002" class="Symbol">)</a> <a id="7004" href="Ordinal.Order.html#7004" class="Bound">β≤α</a><a id="7007" class="Symbol">@(</a><a id="7009" href="Ordinal.Order.html#7009" class="Bound">g</a> <a id="7011" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7013" href="Ordinal.Order.html#7013" class="Bound">g-emb</a><a id="7018" class="Symbol">)</a> <a id="7020" class="Symbol">=</a>
  <a id="7024" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="7035" class="Symbol">(</a><a id="7036" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a> <a id="7040" href="Ordinal.Order.html#6993" class="Bound">f</a> <a id="7042" href="Ordinal.Order.html#7009" class="Bound">g</a> <a id="7044" href="Ordinal.Order.html#7264" class="Function">sec</a> <a id="7048" href="Ordinal.Order.html#7373" class="Function">ret</a><a id="7051" class="Symbol">)</a> <a id="7053" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7055" href="Ordinal.Base.html#7894" class="InductiveConstructor">mkIsOrderEquiv</a> <a id="7070" class="Symbol">λ</a> <a id="7072" href="Ordinal.Order.html#7072" class="Bound">x</a> <a id="7074" href="Ordinal.Order.html#7074" class="Bound">y</a> <a id="7076" class="Symbol">→</a> <a id="7078" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a> <a id="7089" class="Symbol">(</a><a id="7090" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a>
    <a id="7098" class="Symbol">(</a><a id="7099" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="7105" href="Ordinal.Order.html#6997" class="Bound">f-emb</a> <a id="7111" href="Ordinal.Order.html#7072" class="Bound">x</a> <a id="7113" href="Ordinal.Order.html#7074" class="Bound">y</a><a id="7114" class="Symbol">)</a>
    <a id="7120" class="Symbol">(</a><a id="7121" href="Cubical.Foundations.Prelude.html#9252" class="Function">subst2</a> <a id="7128" class="Symbol">(</a><a id="7129" href="Ordinal.Base.html#7045" class="Field">underlyingRel</a> <a id="7143" href="Ordinal.Order.html#6981" class="Bound">α</a><a id="7144" class="Symbol">)</a> <a id="7146" class="Symbol">(</a><a id="7147" href="Ordinal.Order.html#7373" class="Function">ret</a> <a id="7151" href="Ordinal.Order.html#7072" class="Bound">x</a><a id="7152" class="Symbol">)</a> <a id="7154" class="Symbol">(</a><a id="7155" href="Ordinal.Order.html#7373" class="Function">ret</a> <a id="7159" href="Ordinal.Order.html#7074" class="Bound">y</a><a id="7160" class="Symbol">)</a> <a id="7162" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="7164" class="Symbol">(</a><a id="7165" href="Ordinal.Order.html#997" class="Field">pres≺</a> <a id="7171" href="Ordinal.Order.html#7013" class="Bound">g-emb</a> <a id="7177" class="Symbol">_</a> <a id="7179" class="Symbol">_))</a>
    <a id="7187" class="Symbol">(λ</a> <a id="7190" href="Ordinal.Order.html#7190" class="Bound">_</a> <a id="7192" class="Symbol">→</a> <a id="7194" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="7201" class="Symbol">(</a><a id="7202" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="7206" href="Ordinal.Order.html#6985" class="Bound">β</a><a id="7207" class="Symbol">)</a> <a id="7209" class="Symbol">_</a> <a id="7211" class="Symbol">_</a> <a id="7213" class="Symbol">_</a> <a id="7215" class="Symbol">_)</a>
    <a id="7222" class="Symbol">(λ</a> <a id="7225" href="Ordinal.Order.html#7225" class="Bound">_</a> <a id="7227" class="Symbol">→</a> <a id="7229" href="Ordinal.Base.html#4669" class="Function">≺-prop</a> <a id="7236" class="Symbol">(</a><a id="7237" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="7241" href="Ordinal.Order.html#6981" class="Bound">α</a><a id="7242" class="Symbol">)</a> <a id="7244" class="Symbol">_</a> <a id="7246" class="Symbol">_</a> <a id="7248" class="Symbol">_</a> <a id="7250" class="Symbol">_))</a>
  <a id="7256" class="Keyword">where</a>
  <a id="7264" href="Ordinal.Order.html#7264" class="Function">sec</a> <a id="7268" class="Symbol">:</a> <a id="7270" href="Cubical.Foundations.Isomorphism.html#571" class="Function">section</a> <a id="7278" href="Ordinal.Order.html#6993" class="Bound">f</a> <a id="7280" href="Ordinal.Order.html#7009" class="Bound">g</a>
  <a id="7284" href="Ordinal.Order.html#7264" class="Function">sec</a> <a id="7288" class="Symbol">=</a> <a id="7290" href="Cubical.Foundations.Prelude.html#10535" class="Function">funExt⁻</a> <a id="7298" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7300" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="7316" class="Symbol">(</a><a id="7317" href="Ordinal.Order.html#6993" class="Bound">f</a> <a id="7319" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="7321" href="Ordinal.Order.html#7009" class="Bound">g</a><a id="7322" class="Symbol">)</a> <a id="7324" class="Symbol">(</a><a id="7325" href="Cubical.Foundations.Function.html#468" class="Function">idfun</a> <a id="7331" class="Symbol">_)</a> <a id="7334" class="Symbol">(</a><a id="7335" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="7339" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7341" href="Ordinal.Order.html#6180" class="Function">≤-trans</a> <a id="7349" href="Ordinal.Order.html#7004" class="Bound">β≤α</a> <a id="7353" href="Ordinal.Order.html#6988" class="Bound">α≤β</a><a id="7356" class="Symbol">)</a> <a id="7358" class="Symbol">(</a><a id="7359" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="7363" href="Ordinal.Order.html#6040" class="Function">≤-refl</a><a id="7369" class="Symbol">)</a>
  <a id="7373" href="Ordinal.Order.html#7373" class="Function">ret</a> <a id="7377" class="Symbol">:</a> <a id="7379" href="Cubical.Foundations.Isomorphism.html#686" class="Function">retract</a> <a id="7387" href="Ordinal.Order.html#6993" class="Bound">f</a> <a id="7389" href="Ordinal.Order.html#7009" class="Bound">g</a>
  <a id="7393" href="Ordinal.Order.html#7373" class="Function">ret</a> <a id="7397" class="Symbol">=</a> <a id="7399" href="Cubical.Foundations.Prelude.html#10535" class="Function">funExt⁻</a> <a id="7407" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7409" href="Ordinal.Order.html#3786" class="Function">ordEmbed-unique</a> <a id="7425" class="Symbol">(</a><a id="7426" href="Ordinal.Order.html#7009" class="Bound">g</a> <a id="7428" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="7430" href="Ordinal.Order.html#6993" class="Bound">f</a><a id="7431" class="Symbol">)</a> <a id="7433" class="Symbol">(</a><a id="7434" href="Cubical.Foundations.Function.html#468" class="Function">idfun</a> <a id="7440" class="Symbol">_)</a> <a id="7443" class="Symbol">(</a><a id="7444" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="7448" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7450" href="Ordinal.Order.html#6180" class="Function">≤-trans</a> <a id="7458" href="Ordinal.Order.html#6988" class="Bound">α≤β</a> <a id="7462" href="Ordinal.Order.html#7004" class="Bound">β≤α</a><a id="7465" class="Symbol">)</a> <a id="7467" class="Symbol">(</a><a id="7468" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="7472" href="Ordinal.Order.html#6040" class="Function">≤-refl</a><a id="7478" class="Symbol">)</a>
  <a id="7482" class="Keyword">open</a> <a id="7487" href="Ordinal.Order.html#593" class="Module">IsOrdEmbed</a>
  <a id="7500" class="Keyword">open</a> <a id="7505" href="Ordinal.Base.html#5980" class="Module">OrdStr</a>
</pre>
<p><strong>定理</strong> <code>≤</code> 反对称.<br />
<strong>证明</strong> 用序数的泛等原理改写 <code>≤-antisym-≃ₒ</code> 即证. ∎</p>
<pre class="Agda"><a id="≤-antisym"></a><a id="7583" href="Ordinal.Order.html#7583" class="Function">≤-antisym</a> <a id="7593" class="Symbol">:</a> <a id="7595" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="7597" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="7599" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="7601" class="Symbol">→</a> <a id="7603" href="Ordinal.Base.html#6625" class="Generalizable">β</a> <a id="7605" href="Ordinal.Order.html#5662" class="Function Operator">≤</a> <a id="7607" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="7609" class="Symbol">→</a> <a id="7611" href="Ordinal.Base.html#6623" class="Generalizable">α</a> <a id="7613" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7615" href="Ordinal.Base.html#6625" class="Generalizable">β</a>
<a id="7617" href="Ordinal.Order.html#7583" class="Function">≤-antisym</a> <a id="7627" href="Ordinal.Order.html#7627" class="Bound">α≤β</a> <a id="7631" href="Ordinal.Order.html#7631" class="Bound">β≤α</a> <a id="7635" class="Symbol">=</a> <a id="7637" href="Ordinal.Base.html#9769" class="Function">OrdPath</a> <a id="7645" class="Symbol">_</a> <a id="7647" class="Symbol">_</a> <a id="7649" href="Preliminary.html#11018" class="Function Operator">⁺¹</a> <a id="7652" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="7654" href="Ordinal.Order.html#6929" class="Function">≤-antisym-≃ₒ</a> <a id="7667" href="Ordinal.Order.html#7627" class="Bound">α≤β</a> <a id="7671" href="Ordinal.Order.html#7631" class="Bound">β≤α</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
