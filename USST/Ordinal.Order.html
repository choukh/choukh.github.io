<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>泛等结构集合论 (4) 序数的序</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">泛等结构集合论 (4) 序数的序</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#泛等结构集合论-4-序数的序" id="toc-泛等结构集合论-4-序数的序">泛等结构集合论 (4) 序数的序</a>
  <ul>
  <li><a href="#底序" id="toc-底序">底序</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a>
  <ul>
  <li><a href="#单射性" id="toc-单射性">单射性</a></li>
  <li><a href="#命题性" id="toc-命题性">命题性</a></li>
  <li><a href="#唯一性" id="toc-唯一性">唯一性</a></li>
  </ul></li>
  <li><a href="#非严格序" id="toc-非严格序">非严格序</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="泛等结构集合论-4-序数的序">泛等结构集合论 (4) 序数的序</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/USST/blob/main/src/Ordinal/Order.lagda.md">Ordinal.Order.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/USST/Ordinal.Order.html">Ordinal.Order.html</a></p>
</blockquote>
<pre class="Agda"><a id="353" class="Symbol">{-#</a> <a id="357" class="Keyword">OPTIONS</a> <a id="365" class="Pragma">--cubical</a> <a id="375" class="Pragma">--safe</a> <a id="382" class="Symbol">#-}</a>
<a id="386" class="Symbol">{-#</a> <a id="390" class="Keyword">OPTIONS</a> <a id="398" class="Pragma">--lossy-unification</a> <a id="418" class="Pragma">--hidden-argument-puns</a> <a id="441" class="Symbol">#-}</a>
<a id="445" class="Keyword">module</a> <a id="452" href="Ordinal.Order.html" class="Module">Ordinal.Order</a> <a id="466" class="Keyword">where</a>
<a id="472" class="Keyword">open</a> <a id="477" class="Keyword">import</a> <a id="484" href="Preliminary.html" class="Module">Preliminary</a>
<a id="496" class="Keyword">open</a> <a id="501" class="Keyword">import</a> <a id="508" href="Ordinal.Base.html" class="Module">Ordinal.Base</a>
</pre>
<h2 id="底序">底序</h2>
<p>当同时讨论多个序数中的 <code>≺</code> 关系时, 我们用 <code>x ≺⟨ α ⟩ y</code> 的记法标记 <code>≺</code> 所属的序数. 我们把 <code>≺⟨ α ⟩</code> 叫做 <code>α</code> 的底序, 与底集相对应, 它们共同组成了一个序数的底层结构. 若把 <code>≺</code> 看作”属于”关系, <code>∀ z → z ≺⟨ α ⟩ x → z ≺⟨ α ⟩ y</code> 则可以看作是”包含”关系, 记作 <code>≼</code>. 但要注意这些都只是类比的说法, <code>x</code> 和 <code>y</code> 本身不是集合.</p>
<p>以下代码定义了一个支持 <code>x ≺⟨ α ⟩ y</code> 和 <code>x ≼⟨ α ⟩ y</code> 记法的类型类 (typeclass) <code>Underlying</code>.</p>
<pre class="Agda"><a id="827" class="Keyword">record</a> <a id="Underlying"></a><a id="834" href="Ordinal.Order.html#834" class="Record">Underlying</a> <a id="845" class="Symbol">{</a><a id="846" href="Ordinal.Order.html#846" class="Bound">𝓊</a><a id="847" class="Symbol">}</a> <a id="849" class="Symbol">(</a><a id="850" href="Ordinal.Order.html#850" class="Bound">O</a> <a id="852" class="Symbol">:</a> <a id="854" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="859" class="Symbol">(</a><a id="860" href="Ordinal.Order.html#846" class="Bound">𝓊</a> <a id="862" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="863" class="Symbol">))</a> <a id="866" class="Symbol">:</a> <a id="868" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="873" class="Symbol">(</a><a id="874" href="Ordinal.Order.html#846" class="Bound">𝓊</a> <a id="876" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="877" class="Symbol">)</a> <a id="879" class="Keyword">where</a>
  <a id="887" class="Keyword">field</a>
    <a id="Underlying.underlyingSet"></a><a id="897" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="911" class="Symbol">:</a> <a id="913" href="Ordinal.Order.html#850" class="Bound">O</a> <a id="915" class="Symbol">→</a> <a id="917" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="922" href="Ordinal.Order.html#846" class="Bound">𝓊</a>
    <a id="Underlying.underlyingRel"></a><a id="928" href="Ordinal.Order.html#928" class="Field">underlyingRel</a> <a id="942" class="Symbol">:</a> <a id="944" class="Symbol">(</a><a id="945" href="Ordinal.Order.html#945" class="Bound">α</a> <a id="947" class="Symbol">:</a> <a id="949" href="Ordinal.Order.html#850" class="Bound">O</a><a id="950" class="Symbol">)</a> <a id="952" class="Symbol">→</a> <a id="954" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="968" href="Ordinal.Order.html#945" class="Bound">α</a> <a id="970" class="Symbol">→</a> <a id="972" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="986" href="Ordinal.Order.html#945" class="Bound">α</a> <a id="988" class="Symbol">→</a> <a id="990" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="995" href="Ordinal.Order.html#846" class="Bound">𝓊</a>
  <a id="999" class="Keyword">syntax</a> <a id="1006" href="Ordinal.Order.html#928" class="Field">underlyingRel</a> <a id="1020" class="Bound">α</a> <a id="1022" class="Bound">x</a> <a id="1024" class="Bound">y</a> <a id="1026" class="Symbol">=</a> <a id="1028" class="Bound">x</a> <a id="1030" class="Field">≺⟨</a> <a id="1033" class="Bound">α</a> <a id="1035" class="Field">⟩</a> <a id="1037" class="Bound">y</a>

  <a id="Underlying.underlyingPoRel"></a><a id="1042" href="Ordinal.Order.html#1042" class="Function">underlyingPoRel</a> <a id="1058" class="Symbol">:</a> <a id="1060" class="Symbol">(</a><a id="1061" href="Ordinal.Order.html#1061" class="Bound">α</a> <a id="1063" class="Symbol">:</a> <a id="1065" href="Ordinal.Order.html#850" class="Bound">O</a><a id="1066" class="Symbol">)</a> <a id="1068" class="Symbol">→</a> <a id="1070" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="1084" href="Ordinal.Order.html#1061" class="Bound">α</a> <a id="1086" class="Symbol">→</a> <a id="1088" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="1102" href="Ordinal.Order.html#1061" class="Bound">α</a> <a id="1104" class="Symbol">→</a> <a id="1106" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1111" href="Ordinal.Order.html#846" class="Bound">𝓊</a>
  <a id="1115" href="Ordinal.Order.html#1042" class="Function">underlyingPoRel</a> <a id="1131" href="Ordinal.Order.html#1131" class="Bound">α</a> <a id="1133" href="Ordinal.Order.html#1133" class="Bound">x</a> <a id="1135" href="Ordinal.Order.html#1135" class="Bound">y</a> <a id="1137" class="Symbol">=</a> <a id="1139" class="Symbol">∀</a> <a id="1141" href="Ordinal.Order.html#1141" class="Bound">z</a> <a id="1143" class="Symbol">→</a> <a id="1145" href="Ordinal.Order.html#1141" class="Bound">z</a> <a id="1147" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1150" href="Ordinal.Order.html#1131" class="Bound">α</a> <a id="1152" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="1154" href="Ordinal.Order.html#1133" class="Bound">x</a> <a id="1156" class="Symbol">→</a> <a id="1158" href="Ordinal.Order.html#1141" class="Bound">z</a> <a id="1160" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1163" href="Ordinal.Order.html#1131" class="Bound">α</a> <a id="1165" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="1167" href="Ordinal.Order.html#1135" class="Bound">y</a>
  <a id="1171" class="Keyword">syntax</a> <a id="1178" href="Ordinal.Order.html#1042" class="Function">underlyingPoRel</a> <a id="1194" class="Bound">α</a> <a id="1196" class="Bound">x</a> <a id="1198" class="Bound">y</a> <a id="1200" class="Symbol">=</a> <a id="1202" class="Bound">x</a> <a id="1204" class="Function">≼⟨</a> <a id="1207" class="Bound">α</a> <a id="1209" class="Function">⟩</a> <a id="1211" class="Bound">y</a>

<a id="1214" class="Keyword">open</a> <a id="1219" href="Ordinal.Order.html#834" class="Module">Underlying</a> <a id="1230" class="Symbol">⦃...⦄</a> <a id="1236" class="Keyword">public</a>
</pre>
<p>我们对序数实装 <code>Underlying</code> 类型类.</p>
<pre class="Agda"><a id="1283" class="Keyword">instance</a>
  <a id="underlying"></a><a id="1294" href="Ordinal.Order.html#1294" class="Function">underlying</a> <a id="1305" class="Symbol">:</a> <a id="1307" href="Ordinal.Order.html#834" class="Record">Underlying</a> <a id="1318" class="Symbol">(</a><a id="1319" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="1323" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="1324" class="Symbol">)</a>
  <a id="1328" href="Ordinal.Order.html#897" class="Field">underlyingSet</a> <a id="1342" class="Symbol">⦃</a> <a id="1344" href="Ordinal.Order.html#1294" class="Function">underlying</a> <a id="1355" class="Symbol">⦄</a> <a id="1357" class="Symbol">=</a> <a id="1359" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨_⟩</a>
  <a id="1365" href="Ordinal.Order.html#928" class="Field">underlyingRel</a> <a id="1379" class="Symbol">⦃</a> <a id="1381" href="Ordinal.Order.html#1294" class="Function">underlying</a> <a id="1392" class="Symbol">⦄</a> <a id="1394" class="Symbol">=</a> <a id="1396" href="Ordinal.Base.html#6140" class="Field Operator">OrdStr._≺_</a> <a id="1407" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="1409" href="Cubical.Foundations.Structure.html#556" class="Function">str</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们说序数底集间的一个映射是序数嵌入, 当且仅当它保序, 且它的像能形成一个前段.</p>
<pre class="Agda"><a id="1478" class="Keyword">record</a> <a id="IsOrdEmbed"></a><a id="1485" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a> <a id="1496" class="Symbol">{</a><a id="1497" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="1499" class="Symbol">:</a> <a id="1501" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="1505" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="1506" class="Symbol">}</a> <a id="1508" class="Symbol">{</a><a id="1509" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="1511" class="Symbol">:</a> <a id="1513" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="1517" href="Preliminary.html#2650" class="Generalizable">𝓋</a><a id="1518" class="Symbol">}</a> <a id="1520" class="Symbol">(</a><a id="1521" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="1523" class="Symbol">:</a> <a id="1525" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="1527" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="1529" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="1531" class="Symbol">→</a> <a id="1533" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="1535" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="1537" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="1538" class="Symbol">)</a> <a id="1540" class="Symbol">:</a> <a id="1542" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1547" class="Symbol">(</a><a id="1548" href="Ordinal.Order.html#1505" class="Bound">𝓊</a> <a id="1550" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="1552" href="Ordinal.Order.html#1517" class="Bound">𝓋</a><a id="1553" class="Symbol">)</a> <a id="1555" class="Keyword">where</a>
  <a id="1563" class="Keyword">constructor</a> <a id="mkIsOrdEmbed"></a><a id="1575" href="Ordinal.Order.html#1575" class="InductiveConstructor">mkIsOrdEmbed</a>
</pre>
<p>保序性 <code>pres≺</code> 很简单, 它就是上一章同伦保序 <code>hPres≺</code> 的弱化版. “形成前段” <code>formsInitSeg</code> 这一性质的直观可以参考下图. 它说只要一个底集元素被射到, 那么比它小的元素都会被射到, 也就是映射的像能形成 <code>≺</code> 的一个前段.</p>
<pre class="string"><code>... a   ... ≺₁ ... a′  ...  
    |              |  
  f |            f |  
    ↓              ↓  
... f a ... ≺₂ ... f a′ ...  </code></pre>
<pre class="Agda">  <a id="1879" class="Keyword">field</a>
    <a id="IsOrdEmbed.pres≺"></a><a id="1889" href="Ordinal.Order.html#1889" class="Field">pres≺</a> <a id="1895" class="Symbol">:</a> <a id="1897" class="Symbol">∀</a> <a id="1899" href="Ordinal.Order.html#1899" class="Bound">a</a> <a id="1901" href="Ordinal.Order.html#1901" class="Bound">a′</a> <a id="1904" class="Symbol">→</a> <a id="1906" href="Ordinal.Order.html#1899" class="Bound">a</a> <a id="1908" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1911" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="1913" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="1915" href="Ordinal.Order.html#1901" class="Bound">a′</a> <a id="1918" class="Symbol">→</a> <a id="1920" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="1922" href="Ordinal.Order.html#1899" class="Bound">a</a> <a id="1924" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1927" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="1929" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="1931" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="1933" href="Ordinal.Order.html#1901" class="Bound">a′</a>
    <a id="IsOrdEmbed.formsInitSeg"></a><a id="1940" href="Ordinal.Order.html#1940" class="Field">formsInitSeg</a> <a id="1953" class="Symbol">:</a> <a id="1955" class="Symbol">∀</a> <a id="1957" href="Ordinal.Order.html#1957" class="Bound">b</a> <a id="1959" href="Ordinal.Order.html#1959" class="Bound">a′</a> <a id="1962" class="Symbol">→</a> <a id="1964" href="Ordinal.Order.html#1957" class="Bound">b</a> <a id="1966" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1969" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="1971" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="1973" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="1975" href="Ordinal.Order.html#1959" class="Bound">a′</a> <a id="1978" class="Symbol">→</a> <a id="1980" href="Preliminary.html#5363" class="Function">Σ</a> <a id="1982" href="Ordinal.Order.html#1982" class="Bound">a</a> <a id="1984" href="Preliminary.html#5363" class="Function">∶</a> <a id="1986" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="1988" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="1990" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="1992" href="Preliminary.html#5363" class="Function">,</a> <a id="1994" href="Ordinal.Order.html#1982" class="Bound">a</a> <a id="1996" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="1999" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2001" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2003" href="Ordinal.Order.html#1959" class="Bound">a′</a> <a id="2006" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="2008" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2010" href="Ordinal.Order.html#1982" class="Bound">a</a> <a id="2012" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2014" href="Ordinal.Order.html#1957" class="Bound">b</a>
</pre>
<h3 id="单射性">单射性</h3>
<p><strong>引理</strong> 序数嵌入是单射.<br />
<strong>证明</strong> 用双参数形式的良基归纳法 <code>elim2</code>, 拿到归纳假设 <code>IH : ∀ u v → u ≺ x → v ≺ y → f u ＝ f v → u ＝ v</code>, 要证 <code>f x ＝ f y → x ＝ y</code>. 用 <code>≺</code> 的外延性, 要证两种对称的情况 <code>p</code> 和 <code>q</code>, 我们只证 <code>p : ∀ z → z ≺ x → z ≺ y</code>. 由 <code>z ≺ x</code> 及嵌入的保序性有 <code>f z ≺ f x ≡ f y</code>. 由于嵌入能形成前段, 必有一个 <code>w</code> 满足 <code>w ≺ y</code> 且 <code>f w ＝ f z</code>. 再结合归纳假设有 <code>w ＝ z</code>, 改写目标即证 <code>w ≺ y</code>, 此乃前提. ∎</p>
<pre class="Agda">  <a id="IsOrdEmbed.inj"></a><a id="2360" href="Ordinal.Order.html#2360" class="Function">inj</a> <a id="2364" class="Symbol">:</a> <a id="2366" href="Preliminary.html#10336" class="Function">injective</a> <a id="2376" href="Ordinal.Order.html#1521" class="Bound">f</a>
  <a id="2380" href="Ordinal.Order.html#2360" class="Function">inj</a> <a id="2384" class="Symbol">=</a> <a id="2386" href="Ordinal.Base.html#6353" class="Function">elim2</a> <a id="2392" href="Ordinal.Order.html#2460" class="Function">aux</a> <a id="2396" class="Symbol">_</a> <a id="2398" class="Symbol">_</a>
    <a id="2404" class="Keyword">where</a>
    <a id="2414" class="Keyword">open</a> <a id="2419" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="2426" class="Symbol">(</a><a id="2427" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="2431" href="Ordinal.Order.html#1497" class="Bound">α</a><a id="2432" class="Symbol">)</a> <a id="2434" class="Keyword">using</a> <a id="2440" class="Symbol">(</a><a id="2441" href="Ordinal.Base.html#4790" class="Function">≺-ext</a><a id="2446" class="Symbol">;</a> <a id="2448" href="Ordinal.Base.html#6353" class="Function">elim2</a><a id="2453" class="Symbol">)</a>

    <a id="2460" href="Ordinal.Order.html#2460" class="Function">aux</a> <a id="2464" class="Symbol">:</a> <a id="2466" class="Symbol">∀</a> <a id="2468" href="Ordinal.Order.html#2468" class="Bound">x</a> <a id="2470" href="Ordinal.Order.html#2470" class="Bound">y</a> <a id="2472" class="Symbol">→</a> <a id="2474" class="Symbol">(∀</a> <a id="2477" href="Ordinal.Order.html#2477" class="Bound">u</a> <a id="2479" href="Ordinal.Order.html#2479" class="Bound">v</a> <a id="2481" class="Symbol">→</a> <a id="2483" href="Ordinal.Order.html#2477" class="Bound">u</a> <a id="2485" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2488" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2490" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2492" href="Ordinal.Order.html#2468" class="Bound">x</a> <a id="2494" class="Symbol">→</a> <a id="2496" href="Ordinal.Order.html#2479" class="Bound">v</a> <a id="2498" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2501" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2503" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2505" href="Ordinal.Order.html#2470" class="Bound">y</a> <a id="2507" class="Symbol">→</a> <a id="2509" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2511" href="Ordinal.Order.html#2477" class="Bound">u</a> <a id="2513" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2515" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2517" href="Ordinal.Order.html#2479" class="Bound">v</a> <a id="2519" class="Symbol">→</a> <a id="2521" href="Ordinal.Order.html#2477" class="Bound">u</a> <a id="2523" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2525" href="Ordinal.Order.html#2479" class="Bound">v</a><a id="2526" class="Symbol">)</a> <a id="2528" class="Symbol">→</a> <a id="2530" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2532" href="Ordinal.Order.html#2468" class="Bound">x</a> <a id="2534" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2536" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2538" href="Ordinal.Order.html#2470" class="Bound">y</a> <a id="2540" class="Symbol">→</a> <a id="2542" href="Ordinal.Order.html#2468" class="Bound">x</a> <a id="2544" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2546" href="Ordinal.Order.html#2470" class="Bound">y</a>
    <a id="2552" href="Ordinal.Order.html#2460" class="Function">aux</a> <a id="2556" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="2558" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="2560" href="Ordinal.Order.html#2560" class="Bound">IH</a> <a id="2563" href="Ordinal.Order.html#2563" class="Bound">fx＝fy</a> <a id="2569" class="Symbol">=</a> <a id="2571" href="Ordinal.Base.html#4790" class="Function">≺-ext</a> <a id="2577" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="2579" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="2581" class="Symbol">λ</a> <a id="2583" href="Ordinal.Order.html#2583" class="Bound">z</a> <a id="2585" class="Symbol">→</a> <a id="2587" href="Ordinal.Order.html#2615" class="Function">p</a> <a id="2589" href="Ordinal.Order.html#2583" class="Bound">z</a> <a id="2591" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2593" href="Ordinal.Order.html#3056" class="Function">q</a> <a id="2595" href="Ordinal.Order.html#2583" class="Bound">z</a>
      <a id="2603" class="Keyword">where</a>
      <a id="2615" href="Ordinal.Order.html#2615" class="Function">p</a> <a id="2617" class="Symbol">:</a> <a id="2619" class="Symbol">∀</a> <a id="2621" href="Ordinal.Order.html#2621" class="Bound">z</a> <a id="2623" class="Symbol">→</a> <a id="2625" href="Ordinal.Order.html#2621" class="Bound">z</a> <a id="2627" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2630" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2632" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2634" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="2636" class="Symbol">→</a> <a id="2638" href="Ordinal.Order.html#2621" class="Bound">z</a> <a id="2640" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2643" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2645" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2647" href="Ordinal.Order.html#2558" class="Bound">y</a>
      <a id="2655" href="Ordinal.Order.html#2615" class="Function">p</a> <a id="2657" href="Ordinal.Order.html#2657" class="Bound">z</a> <a id="2659" href="Ordinal.Order.html#2659" class="Bound">z≺x</a> <a id="2663" class="Symbol">=</a> <a id="2665" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="2675" class="Symbol">(λ</a> <a id="2678" href="Ordinal.Order.html#2678" class="Bound">-</a> <a id="2680" class="Symbol">→</a> <a id="2682" href="Ordinal.Order.html#2678" class="Bound">-</a> <a id="2684" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2687" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2689" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2691" href="Ordinal.Order.html#2558" class="Bound">y</a><a id="2692" class="Symbol">)</a> <a id="2694" href="Ordinal.Order.html#2991" class="Function">w≡z</a> <a id="2698" href="Ordinal.Order.html#2935" class="Function">w≺y</a>
        <a id="2710" class="Keyword">where</a>
        <a id="2724" href="Ordinal.Order.html#2724" class="Function">fz≺fy</a> <a id="2730" class="Symbol">:</a> <a id="2732" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2734" href="Ordinal.Order.html#2657" class="Bound">z</a> <a id="2736" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2739" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="2741" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2743" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2745" href="Ordinal.Order.html#2558" class="Bound">y</a>
        <a id="2755" href="Ordinal.Order.html#2724" class="Function">fz≺fy</a> <a id="2761" class="Symbol">=</a> <a id="2763" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="2773" class="Symbol">(λ</a> <a id="2776" href="Ordinal.Order.html#2776" class="Bound">-</a> <a id="2778" class="Symbol">→</a> <a id="2780" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2782" href="Ordinal.Order.html#2657" class="Bound">z</a> <a id="2784" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2787" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="2789" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2791" href="Ordinal.Order.html#2776" class="Bound">-</a><a id="2792" class="Symbol">)</a> <a id="2794" href="Ordinal.Order.html#2563" class="Bound">fx＝fy</a> <a id="2800" class="Symbol">(</a><a id="2801" href="Ordinal.Order.html#1889" class="Field">pres≺</a> <a id="2807" href="Ordinal.Order.html#2657" class="Bound">z</a> <a id="2809" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="2811" href="Ordinal.Order.html#2659" class="Bound">z≺x</a><a id="2814" class="Symbol">)</a>
        <a id="2824" href="Ordinal.Order.html#2824" class="Function">Σw</a> <a id="2827" class="Symbol">:</a> <a id="2829" href="Preliminary.html#5363" class="Function">Σ</a> <a id="2831" href="Ordinal.Order.html#2831" class="Bound">w</a> <a id="2833" href="Preliminary.html#5363" class="Function">∶</a> <a id="2835" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="2837" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2839" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="2841" href="Preliminary.html#5363" class="Function">,</a> <a id="2843" class="Symbol">(</a><a id="2844" href="Ordinal.Order.html#2831" class="Bound">w</a> <a id="2846" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="2849" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="2851" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="2853" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="2855" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="2857" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2859" href="Ordinal.Order.html#2831" class="Bound">w</a> <a id="2861" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="2863" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2865" href="Ordinal.Order.html#2657" class="Bound">z</a><a id="2866" class="Symbol">)</a>
        <a id="2876" href="Ordinal.Order.html#2824" class="Function">Σw</a> <a id="2879" class="Symbol">=</a> <a id="2881" href="Ordinal.Order.html#1940" class="Field">formsInitSeg</a> <a id="2894" class="Symbol">(</a><a id="2895" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="2897" href="Ordinal.Order.html#2657" class="Bound">z</a><a id="2898" class="Symbol">)</a> <a id="2900" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="2902" href="Ordinal.Order.html#2724" class="Function">fz≺fy</a>
        <a id="2916" href="Ordinal.Order.html#2916" class="Function">w</a> <a id="2918" class="Symbol">=</a> <a id="2920" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="2924" href="Ordinal.Order.html#2824" class="Function">Σw</a>
        <a id="2935" href="Ordinal.Order.html#2935" class="Function">w≺y</a> <a id="2939" class="Symbol">=</a> <a id="2941" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="2945" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2947" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="2951" href="Ordinal.Order.html#2824" class="Function">Σw</a>
        <a id="2962" href="Ordinal.Order.html#2962" class="Function">fw＝fz</a> <a id="2968" class="Symbol">=</a> <a id="2970" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="2974" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="2976" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="2980" href="Ordinal.Order.html#2824" class="Function">Σw</a>
        <a id="2991" href="Ordinal.Order.html#2991" class="Function">w≡z</a> <a id="2995" class="Symbol">:</a> <a id="2997" href="Ordinal.Order.html#2916" class="Function">w</a> <a id="2999" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="3001" href="Ordinal.Order.html#2657" class="Bound">z</a>
        <a id="3011" href="Ordinal.Order.html#2991" class="Function">w≡z</a> <a id="3015" class="Symbol">=</a> <a id="3017" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="3021" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3023" href="Ordinal.Order.html#2560" class="Bound">IH</a> <a id="3026" href="Ordinal.Order.html#2657" class="Bound">z</a> <a id="3028" href="Ordinal.Order.html#2916" class="Function">w</a> <a id="3030" href="Ordinal.Order.html#2659" class="Bound">z≺x</a> <a id="3034" href="Ordinal.Order.html#2935" class="Function">w≺y</a> <a id="3038" class="Symbol">(</a><a id="3039" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="3043" href="Ordinal.Order.html#2962" class="Function">fw＝fz</a><a id="3048" class="Symbol">)</a>
      <a id="3056" href="Ordinal.Order.html#3056" class="Function">q</a> <a id="3058" class="Symbol">:</a> <a id="3060" class="Symbol">∀</a> <a id="3062" href="Ordinal.Order.html#3062" class="Bound">z</a> <a id="3064" class="Symbol">→</a> <a id="3066" href="Ordinal.Order.html#3062" class="Bound">z</a> <a id="3068" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3071" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3073" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3075" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="3077" class="Symbol">→</a> <a id="3079" href="Ordinal.Order.html#3062" class="Bound">z</a> <a id="3081" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3084" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3086" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3088" href="Ordinal.Order.html#2556" class="Bound">x</a>
      <a id="3096" href="Ordinal.Order.html#3056" class="Function">q</a> <a id="3098" href="Ordinal.Order.html#3098" class="Bound">z</a> <a id="3100" href="Ordinal.Order.html#3100" class="Bound">z≺y</a> <a id="3104" class="Symbol">=</a> <a id="3106" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="3116" class="Symbol">(λ</a> <a id="3119" href="Ordinal.Order.html#3119" class="Bound">-</a> <a id="3121" class="Symbol">→</a> <a id="3123" href="Ordinal.Order.html#3119" class="Bound">-</a> <a id="3125" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3128" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3130" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3132" href="Ordinal.Order.html#2556" class="Bound">x</a><a id="3133" class="Symbol">)</a> <a id="3135" href="Ordinal.Order.html#3438" class="Function">w≡z</a> <a id="3139" href="Ordinal.Order.html#3382" class="Function">w≺x</a>
        <a id="3151" class="Keyword">where</a>
        <a id="3165" href="Ordinal.Order.html#3165" class="Function">fz≺fx</a> <a id="3171" class="Symbol">:</a> <a id="3173" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3175" href="Ordinal.Order.html#3098" class="Bound">z</a> <a id="3177" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3180" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="3182" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3184" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3186" href="Ordinal.Order.html#2556" class="Bound">x</a>
        <a id="3196" href="Ordinal.Order.html#3165" class="Function">fz≺fx</a> <a id="3202" class="Symbol">=</a> <a id="3204" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="3214" class="Symbol">(λ</a> <a id="3217" href="Ordinal.Order.html#3217" class="Bound">-</a> <a id="3219" class="Symbol">→</a> <a id="3221" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3223" href="Ordinal.Order.html#3098" class="Bound">z</a> <a id="3225" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3228" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="3230" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3232" href="Ordinal.Order.html#3217" class="Bound">-</a><a id="3233" class="Symbol">)</a> <a id="3235" class="Symbol">(</a><a id="3236" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="3240" href="Ordinal.Order.html#2563" class="Bound">fx＝fy</a><a id="3245" class="Symbol">)</a> <a id="3247" class="Symbol">(</a><a id="3248" href="Ordinal.Order.html#1889" class="Field">pres≺</a> <a id="3254" href="Ordinal.Order.html#3098" class="Bound">z</a> <a id="3256" href="Ordinal.Order.html#2558" class="Bound">y</a> <a id="3258" href="Ordinal.Order.html#3100" class="Bound">z≺y</a><a id="3261" class="Symbol">)</a>
        <a id="3271" href="Ordinal.Order.html#3271" class="Function">Σw</a> <a id="3274" class="Symbol">:</a> <a id="3276" href="Preliminary.html#5363" class="Function">Σ</a> <a id="3278" href="Ordinal.Order.html#3278" class="Bound">w</a> <a id="3280" href="Preliminary.html#5363" class="Function">∶</a> <a id="3282" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3284" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3286" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="3288" href="Preliminary.html#5363" class="Function">,</a> <a id="3290" class="Symbol">(</a><a id="3291" href="Ordinal.Order.html#3278" class="Bound">w</a> <a id="3293" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3296" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3298" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3300" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="3302" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="3304" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3306" href="Ordinal.Order.html#3278" class="Bound">w</a> <a id="3308" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="3310" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3312" href="Ordinal.Order.html#3098" class="Bound">z</a><a id="3313" class="Symbol">)</a>
        <a id="3323" href="Ordinal.Order.html#3271" class="Function">Σw</a> <a id="3326" class="Symbol">=</a> <a id="3328" href="Ordinal.Order.html#1940" class="Field">formsInitSeg</a> <a id="3341" class="Symbol">(</a><a id="3342" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3344" href="Ordinal.Order.html#3098" class="Bound">z</a><a id="3345" class="Symbol">)</a> <a id="3347" href="Ordinal.Order.html#2556" class="Bound">x</a> <a id="3349" href="Ordinal.Order.html#3165" class="Function">fz≺fx</a>
        <a id="3363" href="Ordinal.Order.html#3363" class="Function">w</a> <a id="3365" class="Symbol">=</a> <a id="3367" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="3371" href="Ordinal.Order.html#3271" class="Function">Σw</a>
        <a id="3382" href="Ordinal.Order.html#3382" class="Function">w≺x</a> <a id="3386" class="Symbol">=</a> <a id="3388" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="3392" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3394" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="3398" href="Ordinal.Order.html#3271" class="Function">Σw</a>
        <a id="3409" href="Ordinal.Order.html#3409" class="Function">fw＝fz</a> <a id="3415" class="Symbol">=</a> <a id="3417" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="3421" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3423" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="3427" href="Ordinal.Order.html#3271" class="Function">Σw</a>
        <a id="3438" href="Ordinal.Order.html#3438" class="Function">w≡z</a> <a id="3442" class="Symbol">:</a> <a id="3444" href="Ordinal.Order.html#3363" class="Function">w</a> <a id="3446" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="3448" href="Ordinal.Order.html#3098" class="Bound">z</a>
        <a id="3458" href="Ordinal.Order.html#3438" class="Function">w≡z</a> <a id="3462" class="Symbol">=</a> <a id="3464" href="Ordinal.Order.html#2560" class="Bound">IH</a> <a id="3467" href="Ordinal.Order.html#3363" class="Function">w</a> <a id="3469" href="Ordinal.Order.html#3098" class="Bound">z</a> <a id="3471" href="Ordinal.Order.html#3382" class="Function">w≺x</a> <a id="3475" href="Ordinal.Order.html#3100" class="Bound">z≺y</a> <a id="3479" href="Ordinal.Order.html#3409" class="Function">fw＝fz</a>
</pre>
<h3 id="命题性">命题性</h3>
<p>易证保序性是命题.</p>
<pre class="Agda">  <a id="IsOrdEmbed.isPropPres≺"></a><a id="3520" href="Ordinal.Order.html#3520" class="Function">isPropPres≺</a> <a id="3532" class="Symbol">:</a> <a id="3534" class="Symbol">∀</a> <a id="3536" href="Ordinal.Order.html#3536" class="Bound">a</a> <a id="3538" href="Ordinal.Order.html#3538" class="Bound">a′</a> <a id="3541" class="Symbol">→</a> <a id="3543" href="Ordinal.Order.html#3536" class="Bound">a</a> <a id="3545" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3548" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3550" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3552" href="Ordinal.Order.html#3538" class="Bound">a′</a> <a id="3555" class="Symbol">→</a> <a id="3557" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3564" class="Symbol">(</a><a id="3565" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3567" href="Ordinal.Order.html#3536" class="Bound">a</a> <a id="3569" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3572" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="3574" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3576" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3578" href="Ordinal.Order.html#3538" class="Bound">a′</a><a id="3580" class="Symbol">)</a>
  <a id="3584" href="Ordinal.Order.html#3520" class="Function">isPropPres≺</a> <a id="3596" class="Symbol">_</a> <a id="3598" class="Symbol">_</a> <a id="3600" class="Symbol">_</a> <a id="3602" class="Symbol">=</a> <a id="3604" href="Ordinal.Base.html#4729" class="Function">≺-prop</a> <a id="3611" class="Symbol">_</a> <a id="3613" class="Symbol">_</a>
    <a id="3619" class="Keyword">where</a> <a id="3625" class="Keyword">open</a> <a id="3630" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="3637" class="Symbol">(</a><a id="3638" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="3642" href="Ordinal.Order.html#1509" class="Bound">β</a><a id="3643" class="Symbol">)</a> <a id="3645" class="Keyword">using</a> <a id="3651" class="Symbol">(</a><a id="3652" href="Ordinal.Base.html#4729" class="Function">≺-prop</a><a id="3658" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> “形成前段”是命题, 尽管没有截断.<br />
<strong>证明</strong> 由于前段性是命题, 只需证 <code>b</code> 对应的 <code>α</code> 前段唯一. 假设有两个这样的前段, 分别有端点 <code>x</code> 和 <code>y</code> 被 <code>f</code> 射到 <code>b</code>, 由嵌入的单射性 <code>x ＝ y</code>. ∎</p>
<pre class="Agda">  <a id="IsOrdEmbed.isPropFormsInitSeg"></a><a id="3804" href="Ordinal.Order.html#3804" class="Function">isPropFormsInitSeg</a> <a id="3823" class="Symbol">:</a> <a id="3825" class="Symbol">∀</a> <a id="3827" href="Ordinal.Order.html#3827" class="Bound">b</a> <a id="3829" href="Ordinal.Order.html#3829" class="Bound">a′</a> <a id="3832" class="Symbol">→</a> <a id="3834" href="Ordinal.Order.html#3827" class="Bound">b</a> <a id="3836" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3839" href="Ordinal.Order.html#1509" class="Bound">β</a> <a id="3841" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3843" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3845" href="Ordinal.Order.html#3829" class="Bound">a′</a> <a id="3848" class="Symbol">→</a> <a id="3850" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3857" class="Symbol">(</a><a id="3858" href="Preliminary.html#5363" class="Function">Σ</a> <a id="3860" href="Ordinal.Order.html#3860" class="Bound">a</a> <a id="3862" href="Preliminary.html#5363" class="Function">∶</a> <a id="3864" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="3866" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3868" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="3870" href="Preliminary.html#5363" class="Function">,</a> <a id="3872" class="Symbol">(</a><a id="3873" href="Ordinal.Order.html#3860" class="Bound">a</a> <a id="3875" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="3878" href="Ordinal.Order.html#1497" class="Bound">α</a> <a id="3880" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="3882" href="Ordinal.Order.html#3829" class="Bound">a′</a><a id="3884" class="Symbol">)</a> <a id="3886" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="3888" class="Symbol">(</a><a id="3889" href="Ordinal.Order.html#1521" class="Bound">f</a> <a id="3891" href="Ordinal.Order.html#3860" class="Bound">a</a> <a id="3893" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="3895" href="Ordinal.Order.html#3827" class="Bound">b</a><a id="3896" class="Symbol">))</a>
  <a id="3901" href="Ordinal.Order.html#3804" class="Function">isPropFormsInitSeg</a> <a id="3920" href="Ordinal.Order.html#3920" class="Bound">b</a> <a id="3922" href="Ordinal.Order.html#3922" class="Bound">a′</a> <a id="3925" href="Ordinal.Order.html#3925" class="Bound">b≺fa′</a> <a id="3931" class="Symbol">(</a><a id="3932" href="Ordinal.Order.html#3932" class="Bound">x</a> <a id="3934" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3936" href="Ordinal.Order.html#3936" class="Bound">x≺a′</a> <a id="3941" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3943" href="Ordinal.Order.html#3943" class="Bound">fx＝b</a><a id="3947" class="Symbol">)</a> <a id="3949" class="Symbol">(</a><a id="3950" href="Ordinal.Order.html#3950" class="Bound">y</a> <a id="3952" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3954" href="Ordinal.Order.html#3954" class="Bound">y≺a′</a> <a id="3959" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3961" href="Ordinal.Order.html#3961" class="Bound">fy＝b</a><a id="3965" class="Symbol">)</a> <a id="3967" class="Symbol">=</a> <a id="3969" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="3978" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="3980" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a>
    <a id="3991" class="Symbol">(λ</a> <a id="3994" href="Ordinal.Order.html#3994" class="Bound">_</a> <a id="3996" class="Symbol">→</a> <a id="3998" href="Cubical.Data.Equality.Conversion.html#5222" class="Function">isPropPathToIsProp</a> <a id="4017" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4019" href="Cubical.Foundations.HLevels.html#13315" class="Function">isProp×</a> <a id="4027" class="Symbol">(</a><a id="4028" href="Ordinal.Base.html#4729" class="Function">≺-prop</a> <a id="4035" class="Symbol">_</a> <a id="4037" class="Symbol">_)</a> <a id="4040" class="Symbol">(</a><a id="4041" href="Preliminary.html#10017" class="Function">transportIsProp</a> <a id="4057" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4059" href="Ordinal.Base.html#5183" class="Function">underlying-set</a> <a id="4074" class="Symbol">_</a> <a id="4076" class="Symbol">_))</a>
    <a id="4084" class="Symbol">(</a><a id="4085" href="Ordinal.Order.html#2360" class="Function">inj</a> <a id="4089" class="Symbol">(</a><a id="4090" href="Ordinal.Order.html#3943" class="Bound">fx＝b</a> <a id="4095" href="Cubical.Data.Equality.Base.html#754" class="Function Operator">∙</a> <a id="4097" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="4101" href="Ordinal.Order.html#3961" class="Bound">fy＝b</a><a id="4105" class="Symbol">))</a>
    <a id="4112" class="Keyword">where</a>
    <a id="4122" class="Keyword">open</a> <a id="4127" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="4134" class="Symbol">(</a><a id="4135" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4139" href="Ordinal.Order.html#1497" class="Bound">α</a><a id="4140" class="Symbol">)</a> <a id="4142" class="Keyword">using</a> <a id="4148" class="Symbol">(</a><a id="4149" href="Ordinal.Base.html#4729" class="Function">≺-prop</a><a id="4155" class="Symbol">)</a>
    <a id="4161" class="Keyword">open</a> <a id="4166" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="4173" class="Symbol">(</a><a id="4174" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="4178" href="Ordinal.Order.html#1509" class="Bound">β</a><a id="4179" class="Symbol">)</a> <a id="4181" class="Keyword">using</a> <a id="4187" class="Symbol">(</a><a id="4188" href="Ordinal.Base.html#5183" class="Function">underlying-set</a><a id="4202" class="Symbol">)</a>
</pre>
<p>于是嵌入性是命题.</p>
<pre class="Agda"><a id="isPropIsOrdEmbed"></a><a id="4228" href="Ordinal.Order.html#4228" class="Function">isPropIsOrdEmbed</a> <a id="4245" class="Symbol">:</a> <a id="4247" class="Symbol">{</a><a id="4248" href="Ordinal.Order.html#4248" class="Bound">α</a> <a id="4250" class="Symbol">:</a> <a id="4252" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="4256" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="4257" class="Symbol">}</a> <a id="4259" class="Symbol">{</a><a id="4260" href="Ordinal.Order.html#4260" class="Bound">β</a> <a id="4262" class="Symbol">:</a> <a id="4264" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="4268" href="Preliminary.html#2650" class="Generalizable">𝓋</a><a id="4269" class="Symbol">}</a> <a id="4271" class="Symbol">(</a><a id="4272" href="Ordinal.Order.html#4272" class="Bound">f</a> <a id="4274" class="Symbol">:</a> <a id="4276" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4278" href="Ordinal.Order.html#4248" class="Bound">α</a> <a id="4280" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="4282" class="Symbol">→</a> <a id="4284" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4286" href="Ordinal.Order.html#4260" class="Bound">β</a> <a id="4288" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="4289" class="Symbol">)</a> <a id="4291" class="Symbol">→</a> <a id="4293" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="4300" class="Symbol">(</a><a id="4301" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a> <a id="4312" href="Ordinal.Order.html#4272" class="Bound">f</a><a id="4313" class="Symbol">)</a>
<a id="4315" href="Ordinal.Order.html#4228" class="Function">isPropIsOrdEmbed</a> <a id="4332" class="Symbol">{</a><a id="4333" href="Ordinal.Order.html#4333" class="Bound">α</a><a id="4334" class="Symbol">}</a> <a id="4336" class="Symbol">{</a><a id="4337" href="Ordinal.Order.html#4337" class="Bound">β</a><a id="4338" class="Symbol">}</a> <a id="4340" href="Ordinal.Order.html#4340" class="Bound">f</a> <a id="4342" class="Symbol">=</a> <a id="4344" href="Cubical.Foundations.HLevels.html#8859" class="Function">isOfHLevelRetractFromIso</a> <a id="4369" class="Number">1</a> <a id="4371" href="Ordinal.Order.html#4414" class="Function">IsOrdEmbedIsoΣ</a> <a id="4386" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4388" href="Ordinal.Order.html#4485" class="Function">aux</a>
  <a id="4394" class="Keyword">where</a>
  <a id="4402" class="Keyword">unquoteDecl</a> <a id="4414" href="Ordinal.Order.html#4414" class="Function">IsOrdEmbedIsoΣ</a> <a id="4429" class="Symbol">=</a> <a id="4431" href="Cubical.Reflection.RecordEquiv.html#9804" class="Function">declareRecordIsoΣ</a> <a id="4449" href="Ordinal.Order.html#4414" class="Function">IsOrdEmbedIsoΣ</a> <a id="4464" class="Symbol">(</a><a id="4465" class="Keyword">quote</a> <a id="4471" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a><a id="4481" class="Symbol">)</a>
  <a id="4485" href="Ordinal.Order.html#4485" class="Function">aux</a> <a id="4489" class="Symbol">:</a> <a id="4491" class="Symbol">∀</a> <a id="4493" href="Ordinal.Order.html#4493" class="Bound">x</a> <a id="4495" href="Ordinal.Order.html#4495" class="Bound">y</a> <a id="4497" class="Symbol">→</a> <a id="4499" href="Ordinal.Order.html#4493" class="Bound">x</a> <a id="4501" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4503" href="Ordinal.Order.html#4495" class="Bound">y</a>
  <a id="4507" href="Ordinal.Order.html#4485" class="Function">aux</a> <a id="4511" href="Ordinal.Order.html#4511" class="Bound">x</a> <a id="4513" class="Symbol">_</a> <a id="4515" class="Symbol">=</a> <a id="4517" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="4524" class="Symbol">(</a><a id="4525" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="4534" href="Ordinal.Order.html#3520" class="Function">isPropPres≺</a> <a id="4546" class="Symbol">_</a> <a id="4548" class="Symbol">_</a> <a id="4550" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4552" href="Cubical.Foundations.HLevels.html#16598" class="Function">isPropΠ3</a> <a id="4561" href="Ordinal.Order.html#3804" class="Function">isPropFormsInitSeg</a> <a id="4580" class="Symbol">_</a> <a id="4582" class="Symbol">_)</a>
    <a id="4589" class="Keyword">where</a> <a id="4595" class="Keyword">open</a> <a id="4600" href="Ordinal.Order.html#1485" class="Module">IsOrdEmbed</a> <a id="4611" class="Symbol">{</a><a id="4612" class="Argument">α</a> <a id="4614" class="Symbol">=</a> <a id="4616" href="Ordinal.Order.html#4333" class="Bound">α</a><a id="4617" class="Symbol">}</a> <a id="4619" class="Symbol">{</a><a id="4620" href="Ordinal.Order.html#4337" class="Bound">β</a><a id="4621" class="Symbol">}</a> <a id="4623" class="Symbol">(</a><a id="4624" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a> <a id="4632" href="Ordinal.Order.html#4414" class="Function">IsOrdEmbedIsoΣ</a> <a id="4647" href="Ordinal.Order.html#4511" class="Bound">x</a><a id="4648" class="Symbol">)</a>
</pre>
<h3 id="唯一性">唯一性</h3>
<p><strong>引理</strong> 给定两个序数, 它们之间的嵌入唯一.<br />
<strong>证明</strong> 用函数的外延性以及底序的外延性, 使用与嵌入的单射性的证明类似的改写即证. ∎</p>
<pre class="Agda"><a id="ordEmbed-unique"></a><a id="4744" href="Ordinal.Order.html#4744" class="Function">ordEmbed-unique</a> <a id="4760" class="Symbol">:</a> <a id="4762" class="Symbol">{</a><a id="4763" href="Ordinal.Order.html#4763" class="Bound">α</a> <a id="4765" class="Symbol">:</a> <a id="4767" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="4771" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="4772" class="Symbol">}</a> <a id="4774" class="Symbol">{</a><a id="4775" href="Ordinal.Order.html#4775" class="Bound">β</a> <a id="4777" class="Symbol">:</a> <a id="4779" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="4783" href="Preliminary.html#2654" class="Generalizable">𝓊′</a><a id="4785" class="Symbol">}</a>
  <a id="4789" class="Symbol">(</a><a id="4790" href="Ordinal.Order.html#4790" class="Bound">f</a> <a id="4792" href="Ordinal.Order.html#4792" class="Bound">g</a> <a id="4794" class="Symbol">:</a> <a id="4796" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4798" href="Ordinal.Order.html#4763" class="Bound">α</a> <a id="4800" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="4802" class="Symbol">→</a> <a id="4804" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="4806" href="Ordinal.Order.html#4775" class="Bound">β</a> <a id="4808" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="4809" class="Symbol">)</a> <a id="4811" class="Symbol">→</a> <a id="4813" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a> <a id="4824" href="Ordinal.Order.html#4790" class="Bound">f</a> <a id="4826" class="Symbol">→</a> <a id="4828" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a> <a id="4839" href="Ordinal.Order.html#4792" class="Bound">g</a> <a id="4841" class="Symbol">→</a> <a id="4843" href="Ordinal.Order.html#4790" class="Bound">f</a> <a id="4845" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">＝</a> <a id="4847" href="Ordinal.Order.html#4792" class="Bound">g</a>
<a id="4849" href="Ordinal.Order.html#4744" class="Function">ordEmbed-unique</a> <a id="4865" class="Symbol">{</a><a id="4866" href="Ordinal.Order.html#4866" class="Bound">α</a><a id="4867" class="Symbol">}</a> <a id="4869" class="Symbol">{</a><a id="4870" href="Ordinal.Order.html#4870" class="Bound">β</a><a id="4871" class="Symbol">}</a> <a id="4873" href="Ordinal.Order.html#4873" class="Bound">f</a> <a id="4875" href="Ordinal.Order.html#4875" class="Bound">g</a> <a id="4877" href="Ordinal.Order.html#4877" class="Bound">f-ordEmb</a> <a id="4886" href="Ordinal.Order.html#4886" class="Bound">g-ordEmb</a> <a id="4895" class="Symbol">=</a>
  <a id="4899" href="Cubical.Data.Equality.Conversion.html#2858" class="Function">funExt</a> <a id="4906" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="4908" href="Ordinal.Base.html#6252" class="Function">elim</a> <a id="4913" class="Symbol">λ</a> <a id="4915" href="Ordinal.Order.html#4915" class="Bound">x</a> <a id="4917" href="Ordinal.Order.html#4917" class="Bound">IH</a> <a id="4920" class="Symbol">→</a> <a id="4922" href="Ordinal.Base.html#4790" class="Function">≺-ext</a> <a id="4928" class="Symbol">(</a><a id="4929" href="Ordinal.Order.html#4873" class="Bound">f</a> <a id="4931" href="Ordinal.Order.html#4915" class="Bound">x</a><a id="4932" class="Symbol">)</a> <a id="4934" class="Symbol">(</a><a id="4935" href="Ordinal.Order.html#4875" class="Bound">g</a> <a id="4937" href="Ordinal.Order.html#4915" class="Bound">x</a><a id="4938" class="Symbol">)</a> <a id="4940" class="Symbol">λ</a> <a id="4942" href="Ordinal.Order.html#4942" class="Bound">z</a> <a id="4944" class="Symbol">→</a>
    <a id="4950" class="Symbol">(λ</a> <a id="4953" href="Ordinal.Order.html#4953" class="Bound">z≺fx</a> <a id="4958" class="Symbol">→</a> <a id="4960" class="Keyword">let</a> <a id="4964" class="Symbol">(</a><a id="4965" href="Ordinal.Order.html#4965" class="Bound">a</a> <a id="4967" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4969" href="Ordinal.Order.html#4969" class="Bound">a≺x</a> <a id="4973" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4975" href="Ordinal.Order.html#4975" class="Bound">fa＝z</a><a id="4979" class="Symbol">)</a> <a id="4981" class="Symbol">=</a> <a id="4983" href="Ordinal.Order.html#1940" class="Field">formsInitSeg</a> <a id="4996" href="Ordinal.Order.html#4877" class="Bound">f-ordEmb</a> <a id="5005" href="Ordinal.Order.html#4942" class="Bound">z</a> <a id="5007" href="Ordinal.Order.html#4915" class="Bound">x</a> <a id="5009" href="Ordinal.Order.html#4953" class="Bound">z≺fx</a> <a id="5014" class="Keyword">in</a>
      <a id="5023" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="5033" class="Symbol">(</a><a id="5034" href="Ordinal.Base.html#6140" class="Function Operator">_≺</a> <a id="5037" href="Ordinal.Order.html#4875" class="Bound">g</a> <a id="5039" href="Ordinal.Order.html#4915" class="Bound">x</a><a id="5040" class="Symbol">)</a> <a id="5042" class="Symbol">(</a><a id="5043" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="5047" class="Symbol">(</a><a id="5048" href="Ordinal.Order.html#4917" class="Bound">IH</a> <a id="5051" href="Ordinal.Order.html#4965" class="Bound">a</a> <a id="5053" href="Ordinal.Order.html#4969" class="Bound">a≺x</a><a id="5056" class="Symbol">)</a> <a id="5058" href="Cubical.Data.Equality.Base.html#754" class="Function Operator">∙</a> <a id="5060" href="Ordinal.Order.html#4975" class="Bound">fa＝z</a><a id="5064" class="Symbol">)</a> <a id="5066" class="Symbol">(</a><a id="5067" href="Ordinal.Order.html#1889" class="Field">pres≺</a> <a id="5073" href="Ordinal.Order.html#4886" class="Bound">g-ordEmb</a> <a id="5082" href="Ordinal.Order.html#4965" class="Bound">a</a> <a id="5084" href="Ordinal.Order.html#4915" class="Bound">x</a> <a id="5086" href="Ordinal.Order.html#4969" class="Bound">a≺x</a><a id="5089" class="Symbol">))</a>
  <a id="5094" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5096" class="Symbol">(λ</a> <a id="5099" href="Ordinal.Order.html#5099" class="Bound">z≺gx</a> <a id="5104" class="Symbol">→</a> <a id="5106" class="Keyword">let</a> <a id="5110" class="Symbol">(</a><a id="5111" href="Ordinal.Order.html#5111" class="Bound">a</a> <a id="5113" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5115" href="Ordinal.Order.html#5115" class="Bound">a≺x</a> <a id="5119" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5121" href="Ordinal.Order.html#5121" class="Bound">ga＝z</a><a id="5125" class="Symbol">)</a> <a id="5127" class="Symbol">=</a> <a id="5129" href="Ordinal.Order.html#1940" class="Field">formsInitSeg</a> <a id="5142" href="Ordinal.Order.html#4886" class="Bound">g-ordEmb</a> <a id="5151" href="Ordinal.Order.html#4942" class="Bound">z</a> <a id="5153" href="Ordinal.Order.html#4915" class="Bound">x</a> <a id="5155" href="Ordinal.Order.html#5099" class="Bound">z≺gx</a> <a id="5160" class="Keyword">in</a>
      <a id="5169" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="5179" class="Symbol">(</a><a id="5180" href="Ordinal.Base.html#6140" class="Function Operator">_≺</a> <a id="5183" href="Ordinal.Order.html#4873" class="Bound">f</a> <a id="5185" href="Ordinal.Order.html#4915" class="Bound">x</a><a id="5186" class="Symbol">)</a> <a id="5188" class="Symbol">(</a><a id="5189" href="Ordinal.Order.html#4917" class="Bound">IH</a> <a id="5192" href="Ordinal.Order.html#5111" class="Bound">a</a> <a id="5194" href="Ordinal.Order.html#5115" class="Bound">a≺x</a> <a id="5198" href="Cubical.Data.Equality.Base.html#754" class="Function Operator">∙</a> <a id="5200" href="Ordinal.Order.html#5121" class="Bound">ga＝z</a><a id="5204" class="Symbol">)</a> <a id="5206" class="Symbol">(</a><a id="5207" href="Ordinal.Order.html#1889" class="Field">pres≺</a> <a id="5213" href="Ordinal.Order.html#4877" class="Bound">f-ordEmb</a> <a id="5222" href="Ordinal.Order.html#5111" class="Bound">a</a> <a id="5224" href="Ordinal.Order.html#4915" class="Bound">x</a> <a id="5226" href="Ordinal.Order.html#5115" class="Bound">a≺x</a><a id="5229" class="Symbol">))</a>
  <a id="5234" class="Keyword">where</a> <a id="5240" class="Keyword">open</a> <a id="5245" href="Ordinal.Order.html#1485" class="Module">IsOrdEmbed</a>
        <a id="5264" class="Keyword">open</a> <a id="5269" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="5276" class="Symbol">(</a><a id="5277" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5281" href="Ordinal.Order.html#4866" class="Bound">α</a><a id="5282" class="Symbol">)</a> <a id="5284" class="Keyword">using</a> <a id="5290" class="Symbol">(</a><a id="5291" href="Ordinal.Base.html#6252" class="Function">elim</a><a id="5295" class="Symbol">)</a>
        <a id="5305" class="Keyword">open</a> <a id="5310" href="Ordinal.Base.html#6040" class="Module">OrdStr</a> <a id="5317" class="Symbol">(</a><a id="5318" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5322" href="Ordinal.Order.html#4870" class="Bound">β</a><a id="5323" class="Symbol">)</a> <a id="5325" class="Keyword">using</a> <a id="5331" class="Symbol">(</a><a id="5332" href="Ordinal.Base.html#4790" class="Function">≺-ext</a><a id="5337" class="Symbol">;</a> <a id="5339" href="Ordinal.Base.html#6140" class="Field Operator">_≺_</a><a id="5342" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 序数等价也是一个序数嵌入.<br />
<strong>证明</strong> 要证序数等价的底层函数 <code>f</code> 保序且形成前段. 保序性即 <code>hPres≺</code> 的底层函数. 对任意 <code>b ≺ f a′</code>, 有 <code>f (f⁻¹ b) ＝ b</code>, 改写可得 <code>f (f⁻¹ b) ≺ f a′</code>, 再用 <code>hPres≺⁻¹</code> 即得 <code>(f⁻¹ b) ≺ a′</code>. 于是 <code>f⁻¹ b</code> 就是”形成前段”条件所要求的 <code>a</code>. ∎</p>
<pre class="Agda"><a id="IsOrdEquiv→IsOrdEmbed"></a><a id="5560" href="Ordinal.Order.html#5560" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="5582" class="Symbol">:</a> <a id="5584" class="Symbol">(</a><a id="5585" href="Ordinal.Order.html#5585" class="Bound">f</a> <a id="5587" class="Symbol">:</a> <a id="5589" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5591" href="Ordinal.Base.html#6687" class="Generalizable">α</a> <a id="5593" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="5595" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="5597" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="5599" href="Ordinal.Base.html#6689" class="Generalizable">β</a> <a id="5601" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="5602" class="Symbol">)</a> <a id="5604" class="Symbol">→</a> <a id="5606" href="Ordinal.Base.html#7016" class="Record">IsOrdEquiv</a> <a id="5617" class="Symbol">(</a><a id="5618" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5622" href="Ordinal.Base.html#6687" class="Generalizable">α</a><a id="5623" class="Symbol">)</a> <a id="5625" href="Ordinal.Order.html#5585" class="Bound">f</a> <a id="5627" class="Symbol">(</a><a id="5628" href="Cubical.Foundations.Structure.html#556" class="Function">str</a> <a id="5632" href="Ordinal.Base.html#6689" class="Generalizable">β</a><a id="5633" class="Symbol">)</a> <a id="5635" class="Symbol">→</a> <a id="5637" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a> <a id="5648" class="Symbol">(</a><a id="5649" href="Ordinal.Order.html#5585" class="Bound">f</a> <a id="5651" href="Preliminary.html#11232" class="Function Operator">⁺¹</a><a id="5653" class="Symbol">)</a>
<a id="5655" href="Ordinal.Order.html#5560" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="5677" class="Symbol">{</a><a id="5678" href="Ordinal.Order.html#5678" class="Bound">β</a><a id="5679" class="Symbol">}</a> <a id="5681" href="Ordinal.Order.html#5681" class="Bound">f</a> <a id="5683" href="Ordinal.Order.html#5683" class="Bound">ordEquiv</a> <a id="5692" class="Symbol">=</a> <a id="5694" href="Ordinal.Order.html#1575" class="InductiveConstructor">mkIsOrdEmbed</a>
  <a id="5709" class="Symbol">(λ</a> <a id="5712" href="Ordinal.Order.html#5712" class="Bound">a</a> <a id="5714" href="Ordinal.Order.html#5714" class="Bound">a′</a> <a id="5717" class="Symbol">→</a> <a id="5719" href="Ordinal.Base.html#7178" class="Field">hPres≺</a> <a id="5726" href="Ordinal.Order.html#5712" class="Bound">a</a> <a id="5728" href="Ordinal.Order.html#5714" class="Bound">a′</a> <a id="5731" href="Preliminary.html#11232" class="Function Operator">⁺¹</a><a id="5733" class="Symbol">)</a>
  <a id="5737" class="Symbol">(λ</a> <a id="5740" href="Ordinal.Order.html#5740" class="Bound">b</a> <a id="5742" href="Ordinal.Order.html#5742" class="Bound">a′</a> <a id="5745" href="Ordinal.Order.html#5745" class="Bound">b≺fa′</a> <a id="5751" class="Symbol">→</a> <a id="5753" class="Symbol">(</a><a id="5754" href="Ordinal.Order.html#5681" class="Bound">f</a> <a id="5756" href="Preliminary.html#11263" class="Function Operator">⁻¹</a><a id="5758" class="Symbol">)</a> <a id="5760" href="Ordinal.Order.html#5740" class="Bound">b</a>
    <a id="5766" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5768" class="Symbol">(</a><a id="5769" href="Ordinal.Base.html#7178" class="Field">hPres≺</a> <a id="5776" class="Symbol">_</a> <a id="5778" href="Ordinal.Order.html#5742" class="Bound">a′</a> <a id="5781" href="Preliminary.html#11263" class="Function Operator">⁻¹</a><a id="5783" class="Symbol">)</a> <a id="5785" class="Symbol">(</a><a id="5786" href="Cubical.Data.Equality.Base.html#978" class="Function">transport</a> <a id="5796" class="Symbol">(λ</a> <a id="5799" href="Ordinal.Order.html#5799" class="Bound">-</a> <a id="5801" class="Symbol">→</a> <a id="5803" href="Ordinal.Order.html#5799" class="Bound">-</a> <a id="5805" href="Ordinal.Order.html#928" class="Field">≺⟨</a> <a id="5808" href="Ordinal.Order.html#5678" class="Bound">β</a> <a id="5810" href="Ordinal.Order.html#928" class="Field">⟩</a> <a id="5812" class="Symbol">_)</a> <a id="5815" class="Symbol">(</a><a id="5816" href="Cubical.Data.Equality.Base.html#1064" class="Function">sym</a> <a id="5820" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5822" href="Preliminary.html#11331" class="Function">secEq</a> <a id="5828" href="Ordinal.Order.html#5681" class="Bound">f</a> <a id="5830" href="Ordinal.Order.html#5740" class="Bound">b</a><a id="5831" class="Symbol">)</a> <a id="5833" href="Ordinal.Order.html#5745" class="Bound">b≺fa′</a><a id="5838" class="Symbol">)</a>
    <a id="5844" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5846" href="Preliminary.html#11331" class="Function">secEq</a> <a id="5852" href="Ordinal.Order.html#5681" class="Bound">f</a> <a id="5854" href="Ordinal.Order.html#5740" class="Bound">b</a><a id="5855" class="Symbol">)</a>
  <a id="5859" class="Keyword">where</a> <a id="5865" class="Keyword">open</a> <a id="5870" href="Ordinal.Base.html#7016" class="Module">IsOrdEquiv</a> <a id="5881" href="Ordinal.Order.html#5683" class="Bound">ordEquiv</a>
</pre>
<p><strong>引理</strong> 给定两个序数, 它们之间的序数等价唯一.<br />
<strong>证明</strong> 由于”是序数等价”是命题, 只需证该等价的底层函数唯一. 又序数等价也是序数嵌入, 由序数嵌入的唯一性得证. ∎</p>
<pre class="Agda"><a id="isPropOrdEquiv"></a><a id="5998" href="Ordinal.Order.html#5998" class="Function">isPropOrdEquiv</a> <a id="6013" class="Symbol">:</a> <a id="6015" class="Symbol">(</a><a id="6016" href="Ordinal.Order.html#6016" class="Bound">α</a> <a id="6018" class="Symbol">:</a> <a id="6020" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6024" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="6025" class="Symbol">)</a> <a id="6027" class="Symbol">(</a><a id="6028" href="Ordinal.Order.html#6028" class="Bound">β</a> <a id="6030" class="Symbol">:</a> <a id="6032" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6036" href="Preliminary.html#2654" class="Generalizable">𝓊′</a><a id="6038" class="Symbol">)</a> <a id="6040" class="Symbol">→</a> <a id="6042" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="6049" class="Symbol">(</a><a id="6050" href="Ordinal.Order.html#6016" class="Bound">α</a> <a id="6052" href="Ordinal.Base.html#7681" class="Function Operator">≃ₒ</a> <a id="6055" href="Ordinal.Order.html#6028" class="Bound">β</a><a id="6056" class="Symbol">)</a>
<a id="6058" href="Ordinal.Order.html#5998" class="Function">isPropOrdEquiv</a> <a id="6073" href="Ordinal.Order.html#6073" class="Bound">α</a> <a id="6075" href="Ordinal.Order.html#6075" class="Bound">β</a> <a id="6077" class="Symbol">(</a><a id="6078" href="Ordinal.Order.html#6078" class="Bound">f</a> <a id="6080" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6082" href="Ordinal.Order.html#6082" class="Bound">f-ordEquiv</a><a id="6092" class="Symbol">)</a> <a id="6094" class="Symbol">(</a><a id="6095" href="Ordinal.Order.html#6095" class="Bound">g</a> <a id="6097" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6099" href="Ordinal.Order.html#6099" class="Bound">g-ordEquiv</a><a id="6109" class="Symbol">)</a> <a id="6111" class="Symbol">=</a> <a id="6113" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="6122" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6124" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a>
  <a id="6133" class="Symbol">(λ</a> <a id="6136" href="Ordinal.Order.html#6136" class="Bound">_</a> <a id="6138" class="Symbol">→</a> <a id="6140" href="Cubical.Data.Equality.Conversion.html#5222" class="Function">isPropPathToIsProp</a> <a id="6159" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6161" href="Ordinal.Base.html#7290" class="Function">isPropIsOrdEquiv</a> <a id="6178" class="Symbol">_</a> <a id="6180" class="Symbol">_</a> <a id="6182" class="Symbol">_)</a>
  <a id="6187" class="Symbol">(</a><a id="6188" href="Preliminary.html#11081" class="Function">equivEq</a> <a id="6196" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6198" href="Ordinal.Order.html#4744" class="Function">ordEmbed-unique</a> <a id="6214" class="Symbol">(</a><a id="6215" href="Ordinal.Order.html#6078" class="Bound">f</a> <a id="6217" href="Preliminary.html#11232" class="Function Operator">⁺¹</a><a id="6219" class="Symbol">)</a> <a id="6221" class="Symbol">(</a><a id="6222" href="Ordinal.Order.html#6095" class="Bound">g</a> <a id="6224" href="Preliminary.html#11232" class="Function Operator">⁺¹</a><a id="6226" class="Symbol">)</a>
    <a id="6232" class="Symbol">(</a><a id="6233" href="Ordinal.Order.html#5560" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="6255" href="Ordinal.Order.html#6078" class="Bound">f</a> <a id="6257" href="Ordinal.Order.html#6082" class="Bound">f-ordEquiv</a><a id="6267" class="Symbol">)</a>
    <a id="6273" class="Symbol">(</a><a id="6274" href="Ordinal.Order.html#5560" class="Function">IsOrdEquiv→IsOrdEmbed</a> <a id="6296" href="Ordinal.Order.html#6095" class="Bound">g</a> <a id="6298" href="Ordinal.Order.html#6099" class="Bound">g-ordEquiv</a><a id="6308" class="Symbol">))</a>
</pre>
<p><strong>推论</strong> 序数宇宙是集合.<br />
<strong>证明</strong> 即证两个序数的相等是命题, 由序数的泛等原理, 这等价于证两个序数间的等价唯一. ∎</p>
<pre class="Agda"><a id="isSetOrd"></a><a id="6393" href="Ordinal.Order.html#6393" class="Function">isSetOrd</a> <a id="6402" class="Symbol">:</a> <a id="6404" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="6410" class="Symbol">(</a><a id="6411" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6415" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="6416" class="Symbol">)</a>
<a id="6418" href="Ordinal.Order.html#6393" class="Function">isSetOrd</a> <a id="6427" href="Ordinal.Order.html#6427" class="Bound">α</a> <a id="6429" href="Ordinal.Order.html#6429" class="Bound">β</a> <a id="6431" class="Symbol">=</a> <a id="6433" class="Symbol">(</a><a id="6434" href="Ordinal.Order.html#6494" class="Function">equiv</a> <a id="6440" href="Preliminary.html#11232" class="Function Operator">⁺¹</a><a id="6442" class="Symbol">)</a> <a id="6444" class="Symbol">(</a><a id="6445" href="Cubical.Foundations.HLevels.html#22399" class="Function">isOfHLevelLift</a> <a id="6460" class="Number">1</a> <a id="6462" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6464" href="Ordinal.Order.html#5998" class="Function">isPropOrdEquiv</a> <a id="6479" href="Ordinal.Order.html#6427" class="Bound">α</a> <a id="6481" href="Ordinal.Order.html#6429" class="Bound">β</a><a id="6482" class="Symbol">)</a>
  <a id="6486" class="Keyword">where</a>
  <a id="6494" href="Ordinal.Order.html#6494" class="Function">equiv</a> <a id="6500" class="Symbol">:</a> <a id="6502" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="6509" class="Symbol">(</a><a id="6510" href="Cubical.Foundations.Prelude.html#19323" class="Record">Lift</a> <a id="6515" class="Symbol">(</a><a id="6516" href="Ordinal.Order.html#6427" class="Bound">α</a> <a id="6518" href="Ordinal.Base.html#7681" class="Function Operator">≃ₒ</a> <a id="6521" href="Ordinal.Order.html#6429" class="Bound">β</a><a id="6522" class="Symbol">))</a> <a id="6525" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="6527" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="6534" class="Symbol">(</a><a id="6535" href="Ordinal.Order.html#6427" class="Bound">α</a> <a id="6537" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6539" href="Ordinal.Order.html#6429" class="Bound">β</a><a id="6540" class="Symbol">)</a>
  <a id="6544" href="Ordinal.Order.html#6494" class="Function">equiv</a> <a id="6550" class="Symbol">=</a> <a id="6552" href="Cubical.Foundations.Equiv.Properties.html#6158" class="Function">cong≃</a> <a id="6558" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="6565" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6567" href="Cubical.Foundations.Equiv.html#3542" class="Function">compEquiv</a> <a id="6577" class="Symbol">(</a><a id="6578" href="Cubical.Foundations.Equiv.html#3368" class="Function">invEquiv</a> <a id="6587" href="Cubical.Foundations.Equiv.html#5297" class="Function">LiftEquiv</a><a id="6596" class="Symbol">)</a> <a id="6598" class="Symbol">(</a><a id="6599" href="Ordinal.Base.html#8332" class="Function">OrdinalPath</a> <a id="6611" href="Ordinal.Order.html#6427" class="Bound">α</a> <a id="6613" href="Ordinal.Order.html#6429" class="Bound">β</a><a id="6614" class="Symbol">)</a>
</pre>
<h2 id="非严格序">非严格序</h2>
<p>序数之间的非严格序 <code>_≤_</code> 定义为它们之间的嵌入的全体.</p>
<pre class="Agda"><a id="_≤_"></a><a id="6670" href="Ordinal.Order.html#6670" class="Function Operator">_≤_</a> <a id="6674" class="Symbol">:</a> <a id="6676" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6680" href="Preliminary.html#2648" class="Generalizable">𝓊</a> <a id="6682" class="Symbol">→</a> <a id="6684" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6688" href="Preliminary.html#2650" class="Generalizable">𝓋</a> <a id="6690" class="Symbol">→</a> <a id="6692" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6697" class="Symbol">(</a><a id="6698" href="Preliminary.html#2648" class="Generalizable">𝓊</a> <a id="6700" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="6702" href="Preliminary.html#2650" class="Generalizable">𝓋</a><a id="6703" class="Symbol">)</a>
<a id="6705" href="Ordinal.Order.html#6705" class="Bound">α</a> <a id="6707" href="Ordinal.Order.html#6670" class="Function Operator">≤</a> <a id="6709" href="Ordinal.Order.html#6709" class="Bound">β</a> <a id="6711" class="Symbol">=</a> <a id="6713" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="6715" class="Symbol">(</a><a id="6716" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6718" href="Ordinal.Order.html#6705" class="Bound">α</a> <a id="6720" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a> <a id="6722" class="Symbol">→</a> <a id="6724" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟨</a> <a id="6726" href="Ordinal.Order.html#6709" class="Bound">β</a> <a id="6728" href="Cubical.Foundations.Structure.html#639" class="Function Operator">⟩</a><a id="6729" class="Symbol">)</a> <a id="6731" href="Ordinal.Order.html#1485" class="Record">IsOrdEmbed</a>
</pre>
<p>因为嵌入是唯一的, 所以 <code>_≤_</code> 是命题.</p>
<pre class="Agda"><a id="≤-prop"></a><a id="6780" href="Ordinal.Order.html#6780" class="Function">≤-prop</a> <a id="6787" class="Symbol">:</a> <a id="6789" class="Symbol">(</a><a id="6790" href="Ordinal.Order.html#6790" class="Bound">α</a> <a id="6792" class="Symbol">:</a> <a id="6794" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6798" href="Preliminary.html#2648" class="Generalizable">𝓊</a><a id="6799" class="Symbol">)</a> <a id="6801" class="Symbol">(</a><a id="6802" href="Ordinal.Order.html#6802" class="Bound">β</a> <a id="6804" class="Symbol">:</a> <a id="6806" href="Ordinal.Base.html#6582" class="Function">Ord</a> <a id="6810" href="Preliminary.html#2650" class="Generalizable">𝓋</a><a id="6811" class="Symbol">)</a> <a id="6813" class="Symbol">→</a> <a id="6815" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="6822" class="Symbol">(</a><a id="6823" href="Ordinal.Order.html#6790" class="Bound">α</a> <a id="6825" href="Ordinal.Order.html#6670" class="Function Operator">≤</a> <a id="6827" href="Ordinal.Order.html#6802" class="Bound">β</a><a id="6828" class="Symbol">)</a>
<a id="6830" href="Ordinal.Order.html#6780" class="Function">≤-prop</a> <a id="6837" href="Ordinal.Order.html#6837" class="Bound">α</a> <a id="6839" href="Ordinal.Order.html#6839" class="Bound">β</a> <a id="6841" class="Symbol">(</a><a id="6842" href="Ordinal.Order.html#6842" class="Bound">f</a> <a id="6844" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6846" href="Ordinal.Order.html#6846" class="Bound">f-ordEmb</a><a id="6854" class="Symbol">)</a> <a id="6856" class="Symbol">(</a><a id="6857" href="Ordinal.Order.html#6857" class="Bound">g</a> <a id="6859" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6861" href="Ordinal.Order.html#6861" class="Bound">g-ordEmb</a><a id="6869" class="Symbol">)</a> <a id="6871" class="Symbol">=</a> <a id="6873" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="6882" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="6884" href="Cubical.Data.Equality.Conversion.html#3107" class="Function">Σ≡Prop</a>
  <a id="6893" class="Symbol">(</a><a id="6894" href="Cubical.Data.Equality.Conversion.html#5222" class="Function">isPropPathToIsProp</a> <a id="6913" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="6915" href="Ordinal.Order.html#4228" class="Function">isPropIsOrdEmbed</a><a id="6931" class="Symbol">)</a>
  <a id="6935" class="Symbol">(</a><a id="6936" href="Ordinal.Order.html#4744" class="Function">ordEmbed-unique</a> <a id="6952" href="Ordinal.Order.html#6842" class="Bound">f</a> <a id="6954" href="Ordinal.Order.html#6857" class="Bound">g</a> <a id="6956" href="Ordinal.Order.html#6846" class="Bound">f-ordEmb</a> <a id="6965" href="Ordinal.Order.html#6861" class="Bound">g-ordEmb</a><a id="6973" class="Symbol">)</a>
</pre>
<p>我们会在下一章定义了前段序数之后再定义严格序.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
