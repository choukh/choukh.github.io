<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (2.1 - 良构树序数的性质)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-2.1---良构树序数的性质" id="toc-形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</a>
  <ul>
  <li><a href="#序数运算" id="toc-序数运算">序数运算</a></li>
  <li><a href="#一些约定" id="toc-一些约定">一些约定</a></li>
  <li><a href="#一些引理" id="toc-一些引理">一些引理</a></li>
  <li><a href="#ω的性质" id="toc-ω的性质">ω的性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/WellFormed/Properties.lagda.md">Properties.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/WellFormed.Properties.html">Properties.html</a></p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/711649863">上一篇</a>我们定义了良构树序数并证明了一些基本性质, 本文将继续讨论它的更多性质.</p>
<pre class="Agda"><a id="474" class="Symbol">{-#</a> <a id="478" class="Keyword">OPTIONS</a> <a id="486" class="Pragma">--safe</a> <a id="493" class="Pragma">--cubical</a> <a id="503" class="Pragma">--lossy-unification</a> <a id="523" class="Symbol">#-}</a>
<a id="527" class="Keyword">module</a> <a id="534" href="WellFormed.Properties.html" class="Module">WellFormed.Properties</a> <a id="556" class="Keyword">where</a>
<a id="562" class="Keyword">open</a> <a id="567" class="Keyword">import</a> <a id="574" href="WellFormed.Base.html" class="Module">WellFormed.Base</a>
</pre>
<h2 id="序数运算">序数运算</h2>
<p>我们先定义关于序数运算的一些性质.</p>
<p><strong>约定 2-1-0</strong> 我们用</p>
<ul>
<li><span class="math inline">A</span> 表示任意类型.</li>
<li><span class="math inline">F</span> 表示 <span class="math inline">A</span> 上的一元运算.</li>
</ul>
<pre class="Agda"><a id="685" class="Keyword">private</a> <a id="693" class="Keyword">variable</a>
  <a id="704" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="706" class="Symbol">:</a> <a id="708" href="Agda.Primitive.html#388" class="Primitive">Type</a>
  <a id="715" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="717" class="Symbol">:</a> <a id="719" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="721" class="Symbol">→</a> <a id="723" href="WellFormed.Properties.html#704" class="Generalizable">A</a>
</pre>
<p><strong>定义 2-1-1</strong> 我们说 <span class="math inline">A</span> 上的一个运算 <span class="math inline">F : A → A</span> <strong>保持</strong> <span class="math inline">A</span> 上的一个二元关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">x \sim y \to F(x) \sim F(y)</span>.</p>
<pre class="Agda"><a id="_preserves_"></a><a id="858" href="WellFormed.Properties.html#858" class="Function Operator">_preserves_</a> <a id="870" class="Symbol">:</a> <a id="872" class="Symbol">(</a><a id="873" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="875" class="Symbol">→</a> <a id="877" href="WellFormed.Properties.html#704" class="Generalizable">A</a><a id="878" class="Symbol">)</a> <a id="880" class="Symbol">→</a> <a id="882" class="Symbol">(</a><a id="883" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="885" class="Symbol">→</a> <a id="887" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="889" class="Symbol">→</a> <a id="891" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="895" class="Symbol">)</a> <a id="897" class="Symbol">→</a> <a id="899" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="904" href="WellFormed.Properties.html#904" class="Bound">F</a> <a id="906" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="916" href="WellFormed.Properties.html#916" class="Bound Operator">_~_</a> <a id="920" class="Symbol">=</a> <a id="922" class="Symbol">∀</a> <a id="924" class="Symbol">{</a><a id="925" href="WellFormed.Properties.html#925" class="Bound">x</a> <a id="927" href="WellFormed.Properties.html#927" class="Bound">y</a><a id="928" class="Symbol">}</a> <a id="930" class="Symbol">→</a> <a id="932" href="WellFormed.Properties.html#925" class="Bound">x</a> <a id="934" href="WellFormed.Properties.html#916" class="Bound Operator">~</a> <a id="936" href="WellFormed.Properties.html#927" class="Bound">y</a> <a id="938" class="Symbol">→</a> <a id="940" href="WellFormed.Properties.html#904" class="Bound">F</a> <a id="942" href="WellFormed.Properties.html#925" class="Bound">x</a> <a id="944" href="WellFormed.Properties.html#916" class="Bound Operator">~</a> <a id="946" href="WellFormed.Properties.html#904" class="Bound">F</a> <a id="948" href="WellFormed.Properties.html#927" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-2</strong> 如果 <span class="math inline">F</span> 保持 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 保持 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-pres≤"></a><a id="1012" href="WellFormed.Properties.html#1012" class="Function">map-pres≤</a> <a id="1022" class="Symbol">:</a> <a id="1024" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="1026" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="1036" href="WellFormed.Base.html#3357" class="Function Operator">_&lt;_</a> <a id="1040" class="Symbol">→</a> <a id="1042" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="1044" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="1054" href="WellFormed.Base.html#11901" class="Function Operator">_≤_</a>
<a id="1058" href="WellFormed.Properties.html#1012" class="Function">map-pres≤</a> <a id="1068" href="WellFormed.Properties.html#1068" class="Bound">pres</a> <a id="1073" class="Symbol">(</a><a id="1074" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1078" href="WellFormed.Properties.html#1078" class="Bound">p</a><a id="1079" class="Symbol">)</a>    <a id="1084" class="Symbol">=</a> <a id="1086" href="WellFormed.Base.html#11913" class="Function">&lt;→≤</a> <a id="1090" class="Symbol">(</a><a id="1091" href="WellFormed.Properties.html#1068" class="Bound">pres</a> <a id="1096" href="WellFormed.Properties.html#1078" class="Bound">p</a><a id="1097" class="Symbol">)</a>
<a id="1099" href="WellFormed.Properties.html#1012" class="Function">map-pres≤</a> <a id="1109" href="WellFormed.Properties.html#1109" class="Bound">pres</a> <a id="1114" class="Symbol">(</a><a id="1115" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1119" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="1123" class="Symbol">)</a> <a id="1125" class="Symbol">=</a> <a id="1127" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1131" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义 2-1-3</strong> 我们说 <span class="math inline">A</span> 上的一个运算 <span class="math inline">F : A → A</span> <strong>单射</strong> <span class="math inline">A</span> 上的一个二元关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">F(x) \sim F(y) \to x \sim y</span>.</p>
<pre class="Agda"><a id="_injects_"></a><a id="1269" href="WellFormed.Properties.html#1269" class="Function Operator">_injects_</a> <a id="1279" class="Symbol">:</a> <a id="1281" class="Symbol">(</a><a id="1282" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="1284" class="Symbol">→</a> <a id="1286" href="WellFormed.Properties.html#704" class="Generalizable">A</a><a id="1287" class="Symbol">)</a> <a id="1289" class="Symbol">→</a> <a id="1291" class="Symbol">(</a><a id="1292" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="1294" class="Symbol">→</a> <a id="1296" href="WellFormed.Properties.html#704" class="Generalizable">A</a> <a id="1298" class="Symbol">→</a> <a id="1300" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1304" class="Symbol">)</a> <a id="1306" class="Symbol">→</a> <a id="1308" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="1313" href="WellFormed.Properties.html#1313" class="Bound">F</a> <a id="1315" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="1323" href="WellFormed.Properties.html#1323" class="Bound Operator">_~_</a> <a id="1327" class="Symbol">=</a> <a id="1329" class="Symbol">∀</a> <a id="1331" class="Symbol">{</a><a id="1332" href="WellFormed.Properties.html#1332" class="Bound">x</a> <a id="1334" href="WellFormed.Properties.html#1334" class="Bound">y</a><a id="1335" class="Symbol">}</a> <a id="1337" class="Symbol">→</a> <a id="1339" href="WellFormed.Properties.html#1313" class="Bound">F</a> <a id="1341" href="WellFormed.Properties.html#1332" class="Bound">x</a> <a id="1343" href="WellFormed.Properties.html#1323" class="Bound Operator">~</a> <a id="1345" href="WellFormed.Properties.html#1313" class="Bound">F</a> <a id="1347" href="WellFormed.Properties.html#1334" class="Bound">y</a> <a id="1349" class="Symbol">→</a> <a id="1351" href="WellFormed.Properties.html#1332" class="Bound">x</a> <a id="1353" href="WellFormed.Properties.html#1323" class="Bound Operator">~</a> <a id="1355" href="WellFormed.Properties.html#1334" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-4</strong> 如果 <span class="math inline">F</span> 单射 <span class="math inline">=</span> 且单射 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 单射 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-inj≤"></a><a id="1427" href="WellFormed.Properties.html#1427" class="Function">map-inj≤</a> <a id="1436" class="Symbol">:</a> <a id="1438" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="1440" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="1448" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="1452" class="Symbol">→</a> <a id="1454" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="1456" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="1464" href="WellFormed.Base.html#3357" class="Function Operator">_&lt;_</a> <a id="1468" class="Symbol">→</a> <a id="1470" href="WellFormed.Properties.html#715" class="Generalizable">F</a> <a id="1472" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="1480" href="WellFormed.Base.html#11901" class="Function Operator">_≤_</a>
<a id="1484" href="WellFormed.Properties.html#1427" class="Function">map-inj≤</a> <a id="1493" href="WellFormed.Properties.html#1493" class="Bound">inj</a> <a id="1497" href="WellFormed.Properties.html#1497" class="Bound">inj&lt;</a> <a id="1502" class="Symbol">(</a><a id="1503" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1507" href="WellFormed.Properties.html#1507" class="Bound">p</a><a id="1508" class="Symbol">)</a> <a id="1510" class="Symbol">=</a> <a id="1512" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1516" class="Symbol">(</a><a id="1517" href="WellFormed.Properties.html#1497" class="Bound">inj&lt;</a> <a id="1522" href="WellFormed.Properties.html#1507" class="Bound">p</a><a id="1523" class="Symbol">)</a>
<a id="1525" href="WellFormed.Properties.html#1427" class="Function">map-inj≤</a> <a id="1534" href="WellFormed.Properties.html#1534" class="Bound">inj</a> <a id="1538" href="WellFormed.Properties.html#1538" class="Bound">inj&lt;</a> <a id="1543" class="Symbol">(</a><a id="1544" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1548" href="WellFormed.Properties.html#1548" class="Bound">p</a><a id="1549" class="Symbol">)</a> <a id="1551" class="Symbol">=</a> <a id="1553" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1557" class="Symbol">(</a><a id="1558" href="WellFormed.Properties.html#1534" class="Bound">inj</a> <a id="1562" href="WellFormed.Properties.html#1548" class="Bound">p</a><a id="1563" class="Symbol">)</a>
</pre>
<h2 id="一些约定">一些约定</h2>
<p><strong>记法 2-1-5</strong> 隐参版极限构造子: 它们与原版的区别在于良构条件为隐式参数, 从而允许从上下文自动推断出它们, 而不用一一显式写出.</p>
<pre class="Agda"><a id="lim-"></a><a id="1660" href="WellFormed.Properties.html#1660" class="Function">lim-</a> <a id="1665" class="Symbol">:</a> <a id="1667" class="Symbol">(</a><a id="1668" href="WellFormed.Properties.html#1668" class="Bound">f</a> <a id="1670" class="Symbol">:</a> <a id="1672" href="WellFormed.Base.html#3639" class="Function">Seq</a><a id="1675" class="Symbol">)</a> <a id="1677" class="Symbol">{</a><a id="1678" href="WellFormed.Properties.html#1678" class="Bound">w</a> <a id="1680" class="Symbol">:</a> <a id="1682" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="1685" href="WellFormed.Properties.html#1668" class="Bound">f</a><a id="1686" class="Symbol">}</a> <a id="1688" class="Symbol">→</a> <a id="1690" href="WellFormed.Base.html#3160" class="Datatype">Ord</a>
<a id="1694" href="WellFormed.Properties.html#1660" class="Function">lim-</a> <a id="1699" href="WellFormed.Properties.html#1699" class="Bound">f</a> <a id="1701" class="Symbol">{</a><a id="1702" href="WellFormed.Properties.html#1702" class="Bound">w</a><a id="1703" class="Symbol">}</a> <a id="1705" class="Symbol">=</a> <a id="1707" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="1711" href="WellFormed.Properties.html#1699" class="Bound">f</a> <a id="1713" class="Symbol">⦃</a> <a id="1715" href="WellFormed.Properties.html#1702" class="Bound">w</a> <a id="1717" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的路径 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的路径记作 <span class="math inline">\text{rd}[n](r)</span>.</p>
<pre class="Agda"><a id="rd[_]"></a><a id="1821" href="WellFormed.Properties.html#1821" class="Function Operator">rd[_]</a> <a id="1827" class="Symbol">:</a> <a id="1829" class="Symbol">(</a><a id="1830" href="WellFormed.Properties.html#1830" class="Bound">n</a> <a id="1832" class="Symbol">:</a> <a id="1834" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1835" class="Symbol">)</a> <a id="1837" class="Symbol">{</a><a id="1838" href="WellFormed.Properties.html#1838" class="Bound">w</a> <a id="1840" class="Symbol">:</a> <a id="1842" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="1845" href="WellFormed.Base.html#3983" class="Generalizable">f</a><a id="1846" class="Symbol">}</a> <a id="1848" class="Symbol">→</a> <a id="1850" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="1855" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="1857" class="Symbol">(</a><a id="1858" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="1860" href="WellFormed.Properties.html#1830" class="Bound">n</a><a id="1861" class="Symbol">)</a> <a id="1863" class="Symbol">→</a> <a id="1865" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="1870" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="1872" class="Symbol">(</a><a id="1873" class="InductiveConstructor">lim</a> <a id="1877" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="1879" class="Symbol">⦃</a> <a id="1881" href="WellFormed.Properties.html#1838" class="Bound">w</a> <a id="1883" class="Symbol">⦄)</a>
<a id="1886" href="WellFormed.Properties.html#1821" class="Function Operator">rd[_]</a> <a id="1892" href="WellFormed.Properties.html#1892" class="Bound">n</a> <a id="1894" class="Symbol">=</a> <a id="1896" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="1900" class="Symbol">{</a><a id="1901" class="Argument">n</a> <a id="1903" class="Symbol">=</a> <a id="1905" href="WellFormed.Properties.html#1892" class="Bound">n</a><a id="1906" class="Symbol">}</a> <a id="1908" class="Symbol">⦃</a> <a id="1910" class="Symbol">_</a> <a id="1912" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的证明 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的证明记作 <span class="math inline">\text{&lt;}[n](r)</span>.</p>
<pre class="Agda"><a id="&lt;[_]"></a><a id="2015" href="WellFormed.Properties.html#2015" class="Function Operator">&lt;[_]</a> <a id="2020" class="Symbol">:</a> <a id="2022" class="Symbol">(</a><a id="2023" href="WellFormed.Properties.html#2023" class="Bound">n</a> <a id="2025" class="Symbol">:</a> <a id="2027" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2028" class="Symbol">)</a> <a id="2030" class="Symbol">{</a><a id="2031" href="WellFormed.Properties.html#2031" class="Bound">w</a> <a id="2033" class="Symbol">:</a> <a id="2035" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="2038" href="WellFormed.Base.html#3983" class="Generalizable">f</a><a id="2039" class="Symbol">}</a> <a id="2041" class="Symbol">→</a> <a id="2043" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="2045" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="2047" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="2049" href="WellFormed.Properties.html#2023" class="Bound">n</a> <a id="2051" class="Symbol">→</a> <a id="2053" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="2055" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="2057" class="InductiveConstructor">lim</a> <a id="2061" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="2063" class="Symbol">⦃</a> <a id="2065" href="WellFormed.Properties.html#2031" class="Bound">w</a> <a id="2067" class="Symbol">⦄</a>
<a id="2069" href="WellFormed.Properties.html#2015" class="Function Operator">&lt;[_]</a> <a id="2074" href="WellFormed.Properties.html#2074" class="Bound">n</a> <a id="2076" class="Symbol">=</a> <a id="2078" href="Cubical.HITs.PropositionalTruncation.Properties.html#6482" class="Function">map</a> <a id="2082" href="WellFormed.Properties.html#1821" class="Function Operator">rd[</a> <a id="2086" href="WellFormed.Properties.html#2074" class="Bound">n</a> <a id="2088" href="WellFormed.Properties.html#1821" class="Function Operator">]</a>
</pre>
<p><strong>约定 2-1-6</strong> 鉴于路径关系与子树关系的高度可互换性, 我们今后在自然语言中会适当地混淆两者, 例如把路径的构造说成是子树关系的证明, 或反之. 读者应该理解为是调用了上一篇的引理进行了两者的转换.</p>
<p>树序数的归纳定义允许我们快速判定一个序数是否是极限序数.</p>
<p><strong>定义 2-1-7</strong> 极限序数谓词: 它仅在遇到极限序数时为真. 该谓词是可判定的.</p>
<pre class="Agda"><a id="isLim"></a><a id="2285" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2291" class="Symbol">:</a> <a id="2293" href="WellFormed.Base.html#3160" class="Datatype">Ord</a> <a id="2297" class="Symbol">→</a> <a id="2299" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="2304" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2310" href="WellFormed.Base.html#4374" class="InductiveConstructor">zero</a> <a id="2315" class="Symbol">=</a> <a id="2317" href="Data.Empty.html#914" class="Function">⊥</a>
<a id="2319" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2325" class="Symbol">(</a><a id="2326" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="2330" href="WellFormed.Properties.html#2330" class="Bound">a</a><a id="2331" class="Symbol">)</a> <a id="2333" class="Symbol">=</a> <a id="2335" href="Data.Empty.html#914" class="Function">⊥</a>
<a id="2337" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2343" class="Symbol">(</a><a id="2344" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="2348" href="WellFormed.Properties.html#2348" class="Bound">f</a><a id="2349" class="Symbol">)</a> <a id="2351" class="Symbol">=</a> <a id="2353" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a>
</pre>
<p><strong>记法 2-1-8</strong> 极限序数的基本列: 如果 <span class="math inline">a</span> 是极限序数, 那么我们用 <span class="math inline">a[n]</span> 表示其基本列的第 <span class="math inline">n</span> 项. 由序数的定义有 <span class="math inline">a[n] &lt; a[n^+]</span>.</p>
<pre class="Agda"><a id="_[_]"></a><a id="2460" href="WellFormed.Properties.html#2460" class="Function Operator">_[_]</a> <a id="2465" class="Symbol">:</a> <a id="2467" class="Symbol">(</a><a id="2468" href="WellFormed.Properties.html#2468" class="Bound">a</a> <a id="2470" class="Symbol">:</a> <a id="2472" href="WellFormed.Base.html#3160" class="Datatype">Ord</a><a id="2475" class="Symbol">)</a> <a id="2477" class="Symbol">→</a> <a id="2479" class="Symbol">⦃</a> <a id="2481" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2487" href="WellFormed.Properties.html#2468" class="Bound">a</a> <a id="2489" class="Symbol">⦄</a> <a id="2491" class="Symbol">→</a> <a id="2493" href="WellFormed.Base.html#3639" class="Function">Seq</a>
<a id="2497" href="WellFormed.Properties.html#2460" class="Function Operator">_[_]</a> <a id="2502" class="Symbol">(</a><a id="2503" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="2507" href="WellFormed.Properties.html#2507" class="Bound">f</a><a id="2508" class="Symbol">)</a> <a id="2510" class="Symbol">=</a> <a id="2512" href="WellFormed.Properties.html#2507" class="Bound">f</a>

<a id="[]-wf"></a><a id="2515" href="WellFormed.Properties.html#2515" class="Function">[]-wf</a> <a id="2521" class="Symbol">:</a> <a id="2523" class="Symbol">⦃</a> <a id="2525" href="WellFormed.Properties.html#2525" class="Bound">_</a> <a id="2527" class="Symbol">:</a> <a id="2529" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="2535" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="2537" class="Symbol">⦄</a> <a id="2539" class="Symbol">→</a> <a id="2541" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="2543" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="2545" href="WellFormed.Base.html#3959" class="Generalizable">n</a> <a id="2547" href="WellFormed.Properties.html#2460" class="Function Operator">]</a> <a id="2549" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="2551" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="2553" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="2555" class="InductiveConstructor">suc</a> <a id="2559" href="WellFormed.Base.html#3959" class="Generalizable">n</a> <a id="2561" href="WellFormed.Properties.html#2460" class="Function Operator">]</a>
<a id="2563" href="WellFormed.Properties.html#2515" class="Function">[]-wf</a> <a id="2569" class="Symbol">{</a><a id="2570" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="2574" href="WellFormed.Properties.html#2574" class="Bound">f</a><a id="2575" class="Symbol">}</a> <a id="2577" class="Symbol">=</a> <a id="2579" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>定义 2-1-9</strong> 自然数到序数的嵌入 <span class="math inline">\text{fin} : ℕ → \text{Ord}</span></p>
<p><span class="math display">
\text{fin}(n) := \text{suc}^n(0)
</span></p>
<p>其中后继函数的上标 <span class="math inline">n</span> 表示迭代 <span class="math inline">n</span> 次.</p>
<pre class="Agda"><a id="2716" class="Keyword">open</a> <a id="2721" class="Keyword">import</a> <a id="2728" href="Lower.html" class="Module">Lower</a> <a id="2734" class="Keyword">public</a> <a id="2741" class="Keyword">using</a> <a id="2747" class="Symbol">(</a><a id="2748" href="Lower.html#1118" class="Function Operator">_∘ⁿ_</a><a id="2752" class="Symbol">)</a>
<a id="fin"></a><a id="2754" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="2758" class="Symbol">:</a> <a id="2760" href="WellFormed.Base.html#3639" class="Function">Seq</a>
<a id="2764" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="2768" href="WellFormed.Properties.html#2768" class="Bound">n</a> <a id="2770" class="Symbol">=</a> <a id="2772" class="Symbol">(</a><a id="2773" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="2777" href="Lower.html#1118" class="Function Operator">∘ⁿ</a> <a id="2780" href="WellFormed.Properties.html#2768" class="Bound">n</a><a id="2781" class="Symbol">)</a> <a id="2783" href="WellFormed.Base.html#4374" class="InductiveConstructor">zero</a>
</pre>
<p>非形式地, 后文中我们把 <span class="math inline">\text{fin}</span> 视作类型强转 (coercion).</p>
<p><strong>约定 2-1-10</strong> 数字字面量既可以表示自然数, 也可以表示序数. Agda 使用<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能实现该约定.</p>
<pre class="Agda"><a id="2987" class="Keyword">open</a> <a id="2992" class="Keyword">import</a> <a id="2999" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="3020" class="Keyword">public</a>
<a id="3027" class="Keyword">instance</a>
  <a id="nNat"></a><a id="3038" href="WellFormed.Properties.html#3038" class="Function">nNat</a> <a id="3043" class="Symbol">=</a> <a id="3045" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3052" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="3056" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3058" class="Keyword">record</a> <a id="3065" class="Symbol">{</a> <a id="3067" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3078" class="Symbol">=</a> <a id="3080" class="Symbol">λ</a> <a id="3082" href="WellFormed.Properties.html#3082" class="Bound">_</a> <a id="3084" class="Symbol">→</a> <a id="3086" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3088" class="Symbol">;</a> <a id="3090" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3098" class="Symbol">=</a> <a id="3100" class="Symbol">λ</a> <a id="3102" href="WellFormed.Properties.html#3102" class="Bound">n</a> <a id="3104" class="Symbol">→</a> <a id="3106" href="WellFormed.Properties.html#3102" class="Bound">n</a> <a id="3108" class="Symbol">}</a>
  <a id="nOrd"></a><a id="3112" href="WellFormed.Properties.html#3112" class="Function">nOrd</a> <a id="3117" class="Symbol">=</a> <a id="3119" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3126" href="WellFormed.Base.html#3160" class="Datatype">Ord</a> <a id="3130" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3132" class="Keyword">record</a> <a id="3139" class="Symbol">{</a> <a id="3141" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3152" class="Symbol">=</a> <a id="3154" class="Symbol">λ</a> <a id="3156" href="WellFormed.Properties.html#3156" class="Bound">_</a> <a id="3158" class="Symbol">→</a> <a id="3160" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3162" class="Symbol">;</a> <a id="3164" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3172" class="Symbol">=</a> <a id="3174" class="Symbol">λ</a> <a id="3176" href="WellFormed.Properties.html#3176" class="Bound">n</a> <a id="3178" class="Symbol">→</a> <a id="3180" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="3184" href="WellFormed.Properties.html#3176" class="Bound">n</a> <a id="3186" class="Symbol">}</a>
</pre>
<h2 id="一些引理">一些引理</h2>
<p><strong>事实 2-1-11</strong> 构造子的单射性</p>
<ul>
<li><span class="math inline">a^+ =b ^+ → a = b</span></li>
<li><span class="math inline">\lim f = \lim g → f = g</span></li>
</ul>
<pre class="Agda"><a id="suc-inj"></a><a id="3284" href="WellFormed.Properties.html#3284" class="Function">suc-inj</a> <a id="3292" class="Symbol">:</a> <a id="3294" class="InductiveConstructor">suc</a> <a id="3298" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3300" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3302" class="InductiveConstructor">suc</a> <a id="3306" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="3308" class="Symbol">→</a> <a id="3310" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3312" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3314" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="3316" href="WellFormed.Properties.html#3284" class="Function">suc-inj</a> <a id="3324" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3329" class="Symbol">=</a> <a id="3331" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lim-inj"></a><a id="3337" href="WellFormed.Properties.html#3337" class="Function">lim-inj</a> <a id="3345" class="Symbol">:</a> <a id="3347" class="Symbol">{</a><a id="3348" href="WellFormed.Properties.html#3348" class="Bound">wff</a> <a id="3352" class="Symbol">:</a> <a id="3354" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="3357" href="WellFormed.Base.html#3983" class="Generalizable">f</a><a id="3358" class="Symbol">}</a> <a id="3360" class="Symbol">{</a><a id="3361" href="WellFormed.Properties.html#3361" class="Bound">wfg</a> <a id="3365" class="Symbol">:</a> <a id="3367" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="3370" href="WellFormed.Base.html#3985" class="Generalizable">g</a><a id="3371" class="Symbol">}</a> <a id="3373" class="Symbol">→</a> <a id="3375" href="WellFormed.Base.html#4406" class="InductiveConstructor">Ord.lim</a> <a id="3383" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="3385" class="Symbol">⦃</a> <a id="3387" href="WellFormed.Properties.html#3348" class="Bound">wff</a> <a id="3391" class="Symbol">⦄</a> <a id="3393" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3395" class="InductiveConstructor">lim</a> <a id="3399" href="WellFormed.Base.html#3985" class="Generalizable">g</a> <a id="3401" class="Symbol">⦃</a> <a id="3403" href="WellFormed.Properties.html#3361" class="Bound">wfg</a> <a id="3407" class="Symbol">⦄</a> <a id="3409" class="Symbol">→</a> <a id="3411" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="3413" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3415" href="WellFormed.Base.html#3985" class="Generalizable">g</a>
<a id="3417" href="WellFormed.Properties.html#3337" class="Function">lim-inj</a> <a id="3425" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3430" class="Symbol">=</a> <a id="3432" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实 2-1-12</strong> 极限路径的反演: 如果 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span>, 那么存在一个自然数 <span class="math inline">n</span> 使得 <span class="math inline">b</span> 小于 <span class="math inline">a[n]</span>.</p>
<pre class="Agda"><a id="lim-inv-rd"></a><a id="3525" href="WellFormed.Properties.html#3525" class="Function">lim-inv-rd</a> <a id="3536" class="Symbol">:</a> <a id="3538" class="Symbol">⦃</a> <a id="3540" href="WellFormed.Properties.html#3540" class="Bound">_</a> <a id="3542" class="Symbol">:</a> <a id="3544" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="3550" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3552" class="Symbol">⦄</a> <a id="3554" class="Symbol">→</a> <a id="3556" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="3561" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="3563" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3565" class="Symbol">→</a> <a id="3567" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3570" href="WellFormed.Properties.html#3570" class="Bound">n</a> <a id="3572" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3574" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3576" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3578" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="3583" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="3585" class="Symbol">(</a><a id="3586" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3588" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="3590" href="WellFormed.Properties.html#3570" class="Bound">n</a> <a id="3592" href="WellFormed.Properties.html#2460" class="Function Operator">]</a><a id="3593" class="Symbol">)</a>
<a id="3595" href="WellFormed.Properties.html#3525" class="Function">lim-inv-rd</a> <a id="3606" class="Symbol">(</a><a id="3607" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="3611" href="WellFormed.Properties.html#3611" class="Bound">r</a><a id="3612" class="Symbol">)</a> <a id="3614" class="Symbol">=</a> <a id="3616" class="Symbol">_</a> <a id="3618" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3620" href="WellFormed.Properties.html#3611" class="Bound">r</a>

<a id="lim-inv"></a><a id="3623" href="WellFormed.Properties.html#3623" class="Function">lim-inv</a> <a id="3631" class="Symbol">:</a> <a id="3633" class="Symbol">⦃</a> <a id="3635" href="WellFormed.Properties.html#3635" class="Bound">_</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="3645" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3647" class="Symbol">⦄</a> <a id="3649" class="Symbol">→</a> <a id="3651" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="3653" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="3655" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3657" class="Symbol">→</a> <a id="3659" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3662" href="WellFormed.Properties.html#3662" class="Bound">n</a> <a id="3664" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3666" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3668" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3670" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="3672" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="3674" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="3676" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="3678" href="WellFormed.Properties.html#3662" class="Bound">n</a> <a id="3680" href="WellFormed.Properties.html#2460" class="Function Operator">]</a>
<a id="3682" href="WellFormed.Properties.html#3623" class="Function">lim-inv</a> <a id="3690" href="WellFormed.Properties.html#3690" class="Bound">r</a> <a id="3692" class="Keyword">with</a> <a id="3697" href="WellFormed.Properties.html#3525" class="Function">lim-inv-rd</a> <a id="3708" class="Symbol">(</a><a id="3709" href="WellFormed.Base.html#25668" class="Function">set</a> <a id="3713" href="WellFormed.Properties.html#3690" class="Bound">r</a><a id="3714" class="Symbol">)</a>
<a id="3716" class="Symbol">...</a> <a id="3720" class="Symbol">|</a> <a id="3722" href="WellFormed.Properties.html#3722" class="Bound">n</a> <a id="3724" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3726" href="WellFormed.Properties.html#3726" class="Bound">r</a> <a id="3728" class="Symbol">=</a> <a id="3730" href="WellFormed.Properties.html#3722" class="Bound">n</a> <a id="3732" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3734" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3736" href="WellFormed.Properties.html#3726" class="Bound">r</a> <a id="3738" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>鉴于互递归证明的特性, 我们有时会先声明定理, 然后再证明其所需的引理, 最后再证明定理本身.</p>
<p><strong>互递归 2-1-13</strong></p>
<p><span class="math display">
\begin{aligned}
(1)&amp; \quad a &lt; a^+ \\
(2)&amp; \quad 0 ≤ a
\end{aligned}
</span></p>
<pre class="Agda"><a id="z&lt;s-rd"></a><a id="3895" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a> <a id="3902" class="Symbol">:</a> <a id="3904" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="3909" class="Number">0</a> <a id="3911" class="Symbol">(</a><a id="3912" class="InductiveConstructor">suc</a> <a id="3916" href="WellFormed.Base.html#3967" class="Generalizable">a</a><a id="3917" class="Symbol">)</a>
<a id="z≤"></a><a id="3919" href="WellFormed.Properties.html#3919" class="Function">z≤</a> <a id="3922" class="Symbol">:</a> <a id="3924" class="Number">0</a> <a id="3926" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="3928" href="WellFormed.Base.html#3967" class="Generalizable">a</a>

<a id="z&lt;s"></a><a id="3931" href="WellFormed.Properties.html#3931" class="Function">z&lt;s</a> <a id="3935" class="Symbol">:</a> <a id="3937" class="Number">0</a> <a id="3939" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="3941" class="InductiveConstructor">suc</a> <a id="3945" href="WellFormed.Base.html#3967" class="Generalizable">a</a>
<a id="3947" href="WellFormed.Properties.html#3931" class="Function">z&lt;s</a> <a id="3951" class="Symbol">=</a> <a id="3953" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3955" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a> <a id="3962" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p><strong>引理 2-1-14</strong> 极限序数必然大于零.<br />
<strong>证明</strong> 由引理 2-1-13-(2) 和定理 2-0-48 即证. ∎</p>
<pre class="Agda"><a id="z&lt;l"></a><a id="4045" href="WellFormed.Properties.html#4045" class="Function">z&lt;l</a> <a id="4049" class="Symbol">:</a> <a id="4051" class="Symbol">{</a><a id="4052" href="WellFormed.Properties.html#4052" class="Bound">w</a> <a id="4054" class="Symbol">:</a> <a id="4056" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="4059" href="WellFormed.Base.html#3983" class="Generalizable">f</a><a id="4060" class="Symbol">}</a> <a id="4062" class="Symbol">→</a> <a id="4064" class="Number">0</a> <a id="4066" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="4068" class="InductiveConstructor">lim</a> <a id="4072" href="WellFormed.Base.html#3983" class="Generalizable">f</a> <a id="4074" class="Symbol">⦃</a> <a id="4076" href="WellFormed.Properties.html#4052" class="Bound">w</a> <a id="4078" class="Symbol">⦄</a>
<a id="4080" href="WellFormed.Properties.html#4045" class="Function">z&lt;l</a> <a id="4084" class="Symbol">{</a><a id="4085" href="WellFormed.Properties.html#4085" class="Bound">f</a><a id="4086" class="Symbol">}</a> <a id="4088" class="Symbol">{</a><a id="4089" href="WellFormed.Properties.html#4089" class="Bound">w</a><a id="4090" class="Symbol">}</a> <a id="4092" class="Symbol">=</a> <a id="4094" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="4109" class="Number">0</a>               <a id="4125" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="4128" href="WellFormed.Properties.html#3919" class="Function">z≤</a> <a id="4131" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="4135" href="WellFormed.Properties.html#4085" class="Bound">f</a> <a id="4137" class="Number">0</a>             <a id="4151" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="4154" href="WellFormed.Base.html#28098" class="Function">f&lt;l</a> <a id="4158" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="4162" href="WellFormed.Properties.html#1660" class="Function">lim-</a> <a id="4167" href="WellFormed.Properties.html#4085" class="Bound">f</a>          <a id="4178" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="4180" class="Keyword">where</a> <a id="4186" class="Keyword">open</a> <a id="4191" href="WellFormed.Base.html#14875" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>定理 2-1-13-(1)</strong> <span class="math inline">0 &lt; a^+</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 有 <span class="math inline">0 : 0 &lt; 0^+</span>.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 有归纳假设 <span class="math inline">r : 0 &lt; a&#39;^+</span>, 所以 <span class="math inline">r^+ : 0 &lt; a&#39;^{++}</span>.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 要证 <span class="math inline">a &lt; \lim(f)^+</span>, 由路径构造子 <span class="math inline">\text{suc}</span> 及引理 2-1-14 即得. ∎</li>
</ul>
<pre class="Agda"><a id="4439" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a> <a id="4446" class="Symbol">{(</a><a id="4448" href="WellFormed.Base.html#4374" class="InductiveConstructor">zero</a><a id="4452" class="Symbol">)}</a> <a id="4455" class="Symbol">=</a> <a id="4457" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a>
<a id="4462" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a> <a id="4469" class="Symbol">{</a><a id="4470" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="4474" href="WellFormed.Properties.html#4474" class="Bound">a</a><a id="4475" class="Symbol">}</a> <a id="4477" class="Symbol">=</a> <a id="4479" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="4483" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a>
<a id="4490" href="WellFormed.Properties.html#3895" class="Function">z&lt;s-rd</a> <a id="4497" class="Symbol">{</a><a id="4498" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="4502" href="WellFormed.Properties.html#4502" class="Bound">f</a><a id="4503" class="Symbol">}</a> <a id="4505" class="Symbol">=</a> <a id="4507" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="4511" class="Symbol">(</a><a id="4512" href="WellFormed.Base.html#25668" class="Function">set</a> <a id="4516" href="WellFormed.Properties.html#4045" class="Function">z&lt;l</a><a id="4519" class="Symbol">)</a>
</pre>
<p><strong>定理 2-1-13-(2)</strong> <span class="math inline">0 ≤ a</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳. 零的情况由自反性, 后继的情况由2-1-13-(1), 极限的情况由引理 2-1-14 即得. ∎</p>
<pre class="Agda"><a id="4631" href="WellFormed.Properties.html#3919" class="Function">z≤</a> <a id="4634" class="Symbol">{(</a><a id="4636" href="WellFormed.Base.html#4374" class="InductiveConstructor">zero</a><a id="4640" class="Symbol">)}</a> <a id="4643" class="Symbol">=</a> <a id="4645" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="4649" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="4654" href="WellFormed.Properties.html#3919" class="Function">z≤</a> <a id="4657" class="Symbol">{</a><a id="4658" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="4662" class="Symbol">_}</a>  <a id="4666" class="Symbol">=</a> <a id="4668" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="4672" href="WellFormed.Properties.html#3931" class="Function">z&lt;s</a>
<a id="4676" href="WellFormed.Properties.html#3919" class="Function">z≤</a> <a id="4679" class="Symbol">{</a><a id="4680" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="4684" class="Symbol">_}</a>  <a id="4688" class="Symbol">=</a> <a id="4690" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="4694" href="WellFormed.Properties.html#4045" class="Function">z&lt;l</a>
</pre>
<p><strong>互递归 2-1-17</strong></p>
<ul>
<li><ol type="1">
<li><span class="math inline">a &lt; b \to a^+ ≤ b</span>.</li>
</ol></li>
<li><ol start="2" type="1">
<li>后继运算保持 <span class="math inline">&lt;</span>.</li>
</ol></li>
</ul>
<pre class="Agda"><a id="&lt;→s≤-rd"></a><a id="4773" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="4781" class="Symbol">:</a> <a id="4783" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="4788" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="4790" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="4792" class="Symbol">→</a> <a id="4794" href="WellFormed.Base.html#11751" class="Function">NSRoad</a> <a id="4801" class="Symbol">(</a><a id="4802" class="InductiveConstructor">suc</a> <a id="4806" href="WellFormed.Base.html#3967" class="Generalizable">a</a><a id="4807" class="Symbol">)</a> <a id="4809" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="s&lt;s-rd"></a><a id="4811" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="4818" class="Symbol">:</a> <a id="4820" class="InductiveConstructor">suc</a> <a id="4824" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="4834" href="WellFormed.Base.html#3176" class="Datatype">Road</a>

<a id="&lt;→s≤"></a><a id="4840" href="WellFormed.Properties.html#4840" class="Function">&lt;→s≤</a> <a id="4845" class="Symbol">:</a> <a id="4847" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="4849" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="4851" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="4853" class="Symbol">→</a> <a id="4855" class="InductiveConstructor">suc</a> <a id="4859" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="4861" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="4863" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="4865" href="WellFormed.Properties.html#4840" class="Function">&lt;→s≤</a> <a id="4870" class="Symbol">=</a> <a id="4872" href="Cubical.HITs.PropositionalTruncation.Properties.html#857" class="Function">rec</a> <a id="4876" href="WellFormed.Base.html#12217" class="Function">isProp≤</a> <a id="4884" class="Symbol">(</a><a id="4885" href="WellFormed.Base.html#11968" class="Function">ns→≤</a> <a id="4890" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4892" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a><a id="4899" class="Symbol">)</a>

<a id="s&lt;s"></a><a id="4902" href="WellFormed.Properties.html#4902" class="Function">s&lt;s</a> <a id="4906" class="Symbol">:</a> <a id="4908" class="InductiveConstructor">suc</a> <a id="4912" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="4922" href="WellFormed.Base.html#3357" class="Function Operator">_&lt;_</a>
<a id="4926" href="WellFormed.Properties.html#4902" class="Function">s&lt;s</a> <a id="4930" class="Symbol">=</a> <a id="4932" href="Cubical.HITs.PropositionalTruncation.Properties.html#6482" class="Function">map</a> <a id="4936" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a>
</pre>
<p><strong>定理 2-1-17-(1)</strong> <span class="math inline">a &lt; b \to a^+ ≤ b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 由自反性即得 <span class="math inline">a^+ ≤ a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由定理 2-1-17-(2) 即得 <span class="math inline">a^+ ≤ b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 由定理 2-1-17-(2) 有 <span class="math inline">a^+ &lt; f(n)^+</span>, 由归纳假设有 <span class="math inline">f(n)^+ ≤ f(n^+)</span>, 由传递性即得 <span class="math inline">a^+ &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="5282" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="5290" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a> <a id="5295" class="Symbol">=</a> <a id="5297" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5301" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5306" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="5314" class="Symbol">(</a><a id="5315" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="5319" href="WellFormed.Properties.html#5319" class="Bound">r</a><a id="5320" class="Symbol">)</a> <a id="5322" class="Symbol">=</a> <a id="5324" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5328" class="Symbol">(</a><a id="5329" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5336" href="WellFormed.Properties.html#5319" class="Bound">r</a><a id="5337" class="Symbol">)</a>
<a id="5339" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="5347" class="Symbol">{</a><a id="5348" href="WellFormed.Properties.html#5348" class="Bound">a</a><a id="5349" class="Symbol">}</a> <a id="5351" class="Symbol">(</a><a id="5352" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="5356" class="Symbol">{</a><a id="5357" href="WellFormed.Properties.html#5357" class="Bound">f</a><a id="5358" class="Symbol">}</a> <a id="5360" class="Symbol">{</a><a id="5361" href="WellFormed.Properties.html#5361" class="Bound">n</a><a id="5362" class="Symbol">}</a> <a id="5364" href="WellFormed.Properties.html#5364" class="Bound">r</a><a id="5365" class="Symbol">)</a> <a id="5367" class="Symbol">=</a> <a id="5369" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5373" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5375" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="5390" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="5394" href="WellFormed.Properties.html#5348" class="Bound">a</a>           <a id="5406" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="5409" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5416" href="WellFormed.Properties.html#5364" class="Bound">r</a> <a id="5418" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="5422" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="5426" class="Symbol">(</a><a id="5427" href="WellFormed.Properties.html#5357" class="Bound">f</a> <a id="5429" href="WellFormed.Properties.html#5361" class="Bound">n</a><a id="5430" class="Symbol">)</a>       <a id="5438" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="5441" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="5449" class="Symbol">(</a><a id="5450" href="WellFormed.Base.html#25668" class="Function">set</a> <a id="5454" href="Function.Base.html#4736" class="Function">it</a><a id="5456" class="Symbol">)</a> <a id="5458" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="5462" href="WellFormed.Properties.html#5357" class="Bound">f</a> <a id="5464" class="Symbol">(</a><a id="5465" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5469" href="WellFormed.Properties.html#5361" class="Bound">n</a><a id="5470" class="Symbol">)</a>       <a id="5478" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="5481" href="WellFormed.Base.html#28164" class="Function">f&lt;l-rd</a> <a id="5488" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="5492" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="5496" href="WellFormed.Properties.html#5357" class="Bound">f</a>           <a id="5508" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="5510" class="Keyword">where</a> <a id="5516" class="Keyword">open</a> <a id="5521" href="WellFormed.Base.html#14665" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-17-(2)</strong> 后继运算保持 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳, 要证 <span class="math inline">a^+ &lt; b^+</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 有 <span class="math inline">0 : a^+ &lt; a^{++}</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由归纳假设即得 <span class="math inline">a^+ &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 与定理 2-1-17-(1) 同理可证 <span class="math inline">a^+ &lt; \lim(f)</span>, 再由路径构造子 <span class="math inline">\text{suc}</span> 即得 <span class="math inline">a^+ &lt; \lim(f)^+</span>. ∎</li>
</ul>
<pre class="Agda"><a id="5870" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5877" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a> <a id="5882" class="Symbol">=</a> <a id="5884" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a>
<a id="5889" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5896" class="Symbol">(</a><a id="5897" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="5901" href="WellFormed.Properties.html#5901" class="Bound">r</a><a id="5902" class="Symbol">)</a> <a id="5904" class="Symbol">=</a> <a id="5906" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="5910" class="Symbol">(</a><a id="5911" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5918" href="WellFormed.Properties.html#5901" class="Bound">r</a><a id="5919" class="Symbol">)</a>
<a id="5921" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5928" class="Symbol">{</a><a id="5929" href="WellFormed.Properties.html#5929" class="Bound">x</a><a id="5930" class="Symbol">}</a> <a id="5932" class="Symbol">(</a><a id="5933" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="5937" class="Symbol">{</a><a id="5938" href="WellFormed.Properties.html#5938" class="Bound">f</a><a id="5939" class="Symbol">}</a> <a id="5941" class="Symbol">{</a><a id="5942" href="WellFormed.Properties.html#5942" class="Bound">n</a><a id="5943" class="Symbol">}</a> <a id="5945" href="WellFormed.Properties.html#5945" class="Bound">r</a><a id="5946" class="Symbol">)</a> <a id="5948" class="Symbol">=</a> <a id="5950" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="5954" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5956" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="5971" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="5975" href="WellFormed.Properties.html#5929" class="Bound">x</a>           <a id="5987" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="5990" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="5997" href="WellFormed.Properties.html#5945" class="Bound">r</a> <a id="5999" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="6003" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="6007" class="Symbol">(</a><a id="6008" href="WellFormed.Properties.html#5938" class="Bound">f</a> <a id="6010" href="WellFormed.Properties.html#5942" class="Bound">n</a><a id="6011" class="Symbol">)</a>       <a id="6019" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="6022" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="6030" class="Symbol">(</a><a id="6031" href="WellFormed.Base.html#25668" class="Function">set</a> <a id="6035" href="Function.Base.html#4736" class="Function">it</a><a id="6037" class="Symbol">)</a> <a id="6039" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="6043" href="WellFormed.Properties.html#5938" class="Bound">f</a> <a id="6045" class="Symbol">(</a><a id="6046" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6050" href="WellFormed.Properties.html#5942" class="Bound">n</a><a id="6051" class="Symbol">)</a>       <a id="6059" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="6062" href="WellFormed.Base.html#28164" class="Function">f&lt;l-rd</a> <a id="6069" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="6073" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="6077" href="WellFormed.Properties.html#5938" class="Bound">f</a>           <a id="6089" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="6091" class="Keyword">where</a> <a id="6097" class="Keyword">open</a> <a id="6102" href="WellFormed.Base.html#14665" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-18</strong> 后继运算单射 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a^+ &lt; b^+</span> 归纳, 要证 <span class="math inline">a &lt; b</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a^+ &lt; a^{++}</span>, 有 <span class="math inline">0 : a &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a^+ &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a^+ &lt; b</span>. 由传递性即得 <span class="math inline">a &lt; a^+ &lt; b</span>.</li>
<li>没有 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 的情况, 因为 <span class="math inline">\lim(f)</span> 不可能是后继序数. ∎</li>
</ul>
<pre class="Agda"><a id="s&lt;s-inj-rd"></a><a id="6382" href="WellFormed.Properties.html#6382" class="Function">s&lt;s-inj-rd</a> <a id="6393" class="Symbol">:</a> <a id="6395" class="InductiveConstructor">suc</a> <a id="6399" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="6407" href="WellFormed.Base.html#3176" class="Datatype">Road</a>
<a id="6412" href="WellFormed.Properties.html#6382" class="Function">s&lt;s-inj-rd</a> <a id="6423" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a> <a id="6428" class="Symbol">=</a> <a id="6430" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a>
<a id="6435" href="WellFormed.Properties.html#6382" class="Function">s&lt;s-inj-rd</a> <a id="6446" class="Symbol">(</a><a id="6447" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="6451" href="WellFormed.Properties.html#6451" class="Bound">r</a><a id="6452" class="Symbol">)</a> <a id="6454" class="Symbol">=</a> <a id="6456" href="WellFormed.Base.html#9240" class="Function">rd-trans</a> <a id="6465" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a> <a id="6470" href="WellFormed.Properties.html#6451" class="Bound">r</a>

<a id="s&lt;s-inj"></a><a id="6473" href="WellFormed.Properties.html#6473" class="Function">s&lt;s-inj</a> <a id="6481" class="Symbol">:</a> <a id="6483" class="InductiveConstructor">suc</a> <a id="6487" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="6495" href="WellFormed.Base.html#3357" class="Function Operator">_&lt;_</a>
<a id="6499" href="WellFormed.Properties.html#6473" class="Function">s&lt;s-inj</a> <a id="6507" class="Symbol">=</a> <a id="6509" href="Cubical.HITs.PropositionalTruncation.Properties.html#6482" class="Function">map</a> <a id="6513" href="WellFormed.Properties.html#6382" class="Function">s&lt;s-inj-rd</a>
</pre>
<p><strong>推论 2-1-19</strong> 后继运算保持 <span class="math inline">\leq</span>, 且单射 <span class="math inline">\leq</span>.<br />
<strong>证明</strong> 由事实 2-1-2 和定理 2-1-17-(2) 可证保持; 由事实 2-1-4, 事实 2-1-11 和定理 2-1-18 可证单射. ∎</p>
<pre class="Agda"><a id="s≤s"></a><a id="6659" href="WellFormed.Properties.html#6659" class="Function">s≤s</a> <a id="6663" class="Symbol">:</a> <a id="6665" class="InductiveConstructor">suc</a> <a id="6669" href="WellFormed.Properties.html#858" class="Function Operator">preserves</a> <a id="6679" href="WellFormed.Base.html#11901" class="Function Operator">_≤_</a>
<a id="6683" href="WellFormed.Properties.html#6659" class="Function">s≤s</a> <a id="6687" class="Symbol">=</a> <a id="6689" href="WellFormed.Properties.html#1012" class="Function">map-pres≤</a> <a id="6699" href="WellFormed.Properties.html#4902" class="Function">s&lt;s</a>

<a id="s≤s-inj"></a><a id="6704" href="WellFormed.Properties.html#6704" class="Function">s≤s-inj</a> <a id="6712" class="Symbol">:</a> <a id="6714" class="InductiveConstructor">suc</a> <a id="6718" href="WellFormed.Properties.html#1269" class="Function Operator">injects</a> <a id="6726" href="WellFormed.Base.html#11901" class="Function Operator">_≤_</a>
<a id="6730" href="WellFormed.Properties.html#6704" class="Function">s≤s-inj</a> <a id="6738" class="Symbol">=</a> <a id="6740" href="WellFormed.Properties.html#1427" class="Function">map-inj≤</a> <a id="6749" href="WellFormed.Properties.html#3284" class="Function">suc-inj</a> <a id="6757" href="WellFormed.Properties.html#6473" class="Function">s&lt;s-inj</a>
</pre>
<p><strong>定理 2-1-20</strong> 定理 2-1-17-(1) 的逆命题 <span class="math inline">a^+ ≤ b → a &lt; b</span> 成立.<br />
<strong>证明</strong> 对 <span class="math inline">b</span> 归纳, 且讨论 <span class="math inline">r : a^+ ≤ b</span>.</p>
<ul>
<li><span class="math inline">b = 0</span> 的情况不可能.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ &lt; b&#39;^+</span>, 由推论 2-1-19 有 <span class="math inline">a &lt; b&#39;</span>, 所以 <span class="math inline">a &lt; b&#39;^+</span>.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ = b&#39;^+</span>, 目标改写变为 <span class="math inline">b&#39; &lt; b</span>, 显然成立.</li>
<li>若 <span class="math inline">b = \lim(f)</span>, <span class="math inline">r</span> 只能为 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 且 <span class="math inline">r&#39; : a^+ &lt; f(n)</span>, 由传递性即得 <span class="math inline">a &lt; a^+ &lt; f(n) &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="s≤→&lt;-rd"></a><a id="7130" href="WellFormed.Properties.html#7130" class="Function">s≤→&lt;-rd</a> <a id="7138" class="Symbol">:</a> <a id="7140" href="WellFormed.Base.html#11751" class="Function">NSRoad</a> <a id="7147" class="Symbol">(</a><a id="7148" class="InductiveConstructor">suc</a> <a id="7152" href="WellFormed.Base.html#3967" class="Generalizable">a</a><a id="7153" class="Symbol">)</a> <a id="7155" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="7157" class="Symbol">→</a> <a id="7159" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="7164" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7166" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="7168" href="WellFormed.Properties.html#7130" class="Function">s≤→&lt;-rd</a> <a id="7176" class="Symbol">{</a><a id="7177" class="Argument">b</a> <a id="7179" class="Symbol">=</a> <a id="7181" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="7185" href="WellFormed.Properties.html#7185" class="Bound">b</a><a id="7186" class="Symbol">}</a> <a id="7188" class="Symbol">(</a><a id="7189" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7193" href="WellFormed.Properties.html#7193" class="Bound">r</a><a id="7194" class="Symbol">)</a>       <a id="7202" class="Symbol">=</a> <a id="7204" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="7208" class="Symbol">(</a><a id="7209" href="WellFormed.Properties.html#6382" class="Function">s&lt;s-inj-rd</a> <a id="7220" href="WellFormed.Properties.html#7193" class="Bound">r</a><a id="7221" class="Symbol">)</a>
<a id="7223" href="WellFormed.Properties.html#7130" class="Function">s≤→&lt;-rd</a> <a id="7231" class="Symbol">{</a><a id="7232" class="Argument">b</a> <a id="7234" class="Symbol">=</a> <a id="7236" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="7240" href="WellFormed.Properties.html#7240" class="Bound">b</a><a id="7241" class="Symbol">}</a> <a id="7243" class="Symbol">(</a><a id="7244" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7248" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7252" class="Symbol">)</a>    <a id="7257" class="Symbol">=</a> <a id="7259" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a>
<a id="7264" href="WellFormed.Properties.html#7130" class="Function">s≤→&lt;-rd</a> <a id="7272" class="Symbol">{</a><a id="7273" class="Argument">b</a> <a id="7275" class="Symbol">=</a> <a id="7277" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="7281" href="WellFormed.Properties.html#7281" class="Bound">f</a><a id="7282" class="Symbol">}</a> <a id="7284" class="Symbol">(</a><a id="7285" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7289" class="Symbol">(</a><a id="7290" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="7294" href="WellFormed.Properties.html#7294" class="Bound">r</a><a id="7295" class="Symbol">))</a> <a id="7298" class="Symbol">=</a> <a id="7300" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="7304" class="Symbol">(</a><a id="7305" href="WellFormed.Base.html#9240" class="Function">rd-trans</a> <a id="7314" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a> <a id="7319" href="WellFormed.Properties.html#7294" class="Bound">r</a><a id="7320" class="Symbol">)</a>

<a id="s≤→&lt;"></a><a id="7323" href="WellFormed.Properties.html#7323" class="Function">s≤→&lt;</a> <a id="7328" class="Symbol">:</a> <a id="7330" class="InductiveConstructor">suc</a> <a id="7334" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7336" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="7338" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="7340" class="Symbol">→</a> <a id="7342" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7344" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="7346" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="7348" href="WellFormed.Properties.html#7323" class="Function">s≤→&lt;</a> <a id="7353" class="Symbol">(</a><a id="7354" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7358" href="WellFormed.Properties.html#7358" class="Bound">r</a><a id="7359" class="Symbol">)</a>    <a id="7364" class="Symbol">=</a> <a id="7366" href="Cubical.HITs.PropositionalTruncation.Properties.html#6482" class="Function">map</a> <a id="7370" class="Symbol">(</a><a id="7371" href="WellFormed.Properties.html#7130" class="Function">s≤→&lt;-rd</a> <a id="7379" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="7381" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a><a id="7384" class="Symbol">)</a> <a id="7386" href="WellFormed.Properties.html#7358" class="Bound">r</a>
<a id="7388" href="WellFormed.Properties.html#7323" class="Function">s≤→&lt;</a> <a id="7393" class="Symbol">(</a><a id="7394" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7398" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7402" class="Symbol">)</a> <a id="7404" class="Symbol">=</a> <a id="7406" href="WellFormed.Base.html#5157" class="InductiveConstructor">zero₁</a>
</pre>
<p><strong>定理 2-1-21</strong> 后继运算在极限序数下封闭.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span> 都有 <span class="math inline">b^+ &lt; a</span>. 讨论 <span class="math inline">r : b &lt; a</span>, 只能有 <span class="math inline">r = \lim(r&#39;) : b &lt; a</span>, 且 <span class="math inline">r&#39; : b &lt; a[n]</span>. 由定理 2-1-17 即传递性即得 <span class="math inline">b^+ &lt; a[n]^+ ≤ a</span>. ∎</p>
<pre class="Agda"><a id="s&lt;l-rd"></a><a id="7601" href="WellFormed.Properties.html#7601" class="Function">s&lt;l-rd</a> <a id="7608" class="Symbol">:</a> <a id="7610" class="Symbol">⦃</a> <a id="7612" href="WellFormed.Properties.html#7612" class="Bound">_</a> <a id="7614" class="Symbol">:</a> <a id="7616" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="7622" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7624" class="Symbol">⦄</a> <a id="7626" class="Symbol">→</a> <a id="7628" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="7633" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="7635" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7637" class="Symbol">→</a> <a id="7639" href="WellFormed.Base.html#3176" class="Datatype">Road</a> <a id="7644" class="Symbol">(</a><a id="7645" class="InductiveConstructor">suc</a> <a id="7649" href="WellFormed.Base.html#3969" class="Generalizable">b</a><a id="7650" class="Symbol">)</a> <a id="7652" href="WellFormed.Base.html#3967" class="Generalizable">a</a>
<a id="7654" href="WellFormed.Properties.html#7601" class="Function">s&lt;l-rd</a> <a id="7661" class="Symbol">{</a><a id="7662" href="WellFormed.Properties.html#7662" class="Bound">a</a><a id="7663" class="Symbol">}</a> <a id="7665" class="Symbol">{</a><a id="7666" href="WellFormed.Properties.html#7666" class="Bound">b</a><a id="7667" class="Symbol">}</a> <a id="7669" class="Symbol">(</a><a id="7670" href="WellFormed.Base.html#4912" class="InductiveConstructor">lim</a> <a id="7674" class="Symbol">{</a><a id="7675" href="WellFormed.Properties.html#7675" class="Bound">n</a><a id="7676" class="Symbol">}</a> <a id="7678" href="WellFormed.Properties.html#7678" class="Bound">r</a><a id="7679" class="Symbol">)</a> <a id="7681" class="Symbol">=</a> <a id="7683" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="7698" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="7702" href="WellFormed.Properties.html#7666" class="Bound">b</a>           <a id="7714" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="7717" href="WellFormed.Properties.html#4811" class="Function">s&lt;s-rd</a> <a id="7724" href="WellFormed.Properties.html#7678" class="Bound">r</a> <a id="7726" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="7730" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="7734" class="Symbol">(</a><a id="7735" href="WellFormed.Properties.html#7662" class="Bound">a</a> <a id="7737" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="7739" href="WellFormed.Properties.html#7675" class="Bound">n</a> <a id="7741" href="WellFormed.Properties.html#2460" class="Function Operator">]</a><a id="7742" class="Symbol">)</a>   <a id="7746" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="7749" href="WellFormed.Properties.html#4773" class="Function">&lt;→s≤-rd</a> <a id="7757" href="WellFormed.Base.html#28164" class="Function">f&lt;l-rd</a> <a id="7764" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="7768" href="WellFormed.Properties.html#7662" class="Bound">a</a>               <a id="7784" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="7786" class="Keyword">where</a> <a id="7792" class="Keyword">open</a> <a id="7797" href="WellFormed.Base.html#14665" class="Module">RoadReasoning</a>

<a id="s&lt;l"></a><a id="7812" href="WellFormed.Properties.html#7812" class="Function">s&lt;l</a> <a id="7816" class="Symbol">:</a> <a id="7818" class="Symbol">⦃</a> <a id="7820" href="WellFormed.Properties.html#7820" class="Bound">_</a> <a id="7822" class="Symbol">:</a> <a id="7824" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="7830" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7832" class="Symbol">⦄</a> <a id="7834" class="Symbol">→</a> <a id="7836" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="7838" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="7840" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="7842" class="Symbol">→</a> <a id="7844" class="InductiveConstructor">suc</a> <a id="7848" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="7850" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="7852" href="WellFormed.Base.html#3967" class="Generalizable">a</a>
<a id="7854" href="WellFormed.Properties.html#7812" class="Function">s&lt;l</a> <a id="7858" class="Symbol">=</a> <a id="7860" href="Cubical.HITs.PropositionalTruncation.Properties.html#6482" class="Function">map</a> <a id="7864" href="WellFormed.Properties.html#7601" class="Function">s&lt;l-rd</a>
</pre>
<p><strong>定理 2-1-22</strong> 直接前驱在极限序数上封闭.<br />
<strong>证明</strong> 要证对任意极限序数 <span class="math inline">a ≤ b^+</span> 有 <span class="math inline">a ≤ b</span>. 讨论 <span class="math inline">a ≤ b^+</span>.</p>
<ul>
<li>不可能有 <span class="math inline">a = b^+</span> 的情况, 因为 <span class="math inline">b^+</span> 不可能是极限序数.</li>
<li>若 <span class="math inline">a &lt; a^+</span>, 有 <span class="math inline">a = a</span>.</li>
<li>若 <span class="math inline">a &lt; b^+</span>, 必然有 <span class="math inline">a &lt; b</span>. ∎</li>
</ul>
<pre class="Agda"><a id="l≤p-rd"></a><a id="8065" href="WellFormed.Properties.html#8065" class="Function">l≤p-rd</a> <a id="8072" class="Symbol">:</a> <a id="8074" class="Symbol">⦃</a> <a id="8076" href="WellFormed.Properties.html#8076" class="Bound">_</a> <a id="8078" class="Symbol">:</a> <a id="8080" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="8086" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8088" class="Symbol">⦄</a> <a id="8090" class="Symbol">→</a> <a id="8092" href="WellFormed.Base.html#11751" class="Function">NSRoad</a> <a id="8099" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8101" class="Symbol">(</a><a id="8102" class="InductiveConstructor">suc</a> <a id="8106" href="WellFormed.Base.html#3969" class="Generalizable">b</a><a id="8107" class="Symbol">)</a> <a id="8109" class="Symbol">→</a> <a id="8111" href="WellFormed.Base.html#11751" class="Function">NSRoad</a> <a id="8118" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8120" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="8122" href="WellFormed.Properties.html#8065" class="Function">l≤p-rd</a> <a id="8129" class="Symbol">{</a><a id="8130" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="8134" href="WellFormed.Properties.html#8134" class="Bound">f</a><a id="8135" class="Symbol">}</a> <a id="8137" class="Symbol">(</a><a id="8138" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8142" href="WellFormed.Base.html#4853" class="InductiveConstructor">zero</a><a id="8146" class="Symbol">)</a>    <a id="8151" class="Symbol">=</a> <a id="8153" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="8157" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="8162" href="WellFormed.Properties.html#8065" class="Function">l≤p-rd</a> <a id="8169" class="Symbol">{</a><a id="8170" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="8174" href="WellFormed.Properties.html#8174" class="Bound">f</a><a id="8175" class="Symbol">}</a> <a id="8177" class="Symbol">(</a><a id="8178" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8182" class="Symbol">(</a><a id="8183" href="WellFormed.Base.html#4877" class="InductiveConstructor">suc</a> <a id="8187" href="WellFormed.Properties.html#8187" class="Bound">r</a><a id="8188" class="Symbol">))</a> <a id="8191" class="Symbol">=</a> <a id="8193" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8197" href="WellFormed.Properties.html#8187" class="Bound">r</a>

<a id="l≤p"></a><a id="8200" href="WellFormed.Properties.html#8200" class="Function">l≤p</a> <a id="8204" class="Symbol">:</a> <a id="8206" class="Symbol">⦃</a> <a id="8208" href="WellFormed.Properties.html#8208" class="Bound">_</a> <a id="8210" class="Symbol">:</a> <a id="8212" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="8218" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8220" class="Symbol">⦄</a> <a id="8222" class="Symbol">→</a> <a id="8224" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8226" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="8228" class="InductiveConstructor">suc</a> <a id="8232" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="8234" class="Symbol">→</a> <a id="8236" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="8238" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="8240" href="WellFormed.Base.html#3969" class="Generalizable">b</a>
<a id="8242" href="WellFormed.Properties.html#8200" class="Function">l≤p</a> <a id="8246" class="Symbol">{</a><a id="8247" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="8251" href="WellFormed.Properties.html#8251" class="Bound">f</a><a id="8252" class="Symbol">}</a> <a id="8254" class="Symbol">(</a><a id="8255" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8259" href="WellFormed.Properties.html#8259" class="Bound">r</a><a id="8260" class="Symbol">)</a> <a id="8262" class="Symbol">=</a> <a id="8264" href="WellFormed.Base.html#11968" class="Function">ns→≤</a> <a id="8269" class="Symbol">(</a><a id="8270" href="WellFormed.Properties.html#8065" class="Function">l≤p-rd</a> <a id="8277" class="Symbol">(</a><a id="8278" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8282" class="Symbol">(</a><a id="8283" href="WellFormed.Base.html#25668" class="Function">set</a> <a id="8287" href="WellFormed.Properties.html#8259" class="Bound">r</a><a id="8288" class="Symbol">)))</a>
</pre>
<h2 id="ω的性质">ω的性质</h2>
<p><strong>定义 2-1-23</strong> 由定义 2-1-9, 显然 <span class="math inline">\text{fin}</span> 是良构序列, 我们把 <span class="math inline">\lim(\text{fin})</span> 记作 <span class="math inline">\omega</span>.</p>
<pre class="Agda"><a id="8399" class="Keyword">instance</a>
  <a id="fin-wf"></a><a id="8410" href="WellFormed.Properties.html#8410" class="Function">fin-wf</a> <a id="8417" class="Symbol">:</a> <a id="8419" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="8422" href="WellFormed.Properties.html#2754" class="Function">fin</a>
  <a id="8428" href="WellFormed.Properties.html#8410" class="Function">fin-wf</a> <a id="8435" class="Symbol">=</a> <a id="8437" href="WellFormed.Base.html#5157" class="InductiveConstructor">zero₁</a>

<a id="ω"></a><a id="8444" href="WellFormed.Properties.html#8444" class="Function">ω</a> <a id="8446" class="Symbol">:</a> <a id="8448" href="WellFormed.Base.html#3160" class="Datatype">Ord</a>
<a id="8452" href="WellFormed.Properties.html#8444" class="Function">ω</a> <a id="8454" class="Symbol">=</a> <a id="8456" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="8460" href="WellFormed.Properties.html#2754" class="Function">fin</a>
</pre>
<p><strong>引理 2-1-24</strong> 有限序数 <span class="math inline">n</span> 都小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 由引理 2-1-15 可知零小于极限序数.</li>
<li>若 <span class="math inline">n</span> 为后继, 由定理 2-1-21 可知后继序数小于极限序数, 只要其直接前驱小于该极限序数, 而这是归纳假设. ∎</li>
</ul>
<pre class="Agda"><a id="n&lt;ω"></a><a id="8634" href="WellFormed.Properties.html#8634" class="Function">n&lt;ω</a> <a id="8638" class="Symbol">:</a> <a id="8640" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="8644" href="WellFormed.Base.html#3959" class="Generalizable">n</a> <a id="8646" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="8648" href="WellFormed.Properties.html#8444" class="Function">ω</a>
<a id="8650" href="WellFormed.Properties.html#8634" class="Function">n&lt;ω</a> <a id="8654" class="Symbol">{</a><a id="8655" class="Argument">n</a> <a id="8657" class="Symbol">=</a> <a id="8659" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="8663" class="Symbol">}</a>  <a id="8666" class="Symbol">=</a> <a id="8668" href="WellFormed.Properties.html#4045" class="Function">z&lt;l</a>
<a id="8672" href="WellFormed.Properties.html#8634" class="Function">n&lt;ω</a> <a id="8676" class="Symbol">{</a><a id="8677" class="Argument">n</a> <a id="8679" class="Symbol">=</a> <a id="8681" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8685" href="WellFormed.Properties.html#8685" class="Bound">n</a><a id="8686" class="Symbol">}</a> <a id="8688" class="Symbol">=</a> <a id="8690" href="WellFormed.Properties.html#7812" class="Function">s&lt;l</a> <a id="8694" href="WellFormed.Properties.html#8634" class="Function">n&lt;ω</a>
</pre>
<p><strong>引理 2-1-25</strong> 任意基本列的第 <span class="math inline">n</span> 项大于等于 <span class="math inline">n</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 显然 <span class="math inline">0 ≤ f(0)</span>.</li>
<li>若 <span class="math inline">n</span> 为后继, 由归纳假设 <span class="math inline">n ≤ f(n)</span> 可得 <span class="math inline">n^+ ≤ f(n)^+ &lt; f(n^+)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="n≤fn"></a><a id="8856" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="8861" class="Symbol">:</a> <a id="8863" class="Symbol">∀</a> <a id="8865" href="WellFormed.Properties.html#8865" class="Bound">f</a> <a id="8867" class="Symbol">→</a> <a id="8869" class="Symbol">⦃</a> <a id="8871" href="WellFormed.Properties.html#8871" class="Bound">_</a> <a id="8873" class="Symbol">:</a> <a id="8875" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="8878" href="WellFormed.Properties.html#8865" class="Bound">f</a> <a id="8880" class="Symbol">⦄</a> <a id="8882" class="Symbol">→</a> <a id="8884" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="8888" href="WellFormed.Base.html#3959" class="Generalizable">n</a> <a id="8890" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="8892" href="WellFormed.Properties.html#8865" class="Bound">f</a> <a id="8894" href="WellFormed.Base.html#3959" class="Generalizable">n</a>
<a id="8896" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="8901" class="Symbol">{</a><a id="8902" class="Argument">n</a> <a id="8904" class="Symbol">=</a> <a id="8906" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="8910" class="Symbol">}</a> <a id="8912" href="WellFormed.Properties.html#8912" class="Bound">f</a>   <a id="8916" class="Symbol">=</a> <a id="8918" href="WellFormed.Properties.html#3919" class="Function">z≤</a>
<a id="8921" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="8926" class="Symbol">{</a><a id="8927" class="Argument">n</a> <a id="8929" class="Symbol">=</a> <a id="8931" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8935" href="WellFormed.Properties.html#8935" class="Bound">n</a><a id="8936" class="Symbol">}</a> <a id="8938" href="WellFormed.Properties.html#8938" class="Bound">f</a>  <a id="8941" class="Symbol">=</a> <a id="8943" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="8951" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="8955" class="Symbol">(</a><a id="8956" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8960" href="WellFormed.Properties.html#8935" class="Bound">n</a><a id="8961" class="Symbol">)</a>         <a id="8971" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="8974" href="WellFormed.Properties.html#6659" class="Function">s≤s</a> <a id="8978" class="Symbol">(</a><a id="8979" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="8984" href="WellFormed.Properties.html#8938" class="Bound">f</a><a id="8985" class="Symbol">)</a> <a id="8987" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="8991" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="8995" class="Symbol">(</a><a id="8996" href="WellFormed.Properties.html#8938" class="Bound">f</a> <a id="8998" href="WellFormed.Properties.html#8935" class="Bound">n</a><a id="8999" class="Symbol">)</a>           <a id="9011" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="9014" href="WellFormed.Properties.html#4840" class="Function">&lt;→s≤</a> <a id="9019" href="Function.Base.html#4736" class="Function">it</a> <a id="9022" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="9026" href="WellFormed.Properties.html#8938" class="Bound">f</a> <a id="9028" class="Symbol">(</a><a id="9029" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9033" href="WellFormed.Properties.html#8935" class="Bound">n</a><a id="9034" class="Symbol">)</a>           <a id="9046" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="9048" class="Keyword">where</a> <a id="9054" class="Keyword">open</a> <a id="9059" href="WellFormed.Base.html#14875" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>推论 2-1-26</strong> 任意基本列的第 <span class="math inline">n^+</span> 项大于 <span class="math inline">n</span>.<br />
<strong>证明</strong> <span class="math inline">n ≤ f(n) &lt; f(n^+)</span>. ∎</p>
<pre class="Agda"><a id="n&lt;fs"></a><a id="9159" href="WellFormed.Properties.html#9159" class="Function">n&lt;fs</a> <a id="9164" class="Symbol">:</a> <a id="9166" class="Symbol">∀</a> <a id="9168" href="WellFormed.Properties.html#9168" class="Bound">f</a> <a id="9170" href="WellFormed.Properties.html#9170" class="Bound">n</a> <a id="9172" class="Symbol">→</a> <a id="9174" class="Symbol">⦃</a> <a id="9176" href="WellFormed.Properties.html#9176" class="Bound">_</a> <a id="9178" class="Symbol">:</a> <a id="9180" href="WellFormed.Base.html#3813" class="Function">wf</a> <a id="9183" href="WellFormed.Properties.html#9168" class="Bound">f</a> <a id="9185" class="Symbol">⦄</a> <a id="9187" class="Symbol">→</a> <a id="9189" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="9193" href="WellFormed.Properties.html#9170" class="Bound">n</a> <a id="9195" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="9197" href="WellFormed.Properties.html#9168" class="Bound">f</a> <a id="9199" class="Symbol">(</a><a id="9200" class="InductiveConstructor">suc</a> <a id="9204" href="WellFormed.Properties.html#9170" class="Bound">n</a><a id="9205" class="Symbol">)</a>
<a id="9207" href="WellFormed.Properties.html#9159" class="Function">n&lt;fs</a> <a id="9212" href="WellFormed.Properties.html#9212" class="Bound">f</a> <a id="9214" class="Symbol">_</a> <a id="9216" class="Symbol">=</a> <a id="9218" href="WellFormed.Base.html#13919" class="Function">≤-&lt;-trans</a> <a id="9228" class="Symbol">(</a><a id="9229" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="9234" href="WellFormed.Properties.html#9212" class="Bound">f</a><a id="9235" class="Symbol">)</a> <a id="9237" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-27</strong> 没有极限序数小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 假设有这样的序数 <span class="math inline">a</span>. 由事实 2-1-12, 存在 <span class="math inline">n</span> 使得 <span class="math inline">a &lt; n</span>. 但由引理 2-1-25 又有 <span class="math inline">n ≤ a[n] &lt; a</span>. 由传递性有 <span class="math inline">n &lt; n</span>, 违反 <span class="math inline">&lt;</span> 的反自反性. ∎</p>
<pre class="Agda"><a id="l≮ω"></a><a id="9403" href="WellFormed.Properties.html#9403" class="Function">l≮ω</a> <a id="9407" class="Symbol">:</a> <a id="9409" class="Symbol">⦃</a> <a id="9411" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="9417" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="9419" class="Symbol">⦄</a> <a id="9421" class="Symbol">→</a> <a id="9423" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="9425" href="WellFormed.Base.html#3361" class="Function Operator">≮</a> <a id="9427" href="WellFormed.Properties.html#8444" class="Function">ω</a>
<a id="9429" href="WellFormed.Properties.html#9403" class="Function">l≮ω</a> <a id="9433" href="WellFormed.Properties.html#9433" class="Bound">a</a><a id="9434" class="Symbol">@{</a><a id="9436" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="9440" href="WellFormed.Properties.html#9440" class="Bound">f</a><a id="9441" class="Symbol">}</a> <a id="9443" href="WellFormed.Properties.html#9443" class="Bound">r</a> <a id="9445" class="Symbol">=</a> <a id="9447" class="Keyword">let</a> <a id="9451" href="WellFormed.Properties.html#9451" class="Bound">n</a> <a id="9453" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9455" href="WellFormed.Properties.html#9455" class="Bound">r</a> <a id="9457" class="Symbol">=</a> <a id="9459" href="WellFormed.Properties.html#3623" class="Function">lim-inv</a> <a id="9467" href="WellFormed.Properties.html#9443" class="Bound">r</a> <a id="9469" class="Keyword">in</a> <a id="9472" href="WellFormed.Base.html#10928" class="Function">&lt;-irrefl</a> <a id="9481" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9486" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9488" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="9503" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="9507" href="WellFormed.Properties.html#9451" class="Bound">n</a>               <a id="9523" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="9526" href="WellFormed.Properties.html#8856" class="Function">n≤fn</a> <a id="9531" href="WellFormed.Properties.html#9440" class="Bound">f</a> <a id="9533" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="9537" href="WellFormed.Properties.html#9433" class="Bound">a</a> <a id="9539" href="WellFormed.Properties.html#2460" class="Function Operator">[</a> <a id="9541" href="WellFormed.Properties.html#9451" class="Bound">n</a> <a id="9543" href="WellFormed.Properties.html#2460" class="Function Operator">]</a>             <a id="9557" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="9560" href="WellFormed.Base.html#28098" class="Function">f&lt;l</a> <a id="9564" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="9568" href="WellFormed.Properties.html#9433" class="Bound">a</a>                   <a id="9588" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="9591" href="WellFormed.Properties.html#9455" class="Bound">r</a> <a id="9593" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="9597" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="9601" href="WellFormed.Properties.html#9451" class="Bound">n</a>               <a id="9617" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="9619" class="Keyword">where</a> <a id="9625" class="Keyword">open</a> <a id="9630" href="WellFormed.Base.html#14875" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>引理 2-1-28</strong> 忽略非同株, <span class="math inline">\omega</span> 是最小的极限序数.<br />
<strong>证明</strong> 对任意与 <span class="math inline">\omega</span> 同株的极限序数 <span class="math inline">a</span>, 由推论 2-0-34, 讨论 <span class="math inline">\omega</span> 与 <span class="math inline">a</span> 的大小关系. 若 <span class="math inline">a &lt; \omega</span>, 由引理 2-1-27 可得矛盾. 所以只能有 <span class="math inline">ω ≤ a</span>. ∎</p>
<pre class="Agda"><a id="ω≤l"></a><a id="9824" href="WellFormed.Properties.html#9824" class="Function">ω≤l</a> <a id="9828" class="Symbol">:</a> <a id="9830" class="Symbol">⦃</a> <a id="9832" href="WellFormed.Properties.html#2285" class="Function">isLim</a> <a id="9838" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="9840" class="Symbol">⦄</a> <a id="9842" class="Symbol">→</a> <a id="9844" href="WellFormed.Properties.html#8444" class="Function">ω</a> <a id="9846" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="9848" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="9850" class="Symbol">→</a> <a id="9852" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="9854" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="9856" href="WellFormed.Base.html#3969" class="Generalizable">b</a> <a id="9858" class="Symbol">→</a> <a id="9860" href="WellFormed.Properties.html#8444" class="Function">ω</a> <a id="9862" href="WellFormed.Base.html#11901" class="Function Operator">≤</a> <a id="9864" href="WellFormed.Base.html#3967" class="Generalizable">a</a>
<a id="9866" href="WellFormed.Properties.html#9824" class="Function">ω≤l</a> <a id="9870" class="Symbol">{</a><a id="9871" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="9875" href="WellFormed.Properties.html#9875" class="Bound">f</a><a id="9876" class="Symbol">}</a> <a id="9878" href="WellFormed.Properties.html#9878" class="Bound">r</a> <a id="9880" href="WellFormed.Properties.html#9880" class="Bound">s</a> <a id="9882" class="Keyword">with</a> <a id="9887" href="WellFormed.Base.html#18774" class="Function">&lt;-connex</a> <a id="9896" href="WellFormed.Properties.html#9878" class="Bound">r</a> <a id="9898" href="WellFormed.Properties.html#9880" class="Bound">s</a>
<a id="9900" class="Symbol">...</a> <a id="9904" class="Symbol">|</a> <a id="9906" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="9910" href="WellFormed.Properties.html#9910" class="Bound">r</a>           <a id="9922" class="Symbol">=</a> <a id="9924" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="9928" href="WellFormed.Properties.html#9910" class="Bound">r</a>
<a id="9930" class="Symbol">...</a> <a id="9934" class="Symbol">|</a> <a id="9936" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="9940" class="Symbol">(</a><a id="9941" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="9945" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="9949" class="Symbol">)</a>  <a id="9952" class="Symbol">=</a> <a id="9954" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="9958" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="9963" class="Symbol">...</a> <a id="9967" class="Symbol">|</a> <a id="9969" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="9973" class="Symbol">(</a><a id="9974" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="9978" href="WellFormed.Properties.html#9978" class="Bound">r</a><a id="9979" class="Symbol">)</a>     <a id="9985" class="Symbol">=</a> <a id="9987" href="Data.Empty.html#1069" class="Function">⊥-elim</a> <a id="9994" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9996" href="WellFormed.Properties.html#9403" class="Function">l≮ω</a> <a id="10000" href="WellFormed.Properties.html#9978" class="Bound">r</a>
</pre>
<p><strong>引理 2-1-29</strong> <span class="math inline">\text{fin}</span> 单射 <span class="math inline">=</span>.<br />
<strong>证明</strong> 对 <span class="math inline">m, n</span> 归纳即得. ∎</p>
<pre class="Agda"><a id="fin-inj"></a><a id="10077" href="WellFormed.Properties.html#10077" class="Function">fin-inj</a> <a id="10085" class="Symbol">:</a> <a id="10087" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="10091" href="WellFormed.Base.html#3957" class="Generalizable">m</a> <a id="10093" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10095" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="10099" href="WellFormed.Base.html#3959" class="Generalizable">n</a> <a id="10101" class="Symbol">→</a> <a id="10103" href="WellFormed.Base.html#3957" class="Generalizable">m</a> <a id="10105" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10107" href="WellFormed.Base.html#3959" class="Generalizable">n</a>
<a id="10109" href="WellFormed.Properties.html#10077" class="Function">fin-inj</a> <a id="10117" class="Symbol">{(</a><a id="10119" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10123" class="Symbol">)}</a> <a id="10126" class="Symbol">{(</a><a id="10128" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10132" class="Symbol">)}</a> <a id="10135" href="WellFormed.Properties.html#10135" class="Bound">eq</a> <a id="10138" class="Symbol">=</a> <a id="10140" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10145" href="WellFormed.Properties.html#10077" class="Function">fin-inj</a> <a id="10153" class="Symbol">{</a><a id="10154" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10158" href="WellFormed.Properties.html#10158" class="Bound">m</a><a id="10159" class="Symbol">}</a>  <a id="10162" class="Symbol">{</a><a id="10163" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10167" href="WellFormed.Properties.html#10167" class="Bound">n</a><a id="10168" class="Symbol">}</a>  <a id="10171" href="WellFormed.Properties.html#10171" class="Bound">eq</a> <a id="10174" class="Symbol">=</a> <a id="10176" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="10181" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10185" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10187" href="WellFormed.Properties.html#10077" class="Function">fin-inj</a> <a id="10195" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10197" href="WellFormed.Properties.html#3284" class="Function">suc-inj</a> <a id="10205" href="WellFormed.Properties.html#10171" class="Bound">eq</a>
</pre>
<p><strong>引理 2-1-30</strong> <span class="math inline">\text{fin}</span> 满射 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">a &lt; ω</span> 都存在 <span class="math inline">n</span> 使得 <span class="math inline">n = a</span>. 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 取 <span class="math inline">n = 0</span> 即可.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 由归纳假设可得一个 <span class="math inline">n&#39; = a&#39;</span>. 取 <span class="math inline">n = n&#39;^+</span> 即可.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 由引理 2-1-27 可得矛盾. ∎</li>
</ul>
<pre class="Agda"><a id="fin-suj"></a><a id="10435" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="10443" class="Symbol">:</a> <a id="10445" href="WellFormed.Base.html#3967" class="Generalizable">a</a> <a id="10447" href="WellFormed.Base.html#3357" class="Function Operator">&lt;</a> <a id="10449" href="WellFormed.Properties.html#8444" class="Function">ω</a> <a id="10451" class="Symbol">→</a> <a id="10453" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="10456" href="WellFormed.Properties.html#10456" class="Bound">n</a> <a id="10458" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="10460" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10462" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="10464" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="10468" href="WellFormed.Properties.html#10456" class="Bound">n</a> <a id="10470" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10472" href="WellFormed.Base.html#3967" class="Generalizable">a</a>
<a id="10474" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="10482" class="Symbol">{(</a><a id="10484" href="WellFormed.Base.html#4374" class="InductiveConstructor">zero</a><a id="10488" class="Symbol">)}</a> <a id="10491" href="WellFormed.Properties.html#10491" class="Bound">r</a>  <a id="10494" class="Symbol">=</a> <a id="10496" class="Number">0</a> <a id="10498" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10500" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10505" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="10513" class="Symbol">{</a><a id="10514" href="WellFormed.Base.html#4387" class="InductiveConstructor">suc</a> <a id="10518" class="Symbol">_}</a>  <a id="10522" href="WellFormed.Properties.html#10522" class="Bound">r</a>  <a id="10525" class="Keyword">with</a> <a id="10530" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="10538" class="Symbol">(</a><a id="10539" href="WellFormed.Base.html#9422" class="Function">&lt;-trans</a> <a id="10547" href="WellFormed.Base.html#5157" class="InductiveConstructor">zero₁</a> <a id="10553" href="WellFormed.Properties.html#10522" class="Bound">r</a><a id="10554" class="Symbol">)</a>
<a id="10556" class="Symbol">...</a> <a id="10560" class="Symbol">|</a> <a id="10562" href="WellFormed.Properties.html#10562" class="Bound">n</a> <a id="10564" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10566" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>      <a id="10576" class="Symbol">=</a> <a id="10578" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10582" href="WellFormed.Properties.html#10562" class="Bound">n</a> <a id="10584" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10586" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10591" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="10599" class="Symbol">{</a><a id="10600" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="10604" href="WellFormed.Properties.html#10604" class="Bound">f</a><a id="10605" class="Symbol">}</a>  <a id="10608" href="WellFormed.Properties.html#10608" class="Bound">r</a>  <a id="10611" class="Symbol">=</a> <a id="10613" href="Data.Empty.html#1069" class="Function">⊥-elim</a> <a id="10620" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10622" href="WellFormed.Base.html#10928" class="Function">&lt;-irrefl</a> <a id="10631" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="10636" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10638" href="Relation.Binary.Reasoning.Syntax.html#3008" class="Function Operator">begin-strict</a>
  <a id="10653" href="WellFormed.Properties.html#8444" class="Function">ω</a>                   <a id="10673" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">≤⟨</a> <a id="10676" href="WellFormed.Properties.html#9824" class="Function">ω≤l</a> <a id="10680" href="WellFormed.Base.html#5157" class="InductiveConstructor">zero₁</a> <a id="10686" class="Symbol">(</a><a id="10687" href="WellFormed.Base.html#9422" class="Function">&lt;-trans</a> <a id="10695" href="WellFormed.Properties.html#10608" class="Bound">r</a> <a id="10697" href="WellFormed.Base.html#5157" class="InductiveConstructor">zero₁</a><a id="10702" class="Symbol">)</a> <a id="10704" href="Relation.Binary.Reasoning.Syntax.html#5544" class="Function">⟩</a>
  <a id="10708" href="WellFormed.Base.html#4406" class="InductiveConstructor">lim</a> <a id="10712" href="WellFormed.Properties.html#10604" class="Bound">f</a>               <a id="10728" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">&lt;⟨</a> <a id="10731" href="WellFormed.Properties.html#10608" class="Bound">r</a> <a id="10733" href="Relation.Binary.Reasoning.Syntax.html#5689" class="Function">⟩</a>
  <a id="10737" href="WellFormed.Properties.html#8444" class="Function">ω</a>                   <a id="10757" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="10759" class="Keyword">where</a> <a id="10765" class="Keyword">open</a> <a id="10770" href="WellFormed.Base.html#14875" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>定理 2-1-31</strong> <span class="math inline">ℕ</span> 与小于 <span class="math inline">\omega</span> 的序数同构.<br />
<strong>证明</strong> <span class="math inline">\text{fin}</span> 提供了正映射, 引理 2-1-30 提供了逆映射. 结合引理 2-1-29 可以说明它们互逆. ∎</p>
<pre class="Agda"><a id="ℕ≡ω"></a><a id="10911" href="WellFormed.Properties.html#10911" class="Function">ℕ≡ω</a> <a id="10915" class="Symbol">:</a> <a id="10917" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10919" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10921" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10923" href="WellFormed.Base.html#3160" class="Datatype">Ord</a> <a id="10927" class="Symbol">(</a><a id="10928" href="WellFormed.Base.html#3357" class="Function Operator">_&lt;</a> <a id="10931" href="WellFormed.Properties.html#8444" class="Function">ω</a><a id="10932" class="Symbol">)</a>
<a id="10934" href="WellFormed.Properties.html#10911" class="Function">ℕ≡ω</a> <a id="10938" class="Symbol">=</a> <a id="10940" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="10949" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10951" href="Cubical.Foundations.Isomorphism.html#3714" class="Function">isoToPath</a> <a id="10961" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10963" href="Cubical.Foundations.Isomorphism.html#863" class="InductiveConstructor">iso</a>
  <a id="10969" class="Symbol">(λ</a> <a id="10972" href="WellFormed.Properties.html#10972" class="Bound">n</a> <a id="10974" class="Symbol">→</a> <a id="10976" href="WellFormed.Properties.html#2754" class="Function">fin</a> <a id="10980" href="WellFormed.Properties.html#10972" class="Bound">n</a> <a id="10982" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10984" href="WellFormed.Properties.html#8634" class="Function">n&lt;ω</a><a id="10987" class="Symbol">)</a>
  <a id="10991" class="Symbol">(λ</a> <a id="10994" class="Symbol">(</a><a id="10995" href="WellFormed.Properties.html#10995" class="Bound">a</a> <a id="10997" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10999" href="WellFormed.Properties.html#10999" class="Bound">a&lt;ω</a><a id="11002" class="Symbol">)</a> <a id="11004" class="Symbol">→</a> <a id="11006" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="11010" class="Symbol">(</a><a id="11011" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="11019" href="WellFormed.Properties.html#10999" class="Bound">a&lt;ω</a><a id="11022" class="Symbol">))</a>
  <a id="11027" class="Symbol">(λ</a> <a id="11030" href="WellFormed.Properties.html#11030" class="Bound">a</a> <a id="11032" class="Symbol">→</a> <a id="11034" href="Cubical.Data.Sigma.Properties.html#1919" class="Function">ΣPathP</a> <a id="11041" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11043" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11052" class="Symbol">(</a><a id="11053" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11057" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11059" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="11067" class="Symbol">_)</a> <a id="11070" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11072" href="Cubical.Foundations.Prelude.html#14254" class="Function">toPathP</a> <a id="11080" class="Symbol">(</a><a id="11081" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="11089" class="Symbol">_</a> <a id="11091" class="Symbol">_))</a>
  <a id="11097" class="Symbol">(λ</a> <a id="11100" href="WellFormed.Properties.html#11100" class="Bound">n</a> <a id="11102" class="Symbol">→</a> <a id="11104" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11113" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11115" href="WellFormed.Properties.html#10077" class="Function">fin-inj</a> <a id="11123" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11125" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11129" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11131" href="WellFormed.Properties.html#10435" class="Function">fin-suj</a> <a id="11139" class="Symbol">_)</a>
  <a id="11144" class="Keyword">where</a> <a id="11150" class="Keyword">open</a> <a id="11155" class="Keyword">import</a> <a id="11162" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
