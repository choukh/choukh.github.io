<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (2.1 - 良构树序数的性质)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-2.1---良构树序数的性质" id="toc-形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</a>
  <ul>
  <li><a href="#序数函数" id="toc-序数函数">序数函数</a></li>
  <li><a href="#一些约定" id="toc-一些约定">一些约定</a></li>
  <li><a href="#一些引理" id="toc-一些引理">一些引理</a></li>
  <li><a href="#ω的性质" id="toc-ω的性质">ω的性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/WellFormed/Properties.lagda.md">Properties.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/WellFormed.Properties.html">Properties.html</a></p>
</blockquote>
<pre class="Agda"><a id="391" class="Symbol">{-#</a> <a id="395" class="Keyword">OPTIONS</a> <a id="403" class="Pragma">--safe</a> <a id="410" class="Pragma">--cubical</a> <a id="420" class="Pragma">--lossy-unification</a> <a id="440" class="Symbol">#-}</a>
<a id="444" class="Keyword">module</a> <a id="451" href="WellFormed.Properties.html" class="Module">WellFormed.Properties</a> <a id="473" class="Keyword">where</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="WellFormed.Base.html" class="Module">WellFormed.Base</a>
</pre>
<p><a href="https://zhuanlan.zhihu.com/p/711649863">上一篇</a>我们定义了良构树序数并证明了一些基本性质, 本文将继续讨论它的更多性质.</p>
<h2 id="序数函数">序数函数</h2>
<p>我们先定义关于序数函数的一些性质.</p>
<p><strong>定义 2-1-0</strong> 我们把序数函数的类型简记作 <span class="math inline">\text{Func}</span>, 序数的二元关系的类型简记作 <span class="math inline">\text{Rel}</span>, 并约定用大写的 <span class="math inline">F</span> 表示序数函数.</p>
<pre class="Agda"><a id="Func"></a><a id="722" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="727" class="Symbol">:</a> <a id="729" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="734" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="739" class="Symbol">=</a> <a id="741" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="745" class="Symbol">→</a> <a id="747" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>

<a id="Rel"></a><a id="752" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="756" class="Symbol">:</a> <a id="758" href="Agda.Primitive.html#388" class="Primitive">Type₁</a>
<a id="764" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="768" class="Symbol">=</a> <a id="770" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="774" class="Symbol">→</a> <a id="776" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="780" class="Symbol">→</a> <a id="782" href="Agda.Primitive.html#388" class="Primitive">Type</a>

<a id="788" class="Keyword">private</a> <a id="796" class="Keyword">variable</a> <a id="805" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="807" class="Symbol">:</a> <a id="809" href="WellFormed.Properties.html#722" class="Function">Func</a>
</pre>
<p><strong>定义 2-1-1</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>保持</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">x \sim y \to F(x) \sim F(y)</span>.</p>
<pre class="Agda"><a id="_preserves_"></a><a id="927" href="WellFormed.Properties.html#927" class="Function Operator">_preserves_</a> <a id="939" class="Symbol">:</a> <a id="941" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="946" class="Symbol">→</a> <a id="948" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="952" class="Symbol">→</a> <a id="954" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="959" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="961" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="971" href="WellFormed.Properties.html#971" class="Bound Operator">_~_</a> <a id="975" class="Symbol">=</a> <a id="977" class="Symbol">∀</a> <a id="979" class="Symbol">{</a><a id="980" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="982" href="WellFormed.Properties.html#982" class="Bound">y</a><a id="983" class="Symbol">}</a> <a id="985" class="Symbol">→</a> <a id="987" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="989" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="991" href="WellFormed.Properties.html#982" class="Bound">y</a> <a id="993" class="Symbol">→</a> <a id="995" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="997" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="999" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="1001" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="1003" href="WellFormed.Properties.html#982" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-2</strong> 如果 <span class="math inline">F</span> 保持 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 保持 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-pres≤"></a><a id="1067" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1077" class="Symbol">:</a> <a id="1079" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1081" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1091" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1095" class="Symbol">→</a> <a id="1097" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1099" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1109" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1113" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1123" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1128" class="Symbol">(</a><a id="1129" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1133" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1134" class="Symbol">)</a>    <a id="1139" class="Symbol">=</a> <a id="1141" href="WellFormed.Base.html#11879" class="Function">&lt;→≤</a> <a id="1145" class="Symbol">(</a><a id="1146" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1151" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1152" class="Symbol">)</a>
<a id="1154" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1164" href="WellFormed.Properties.html#1164" class="Bound">pres</a> <a id="1169" class="Symbol">(</a><a id="1170" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1174" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="1178" class="Symbol">)</a> <a id="1180" class="Symbol">=</a> <a id="1182" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1186" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义 2-1-3</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>单射</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">F(x) \sim F(y) \to x \sim y</span>.</p>
<pre class="Agda"><a id="_injects_"></a><a id="1304" href="WellFormed.Properties.html#1304" class="Function Operator">_injects_</a> <a id="1314" class="Symbol">:</a> <a id="1316" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="1321" class="Symbol">→</a> <a id="1323" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="1327" class="Symbol">→</a> <a id="1329" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="1334" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1336" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1344" href="WellFormed.Properties.html#1344" class="Bound Operator">_~_</a> <a id="1348" class="Symbol">=</a> <a id="1350" class="Symbol">∀</a> <a id="1352" class="Symbol">{</a><a id="1353" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1355" href="WellFormed.Properties.html#1355" class="Bound">y</a><a id="1356" class="Symbol">}</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1362" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1364" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1366" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1368" href="WellFormed.Properties.html#1355" class="Bound">y</a> <a id="1370" class="Symbol">→</a> <a id="1372" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1374" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1376" href="WellFormed.Properties.html#1355" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-4</strong> 如果 <span class="math inline">F</span> 单射 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 单射 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-inj≤"></a><a id="1440" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1449" class="Symbol">:</a> <a id="1451" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1453" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1461" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="1465" class="Symbol">→</a> <a id="1467" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1469" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1477" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1481" class="Symbol">→</a> <a id="1483" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1485" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1493" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1497" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1506" href="WellFormed.Properties.html#1506" class="Bound">inj</a> <a id="1510" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1515" class="Symbol">(</a><a id="1516" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1520" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1521" class="Symbol">)</a> <a id="1523" class="Symbol">=</a> <a id="1525" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1529" class="Symbol">(</a><a id="1530" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1535" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1536" class="Symbol">)</a>
<a id="1538" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1547" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1551" href="WellFormed.Properties.html#1551" class="Bound">inj&lt;</a> <a id="1556" class="Symbol">(</a><a id="1557" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1561" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1562" class="Symbol">)</a> <a id="1564" class="Symbol">=</a> <a id="1566" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1570" class="Symbol">(</a><a id="1571" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1575" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1576" class="Symbol">)</a>
</pre>
<h2 id="一些约定">一些约定</h2>
<p><strong>记法 2-1-5</strong> 隐参版极限构造子: 它们与原版的区别在于良构条件为隐式参数, 从而允许从上下文自动推断出它们, 而不用一一显式写出.</p>
<pre class="Agda"><a id="lim-"></a><a id="1673" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1678" class="Symbol">:</a> <a id="1680" class="Symbol">(</a><a id="1681" href="WellFormed.Properties.html#1681" class="Bound">f</a> <a id="1683" class="Symbol">:</a> <a id="1685" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="1688" class="Symbol">)</a> <a id="1690" class="Symbol">{</a><a id="1691" href="WellFormed.Properties.html#1691" class="Bound">w</a> <a id="1693" class="Symbol">:</a> <a id="1695" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1698" href="WellFormed.Properties.html#1681" class="Bound">f</a><a id="1699" class="Symbol">}</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="1707" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1712" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1714" class="Symbol">{</a><a id="1715" href="WellFormed.Properties.html#1715" class="Bound">w</a><a id="1716" class="Symbol">}</a> <a id="1718" class="Symbol">=</a> <a id="1720" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="1724" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1726" class="Symbol">⦃</a> <a id="1728" href="WellFormed.Properties.html#1715" class="Bound">w</a> <a id="1730" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的路径 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的路径记作 <span class="math inline">\text{rd}[n](r)</span>.</p>
<pre class="Agda"><a id="rd[_]"></a><a id="1834" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1840" class="Symbol">:</a> <a id="1842" class="Symbol">(</a><a id="1843" href="WellFormed.Properties.html#1843" class="Bound">n</a> <a id="1845" class="Symbol">:</a> <a id="1847" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1848" class="Symbol">)</a> <a id="1850" class="Symbol">{</a><a id="1851" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1853" class="Symbol">:</a> <a id="1855" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1858" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="1859" class="Symbol">}</a> <a id="1861" class="Symbol">→</a> <a id="1863" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1868" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1870" class="Symbol">(</a><a id="1871" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1873" href="WellFormed.Properties.html#1843" class="Bound">n</a><a id="1874" class="Symbol">)</a> <a id="1876" class="Symbol">→</a> <a id="1878" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1883" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1885" class="Symbol">(</a><a id="1886" class="InductiveConstructor">lim</a> <a id="1890" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1892" class="Symbol">⦃</a> <a id="1894" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1896" class="Symbol">⦄)</a>
<a id="1899" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1905" href="WellFormed.Properties.html#1905" class="Bound">n</a> <a id="1907" class="Symbol">=</a> <a id="1909" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="1913" class="Symbol">{</a><a id="1914" class="Argument">n</a> <a id="1916" class="Symbol">=</a> <a id="1918" href="WellFormed.Properties.html#1905" class="Bound">n</a><a id="1919" class="Symbol">}</a> <a id="1921" class="Symbol">⦃</a> <a id="1923" class="Symbol">_</a> <a id="1925" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的证明 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的证明记作 <span class="math inline">\text{&lt;}[n](r)</span>.</p>
<pre class="Agda"><a id="&lt;[_]"></a><a id="2028" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2033" class="Symbol">:</a> <a id="2035" class="Symbol">(</a><a id="2036" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2038" class="Symbol">:</a> <a id="2040" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2041" class="Symbol">)</a> <a id="2043" class="Symbol">{</a><a id="2044" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2046" class="Symbol">:</a> <a id="2048" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="2051" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="2052" class="Symbol">}</a> <a id="2054" class="Symbol">→</a> <a id="2056" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2058" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2060" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2062" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2064" class="Symbol">→</a> <a id="2066" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2068" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2070" class="InductiveConstructor">lim</a> <a id="2074" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2076" class="Symbol">⦃</a> <a id="2078" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2080" class="Symbol">⦄</a>
<a id="2082" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2087" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2089" class="Symbol">=</a> <a id="2091" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="2095" href="WellFormed.Properties.html#1834" class="Function Operator">rd[</a> <a id="2099" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2101" href="WellFormed.Properties.html#1834" class="Function Operator">]</a>
</pre>
<p><strong>约定 2-1-6</strong> 鉴于路径关系与子树关系的高度可互换性, 我们今后在自然语言中会适当地混淆两者, 例如把路径的构造说成是子树关系的证明, 或反之. 读者应该理解为是调用了上一篇的引理进行了两者的转换.</p>
<p><strong>事实 2-1-7</strong> 极限序数的判定: 树序数的归纳定义允许我们快速判断一个序数是否是极限序数.</p>
<pre class="Agda"><a id="IsLim"></a><a id="2274" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2280" class="Symbol">:</a> <a id="2282" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="2286" class="Symbol">→</a> <a id="2288" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="2293" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2299" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="2304" class="Symbol">=</a> <a id="2306" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2308" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2314" class="Symbol">(</a><a id="2315" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2319" href="WellFormed.Properties.html#2319" class="Bound">a</a><a id="2320" class="Symbol">)</a> <a id="2322" class="Symbol">=</a> <a id="2324" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2326" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2332" class="Symbol">(</a><a id="2333" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2337" href="WellFormed.Properties.html#2337" class="Bound">f</a><a id="2338" class="Symbol">)</a> <a id="2340" class="Symbol">=</a> <a id="2342" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a>
</pre>
<p><strong>记法 2-1-8</strong> 极限序数的基本列: 如果 <span class="math inline">a</span> 是极限序数, 那么我们用 <span class="math inline">a[n]</span> 表示其基本列的第 <span class="math inline">n</span> 项. 由序数的定义有 <span class="math inline">a[n] &lt; a[n^+]</span>.</p>
<pre class="Agda"><a id="_[_]"></a><a id="2449" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2454" class="Symbol">:</a> <a id="2456" class="Symbol">(</a><a id="2457" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2459" class="Symbol">:</a> <a id="2461" href="WellFormed.Base.html#2971" class="Datatype">Ord</a><a id="2464" class="Symbol">)</a> <a id="2466" class="Symbol">→</a> <a id="2468" class="Symbol">⦃</a> <a id="2470" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2476" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2478" class="Symbol">⦄</a> <a id="2480" class="Symbol">→</a> <a id="2482" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2486" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2491" class="Symbol">(</a><a id="2492" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2496" href="WellFormed.Properties.html#2496" class="Bound">f</a><a id="2497" class="Symbol">)</a> <a id="2499" class="Symbol">=</a> <a id="2501" href="WellFormed.Properties.html#2496" class="Bound">f</a>

<a id="[]-wf"></a><a id="2504" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2510" class="Symbol">:</a> <a id="2512" class="Symbol">⦃</a> <a id="2514" href="WellFormed.Properties.html#2514" class="Bound">_</a> <a id="2516" class="Symbol">:</a> <a id="2518" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2524" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2526" class="Symbol">⦄</a> <a id="2528" class="Symbol">→</a> <a id="2530" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2532" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2534" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2536" href="WellFormed.Properties.html#2449" class="Function Operator">]</a> <a id="2538" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2540" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2542" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2544" class="InductiveConstructor">suc</a> <a id="2548" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2550" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="2552" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2558" class="Symbol">{</a><a id="2559" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2563" href="WellFormed.Properties.html#2563" class="Bound">f</a><a id="2564" class="Symbol">}</a> <a id="2566" class="Symbol">=</a> <a id="2568" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>定义 2-1-9</strong> 自然数到序数的嵌入 <span class="math inline">\text{fin} : ℕ → \text{Ord}</span></p>
<p><span class="math display">
\text{fin}(n) := \text{suc}^n(0)
</span></p>
<p>其中后继函数的上标 <span class="math inline">n</span> 表示迭代 <span class="math inline">n</span> 次.</p>
<pre class="Agda"><a id="2705" class="Keyword">open</a> <a id="2710" class="Keyword">import</a> <a id="2717" href="Lower.html" class="Module">Lower</a> <a id="2723" class="Keyword">public</a> <a id="2730" class="Keyword">using</a> <a id="2736" class="Symbol">(</a><a id="2737" href="Lower.html#1118" class="Function Operator">_∘ⁿ_</a><a id="2741" class="Symbol">)</a>
<a id="fin"></a><a id="2743" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2747" class="Symbol">:</a> <a id="2749" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2753" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2757" href="WellFormed.Properties.html#2757" class="Bound">n</a> <a id="2759" class="Symbol">=</a> <a id="2761" class="Symbol">(</a><a id="2762" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2766" href="Lower.html#1118" class="Function Operator">∘ⁿ</a> <a id="2769" href="WellFormed.Properties.html#2757" class="Bound">n</a><a id="2770" class="Symbol">)</a> <a id="2772" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a>
</pre>
<p>非形式地, 后文中我们把 <span class="math inline">\text{fin}</span> 视作类型强转 (coercion).</p>
<p><strong>约定 2-1-10</strong> 数字字面量既可以表示自然数, 也可以表示序数. Agda 使用<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能实现该约定.</p>
<pre class="Agda"><a id="2976" class="Keyword">open</a> <a id="2981" class="Keyword">import</a> <a id="2988" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="3009" class="Keyword">public</a>
<a id="3016" class="Keyword">instance</a>
  <a id="nNat"></a><a id="3027" href="WellFormed.Properties.html#3027" class="Function">nNat</a> <a id="3032" class="Symbol">=</a> <a id="3034" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3041" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="3045" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3047" class="Keyword">record</a> <a id="3054" class="Symbol">{</a> <a id="3056" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3067" class="Symbol">=</a> <a id="3069" class="Symbol">λ</a> <a id="3071" href="WellFormed.Properties.html#3071" class="Bound">_</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3077" class="Symbol">;</a> <a id="3079" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3087" class="Symbol">=</a> <a id="3089" class="Symbol">λ</a> <a id="3091" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3093" class="Symbol">→</a> <a id="3095" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3097" class="Symbol">}</a>
  <a id="nOrd"></a><a id="3101" href="WellFormed.Properties.html#3101" class="Function">nOrd</a> <a id="3106" class="Symbol">=</a> <a id="3108" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3115" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3119" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3121" class="Keyword">record</a> <a id="3128" class="Symbol">{</a> <a id="3130" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3141" class="Symbol">=</a> <a id="3143" class="Symbol">λ</a> <a id="3145" href="WellFormed.Properties.html#3145" class="Bound">_</a> <a id="3147" class="Symbol">→</a> <a id="3149" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3151" class="Symbol">;</a> <a id="3153" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3161" class="Symbol">=</a> <a id="3163" class="Symbol">λ</a> <a id="3165" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3167" class="Symbol">→</a> <a id="3169" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="3173" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3175" class="Symbol">}</a>
</pre>
<h2 id="一些引理">一些引理</h2>
<p><strong>事实 2-1-11</strong> 构造子的单射性</p>
<ul>
<li><span class="math inline">a^+ =b ^+ → a = b</span></li>
<li><span class="math inline">\lim f = \lim g → f = g</span></li>
</ul>
<pre class="Agda"><a id="suc-inj"></a><a id="3273" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3281" class="Symbol">:</a> <a id="3283" class="InductiveConstructor">suc</a> <a id="3287" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3289" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3291" class="InductiveConstructor">suc</a> <a id="3295" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3297" class="Symbol">→</a> <a id="3299" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3301" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3303" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3305" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3313" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3318" class="Symbol">=</a> <a id="3320" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lim-inj"></a><a id="3326" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3334" class="Symbol">:</a> <a id="3336" class="Symbol">{</a><a id="3337" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3341" class="Symbol">:</a> <a id="3343" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3346" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="3347" class="Symbol">}</a> <a id="3349" class="Symbol">{</a><a id="3350" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3354" class="Symbol">:</a> <a id="3356" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3359" href="WellFormed.Base.html#3796" class="Generalizable">g</a><a id="3360" class="Symbol">}</a> <a id="3362" class="Symbol">→</a> <a id="3364" href="WellFormed.Base.html#4217" class="InductiveConstructor">Ord.lim</a> <a id="3372" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3374" class="Symbol">⦃</a> <a id="3376" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3380" class="Symbol">⦄</a> <a id="3382" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3384" class="InductiveConstructor">lim</a> <a id="3388" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="3390" class="Symbol">⦃</a> <a id="3392" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3396" class="Symbol">⦄</a> <a id="3398" class="Symbol">→</a> <a id="3400" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3402" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3404" href="WellFormed.Base.html#3796" class="Generalizable">g</a>
<a id="3406" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3414" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3419" class="Symbol">=</a> <a id="3421" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实 2-1-12</strong> 极限路径的反演: 如果 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span>, 那么存在一个自然数 <span class="math inline">n</span> 使得 <span class="math inline">b</span> 小于 <span class="math inline">a[n]</span>.</p>
<pre class="Agda"><a id="lim-inv-rd"></a><a id="3514" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3525" class="Symbol">:</a> <a id="3527" class="Symbol">⦃</a> <a id="3529" href="WellFormed.Properties.html#3529" class="Bound">_</a> <a id="3531" class="Symbol">:</a> <a id="3533" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3539" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3541" class="Symbol">⦄</a> <a id="3543" class="Symbol">→</a> <a id="3545" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3550" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3552" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3554" class="Symbol">→</a> <a id="3556" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3559" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3561" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3563" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3565" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3567" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3572" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3574" class="Symbol">(</a><a id="3575" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3577" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3579" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3581" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="3582" class="Symbol">)</a>
<a id="3584" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3595" class="Symbol">(</a><a id="3596" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="3600" href="WellFormed.Properties.html#3600" class="Bound">r</a><a id="3601" class="Symbol">)</a> <a id="3603" class="Symbol">=</a> <a id="3605" class="Symbol">_</a> <a id="3607" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3609" href="WellFormed.Properties.html#3600" class="Bound">r</a>

<a id="lim-inv"></a><a id="3612" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3620" class="Symbol">:</a> <a id="3622" class="Symbol">⦃</a> <a id="3624" href="WellFormed.Properties.html#3624" class="Bound">_</a> <a id="3626" class="Symbol">:</a> <a id="3628" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3634" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3636" class="Symbol">⦄</a> <a id="3638" class="Symbol">→</a> <a id="3640" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3642" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3644" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3646" class="Symbol">→</a> <a id="3648" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3651" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3653" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3655" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3657" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3659" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3661" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3663" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3665" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3667" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3669" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="3671" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3679" href="WellFormed.Properties.html#3679" class="Bound">r</a> <a id="3681" class="Keyword">with</a> <a id="3686" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3697" class="Symbol">(</a><a id="3698" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="3702" href="WellFormed.Properties.html#3679" class="Bound">r</a><a id="3703" class="Symbol">)</a>
<a id="3705" class="Symbol">...</a> <a id="3709" class="Symbol">|</a> <a id="3711" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3713" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3715" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3717" class="Symbol">=</a> <a id="3719" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3721" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3723" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3725" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3727" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>鉴于互递归证明的特性, 我们有时会先声明定理, 然后再证明其所需的引理, 最后再证明定理本身.</p>
<p><strong>定理 2-1-13</strong> 互递归地, 有</p>
<p><span class="math display">
\begin{aligned}
(1)&amp; \quad a &lt; b → 0 &lt; b \\
(2)&amp; \quad 0 &lt; a^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="z&lt;b-rd"></a><a id="3899" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="3906" class="Symbol">:</a> <a id="3908" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3913" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3915" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3917" class="Symbol">→</a> <a id="3919" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3924" class="Number">0</a> <a id="3926" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="z&lt;s-rd"></a><a id="3928" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="3935" class="Symbol">:</a> <a id="3937" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3942" class="Number">0</a> <a id="3944" class="Symbol">(</a><a id="3945" class="InductiveConstructor">suc</a> <a id="3949" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="3950" class="Symbol">)</a>

<a id="z&lt;b"></a><a id="3953" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3957" class="Symbol">:</a> <a id="3959" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3961" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3963" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3965" class="Symbol">→</a> <a id="3967" class="Number">0</a> <a id="3969" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3971" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3973" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3977" class="Symbol">=</a> <a id="3979" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="3983" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a>

<a id="z&lt;s"></a><a id="3991" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="3995" class="Symbol">:</a> <a id="3997" class="Number">0</a> <a id="3999" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4001" class="InductiveConstructor">suc</a> <a id="4005" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="4007" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="4011" class="Symbol">=</a> <a id="4013" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="4015" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4022" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p><strong>引理 2-1-14</strong> 基本列的后继项必然大于零.<br />
<strong>证明</strong> 给定基本列 <span class="math inline">f</span>, 由于 <span class="math inline">f(n)&lt;f(n^+)</span>, 由定理 2-1-13-(1) 即证. ∎</p>
<pre class="Agda"><a id="z&lt;fs"></a><a id="4126" href="WellFormed.Properties.html#4126" class="Function">z&lt;fs</a> <a id="4131" class="Symbol">:</a> <a id="4133" class="Symbol">∀</a> <a id="4135" href="WellFormed.Properties.html#4135" class="Bound">f</a> <a id="4137" href="WellFormed.Properties.html#4137" class="Bound">n</a> <a id="4139" class="Symbol">→</a> <a id="4141" class="Symbol">⦃</a> <a id="4143" href="WellFormed.Properties.html#4143" class="Bound">_</a> <a id="4145" class="Symbol">:</a> <a id="4147" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4150" href="WellFormed.Properties.html#4135" class="Bound">f</a> <a id="4152" class="Symbol">⦄</a> <a id="4154" class="Symbol">→</a> <a id="4156" class="Number">0</a> <a id="4158" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4160" href="WellFormed.Properties.html#4135" class="Bound">f</a> <a id="4162" class="Symbol">(</a><a id="4163" class="InductiveConstructor">suc</a> <a id="4167" href="WellFormed.Properties.html#4137" class="Bound">n</a><a id="4168" class="Symbol">)</a>
<a id="4170" href="WellFormed.Properties.html#4126" class="Function">z&lt;fs</a> <a id="4175" href="WellFormed.Properties.html#4175" class="Bound">f</a> <a id="4177" href="WellFormed.Properties.html#4177" class="Bound">n</a> <a id="4179" class="Symbol">=</a> <a id="4181" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="4185" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-15</strong> 极限序数必然大于零.<br />
<strong>证明</strong> 由 <span class="math inline">\text{&lt;}[1]</span>, 我们证明其基本列第 <span class="math inline">1</span> 项大于零, 而这由引理 2-1-14 即证. ∎</p>
<pre class="Agda"><a id="z&lt;l"></a><a id="4292" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a> <a id="4296" class="Symbol">:</a> <a id="4298" class="Symbol">{</a><a id="4299" href="WellFormed.Properties.html#4299" class="Bound">w</a> <a id="4301" class="Symbol">:</a> <a id="4303" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4306" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="4307" class="Symbol">}</a> <a id="4309" class="Symbol">→</a> <a id="4311" class="Number">0</a> <a id="4313" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4315" class="InductiveConstructor">lim</a> <a id="4319" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="4321" class="Symbol">⦃</a> <a id="4323" href="WellFormed.Properties.html#4299" class="Bound">w</a> <a id="4325" class="Symbol">⦄</a>
<a id="4327" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a> <a id="4331" class="Symbol">{</a><a id="4332" href="WellFormed.Properties.html#4332" class="Bound">f</a><a id="4333" class="Symbol">}</a> <a id="4335" class="Symbol">{</a><a id="4336" href="WellFormed.Properties.html#4336" class="Bound">w</a><a id="4337" class="Symbol">}</a> <a id="4339" class="Symbol">=</a> <a id="4341" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[</a> <a id="4344" class="Number">1</a> <a id="4346" href="WellFormed.Properties.html#2028" class="Function Operator">]</a> <a id="4348" class="Symbol">(</a><a id="4349" href="WellFormed.Properties.html#4126" class="Function">z&lt;fs</a> <a id="4354" href="WellFormed.Properties.html#4332" class="Bound">f</a> <a id="4356" class="Number">0</a> <a id="4358" class="Symbol">⦃</a> <a id="4360" href="WellFormed.Properties.html#4336" class="Bound">w</a> <a id="4362" class="Symbol">⦄)</a>
</pre>
<p><strong>定理 2-1-13-(1)</strong> <span class="math inline">a &lt; b → 0 &lt; b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 由引理 2-1-15 即得 <span class="math inline">0 &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="4616" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4623" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="4628" class="Symbol">=</a> <a id="4630" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4637" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4644" class="Symbol">(</a><a id="4645" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4649" href="WellFormed.Properties.html#4649" class="Bound">r</a><a id="4650" class="Symbol">)</a> <a id="4652" class="Symbol">=</a> <a id="4654" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4661" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4668" class="Symbol">(</a><a id="4669" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="4673" href="WellFormed.Properties.html#4673" class="Bound">r</a><a id="4674" class="Symbol">)</a> <a id="4676" class="Symbol">=</a> <a id="4678" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="4682" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-13-(2)</strong> <span class="math inline">0 &lt; a^+</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 有 <span class="math inline">0 : 0 &lt; 0^+</span>.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 有归纳假设 <span class="math inline">r : 0 &lt; a&#39;^+</span>, 所以 <span class="math inline">r^+ : 0 &lt; a&#39;^{++}</span>.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 要证 <span class="math inline">a &lt; \lim(f)^+</span>, 由路径构造子 <span class="math inline">\text{suc}</span> 及引理 2-1-15 即得. ∎</li>
</ul>
<pre class="Agda"><a id="4917" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4924" class="Symbol">{(</a><a id="4926" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="4930" class="Symbol">)}</a> <a id="4933" class="Symbol">=</a> <a id="4935" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="4940" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4947" class="Symbol">{</a><a id="4948" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="4952" href="WellFormed.Properties.html#4952" class="Bound">a</a><a id="4953" class="Symbol">}</a> <a id="4955" class="Symbol">=</a> <a id="4957" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4961" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4968" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4975" class="Symbol">{</a><a id="4976" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="4980" href="WellFormed.Properties.html#4980" class="Bound">f</a><a id="4981" class="Symbol">}</a> <a id="4983" class="Symbol">=</a> <a id="4985" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4989" class="Symbol">(</a><a id="4990" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="4994" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a><a id="4997" class="Symbol">)</a>
</pre>
<p><strong>推论 2-1-16</strong> 零小于等于任何序数.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳. 零的情况由自反性, 后继的情况由2-1-13-(2), 极限的情况由引理 2-1-15 即得. ∎</p>
<pre class="Agda"><a id="z≤"></a><a id="5107" href="WellFormed.Properties.html#5107" class="Function">z≤</a> <a id="5110" class="Symbol">:</a> <a id="5112" class="Number">0</a> <a id="5114" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5116" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="5118" href="WellFormed.Properties.html#5107" class="Function">z≤</a> <a id="5121" class="Symbol">{(</a><a id="5123" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="5127" class="Symbol">)}</a> <a id="5130" class="Symbol">=</a> <a id="5132" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5136" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5141" href="WellFormed.Properties.html#5107" class="Function">z≤</a> <a id="5144" class="Symbol">{</a><a id="5145" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5149" class="Symbol">_}</a>  <a id="5153" class="Symbol">=</a> <a id="5155" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5159" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a>
<a id="5163" href="WellFormed.Properties.html#5107" class="Function">z≤</a> <a id="5166" class="Symbol">{</a><a id="5167" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5171" class="Symbol">_}</a>  <a id="5175" class="Symbol">=</a> <a id="5177" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5181" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-17</strong> 互递归地, 有</p>
<ul>
<li><ol type="1">
<li><span class="math inline">a &lt; b \to a^+ ≤ b</span>.</li>
</ol></li>
<li><ol start="2" type="1">
<li>后继运算保持 <span class="math inline">&lt;</span>.</li>
</ol></li>
</ul>
<pre class="Agda"><a id="&lt;→s≤-rd"></a><a id="5267" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="5275" class="Symbol">:</a> <a id="5277" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="5282" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5284" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5286" class="Symbol">→</a> <a id="5288" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="5295" class="Symbol">(</a><a id="5296" class="InductiveConstructor">suc</a> <a id="5300" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="5301" class="Symbol">)</a> <a id="5303" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="s&lt;s-rd"></a><a id="5305" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="5312" class="Symbol">:</a> <a id="5314" class="InductiveConstructor">suc</a> <a id="5318" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5328" href="WellFormed.Base.html#2987" class="Datatype">Road</a>

<a id="&lt;→s≤"></a><a id="5334" href="WellFormed.Properties.html#5334" class="Function">&lt;→s≤</a> <a id="5339" class="Symbol">:</a> <a id="5341" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5343" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="5345" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5347" class="Symbol">→</a> <a id="5349" class="InductiveConstructor">suc</a> <a id="5353" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5355" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5357" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="5359" href="WellFormed.Properties.html#5334" class="Function">&lt;→s≤</a> <a id="5364" class="Symbol">=</a> <a id="5366" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="5370" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="5378" class="Symbol">(</a><a id="5379" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="5384" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5386" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a><a id="5393" class="Symbol">)</a>

<a id="s&lt;s"></a><a id="5396" href="WellFormed.Properties.html#5396" class="Function">s&lt;s</a> <a id="5400" class="Symbol">:</a> <a id="5402" class="InductiveConstructor">suc</a> <a id="5406" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5416" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="5420" href="WellFormed.Properties.html#5396" class="Function">s&lt;s</a> <a id="5424" class="Symbol">=</a> <a id="5426" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="5430" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a>
</pre>
<p><strong>定理 2-1-17-(1)</strong> <span class="math inline">a &lt; b \to a^+ ≤ b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 由自反性即得 <span class="math inline">a^+ ≤ a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由定理 2-1-17-(2) 即得 <span class="math inline">a^+ ≤ b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 由定理 2-1-17-(2) 有 <span class="math inline">a^+ &lt; f(n)^+</span>, 由归纳假设有 <span class="math inline">f(n)^+ ≤ f(n^+)</span>, 由传递性即得 <span class="math inline">a^+ &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="5776" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="5784" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="5789" class="Symbol">=</a> <a id="5791" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5795" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5800" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="5808" class="Symbol">(</a><a id="5809" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="5813" href="WellFormed.Properties.html#5813" class="Bound">r</a><a id="5814" class="Symbol">)</a> <a id="5816" class="Symbol">=</a> <a id="5818" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5822" class="Symbol">(</a><a id="5823" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="5830" href="WellFormed.Properties.html#5813" class="Bound">r</a><a id="5831" class="Symbol">)</a>
<a id="5833" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="5841" class="Symbol">{</a><a id="5842" href="WellFormed.Properties.html#5842" class="Bound">a</a><a id="5843" class="Symbol">}</a> <a id="5845" class="Symbol">(</a><a id="5846" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="5850" class="Symbol">{</a><a id="5851" href="WellFormed.Properties.html#5851" class="Bound">f</a><a id="5852" class="Symbol">}</a> <a id="5854" class="Symbol">{</a><a id="5855" href="WellFormed.Properties.html#5855" class="Bound">n</a><a id="5856" class="Symbol">}</a> <a id="5858" href="WellFormed.Properties.html#5858" class="Bound">r</a><a id="5859" class="Symbol">)</a> <a id="5861" class="Symbol">=</a> <a id="5863" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5867" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5869" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="5884" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5888" href="WellFormed.Properties.html#5842" class="Bound">a</a>           <a id="5900" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="5903" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="5910" href="WellFormed.Properties.html#5858" class="Bound">r</a> <a id="5912" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="5916" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5920" class="Symbol">(</a><a id="5921" href="WellFormed.Properties.html#5851" class="Bound">f</a> <a id="5923" href="WellFormed.Properties.html#5855" class="Bound">n</a><a id="5924" class="Symbol">)</a>       <a id="5932" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="5935" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="5943" class="Symbol">(</a><a id="5944" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="5948" href="Function.Base.html#4736" class="Function">it</a><a id="5950" class="Symbol">)</a> <a id="5952" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="5956" href="WellFormed.Properties.html#5851" class="Bound">f</a> <a id="5958" class="Symbol">(</a><a id="5959" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5963" href="WellFormed.Properties.html#5855" class="Bound">n</a><a id="5964" class="Symbol">)</a>       <a id="5972" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="5975" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="5982" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="5986" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5990" href="WellFormed.Properties.html#5851" class="Bound">f</a>           <a id="6002" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6004" class="Keyword">where</a> <a id="6010" class="Keyword">open</a> <a id="6015" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-17-(2)</strong> 后继运算保持 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳, 要证 <span class="math inline">a^+ &lt; b^+</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 有 <span class="math inline">0 : a^+ &lt; a^{++}</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由归纳假设即得 <span class="math inline">a^+ &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 与定理 2-1-17-(1) 同理可证 <span class="math inline">a^+ &lt; \lim(f)</span>, 再由路径构造子 <span class="math inline">\text{suc}</span> 即得 <span class="math inline">a^+ &lt; \lim(f)^+</span>. ∎</li>
</ul>
<pre class="Agda"><a id="6364" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="6371" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6376" class="Symbol">=</a> <a id="6378" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="6383" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="6390" class="Symbol">(</a><a id="6391" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6395" href="WellFormed.Properties.html#6395" class="Bound">r</a><a id="6396" class="Symbol">)</a> <a id="6398" class="Symbol">=</a> <a id="6400" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6404" class="Symbol">(</a><a id="6405" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="6412" href="WellFormed.Properties.html#6395" class="Bound">r</a><a id="6413" class="Symbol">)</a>
<a id="6415" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="6422" class="Symbol">{</a><a id="6423" href="WellFormed.Properties.html#6423" class="Bound">x</a><a id="6424" class="Symbol">}</a> <a id="6426" class="Symbol">(</a><a id="6427" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="6431" class="Symbol">{</a><a id="6432" href="WellFormed.Properties.html#6432" class="Bound">f</a><a id="6433" class="Symbol">}</a> <a id="6435" class="Symbol">{</a><a id="6436" href="WellFormed.Properties.html#6436" class="Bound">n</a><a id="6437" class="Symbol">}</a> <a id="6439" href="WellFormed.Properties.html#6439" class="Bound">r</a><a id="6440" class="Symbol">)</a> <a id="6442" class="Symbol">=</a> <a id="6444" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6448" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6450" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="6465" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6469" href="WellFormed.Properties.html#6423" class="Bound">x</a>           <a id="6481" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6484" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="6491" href="WellFormed.Properties.html#6439" class="Bound">r</a> <a id="6493" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6497" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6501" class="Symbol">(</a><a id="6502" href="WellFormed.Properties.html#6432" class="Bound">f</a> <a id="6504" href="WellFormed.Properties.html#6436" class="Bound">n</a><a id="6505" class="Symbol">)</a>       <a id="6513" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="6516" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="6524" class="Symbol">(</a><a id="6525" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="6529" href="Function.Base.html#4736" class="Function">it</a><a id="6531" class="Symbol">)</a> <a id="6533" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="6537" href="WellFormed.Properties.html#6432" class="Bound">f</a> <a id="6539" class="Symbol">(</a><a id="6540" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6544" href="WellFormed.Properties.html#6436" class="Bound">n</a><a id="6545" class="Symbol">)</a>       <a id="6553" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6556" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="6563" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6567" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6571" href="WellFormed.Properties.html#6432" class="Bound">f</a>           <a id="6583" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6585" class="Keyword">where</a> <a id="6591" class="Keyword">open</a> <a id="6596" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-18</strong> 后继运算单射 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a^+ &lt; b^+</span> 归纳, 要证 <span class="math inline">a &lt; b</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a^+ &lt; a^{++}</span>, 有 <span class="math inline">0 : a &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a^+ &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a^+ &lt; b</span>. 由传递性即得 <span class="math inline">a &lt; a^+ &lt; b</span>.</li>
<li>没有 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 的情况, 因为 <span class="math inline">\lim(f)</span> 不可能是后继序数. ∎</li>
</ul>
<pre class="Agda"><a id="s&lt;s-inj-rd"></a><a id="6876" href="WellFormed.Properties.html#6876" class="Function">s&lt;s-inj-rd</a> <a id="6887" class="Symbol">:</a> <a id="6889" class="InductiveConstructor">suc</a> <a id="6893" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="6901" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="6906" href="WellFormed.Properties.html#6876" class="Function">s&lt;s-inj-rd</a> <a id="6917" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6922" class="Symbol">=</a> <a id="6924" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="6929" href="WellFormed.Properties.html#6876" class="Function">s&lt;s-inj-rd</a> <a id="6940" class="Symbol">(</a><a id="6941" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6945" href="WellFormed.Properties.html#6945" class="Bound">r</a><a id="6946" class="Symbol">)</a> <a id="6948" class="Symbol">=</a> <a id="6950" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="6959" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6964" href="WellFormed.Properties.html#6945" class="Bound">r</a>

<a id="s&lt;s-inj"></a><a id="6967" href="WellFormed.Properties.html#6967" class="Function">s&lt;s-inj</a> <a id="6975" class="Symbol">:</a> <a id="6977" class="InductiveConstructor">suc</a> <a id="6981" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="6989" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="6993" href="WellFormed.Properties.html#6967" class="Function">s&lt;s-inj</a> <a id="7001" class="Symbol">=</a> <a id="7003" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7007" href="WellFormed.Properties.html#6876" class="Function">s&lt;s-inj-rd</a>
</pre>
<p><strong>推论 2-1-19</strong> 后继运算保持 <span class="math inline">\leq</span>, 且单射 <span class="math inline">\leq</span>.<br />
<strong>证明</strong> 由事实 2-1-2 和定理 2-1-17-(2) 可证保持; 由事实 2-1-4, 事实 2-1-11 和定理 2-1-18 可证单射. ∎</p>
<pre class="Agda"><a id="s≤s"></a><a id="7153" href="WellFormed.Properties.html#7153" class="Function">s≤s</a> <a id="7157" class="Symbol">:</a> <a id="7159" class="InductiveConstructor">suc</a> <a id="7163" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="7173" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7177" href="WellFormed.Properties.html#7153" class="Function">s≤s</a> <a id="7181" class="Symbol">=</a> <a id="7183" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="7193" href="WellFormed.Properties.html#5396" class="Function">s&lt;s</a>

<a id="s≤s-inj"></a><a id="7198" href="WellFormed.Properties.html#7198" class="Function">s≤s-inj</a> <a id="7206" class="Symbol">:</a> <a id="7208" class="InductiveConstructor">suc</a> <a id="7212" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="7220" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7224" href="WellFormed.Properties.html#7198" class="Function">s≤s-inj</a> <a id="7232" class="Symbol">=</a> <a id="7234" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="7243" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="7251" href="WellFormed.Properties.html#6967" class="Function">s&lt;s-inj</a>
</pre>
<p><strong>定理 2-1-20</strong> 定理 2-1-17-(1) 的逆命题 <span class="math inline">a^+ ≤ b → a &lt; b</span> 成立.<br />
<strong>证明</strong> 对 <span class="math inline">b</span> 归纳, 且讨论 <span class="math inline">r : a^+ ≤ b</span>.</p>
<ul>
<li><span class="math inline">b = 0</span> 的情况不可能.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ &lt; b&#39;^+</span>, 由推论 2-1-19 有 <span class="math inline">a &lt; b&#39;</span>, 所以 <span class="math inline">a &lt; b&#39;^+</span>.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ = b&#39;^+</span>, 目标改写变为 <span class="math inline">b&#39; &lt; b</span>, 显然成立.</li>
<li>若 <span class="math inline">b = \lim(f)</span>, <span class="math inline">r</span> 只能为 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 且 <span class="math inline">r&#39; : a^+ &lt; f(n)</span>, 由传递性即得 <span class="math inline">a &lt; a^+ &lt; f(n) &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="s≤→&lt;-rd"></a><a id="7624" href="WellFormed.Properties.html#7624" class="Function">s≤→&lt;-rd</a> <a id="7632" class="Symbol">:</a> <a id="7634" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="7641" class="Symbol">(</a><a id="7642" class="InductiveConstructor">suc</a> <a id="7646" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="7647" class="Symbol">)</a> <a id="7649" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7651" class="Symbol">→</a> <a id="7653" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="7658" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7660" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7662" href="WellFormed.Properties.html#7624" class="Function">s≤→&lt;-rd</a> <a id="7670" class="Symbol">{</a><a id="7671" class="Argument">b</a> <a id="7673" class="Symbol">=</a> <a id="7675" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7679" href="WellFormed.Properties.html#7679" class="Bound">b</a><a id="7680" class="Symbol">}</a> <a id="7682" class="Symbol">(</a><a id="7683" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7687" href="WellFormed.Properties.html#7687" class="Bound">r</a><a id="7688" class="Symbol">)</a>       <a id="7696" class="Symbol">=</a> <a id="7698" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="7702" class="Symbol">(</a><a id="7703" href="WellFormed.Properties.html#6876" class="Function">s&lt;s-inj-rd</a> <a id="7714" href="WellFormed.Properties.html#7687" class="Bound">r</a><a id="7715" class="Symbol">)</a>
<a id="7717" href="WellFormed.Properties.html#7624" class="Function">s≤→&lt;-rd</a> <a id="7725" class="Symbol">{</a><a id="7726" class="Argument">b</a> <a id="7728" class="Symbol">=</a> <a id="7730" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7734" href="WellFormed.Properties.html#7734" class="Bound">b</a><a id="7735" class="Symbol">}</a> <a id="7737" class="Symbol">(</a><a id="7738" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7742" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7746" class="Symbol">)</a>    <a id="7751" class="Symbol">=</a> <a id="7753" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="7758" href="WellFormed.Properties.html#7624" class="Function">s≤→&lt;-rd</a> <a id="7766" class="Symbol">{</a><a id="7767" class="Argument">b</a> <a id="7769" class="Symbol">=</a> <a id="7771" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="7775" href="WellFormed.Properties.html#7775" class="Bound">f</a><a id="7776" class="Symbol">}</a> <a id="7778" class="Symbol">(</a><a id="7779" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7783" class="Symbol">(</a><a id="7784" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7788" href="WellFormed.Properties.html#7788" class="Bound">r</a><a id="7789" class="Symbol">))</a> <a id="7792" class="Symbol">=</a> <a id="7794" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7798" class="Symbol">(</a><a id="7799" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="7808" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="7813" href="WellFormed.Properties.html#7788" class="Bound">r</a><a id="7814" class="Symbol">)</a>

<a id="s≤→&lt;"></a><a id="7817" href="WellFormed.Properties.html#7817" class="Function">s≤→&lt;</a> <a id="7822" class="Symbol">:</a> <a id="7824" class="InductiveConstructor">suc</a> <a id="7828" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7830" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="7832" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7834" class="Symbol">→</a> <a id="7836" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7838" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="7840" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7842" href="WellFormed.Properties.html#7817" class="Function">s≤→&lt;</a> <a id="7847" class="Symbol">(</a><a id="7848" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7852" href="WellFormed.Properties.html#7852" class="Bound">r</a><a id="7853" class="Symbol">)</a>    <a id="7858" class="Symbol">=</a> <a id="7860" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7864" class="Symbol">(</a><a id="7865" href="WellFormed.Properties.html#7624" class="Function">s≤→&lt;-rd</a> <a id="7873" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="7875" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a><a id="7878" class="Symbol">)</a> <a id="7880" href="WellFormed.Properties.html#7852" class="Bound">r</a>
<a id="7882" href="WellFormed.Properties.html#7817" class="Function">s≤→&lt;</a> <a id="7887" class="Symbol">(</a><a id="7888" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7892" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7896" class="Symbol">)</a> <a id="7898" class="Symbol">=</a> <a id="7900" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>
</pre>
<p><strong>定理 2-1-21</strong> 后继运算在极限序数下封闭.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span> 都有 <span class="math inline">b^+ &lt; a</span>. 讨论 <span class="math inline">r : b &lt; a</span>, 只能有 <span class="math inline">r = \lim(r&#39;) : b &lt; a</span>, 且 <span class="math inline">r&#39; : b &lt; a[n]</span>. 由定理 2-1-17 即传递性即得 <span class="math inline">b^+ &lt; a[n]^+ ≤ a</span>. ∎</p>
<pre class="Agda"><a id="s&lt;l-rd"></a><a id="8095" href="WellFormed.Properties.html#8095" class="Function">s&lt;l-rd</a> <a id="8102" class="Symbol">:</a> <a id="8104" class="Symbol">⦃</a> <a id="8106" href="WellFormed.Properties.html#8106" class="Bound">_</a> <a id="8108" class="Symbol">:</a> <a id="8110" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8116" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8118" class="Symbol">⦄</a> <a id="8120" class="Symbol">→</a> <a id="8122" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8127" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8129" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8131" class="Symbol">→</a> <a id="8133" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8138" class="Symbol">(</a><a id="8139" class="InductiveConstructor">suc</a> <a id="8143" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8144" class="Symbol">)</a> <a id="8146" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8148" href="WellFormed.Properties.html#8095" class="Function">s&lt;l-rd</a> <a id="8155" class="Symbol">{</a><a id="8156" href="WellFormed.Properties.html#8156" class="Bound">a</a><a id="8157" class="Symbol">}</a> <a id="8159" class="Symbol">{</a><a id="8160" href="WellFormed.Properties.html#8160" class="Bound">b</a><a id="8161" class="Symbol">}</a> <a id="8163" class="Symbol">(</a><a id="8164" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="8168" class="Symbol">{</a><a id="8169" href="WellFormed.Properties.html#8169" class="Bound">n</a><a id="8170" class="Symbol">}</a> <a id="8172" href="WellFormed.Properties.html#8172" class="Bound">r</a><a id="8173" class="Symbol">)</a> <a id="8175" class="Symbol">=</a> <a id="8177" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="8192" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8196" href="WellFormed.Properties.html#8160" class="Bound">b</a>           <a id="8208" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="8211" href="WellFormed.Properties.html#5305" class="Function">s&lt;s-rd</a> <a id="8218" href="WellFormed.Properties.html#8172" class="Bound">r</a> <a id="8220" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="8224" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8228" class="Symbol">(</a><a id="8229" href="WellFormed.Properties.html#8156" class="Bound">a</a> <a id="8231" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="8233" href="WellFormed.Properties.html#8169" class="Bound">n</a> <a id="8235" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="8236" class="Symbol">)</a>   <a id="8240" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="8243" href="WellFormed.Properties.html#5267" class="Function">&lt;→s≤-rd</a> <a id="8251" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="8258" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="8262" href="WellFormed.Properties.html#8156" class="Bound">a</a>               <a id="8278" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="8280" class="Keyword">where</a> <a id="8286" class="Keyword">open</a> <a id="8291" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>

<a id="s&lt;l"></a><a id="8306" href="WellFormed.Properties.html#8306" class="Function">s&lt;l</a> <a id="8310" class="Symbol">:</a> <a id="8312" class="Symbol">⦃</a> <a id="8314" href="WellFormed.Properties.html#8314" class="Bound">_</a> <a id="8316" class="Symbol">:</a> <a id="8318" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8324" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8326" class="Symbol">⦄</a> <a id="8328" class="Symbol">→</a> <a id="8330" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8332" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8334" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8336" class="Symbol">→</a> <a id="8338" class="InductiveConstructor">suc</a> <a id="8342" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8344" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8346" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8348" href="WellFormed.Properties.html#8306" class="Function">s&lt;l</a> <a id="8352" class="Symbol">=</a> <a id="8354" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="8358" href="WellFormed.Properties.html#8095" class="Function">s&lt;l-rd</a>
</pre>
<p><strong>定理 2-1-22</strong> 直接前驱在极限序数上封闭.<br />
<strong>证明</strong> 要证对任意极限序数 <span class="math inline">a ≤ b^+</span> 有 <span class="math inline">a ≤ b</span>. 讨论 <span class="math inline">a ≤ b^+</span>.</p>
<ul>
<li>不可能有 <span class="math inline">a = b^+</span> 的情况, 因为 <span class="math inline">b^+</span> 不可能是极限序数.</li>
<li>若 <span class="math inline">a &lt; a^+</span>, 有 <span class="math inline">a = a</span>.</li>
<li>若 <span class="math inline">a &lt; b^+</span>, 必然有 <span class="math inline">a &lt; b</span>. ∎</li>
</ul>
<pre class="Agda"><a id="l≤p-rd"></a><a id="8559" href="WellFormed.Properties.html#8559" class="Function">l≤p-rd</a> <a id="8566" class="Symbol">:</a> <a id="8568" class="Symbol">⦃</a> <a id="8570" href="WellFormed.Properties.html#8570" class="Bound">_</a> <a id="8572" class="Symbol">:</a> <a id="8574" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8580" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8582" class="Symbol">⦄</a> <a id="8584" class="Symbol">→</a> <a id="8586" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8593" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8595" class="Symbol">(</a><a id="8596" class="InductiveConstructor">suc</a> <a id="8600" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8601" class="Symbol">)</a> <a id="8603" class="Symbol">→</a> <a id="8605" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8612" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8614" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8616" href="WellFormed.Properties.html#8559" class="Function">l≤p-rd</a> <a id="8623" class="Symbol">{</a><a id="8624" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8628" href="WellFormed.Properties.html#8628" class="Bound">f</a><a id="8629" class="Symbol">}</a> <a id="8631" class="Symbol">(</a><a id="8632" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8636" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a><a id="8640" class="Symbol">)</a>    <a id="8645" class="Symbol">=</a> <a id="8647" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="8651" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="8656" href="WellFormed.Properties.html#8559" class="Function">l≤p-rd</a> <a id="8663" class="Symbol">{</a><a id="8664" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8668" href="WellFormed.Properties.html#8668" class="Bound">f</a><a id="8669" class="Symbol">}</a> <a id="8671" class="Symbol">(</a><a id="8672" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8676" class="Symbol">(</a><a id="8677" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="8681" href="WellFormed.Properties.html#8681" class="Bound">r</a><a id="8682" class="Symbol">))</a> <a id="8685" class="Symbol">=</a> <a id="8687" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8691" href="WellFormed.Properties.html#8681" class="Bound">r</a>

<a id="l≤p"></a><a id="8694" href="WellFormed.Properties.html#8694" class="Function">l≤p</a> <a id="8698" class="Symbol">:</a> <a id="8700" class="Symbol">⦃</a> <a id="8702" href="WellFormed.Properties.html#8702" class="Bound">_</a> <a id="8704" class="Symbol">:</a> <a id="8706" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8712" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8714" class="Symbol">⦄</a> <a id="8716" class="Symbol">→</a> <a id="8718" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8720" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8722" class="InductiveConstructor">suc</a> <a id="8726" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8728" class="Symbol">→</a> <a id="8730" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8732" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8734" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8736" href="WellFormed.Properties.html#8694" class="Function">l≤p</a> <a id="8740" class="Symbol">{</a><a id="8741" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8745" href="WellFormed.Properties.html#8745" class="Bound">f</a><a id="8746" class="Symbol">}</a> <a id="8748" class="Symbol">(</a><a id="8749" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8753" href="WellFormed.Properties.html#8753" class="Bound">r</a><a id="8754" class="Symbol">)</a> <a id="8756" class="Symbol">=</a> <a id="8758" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="8763" class="Symbol">(</a><a id="8764" href="WellFormed.Properties.html#8559" class="Function">l≤p-rd</a> <a id="8771" class="Symbol">(</a><a id="8772" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8776" class="Symbol">(</a><a id="8777" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="8781" href="WellFormed.Properties.html#8753" class="Bound">r</a><a id="8782" class="Symbol">)))</a>
</pre>
<h2 id="ω的性质">ω的性质</h2>
<p><strong>定义 2-1-23</strong> 由定义 2-1-9, 显然 <span class="math inline">\text{fin}</span> 是良构序列, 我们把 <span class="math inline">\lim(\text{fin})</span> 记作 <span class="math inline">\omega</span>.</p>
<pre class="Agda"><a id="8893" class="Keyword">instance</a>
  <a id="fin-wf"></a><a id="8904" href="WellFormed.Properties.html#8904" class="Function">fin-wf</a> <a id="8911" class="Symbol">:</a> <a id="8913" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="8916" href="WellFormed.Properties.html#2743" class="Function">fin</a>
  <a id="8922" href="WellFormed.Properties.html#8904" class="Function">fin-wf</a> <a id="8929" class="Symbol">=</a> <a id="8931" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>

<a id="ω"></a><a id="8938" href="WellFormed.Properties.html#8938" class="Function">ω</a> <a id="8940" class="Symbol">:</a> <a id="8942" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="8946" href="WellFormed.Properties.html#8938" class="Function">ω</a> <a id="8948" class="Symbol">=</a> <a id="8950" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8954" href="WellFormed.Properties.html#2743" class="Function">fin</a>
</pre>
<p><strong>引理 2-1-24</strong> 有限序数 <span class="math inline">n</span> 都小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 由引理 2-1-15 可知零小于极限序数.</li>
<li>若 <span class="math inline">n</span> 为后继, 由定理 2-1-21 可知后继序数小于极限序数, 只要其直接前驱小于该极限序数, 而这是归纳假设. ∎</li>
</ul>
<pre class="Agda"><a id="n&lt;ω"></a><a id="9128" href="WellFormed.Properties.html#9128" class="Function">n&lt;ω</a> <a id="9132" class="Symbol">:</a> <a id="9134" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9138" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9140" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9142" href="WellFormed.Properties.html#8938" class="Function">ω</a>
<a id="9144" href="WellFormed.Properties.html#9128" class="Function">n&lt;ω</a> <a id="9148" class="Symbol">{</a><a id="9149" class="Argument">n</a> <a id="9151" class="Symbol">=</a> <a id="9153" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9157" class="Symbol">}</a>  <a id="9160" class="Symbol">=</a> <a id="9162" href="WellFormed.Properties.html#4292" class="Function">z&lt;l</a>
<a id="9166" href="WellFormed.Properties.html#9128" class="Function">n&lt;ω</a> <a id="9170" class="Symbol">{</a><a id="9171" class="Argument">n</a> <a id="9173" class="Symbol">=</a> <a id="9175" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9179" href="WellFormed.Properties.html#9179" class="Bound">n</a><a id="9180" class="Symbol">}</a> <a id="9182" class="Symbol">=</a> <a id="9184" href="WellFormed.Properties.html#8306" class="Function">s&lt;l</a> <a id="9188" href="WellFormed.Properties.html#9128" class="Function">n&lt;ω</a>
</pre>
<p><strong>引理 2-1-25</strong> 任意基本列的第 <span class="math inline">n</span> 项大于等于 <span class="math inline">n</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 显然 <span class="math inline">0 ≤ f(0)</span>.</li>
<li>若 <span class="math inline">n</span> 为后继, 由归纳假设 <span class="math inline">n ≤ f(n)</span> 可得 <span class="math inline">n^+ ≤ f(n)^+ &lt; f(n^+)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="n≤fn"></a><a id="9350" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="9355" class="Symbol">:</a> <a id="9357" class="Symbol">∀</a> <a id="9359" href="WellFormed.Properties.html#9359" class="Bound">f</a> <a id="9361" class="Symbol">→</a> <a id="9363" class="Symbol">⦃</a> <a id="9365" href="WellFormed.Properties.html#9365" class="Bound">_</a> <a id="9367" class="Symbol">:</a> <a id="9369" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9372" href="WellFormed.Properties.html#9359" class="Bound">f</a> <a id="9374" class="Symbol">⦄</a> <a id="9376" class="Symbol">→</a> <a id="9378" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9382" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9384" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="9386" href="WellFormed.Properties.html#9359" class="Bound">f</a> <a id="9388" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="9390" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="9395" class="Symbol">{</a><a id="9396" class="Argument">n</a> <a id="9398" class="Symbol">=</a> <a id="9400" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9404" class="Symbol">}</a> <a id="9406" href="WellFormed.Properties.html#9406" class="Bound">f</a>   <a id="9410" class="Symbol">=</a> <a id="9412" href="WellFormed.Properties.html#5107" class="Function">z≤</a>
<a id="9415" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="9420" class="Symbol">{</a><a id="9421" class="Argument">n</a> <a id="9423" class="Symbol">=</a> <a id="9425" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9429" href="WellFormed.Properties.html#9429" class="Bound">n</a><a id="9430" class="Symbol">}</a> <a id="9432" href="WellFormed.Properties.html#9432" class="Bound">f</a>  <a id="9435" class="Symbol">=</a> <a id="9437" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="9445" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9449" class="Symbol">(</a><a id="9450" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9454" href="WellFormed.Properties.html#9429" class="Bound">n</a><a id="9455" class="Symbol">)</a>         <a id="9465" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9468" href="WellFormed.Properties.html#7153" class="Function">s≤s</a> <a id="9472" class="Symbol">(</a><a id="9473" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="9478" href="WellFormed.Properties.html#9432" class="Bound">f</a><a id="9479" class="Symbol">)</a> <a id="9481" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9485" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="9489" class="Symbol">(</a><a id="9490" href="WellFormed.Properties.html#9432" class="Bound">f</a> <a id="9492" href="WellFormed.Properties.html#9429" class="Bound">n</a><a id="9493" class="Symbol">)</a>           <a id="9505" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9508" href="WellFormed.Properties.html#5334" class="Function">&lt;→s≤</a> <a id="9513" href="Function.Base.html#4736" class="Function">it</a> <a id="9516" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9520" href="WellFormed.Properties.html#9432" class="Bound">f</a> <a id="9522" class="Symbol">(</a><a id="9523" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9527" href="WellFormed.Properties.html#9429" class="Bound">n</a><a id="9528" class="Symbol">)</a>           <a id="9540" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="9542" class="Keyword">where</a> <a id="9548" class="Keyword">open</a> <a id="9553" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>推论 2-1-26</strong> 任意基本列的第 <span class="math inline">n^+</span> 项大于 <span class="math inline">n</span>.<br />
<strong>证明</strong> <span class="math inline">n ≤ f(n) &lt; f(n^+)</span>. ∎</p>
<pre class="Agda"><a id="n&lt;fs"></a><a id="9653" href="WellFormed.Properties.html#9653" class="Function">n&lt;fs</a> <a id="9658" class="Symbol">:</a> <a id="9660" class="Symbol">∀</a> <a id="9662" href="WellFormed.Properties.html#9662" class="Bound">f</a> <a id="9664" href="WellFormed.Properties.html#9664" class="Bound">n</a> <a id="9666" class="Symbol">→</a> <a id="9668" class="Symbol">⦃</a> <a id="9670" href="WellFormed.Properties.html#9670" class="Bound">_</a> <a id="9672" class="Symbol">:</a> <a id="9674" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9677" href="WellFormed.Properties.html#9662" class="Bound">f</a> <a id="9679" class="Symbol">⦄</a> <a id="9681" class="Symbol">→</a> <a id="9683" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9687" href="WellFormed.Properties.html#9664" class="Bound">n</a> <a id="9689" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9691" href="WellFormed.Properties.html#9662" class="Bound">f</a> <a id="9693" class="Symbol">(</a><a id="9694" class="InductiveConstructor">suc</a> <a id="9698" href="WellFormed.Properties.html#9664" class="Bound">n</a><a id="9699" class="Symbol">)</a>
<a id="9701" href="WellFormed.Properties.html#9653" class="Function">n&lt;fs</a> <a id="9706" href="WellFormed.Properties.html#9706" class="Bound">f</a> <a id="9708" class="Symbol">_</a> <a id="9710" class="Symbol">=</a> <a id="9712" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="9722" class="Symbol">(</a><a id="9723" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="9728" href="WellFormed.Properties.html#9706" class="Bound">f</a><a id="9729" class="Symbol">)</a> <a id="9731" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-27</strong> 没有极限序数小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 假设有这样的序数 <span class="math inline">a</span>. 由事实 2-1-12, 存在 <span class="math inline">n</span> 使得 <span class="math inline">a &lt; n</span>. 但由引理 2-1-25 又有 <span class="math inline">n ≤ a[n] &lt; a</span>. 由传递性有 <span class="math inline">n &lt; n</span>, 违反 <span class="math inline">&lt;</span> 的反自反性. ∎</p>
<pre class="Agda"><a id="l≮ω"></a><a id="9897" href="WellFormed.Properties.html#9897" class="Function">l≮ω</a> <a id="9901" class="Symbol">:</a> <a id="9903" class="Symbol">⦃</a> <a id="9905" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="9911" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="9913" class="Symbol">⦄</a> <a id="9915" class="Symbol">→</a> <a id="9917" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="9919" href="WellFormed.Base.html#3172" class="Function Operator">≮</a> <a id="9921" href="WellFormed.Properties.html#8938" class="Function">ω</a>
<a id="9923" href="WellFormed.Properties.html#9897" class="Function">l≮ω</a> <a id="9927" href="WellFormed.Properties.html#9927" class="Bound">a</a><a id="9928" class="Symbol">@{</a><a id="9930" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="9934" href="WellFormed.Properties.html#9934" class="Bound">f</a><a id="9935" class="Symbol">}</a> <a id="9937" href="WellFormed.Properties.html#9937" class="Bound">r</a> <a id="9939" class="Symbol">=</a> <a id="9941" class="Keyword">let</a> <a id="9945" href="WellFormed.Properties.html#9945" class="Bound">n</a> <a id="9947" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9949" href="WellFormed.Properties.html#9949" class="Bound">r</a> <a id="9951" class="Symbol">=</a> <a id="9953" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="9961" href="WellFormed.Properties.html#9937" class="Bound">r</a> <a id="9963" class="Keyword">in</a> <a id="9966" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="9975" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9980" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9982" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="9997" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10001" href="WellFormed.Properties.html#9945" class="Bound">n</a>               <a id="10017" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="10020" href="WellFormed.Properties.html#9350" class="Function">n≤fn</a> <a id="10025" href="WellFormed.Properties.html#9934" class="Bound">f</a> <a id="10027" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="10031" href="WellFormed.Properties.html#9927" class="Bound">a</a> <a id="10033" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="10035" href="WellFormed.Properties.html#9945" class="Bound">n</a> <a id="10037" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>             <a id="10051" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10054" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a> <a id="10058" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10062" href="WellFormed.Properties.html#9927" class="Bound">a</a>                   <a id="10082" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10085" href="WellFormed.Properties.html#9949" class="Bound">r</a> <a id="10087" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10091" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10095" href="WellFormed.Properties.html#9945" class="Bound">n</a>               <a id="10111" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="10113" class="Keyword">where</a> <a id="10119" class="Keyword">open</a> <a id="10124" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>引理 2-1-28</strong> 忽略非同株, <span class="math inline">\omega</span> 是最小的极限序数.<br />
<strong>证明</strong> 对任意与 <span class="math inline">\omega</span> 同株的极限序数 <span class="math inline">a</span>, 由推论 2-0-34, 讨论 <span class="math inline">\omega</span> 与 <span class="math inline">a</span> 的大小关系. 若 <span class="math inline">a &lt; \omega</span>, 由引理 2-1-27 可得矛盾. 所以只能有 <span class="math inline">ω ≤ a</span>. ∎</p>
<pre class="Agda"><a id="ω≤l"></a><a id="10318" href="WellFormed.Properties.html#10318" class="Function">ω≤l</a> <a id="10322" class="Symbol">:</a> <a id="10324" class="Symbol">⦃</a> <a id="10326" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="10332" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10334" class="Symbol">⦄</a> <a id="10336" class="Symbol">→</a> <a id="10338" href="WellFormed.Properties.html#8938" class="Function">ω</a> <a id="10340" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10342" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10344" class="Symbol">→</a> <a id="10346" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10348" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10350" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10352" class="Symbol">→</a> <a id="10354" href="WellFormed.Properties.html#8938" class="Function">ω</a> <a id="10356" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="10358" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10360" href="WellFormed.Properties.html#10318" class="Function">ω≤l</a> <a id="10364" class="Symbol">{</a><a id="10365" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="10369" href="WellFormed.Properties.html#10369" class="Bound">f</a><a id="10370" class="Symbol">}</a> <a id="10372" href="WellFormed.Properties.html#10372" class="Bound">r</a> <a id="10374" href="WellFormed.Properties.html#10374" class="Bound">s</a> <a id="10376" class="Keyword">with</a> <a id="10381" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="10390" href="WellFormed.Properties.html#10372" class="Bound">r</a> <a id="10392" href="WellFormed.Properties.html#10374" class="Bound">s</a>
<a id="10394" class="Symbol">...</a> <a id="10398" class="Symbol">|</a> <a id="10400" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10404" href="WellFormed.Properties.html#10404" class="Bound">r</a>           <a id="10416" class="Symbol">=</a> <a id="10418" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10422" href="WellFormed.Properties.html#10404" class="Bound">r</a>
<a id="10424" class="Symbol">...</a> <a id="10428" class="Symbol">|</a> <a id="10430" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10434" class="Symbol">(</a><a id="10435" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10439" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="10443" class="Symbol">)</a>  <a id="10446" class="Symbol">=</a> <a id="10448" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10452" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10457" class="Symbol">...</a> <a id="10461" class="Symbol">|</a> <a id="10463" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10467" class="Symbol">(</a><a id="10468" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10472" href="WellFormed.Properties.html#10472" class="Bound">r</a><a id="10473" class="Symbol">)</a>     <a id="10479" class="Symbol">=</a> <a id="10481" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="10488" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10490" href="WellFormed.Properties.html#9897" class="Function">l≮ω</a> <a id="10494" href="WellFormed.Properties.html#10472" class="Bound">r</a>
</pre>
<p><strong>引理 2-1-29</strong> <span class="math inline">\text{fin}</span> 单射 <span class="math inline">=</span>.<br />
<strong>证明</strong> 对 <span class="math inline">m, n</span> 归纳即得. ∎</p>
<pre class="Agda"><a id="fin-inj"></a><a id="10571" href="WellFormed.Properties.html#10571" class="Function">fin-inj</a> <a id="10579" class="Symbol">:</a> <a id="10581" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10585" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10587" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10589" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10593" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="10595" class="Symbol">→</a> <a id="10597" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10599" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10601" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="10603" href="WellFormed.Properties.html#10571" class="Function">fin-inj</a> <a id="10611" class="Symbol">{(</a><a id="10613" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10617" class="Symbol">)}</a> <a id="10620" class="Symbol">{(</a><a id="10622" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10626" class="Symbol">)}</a> <a id="10629" href="WellFormed.Properties.html#10629" class="Bound">eq</a> <a id="10632" class="Symbol">=</a> <a id="10634" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10639" href="WellFormed.Properties.html#10571" class="Function">fin-inj</a> <a id="10647" class="Symbol">{</a><a id="10648" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10652" href="WellFormed.Properties.html#10652" class="Bound">m</a><a id="10653" class="Symbol">}</a>  <a id="10656" class="Symbol">{</a><a id="10657" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10661" href="WellFormed.Properties.html#10661" class="Bound">n</a><a id="10662" class="Symbol">}</a>  <a id="10665" href="WellFormed.Properties.html#10665" class="Bound">eq</a> <a id="10668" class="Symbol">=</a> <a id="10670" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10675" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10679" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10681" href="WellFormed.Properties.html#10571" class="Function">fin-inj</a> <a id="10689" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10691" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="10699" href="WellFormed.Properties.html#10665" class="Bound">eq</a>
</pre>
<p><strong>引理 2-1-30</strong> <span class="math inline">\text{fin}</span> 满射 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">a &lt; ω</span> 都存在 <span class="math inline">n</span> 使得 <span class="math inline">n = a</span>. 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 取 <span class="math inline">n = 0</span> 即可.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 由归纳假设可得一个 <span class="math inline">n&#39; = a&#39;</span>. 取 <span class="math inline">n = n&#39;^+</span> 即可.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 由引理 2-1-27 可得矛盾. ∎</li>
</ul>
<pre class="Agda"><a id="fin-suj"></a><a id="10929" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="10937" class="Symbol">:</a> <a id="10939" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10941" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10943" href="WellFormed.Properties.html#8938" class="Function">ω</a> <a id="10945" class="Symbol">→</a> <a id="10947" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="10950" href="WellFormed.Properties.html#10950" class="Bound">n</a> <a id="10952" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="10954" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10956" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="10958" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10962" href="WellFormed.Properties.html#10950" class="Bound">n</a> <a id="10964" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10966" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10968" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="10976" class="Symbol">{(</a><a id="10978" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="10982" class="Symbol">)}</a> <a id="10985" href="WellFormed.Properties.html#10985" class="Bound">r</a>  <a id="10988" class="Symbol">=</a> <a id="10990" class="Number">0</a> <a id="10992" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10994" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10999" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11007" class="Symbol">{</a><a id="11008" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="11012" class="Symbol">_}</a>  <a id="11016" href="WellFormed.Properties.html#11016" class="Bound">r</a>  <a id="11019" class="Keyword">with</a> <a id="11024" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11032" class="Symbol">(</a><a id="11033" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11041" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11047" href="WellFormed.Properties.html#11016" class="Bound">r</a><a id="11048" class="Symbol">)</a>
<a id="11050" class="Symbol">...</a> <a id="11054" class="Symbol">|</a> <a id="11056" href="WellFormed.Properties.html#11056" class="Bound">n</a> <a id="11058" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11060" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>      <a id="11070" class="Symbol">=</a> <a id="11072" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11076" href="WellFormed.Properties.html#11056" class="Bound">n</a> <a id="11078" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11080" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11085" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11093" class="Symbol">{</a><a id="11094" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11098" href="WellFormed.Properties.html#11098" class="Bound">f</a><a id="11099" class="Symbol">}</a>  <a id="11102" href="WellFormed.Properties.html#11102" class="Bound">r</a>  <a id="11105" class="Symbol">=</a> <a id="11107" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="11114" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11116" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="11125" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11130" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11132" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="11147" href="WellFormed.Properties.html#8938" class="Function">ω</a>                   <a id="11167" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="11170" href="WellFormed.Properties.html#10318" class="Function">ω≤l</a> <a id="11174" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11180" class="Symbol">(</a><a id="11181" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11189" href="WellFormed.Properties.html#11102" class="Bound">r</a> <a id="11191" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a><a id="11196" class="Symbol">)</a> <a id="11198" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="11202" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11206" href="WellFormed.Properties.html#11098" class="Bound">f</a>               <a id="11222" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="11225" href="WellFormed.Properties.html#11102" class="Bound">r</a> <a id="11227" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="11231" href="WellFormed.Properties.html#8938" class="Function">ω</a>                   <a id="11251" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="11253" class="Keyword">where</a> <a id="11259" class="Keyword">open</a> <a id="11264" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>定理 2-1-31</strong> <span class="math inline">ℕ</span> 与小于 <span class="math inline">\omega</span> 的序数同构.<br />
<strong>证明</strong> <span class="math inline">\text{fin}</span> 提供了正映射, 引理 2-1-30 提供了逆映射. 结合引理 2-1-29 可以说明它们互逆. ∎</p>
<pre class="Agda"><a id="ℕ≡ω"></a><a id="11405" href="WellFormed.Properties.html#11405" class="Function">ℕ≡ω</a> <a id="11409" class="Symbol">:</a> <a id="11411" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="11413" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11415" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11417" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="11421" class="Symbol">(</a><a id="11422" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;</a> <a id="11425" href="WellFormed.Properties.html#8938" class="Function">ω</a><a id="11426" class="Symbol">)</a>
<a id="11428" href="WellFormed.Properties.html#11405" class="Function">ℕ≡ω</a> <a id="11432" class="Symbol">=</a> <a id="11434" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="11443" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11445" href="Cubical.Foundations.Isomorphism.html#3223" class="Function">isoToPath</a> <a id="11455" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11457" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a>
  <a id="11463" class="Symbol">(λ</a> <a id="11466" href="WellFormed.Properties.html#11466" class="Bound">n</a> <a id="11468" class="Symbol">→</a> <a id="11470" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="11474" href="WellFormed.Properties.html#11466" class="Bound">n</a> <a id="11476" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11478" href="WellFormed.Properties.html#9128" class="Function">n&lt;ω</a><a id="11481" class="Symbol">)</a>
  <a id="11485" class="Symbol">(λ</a> <a id="11488" class="Symbol">(</a><a id="11489" href="WellFormed.Properties.html#11489" class="Bound">a</a> <a id="11491" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11493" href="WellFormed.Properties.html#11493" class="Bound">a&lt;ω</a><a id="11496" class="Symbol">)</a> <a id="11498" class="Symbol">→</a> <a id="11500" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="11504" class="Symbol">(</a><a id="11505" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11513" href="WellFormed.Properties.html#11493" class="Bound">a&lt;ω</a><a id="11516" class="Symbol">))</a>
  <a id="11521" class="Symbol">(λ</a> <a id="11524" href="WellFormed.Properties.html#11524" class="Bound">a</a> <a id="11526" class="Symbol">→</a> <a id="11528" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="11535" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11537" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11546" class="Symbol">(</a><a id="11547" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11551" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11553" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11561" class="Symbol">_)</a> <a id="11564" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11566" href="Cubical.Foundations.Prelude.html#13282" class="Function">toPathP</a> <a id="11574" class="Symbol">(</a><a id="11575" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="11583" class="Symbol">_</a> <a id="11585" class="Symbol">_))</a>
  <a id="11591" class="Symbol">(λ</a> <a id="11594" href="WellFormed.Properties.html#11594" class="Bound">n</a> <a id="11596" class="Symbol">→</a> <a id="11598" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11607" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11609" href="WellFormed.Properties.html#10571" class="Function">fin-inj</a> <a id="11617" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11619" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11623" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11625" href="WellFormed.Properties.html#10929" class="Function">fin-suj</a> <a id="11633" class="Symbol">_)</a>
  <a id="11638" class="Keyword">where</a> <a id="11644" class="Keyword">open</a> <a id="11649" class="Keyword">import</a> <a id="11656" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
