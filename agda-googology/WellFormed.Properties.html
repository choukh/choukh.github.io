<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (2.1 - 良构树序数的性质)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-2.1---良构树序数的性质" id="toc-形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</a>
  <ul>
  <li><a href="#序数函数" id="toc-序数函数">序数函数</a></li>
  <li><a href="#一些约定" id="toc-一些约定">一些约定</a></li>
  <li><a href="#一些引理" id="toc-一些引理">一些引理</a></li>
  <li><a href="#ω的性质" id="toc-ω的性质">ω的性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/WellFormed/Properties.lagda.md">Properties.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/WellFormed.Properties.html">Properties.html</a></p>
</blockquote>
<pre class="Agda"><a id="391" class="Symbol">{-#</a> <a id="395" class="Keyword">OPTIONS</a> <a id="403" class="Pragma">--safe</a> <a id="410" class="Pragma">--cubical</a> <a id="420" class="Pragma">--lossy-unification</a> <a id="440" class="Symbol">#-}</a>
<a id="444" class="Keyword">module</a> <a id="451" href="WellFormed.Properties.html" class="Module">WellFormed.Properties</a> <a id="473" class="Keyword">where</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="WellFormed.Base.html" class="Module">WellFormed.Base</a>
</pre>
<p><a href="https://zhuanlan.zhihu.com/p/711649863">上一篇</a>我们定义了良构树序数并证明了一些基本性质, 本文将继续讨论它的更多性质.</p>
<h2 id="序数函数">序数函数</h2>
<p>我们先定义关于序数函数的一些性质.</p>
<p><strong>定义 2-1-0</strong> 我们把序数函数的类型简记作 <span class="math inline">\text{Func}</span>, 序数的二元关系的类型简记作 <span class="math inline">\text{Rel}</span>, 并约定用大写的 <span class="math inline">F</span> 表示序数函数.</p>
<pre class="Agda"><a id="Func"></a><a id="722" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="727" class="Symbol">:</a> <a id="729" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="734" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="739" class="Symbol">=</a> <a id="741" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="745" class="Symbol">→</a> <a id="747" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>

<a id="Rel"></a><a id="752" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="756" class="Symbol">:</a> <a id="758" href="Agda.Primitive.html#388" class="Primitive">Type₁</a>
<a id="764" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="768" class="Symbol">=</a> <a id="770" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="774" class="Symbol">→</a> <a id="776" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="780" class="Symbol">→</a> <a id="782" href="Agda.Primitive.html#388" class="Primitive">Type</a>

<a id="788" class="Keyword">private</a> <a id="796" class="Keyword">variable</a> <a id="805" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="807" class="Symbol">:</a> <a id="809" href="WellFormed.Properties.html#722" class="Function">Func</a>
</pre>
<p><strong>定义 2-1-1</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>保持</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">x \sim y \to F(x) \sim F(y)</span>.</p>
<pre class="Agda"><a id="_preserves_"></a><a id="927" href="WellFormed.Properties.html#927" class="Function Operator">_preserves_</a> <a id="939" class="Symbol">:</a> <a id="941" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="946" class="Symbol">→</a> <a id="948" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="952" class="Symbol">→</a> <a id="954" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="959" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="961" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="971" href="WellFormed.Properties.html#971" class="Bound Operator">_~_</a> <a id="975" class="Symbol">=</a> <a id="977" class="Symbol">∀</a> <a id="979" class="Symbol">{</a><a id="980" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="982" href="WellFormed.Properties.html#982" class="Bound">y</a><a id="983" class="Symbol">}</a> <a id="985" class="Symbol">→</a> <a id="987" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="989" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="991" href="WellFormed.Properties.html#982" class="Bound">y</a> <a id="993" class="Symbol">→</a> <a id="995" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="997" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="999" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="1001" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="1003" href="WellFormed.Properties.html#982" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-2</strong> 如果 <span class="math inline">F</span> 保持 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 保持 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-pres≤"></a><a id="1067" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1077" class="Symbol">:</a> <a id="1079" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1081" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1091" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1095" class="Symbol">→</a> <a id="1097" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1099" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1109" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1113" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1123" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1128" class="Symbol">(</a><a id="1129" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1133" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1134" class="Symbol">)</a>    <a id="1139" class="Symbol">=</a> <a id="1141" href="WellFormed.Base.html#11879" class="Function">&lt;→≤</a> <a id="1145" class="Symbol">(</a><a id="1146" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1151" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1152" class="Symbol">)</a>
<a id="1154" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1164" href="WellFormed.Properties.html#1164" class="Bound">pres</a> <a id="1169" class="Symbol">(</a><a id="1170" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1174" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="1178" class="Symbol">)</a> <a id="1180" class="Symbol">=</a> <a id="1182" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1186" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义 2-1-3</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>单射</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">F(x) \sim F(y) \to x \sim y</span>.</p>
<pre class="Agda"><a id="_injects_"></a><a id="1304" href="WellFormed.Properties.html#1304" class="Function Operator">_injects_</a> <a id="1314" class="Symbol">:</a> <a id="1316" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="1321" class="Symbol">→</a> <a id="1323" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="1327" class="Symbol">→</a> <a id="1329" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="1334" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1336" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1344" href="WellFormed.Properties.html#1344" class="Bound Operator">_~_</a> <a id="1348" class="Symbol">=</a> <a id="1350" class="Symbol">∀</a> <a id="1352" class="Symbol">{</a><a id="1353" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1355" href="WellFormed.Properties.html#1355" class="Bound">y</a><a id="1356" class="Symbol">}</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1362" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1364" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1366" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1368" href="WellFormed.Properties.html#1355" class="Bound">y</a> <a id="1370" class="Symbol">→</a> <a id="1372" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1374" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1376" href="WellFormed.Properties.html#1355" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-4</strong> 如果 <span class="math inline">F</span> 单射 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 单射 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-inj≤"></a><a id="1440" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1449" class="Symbol">:</a> <a id="1451" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1453" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1461" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="1465" class="Symbol">→</a> <a id="1467" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1469" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1477" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1481" class="Symbol">→</a> <a id="1483" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1485" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1493" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1497" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1506" href="WellFormed.Properties.html#1506" class="Bound">inj</a> <a id="1510" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1515" class="Symbol">(</a><a id="1516" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1520" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1521" class="Symbol">)</a> <a id="1523" class="Symbol">=</a> <a id="1525" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1529" class="Symbol">(</a><a id="1530" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1535" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1536" class="Symbol">)</a>
<a id="1538" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1547" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1551" href="WellFormed.Properties.html#1551" class="Bound">inj&lt;</a> <a id="1556" class="Symbol">(</a><a id="1557" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1561" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1562" class="Symbol">)</a> <a id="1564" class="Symbol">=</a> <a id="1566" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1570" class="Symbol">(</a><a id="1571" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1575" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1576" class="Symbol">)</a>
</pre>
<h2 id="一些约定">一些约定</h2>
<p><strong>记法 2-1-5</strong> 隐参版极限构造子: 它们与原版的区别在于良构条件为隐式参数, 从而允许从上下文自动推断出它们, 而不用一一显式写出.</p>
<pre class="Agda"><a id="lim-"></a><a id="1673" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1678" class="Symbol">:</a> <a id="1680" class="Symbol">(</a><a id="1681" href="WellFormed.Properties.html#1681" class="Bound">f</a> <a id="1683" class="Symbol">:</a> <a id="1685" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="1688" class="Symbol">)</a> <a id="1690" class="Symbol">{</a><a id="1691" href="WellFormed.Properties.html#1691" class="Bound">w</a> <a id="1693" class="Symbol">:</a> <a id="1695" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1698" href="WellFormed.Properties.html#1681" class="Bound">f</a><a id="1699" class="Symbol">}</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="1707" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1712" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1714" class="Symbol">{</a><a id="1715" href="WellFormed.Properties.html#1715" class="Bound">w</a><a id="1716" class="Symbol">}</a> <a id="1718" class="Symbol">=</a> <a id="1720" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="1724" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1726" class="Symbol">⦃</a> <a id="1728" href="WellFormed.Properties.html#1715" class="Bound">w</a> <a id="1730" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的路径 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的路径记作 <span class="math inline">\text{rd}[n](r)</span>.</p>
<pre class="Agda"><a id="rd[_]"></a><a id="1834" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1840" class="Symbol">:</a> <a id="1842" class="Symbol">(</a><a id="1843" href="WellFormed.Properties.html#1843" class="Bound">n</a> <a id="1845" class="Symbol">:</a> <a id="1847" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1848" class="Symbol">)</a> <a id="1850" class="Symbol">{</a><a id="1851" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1853" class="Symbol">:</a> <a id="1855" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1858" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="1859" class="Symbol">}</a> <a id="1861" class="Symbol">→</a> <a id="1863" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1868" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1870" class="Symbol">(</a><a id="1871" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1873" href="WellFormed.Properties.html#1843" class="Bound">n</a><a id="1874" class="Symbol">)</a> <a id="1876" class="Symbol">→</a> <a id="1878" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1883" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1885" class="Symbol">(</a><a id="1886" class="InductiveConstructor">lim</a> <a id="1890" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1892" class="Symbol">⦃</a> <a id="1894" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1896" class="Symbol">⦄)</a>
<a id="1899" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1905" href="WellFormed.Properties.html#1905" class="Bound">n</a> <a id="1907" class="Symbol">=</a> <a id="1909" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="1913" class="Symbol">{</a><a id="1914" class="Argument">n</a> <a id="1916" class="Symbol">=</a> <a id="1918" href="WellFormed.Properties.html#1905" class="Bound">n</a><a id="1919" class="Symbol">}</a> <a id="1921" class="Symbol">⦃</a> <a id="1923" class="Symbol">_</a> <a id="1925" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的证明 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的证明记作 <span class="math inline">\text{&lt;}[n](r)</span>.</p>
<pre class="Agda"><a id="&lt;[_]"></a><a id="2028" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2033" class="Symbol">:</a> <a id="2035" class="Symbol">(</a><a id="2036" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2038" class="Symbol">:</a> <a id="2040" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2041" class="Symbol">)</a> <a id="2043" class="Symbol">{</a><a id="2044" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2046" class="Symbol">:</a> <a id="2048" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="2051" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="2052" class="Symbol">}</a> <a id="2054" class="Symbol">→</a> <a id="2056" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2058" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2060" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2062" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2064" class="Symbol">→</a> <a id="2066" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2068" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2070" class="InductiveConstructor">lim</a> <a id="2074" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2076" class="Symbol">⦃</a> <a id="2078" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2080" class="Symbol">⦄</a>
<a id="2082" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2087" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2089" class="Symbol">=</a> <a id="2091" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="2095" href="WellFormed.Properties.html#1834" class="Function Operator">rd[</a> <a id="2099" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2101" href="WellFormed.Properties.html#1834" class="Function Operator">]</a>
</pre>
<p><strong>约定 2-1-6</strong> 鉴于路径关系与子树关系的高度可互换性, 我们今后在自然语言中会适当地混淆两者, 例如把路径的构造说成是子树关系的证明, 或反之. 读者应该理解为是调用了上一篇的引理进行了两者的转换.</p>
<p><strong>事实 2-1-7</strong> 极限序数的判定: 树序数的归纳定义允许我们快速判断一个序数是否是极限序数.</p>
<pre class="Agda"><a id="IsLim"></a><a id="2274" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2280" class="Symbol">:</a> <a id="2282" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="2286" class="Symbol">→</a> <a id="2288" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="2293" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2299" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="2304" class="Symbol">=</a> <a id="2306" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2308" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2314" class="Symbol">(</a><a id="2315" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2319" href="WellFormed.Properties.html#2319" class="Bound">a</a><a id="2320" class="Symbol">)</a> <a id="2322" class="Symbol">=</a> <a id="2324" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2326" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2332" class="Symbol">(</a><a id="2333" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2337" href="WellFormed.Properties.html#2337" class="Bound">f</a><a id="2338" class="Symbol">)</a> <a id="2340" class="Symbol">=</a> <a id="2342" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a>
</pre>
<p><strong>记法 2-1-8</strong> 极限序数的基本列: 如果 <span class="math inline">a</span> 是极限序数, 那么我们用 <span class="math inline">a[n]</span> 表示其基本列的第 <span class="math inline">n</span> 项. 由序数的定义有 <span class="math inline">a[n] &lt; a[n^+]</span>.</p>
<pre class="Agda"><a id="_[_]"></a><a id="2449" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2454" class="Symbol">:</a> <a id="2456" class="Symbol">(</a><a id="2457" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2459" class="Symbol">:</a> <a id="2461" href="WellFormed.Base.html#2971" class="Datatype">Ord</a><a id="2464" class="Symbol">)</a> <a id="2466" class="Symbol">→</a> <a id="2468" class="Symbol">⦃</a> <a id="2470" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2476" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2478" class="Symbol">⦄</a> <a id="2480" class="Symbol">→</a> <a id="2482" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2486" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2491" class="Symbol">(</a><a id="2492" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2496" href="WellFormed.Properties.html#2496" class="Bound">f</a><a id="2497" class="Symbol">)</a> <a id="2499" class="Symbol">=</a> <a id="2501" href="WellFormed.Properties.html#2496" class="Bound">f</a>

<a id="[]-wf"></a><a id="2504" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2510" class="Symbol">:</a> <a id="2512" class="Symbol">⦃</a> <a id="2514" href="WellFormed.Properties.html#2514" class="Bound">_</a> <a id="2516" class="Symbol">:</a> <a id="2518" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2524" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2526" class="Symbol">⦄</a> <a id="2528" class="Symbol">→</a> <a id="2530" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2532" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2534" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2536" href="WellFormed.Properties.html#2449" class="Function Operator">]</a> <a id="2538" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2540" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2542" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2544" class="InductiveConstructor">suc</a> <a id="2548" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2550" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="2552" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2558" class="Symbol">{</a><a id="2559" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2563" href="WellFormed.Properties.html#2563" class="Bound">f</a><a id="2564" class="Symbol">}</a> <a id="2566" class="Symbol">=</a> <a id="2568" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>定义 2-1-9</strong> 自然数到序数的嵌入 <span class="math inline">\text{fin} : ℕ → \text{Ord}</span></p>
<p><span class="math display">
\text{fin}(n) := \text{suc}^n(0)
</span></p>
<p>其中后继函数的上标 <span class="math inline">n</span> 表示迭代 <span class="math inline">n</span> 次.</p>
<pre class="Agda"><a id="2705" class="Keyword">open</a> <a id="2710" class="Keyword">import</a> <a id="2717" href="Lower.html" class="Module">Lower</a> <a id="2723" class="Keyword">public</a> <a id="2730" class="Keyword">using</a> <a id="2736" class="Symbol">(</a><a id="2737" href="Lower.html#1118" class="Function Operator">_∘ⁿ_</a><a id="2741" class="Symbol">)</a>
<a id="fin"></a><a id="2743" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2747" class="Symbol">:</a> <a id="2749" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2753" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2757" href="WellFormed.Properties.html#2757" class="Bound">n</a> <a id="2759" class="Symbol">=</a> <a id="2761" class="Symbol">(</a><a id="2762" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2766" href="Lower.html#1118" class="Function Operator">∘ⁿ</a> <a id="2769" href="WellFormed.Properties.html#2757" class="Bound">n</a><a id="2770" class="Symbol">)</a> <a id="2772" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a>
</pre>
<p>非形式地, 后文中我们把 <span class="math inline">\text{fin}</span> 视作类型强转 (coercion).</p>
<p><strong>约定 2-1-10</strong> 数字字面量既可以表示自然数, 也可以表示序数. Agda 使用<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能实现该约定.</p>
<pre class="Agda"><a id="2976" class="Keyword">open</a> <a id="2981" class="Keyword">import</a> <a id="2988" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="3009" class="Keyword">public</a>
<a id="3016" class="Keyword">instance</a>
  <a id="nNat"></a><a id="3027" href="WellFormed.Properties.html#3027" class="Function">nNat</a> <a id="3032" class="Symbol">=</a> <a id="3034" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3041" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="3045" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3047" class="Keyword">record</a> <a id="3054" class="Symbol">{</a> <a id="3056" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3067" class="Symbol">=</a> <a id="3069" class="Symbol">λ</a> <a id="3071" href="WellFormed.Properties.html#3071" class="Bound">_</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3077" class="Symbol">;</a> <a id="3079" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3087" class="Symbol">=</a> <a id="3089" class="Symbol">λ</a> <a id="3091" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3093" class="Symbol">→</a> <a id="3095" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3097" class="Symbol">}</a>
  <a id="nOrd"></a><a id="3101" href="WellFormed.Properties.html#3101" class="Function">nOrd</a> <a id="3106" class="Symbol">=</a> <a id="3108" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3115" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3119" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3121" class="Keyword">record</a> <a id="3128" class="Symbol">{</a> <a id="3130" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3141" class="Symbol">=</a> <a id="3143" class="Symbol">λ</a> <a id="3145" href="WellFormed.Properties.html#3145" class="Bound">_</a> <a id="3147" class="Symbol">→</a> <a id="3149" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3151" class="Symbol">;</a> <a id="3153" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3161" class="Symbol">=</a> <a id="3163" class="Symbol">λ</a> <a id="3165" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3167" class="Symbol">→</a> <a id="3169" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="3173" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3175" class="Symbol">}</a>
</pre>
<h2 id="一些引理">一些引理</h2>
<p><strong>事实 2-1-11</strong> 构造子的单射性</p>
<ul>
<li><span class="math inline">a^+ =b ^+ → a = b</span></li>
<li><span class="math inline">\lim f = \lim g → f = g</span></li>
</ul>
<pre class="Agda"><a id="suc-inj"></a><a id="3273" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3281" class="Symbol">:</a> <a id="3283" class="InductiveConstructor">suc</a> <a id="3287" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3289" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3291" class="InductiveConstructor">suc</a> <a id="3295" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3297" class="Symbol">→</a> <a id="3299" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3301" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3303" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3305" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3313" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3318" class="Symbol">=</a> <a id="3320" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lim-inj"></a><a id="3326" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3334" class="Symbol">:</a> <a id="3336" class="Symbol">{</a><a id="3337" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3341" class="Symbol">:</a> <a id="3343" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3346" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="3347" class="Symbol">}</a> <a id="3349" class="Symbol">{</a><a id="3350" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3354" class="Symbol">:</a> <a id="3356" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3359" href="WellFormed.Base.html#3796" class="Generalizable">g</a><a id="3360" class="Symbol">}</a> <a id="3362" class="Symbol">→</a> <a id="3364" href="WellFormed.Base.html#4217" class="InductiveConstructor">Ord.lim</a> <a id="3372" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3374" class="Symbol">⦃</a> <a id="3376" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3380" class="Symbol">⦄</a> <a id="3382" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3384" class="InductiveConstructor">lim</a> <a id="3388" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="3390" class="Symbol">⦃</a> <a id="3392" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3396" class="Symbol">⦄</a> <a id="3398" class="Symbol">→</a> <a id="3400" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3402" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3404" href="WellFormed.Base.html#3796" class="Generalizable">g</a>
<a id="3406" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3414" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3419" class="Symbol">=</a> <a id="3421" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实 2-1-12</strong> 极限路径的反演: 如果 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span>, 那么存在一个自然数 <span class="math inline">n</span> 使得 <span class="math inline">b</span> 小于 <span class="math inline">a[n]</span>.</p>
<pre class="Agda"><a id="lim-inv-rd"></a><a id="3514" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3525" class="Symbol">:</a> <a id="3527" class="Symbol">⦃</a> <a id="3529" href="WellFormed.Properties.html#3529" class="Bound">_</a> <a id="3531" class="Symbol">:</a> <a id="3533" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3539" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3541" class="Symbol">⦄</a> <a id="3543" class="Symbol">→</a> <a id="3545" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3550" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3552" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3554" class="Symbol">→</a> <a id="3556" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3559" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3561" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3563" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3565" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3567" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3572" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3574" class="Symbol">(</a><a id="3575" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3577" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3579" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3581" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="3582" class="Symbol">)</a>
<a id="3584" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3595" class="Symbol">(</a><a id="3596" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="3600" href="WellFormed.Properties.html#3600" class="Bound">r</a><a id="3601" class="Symbol">)</a> <a id="3603" class="Symbol">=</a> <a id="3605" class="Symbol">_</a> <a id="3607" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3609" href="WellFormed.Properties.html#3600" class="Bound">r</a>

<a id="lim-inv"></a><a id="3612" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3620" class="Symbol">:</a> <a id="3622" class="Symbol">⦃</a> <a id="3624" href="WellFormed.Properties.html#3624" class="Bound">_</a> <a id="3626" class="Symbol">:</a> <a id="3628" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3634" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3636" class="Symbol">⦄</a> <a id="3638" class="Symbol">→</a> <a id="3640" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3642" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3644" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3646" class="Symbol">→</a> <a id="3648" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3651" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3653" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3655" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3657" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3659" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3661" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3663" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3665" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3667" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3669" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="3671" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3679" href="WellFormed.Properties.html#3679" class="Bound">r</a> <a id="3681" class="Keyword">with</a> <a id="3686" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3697" class="Symbol">(</a><a id="3698" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="3702" href="WellFormed.Properties.html#3679" class="Bound">r</a><a id="3703" class="Symbol">)</a>
<a id="3705" class="Symbol">...</a> <a id="3709" class="Symbol">|</a> <a id="3711" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3713" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3715" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3717" class="Symbol">=</a> <a id="3719" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3721" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3723" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3725" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3727" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>鉴于互递归证明的特性, 我们有时会先声明定理, 然后再证明其所需的引理, 最后再证明定理本身.</p>
<p><strong>定理 2-1-13</strong> 互递归地, 有</p>
<p><span class="math display">
\begin{aligned}
(1)&amp; \quad a &lt; b → 0 &lt; b \\
(2)&amp; \quad 0 &lt; a^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="z&lt;b-rd"></a><a id="3899" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="3906" class="Symbol">:</a> <a id="3908" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3913" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3915" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3917" class="Symbol">→</a> <a id="3919" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3924" class="Number">0</a> <a id="3926" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="z&lt;s-rd"></a><a id="3928" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="3935" class="Symbol">:</a> <a id="3937" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3942" class="Number">0</a> <a id="3944" class="Symbol">(</a><a id="3945" class="InductiveConstructor">suc</a> <a id="3949" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="3950" class="Symbol">)</a>

<a id="z&lt;b"></a><a id="3953" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3957" class="Symbol">:</a> <a id="3959" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3961" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3963" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3965" class="Symbol">→</a> <a id="3967" class="Number">0</a> <a id="3969" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3971" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3973" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3977" class="Symbol">=</a> <a id="3979" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="3983" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a>

<a id="z&lt;s"></a><a id="3991" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="3995" class="Symbol">:</a> <a id="3997" class="Number">0</a> <a id="3999" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4001" class="InductiveConstructor">suc</a> <a id="4005" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="4007" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="4011" class="Symbol">=</a> <a id="4013" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="4015" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4022" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p><strong>引理 2-1-14</strong> 基本列的后继项必然大于零.<br />
<strong>证明</strong> 给定基本列 <span class="math inline">f</span>, 由于 <span class="math inline">f(n)&lt;f(n^+)</span>, 由定理 2-1-12 即证. ∎</p>
<pre class="Agda"><a id="z&lt;fs"></a><a id="4122" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4127" class="Symbol">:</a> <a id="4129" class="Symbol">∀</a> <a id="4131" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4133" href="WellFormed.Properties.html#4133" class="Bound">n</a> <a id="4135" class="Symbol">→</a> <a id="4137" class="Symbol">⦃</a> <a id="4139" href="WellFormed.Properties.html#4139" class="Bound">_</a> <a id="4141" class="Symbol">:</a> <a id="4143" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4146" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4148" class="Symbol">⦄</a> <a id="4150" class="Symbol">→</a> <a id="4152" class="Number">0</a> <a id="4154" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4156" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4158" class="Symbol">(</a><a id="4159" class="InductiveConstructor">suc</a> <a id="4163" href="WellFormed.Properties.html#4133" class="Bound">n</a><a id="4164" class="Symbol">)</a>
<a id="4166" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4171" href="WellFormed.Properties.html#4171" class="Bound">f</a> <a id="4173" href="WellFormed.Properties.html#4173" class="Bound">n</a> <a id="4175" class="Symbol">=</a> <a id="4177" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="4181" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-15</strong> 极限序数必然大于零.<br />
<strong>证明</strong> 由 <span class="math inline">\text{&lt;}[1]</span>, 我们证明其基本列第 <span class="math inline">1</span> 项大于零, 而这由引理 2-1-14 即证. ∎</p>
<pre class="Agda"><a id="z&lt;l"></a><a id="4288" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a> <a id="4292" class="Symbol">:</a> <a id="4294" class="Symbol">{</a><a id="4295" href="WellFormed.Properties.html#4295" class="Bound">w</a> <a id="4297" class="Symbol">:</a> <a id="4299" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4302" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="4303" class="Symbol">}</a> <a id="4305" class="Symbol">→</a> <a id="4307" class="Number">0</a> <a id="4309" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4311" class="InductiveConstructor">lim</a> <a id="4315" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="4317" class="Symbol">⦃</a> <a id="4319" href="WellFormed.Properties.html#4295" class="Bound">w</a> <a id="4321" class="Symbol">⦄</a>
<a id="4323" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a> <a id="4327" class="Symbol">{</a><a id="4328" href="WellFormed.Properties.html#4328" class="Bound">f</a><a id="4329" class="Symbol">}</a> <a id="4331" class="Symbol">{</a><a id="4332" href="WellFormed.Properties.html#4332" class="Bound">w</a><a id="4333" class="Symbol">}</a> <a id="4335" class="Symbol">=</a> <a id="4337" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[</a> <a id="4340" class="Number">1</a> <a id="4342" href="WellFormed.Properties.html#2028" class="Function Operator">]</a> <a id="4344" class="Symbol">(</a><a id="4345" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4350" href="WellFormed.Properties.html#4328" class="Bound">f</a> <a id="4352" class="Number">0</a> <a id="4354" class="Symbol">⦃</a> <a id="4356" href="WellFormed.Properties.html#4332" class="Bound">w</a> <a id="4358" class="Symbol">⦄)</a>
</pre>
<p><strong>定理 2-1-13-(1)</strong> <span class="math inline">a &lt; b → 0 &lt; b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = \text{zero} : a &lt; a^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = \text{suc}(r&#39;) : a &lt; b^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 由引理 2-1-15 即得 <span class="math inline">0 &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="4632" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4639" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="4644" class="Symbol">=</a> <a id="4646" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4653" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4660" class="Symbol">(</a><a id="4661" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4665" href="WellFormed.Properties.html#4665" class="Bound">r</a><a id="4666" class="Symbol">)</a> <a id="4668" class="Symbol">=</a> <a id="4670" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4677" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4684" class="Symbol">(</a><a id="4685" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="4689" href="WellFormed.Properties.html#4689" class="Bound">r</a><a id="4690" class="Symbol">)</a> <a id="4692" class="Symbol">=</a> <a id="4694" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="4698" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-13-(2)</strong> <span class="math inline">0 &lt; a^+</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 有 <span class="math inline">\text{zero}:0 &lt; 0^+</span>.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 有归纳假设 <span class="math inline">r : 0 &lt; a&#39;^+</span>, 所以 <span class="math inline">\text{suc}(r) : 0 &lt; a&#39;^{++}</span>.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 要证 <span class="math inline">a &lt; \lim(f)^+</span>, 由路径构造子 <span class="math inline">\text{suc}</span> 及引理 2-1-15 即得. ∎</li>
</ul>
<pre class="Agda"><a id="4951" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4958" class="Symbol">{(</a><a id="4960" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="4964" class="Symbol">)}</a> <a id="4967" class="Symbol">=</a> <a id="4969" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="4974" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4981" class="Symbol">{</a><a id="4982" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="4986" href="WellFormed.Properties.html#4986" class="Bound">a</a><a id="4987" class="Symbol">}</a> <a id="4989" class="Symbol">=</a> <a id="4991" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4995" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="5002" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="5009" class="Symbol">{</a><a id="5010" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5014" href="WellFormed.Properties.html#5014" class="Bound">f</a><a id="5015" class="Symbol">}</a> <a id="5017" class="Symbol">=</a> <a id="5019" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="5023" class="Symbol">(</a><a id="5024" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="5028" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a><a id="5031" class="Symbol">)</a>
</pre>
<p><strong>推论 2-1-16</strong> 零小于等于任何序数.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳. 零的情况由自反性, 后继的情况由2-1-13-(2), 极限的情况由引理 2-1-15 即得. ∎</p>
<pre class="Agda"><a id="z≤"></a><a id="5141" href="WellFormed.Properties.html#5141" class="Function">z≤</a> <a id="5144" class="Symbol">:</a> <a id="5146" class="Number">0</a> <a id="5148" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5150" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="5152" href="WellFormed.Properties.html#5141" class="Function">z≤</a> <a id="5155" class="Symbol">{(</a><a id="5157" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="5161" class="Symbol">)}</a> <a id="5164" class="Symbol">=</a> <a id="5166" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5170" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5175" href="WellFormed.Properties.html#5141" class="Function">z≤</a> <a id="5178" class="Symbol">{</a><a id="5179" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5183" class="Symbol">_}</a>  <a id="5187" class="Symbol">=</a> <a id="5189" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5193" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a>
<a id="5197" href="WellFormed.Properties.html#5141" class="Function">z≤</a> <a id="5200" class="Symbol">{</a><a id="5201" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5205" class="Symbol">_}</a>  <a id="5209" class="Symbol">=</a> <a id="5211" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5215" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-17</strong> 互递归地, 有</p>
<ul>
<li><ol type="1">
<li><span class="math inline">a &lt; b \to a^+ ≤ b</span>.</li>
</ol></li>
<li><ol start="2" type="1">
<li>后继运算保持 <span class="math inline">&lt;</span>.</li>
</ol></li>
</ul>
<pre class="Agda"><a id="&lt;→s≤-rd"></a><a id="5301" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="5309" class="Symbol">:</a> <a id="5311" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="5316" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5318" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5320" class="Symbol">→</a> <a id="5322" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="5329" class="Symbol">(</a><a id="5330" class="InductiveConstructor">suc</a> <a id="5334" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="5335" class="Symbol">)</a> <a id="5337" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="s&lt;s-rd"></a><a id="5339" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="5346" class="Symbol">:</a> <a id="5348" class="InductiveConstructor">suc</a> <a id="5352" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5362" href="WellFormed.Base.html#2987" class="Datatype">Road</a>

<a id="&lt;→s≤"></a><a id="5368" href="WellFormed.Properties.html#5368" class="Function">&lt;→s≤</a> <a id="5373" class="Symbol">:</a> <a id="5375" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5377" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="5379" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5381" class="Symbol">→</a> <a id="5383" class="InductiveConstructor">suc</a> <a id="5387" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5389" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5391" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="5393" href="WellFormed.Properties.html#5368" class="Function">&lt;→s≤</a> <a id="5398" class="Symbol">=</a> <a id="5400" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="5404" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="5412" class="Symbol">(</a><a id="5413" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="5418" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5420" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a><a id="5427" class="Symbol">)</a>

<a id="s&lt;s"></a><a id="5430" href="WellFormed.Properties.html#5430" class="Function">s&lt;s</a> <a id="5434" class="Symbol">:</a> <a id="5436" class="InductiveConstructor">suc</a> <a id="5440" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5450" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="5454" href="WellFormed.Properties.html#5430" class="Function">s&lt;s</a> <a id="5458" class="Symbol">=</a> <a id="5460" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="5464" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a>
</pre>
<p><strong>定理 2-1-17-(1)</strong> <span class="math inline">a &lt; b \to a^+ ≤ b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = \text{zero} : a &lt; a^+</span>, 由自反性即得 <span class="math inline">a^+ ≤ a^+</span>.</li>
<li>若 <span class="math inline">r = \text{suc}(r&#39;) : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由定理 2-1-17-(2) 即得 <span class="math inline">a^+ ≤ b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 由定理 2-1-17-(2) 有 <span class="math inline">a^+ &lt; f(n)^+</span>, 由归纳假设有 <span class="math inline">f(n)^+ ≤ f(n^+)</span>, 由传递性即得 <span class="math inline">a^+ &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="5830" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="5838" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="5843" class="Symbol">=</a> <a id="5845" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5849" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5854" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="5862" class="Symbol">(</a><a id="5863" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="5867" href="WellFormed.Properties.html#5867" class="Bound">r</a><a id="5868" class="Symbol">)</a> <a id="5870" class="Symbol">=</a> <a id="5872" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5876" class="Symbol">(</a><a id="5877" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="5884" href="WellFormed.Properties.html#5867" class="Bound">r</a><a id="5885" class="Symbol">)</a>
<a id="5887" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="5895" class="Symbol">{</a><a id="5896" href="WellFormed.Properties.html#5896" class="Bound">a</a><a id="5897" class="Symbol">}</a> <a id="5899" class="Symbol">(</a><a id="5900" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="5904" class="Symbol">{</a><a id="5905" href="WellFormed.Properties.html#5905" class="Bound">f</a><a id="5906" class="Symbol">}</a> <a id="5908" class="Symbol">{</a><a id="5909" href="WellFormed.Properties.html#5909" class="Bound">n</a><a id="5910" class="Symbol">}</a> <a id="5912" href="WellFormed.Properties.html#5912" class="Bound">r</a><a id="5913" class="Symbol">)</a> <a id="5915" class="Symbol">=</a> <a id="5917" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5921" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5923" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="5938" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5942" href="WellFormed.Properties.html#5896" class="Bound">a</a>           <a id="5954" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="5957" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="5964" href="WellFormed.Properties.html#5912" class="Bound">r</a> <a id="5966" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="5970" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5974" class="Symbol">(</a><a id="5975" href="WellFormed.Properties.html#5905" class="Bound">f</a> <a id="5977" href="WellFormed.Properties.html#5909" class="Bound">n</a><a id="5978" class="Symbol">)</a>       <a id="5986" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="5989" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="5997" class="Symbol">(</a><a id="5998" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="6002" href="Function.Base.html#4736" class="Function">it</a><a id="6004" class="Symbol">)</a> <a id="6006" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="6010" href="WellFormed.Properties.html#5905" class="Bound">f</a> <a id="6012" class="Symbol">(</a><a id="6013" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6017" href="WellFormed.Properties.html#5909" class="Bound">n</a><a id="6018" class="Symbol">)</a>       <a id="6026" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6029" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="6036" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6040" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6044" href="WellFormed.Properties.html#5905" class="Bound">f</a>           <a id="6056" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6058" class="Keyword">where</a> <a id="6064" class="Keyword">open</a> <a id="6069" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-17-(2)</strong> 后继运算保持 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳, 要证 <span class="math inline">a^+ &lt; b^+</span>.</p>
<ul>
<li>若 <span class="math inline">r = \text{zero} : a &lt; a^+</span>, 有 <span class="math inline">\text{zero} : a^+ &lt; a^{++}</span>.</li>
<li>若 <span class="math inline">r = \text{suc}(r&#39;) : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由归纳假设即得 <span class="math inline">a^+ &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 与定理 2-1-17-(1) 同理可证 <span class="math inline">a^+ &lt; \lim(f)</span>, 再由路径构造子 <span class="math inline">\text{suc}</span> 即得 <span class="math inline">a^+ &lt; \lim(f)^+</span>. ∎</li>
</ul>
<pre class="Agda"><a id="6448" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="6455" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6460" class="Symbol">=</a> <a id="6462" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="6467" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="6474" class="Symbol">(</a><a id="6475" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6479" href="WellFormed.Properties.html#6479" class="Bound">r</a><a id="6480" class="Symbol">)</a> <a id="6482" class="Symbol">=</a> <a id="6484" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6488" class="Symbol">(</a><a id="6489" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="6496" href="WellFormed.Properties.html#6479" class="Bound">r</a><a id="6497" class="Symbol">)</a>
<a id="6499" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="6506" class="Symbol">{</a><a id="6507" href="WellFormed.Properties.html#6507" class="Bound">x</a><a id="6508" class="Symbol">}</a> <a id="6510" class="Symbol">(</a><a id="6511" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="6515" class="Symbol">{</a><a id="6516" href="WellFormed.Properties.html#6516" class="Bound">f</a><a id="6517" class="Symbol">}</a> <a id="6519" class="Symbol">{</a><a id="6520" href="WellFormed.Properties.html#6520" class="Bound">n</a><a id="6521" class="Symbol">}</a> <a id="6523" href="WellFormed.Properties.html#6523" class="Bound">r</a><a id="6524" class="Symbol">)</a> <a id="6526" class="Symbol">=</a> <a id="6528" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6532" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6534" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="6549" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6553" href="WellFormed.Properties.html#6507" class="Bound">x</a>           <a id="6565" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6568" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="6575" href="WellFormed.Properties.html#6523" class="Bound">r</a> <a id="6577" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6581" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6585" class="Symbol">(</a><a id="6586" href="WellFormed.Properties.html#6516" class="Bound">f</a> <a id="6588" href="WellFormed.Properties.html#6520" class="Bound">n</a><a id="6589" class="Symbol">)</a>       <a id="6597" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="6600" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="6608" class="Symbol">(</a><a id="6609" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="6613" href="Function.Base.html#4736" class="Function">it</a><a id="6615" class="Symbol">)</a> <a id="6617" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="6621" href="WellFormed.Properties.html#6516" class="Bound">f</a> <a id="6623" class="Symbol">(</a><a id="6624" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6628" href="WellFormed.Properties.html#6520" class="Bound">n</a><a id="6629" class="Symbol">)</a>       <a id="6637" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6640" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="6647" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6651" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6655" href="WellFormed.Properties.html#6516" class="Bound">f</a>           <a id="6667" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6669" class="Keyword">where</a> <a id="6675" class="Keyword">open</a> <a id="6680" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-18</strong> 后继运算单射 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a^+ &lt; b^+</span> 归纳, 要证 <span class="math inline">a &lt; b</span>.</p>
<ul>
<li>若 <span class="math inline">r = \text{zero} : a^+ &lt; a^{++}</span>, 有 <span class="math inline">\text{zero} : a &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = \text{suc}(r&#39;) : a^+ &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a^+ &lt; b</span>. 由传递性即得 <span class="math inline">a &lt; a^+ &lt; b</span>.</li>
<li>没有 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 的情况, 因为 <span class="math inline">\lim(f)</span> 不可能是后继序数. ∎</li>
</ul>
<pre class="Agda"><a id="s&lt;s-inj-rd"></a><a id="6990" href="WellFormed.Properties.html#6990" class="Function">s&lt;s-inj-rd</a> <a id="7001" class="Symbol">:</a> <a id="7003" class="InductiveConstructor">suc</a> <a id="7007" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="7015" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="7020" href="WellFormed.Properties.html#6990" class="Function">s&lt;s-inj-rd</a> <a id="7031" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="7036" class="Symbol">=</a> <a id="7038" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="7043" href="WellFormed.Properties.html#6990" class="Function">s&lt;s-inj-rd</a> <a id="7054" class="Symbol">(</a><a id="7055" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="7059" href="WellFormed.Properties.html#7059" class="Bound">r</a><a id="7060" class="Symbol">)</a> <a id="7062" class="Symbol">=</a> <a id="7064" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="7073" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="7078" href="WellFormed.Properties.html#7059" class="Bound">r</a>

<a id="s&lt;s-inj"></a><a id="7081" href="WellFormed.Properties.html#7081" class="Function">s&lt;s-inj</a> <a id="7089" class="Symbol">:</a> <a id="7091" class="InductiveConstructor">suc</a> <a id="7095" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="7103" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="7107" href="WellFormed.Properties.html#7081" class="Function">s&lt;s-inj</a> <a id="7115" class="Symbol">=</a> <a id="7117" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7121" href="WellFormed.Properties.html#6990" class="Function">s&lt;s-inj-rd</a>
</pre>
<p><strong>推论 2-1-19</strong> 后继运算保持 <span class="math inline">\leq</span>, 且单射 <span class="math inline">\leq</span>.<br />
<strong>证明</strong> 由事实 2-1-2 和定理 2-1-17-(2) 可证保持; 由事实 2-1-4, 事实 2-1-11 和定理 2-1-18 可证单射. ∎</p>
<pre class="Agda"><a id="s≤s"></a><a id="7267" href="WellFormed.Properties.html#7267" class="Function">s≤s</a> <a id="7271" class="Symbol">:</a> <a id="7273" class="InductiveConstructor">suc</a> <a id="7277" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="7287" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7291" href="WellFormed.Properties.html#7267" class="Function">s≤s</a> <a id="7295" class="Symbol">=</a> <a id="7297" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="7307" href="WellFormed.Properties.html#5430" class="Function">s&lt;s</a>

<a id="s≤s-inj"></a><a id="7312" href="WellFormed.Properties.html#7312" class="Function">s≤s-inj</a> <a id="7320" class="Symbol">:</a> <a id="7322" class="InductiveConstructor">suc</a> <a id="7326" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="7334" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7338" href="WellFormed.Properties.html#7312" class="Function">s≤s-inj</a> <a id="7346" class="Symbol">=</a> <a id="7348" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="7357" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="7365" href="WellFormed.Properties.html#7081" class="Function">s&lt;s-inj</a>
</pre>
<p><strong>定理 2-1-20</strong> 定理 2-1-17-(1) 的逆命题 <span class="math inline">a^+ ≤ b → a &lt; b</span> 成立.<br />
<strong>证明</strong> 对 <span class="math inline">b</span> 归纳, 且讨论 <span class="math inline">r : a^+ ≤ b</span>.</p>
<ul>
<li><span class="math inline">b = 0</span> 的情况不可能.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ &lt; b&#39;^+</span>, 由推论 2-1-19 有 <span class="math inline">a &lt; b&#39;</span>, 所以 <span class="math inline">a &lt; b&#39;^+</span>.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ = b&#39;^+</span>, 目标改写变为 <span class="math inline">b&#39; &lt; b</span>, 显然成立.</li>
<li>若 <span class="math inline">b = \lim(f)</span>, <span class="math inline">r</span> 只能为 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 且 <span class="math inline">r&#39; : a^+ &lt; f(n)</span>, 由传递性即得 <span class="math inline">a &lt; a^+ &lt; f(n) &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="s≤→&lt;-rd"></a><a id="7738" href="WellFormed.Properties.html#7738" class="Function">s≤→&lt;-rd</a> <a id="7746" class="Symbol">:</a> <a id="7748" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="7755" class="Symbol">(</a><a id="7756" class="InductiveConstructor">suc</a> <a id="7760" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="7761" class="Symbol">)</a> <a id="7763" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7765" class="Symbol">→</a> <a id="7767" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="7772" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7774" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7776" href="WellFormed.Properties.html#7738" class="Function">s≤→&lt;-rd</a> <a id="7784" class="Symbol">{</a><a id="7785" class="Argument">b</a> <a id="7787" class="Symbol">=</a> <a id="7789" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7793" href="WellFormed.Properties.html#7793" class="Bound">b</a><a id="7794" class="Symbol">}</a> <a id="7796" class="Symbol">(</a><a id="7797" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7801" href="WellFormed.Properties.html#7801" class="Bound">r</a><a id="7802" class="Symbol">)</a>       <a id="7810" class="Symbol">=</a> <a id="7812" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="7816" class="Symbol">(</a><a id="7817" href="WellFormed.Properties.html#6990" class="Function">s&lt;s-inj-rd</a> <a id="7828" href="WellFormed.Properties.html#7801" class="Bound">r</a><a id="7829" class="Symbol">)</a>
<a id="7831" href="WellFormed.Properties.html#7738" class="Function">s≤→&lt;-rd</a> <a id="7839" class="Symbol">{</a><a id="7840" class="Argument">b</a> <a id="7842" class="Symbol">=</a> <a id="7844" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7848" href="WellFormed.Properties.html#7848" class="Bound">b</a><a id="7849" class="Symbol">}</a> <a id="7851" class="Symbol">(</a><a id="7852" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7856" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7860" class="Symbol">)</a>    <a id="7865" class="Symbol">=</a> <a id="7867" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="7872" href="WellFormed.Properties.html#7738" class="Function">s≤→&lt;-rd</a> <a id="7880" class="Symbol">{</a><a id="7881" class="Argument">b</a> <a id="7883" class="Symbol">=</a> <a id="7885" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="7889" href="WellFormed.Properties.html#7889" class="Bound">f</a><a id="7890" class="Symbol">}</a> <a id="7892" class="Symbol">(</a><a id="7893" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7897" class="Symbol">(</a><a id="7898" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7902" href="WellFormed.Properties.html#7902" class="Bound">r</a><a id="7903" class="Symbol">))</a> <a id="7906" class="Symbol">=</a> <a id="7908" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7912" class="Symbol">(</a><a id="7913" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="7922" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="7927" href="WellFormed.Properties.html#7902" class="Bound">r</a><a id="7928" class="Symbol">)</a>

<a id="s≤→&lt;"></a><a id="7931" href="WellFormed.Properties.html#7931" class="Function">s≤→&lt;</a> <a id="7936" class="Symbol">:</a> <a id="7938" class="InductiveConstructor">suc</a> <a id="7942" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7944" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="7946" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7948" class="Symbol">→</a> <a id="7950" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7952" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="7954" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7956" href="WellFormed.Properties.html#7931" class="Function">s≤→&lt;</a> <a id="7961" class="Symbol">(</a><a id="7962" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7966" href="WellFormed.Properties.html#7966" class="Bound">r</a><a id="7967" class="Symbol">)</a>    <a id="7972" class="Symbol">=</a> <a id="7974" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7978" class="Symbol">(</a><a id="7979" href="WellFormed.Properties.html#7738" class="Function">s≤→&lt;-rd</a> <a id="7987" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="7989" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a><a id="7992" class="Symbol">)</a> <a id="7994" href="WellFormed.Properties.html#7966" class="Bound">r</a>
<a id="7996" href="WellFormed.Properties.html#7931" class="Function">s≤→&lt;</a> <a id="8001" class="Symbol">(</a><a id="8002" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="8006" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="8010" class="Symbol">)</a> <a id="8012" class="Symbol">=</a> <a id="8014" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>
</pre>
<p><strong>定理 2-1-21</strong> 后继运算在极限序数下封闭.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span> 都有 <span class="math inline">b^+ &lt; a</span>. 讨论 <span class="math inline">r : b &lt; a</span>, 只能有 <span class="math inline">r = \lim(r&#39;) : b &lt; a</span>, 且 <span class="math inline">r&#39; : b &lt; a[n]</span>. 由定理 2-1-17 即传递性即得 <span class="math inline">b^+ &lt; a[n]^+ ≤ a</span>. ∎</p>
<pre class="Agda"><a id="s&lt;l-rd"></a><a id="8209" href="WellFormed.Properties.html#8209" class="Function">s&lt;l-rd</a> <a id="8216" class="Symbol">:</a> <a id="8218" class="Symbol">⦃</a> <a id="8220" href="WellFormed.Properties.html#8220" class="Bound">_</a> <a id="8222" class="Symbol">:</a> <a id="8224" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8230" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8232" class="Symbol">⦄</a> <a id="8234" class="Symbol">→</a> <a id="8236" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8241" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8243" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8245" class="Symbol">→</a> <a id="8247" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8252" class="Symbol">(</a><a id="8253" class="InductiveConstructor">suc</a> <a id="8257" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8258" class="Symbol">)</a> <a id="8260" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8262" href="WellFormed.Properties.html#8209" class="Function">s&lt;l-rd</a> <a id="8269" class="Symbol">{</a><a id="8270" href="WellFormed.Properties.html#8270" class="Bound">a</a><a id="8271" class="Symbol">}</a> <a id="8273" class="Symbol">{</a><a id="8274" href="WellFormed.Properties.html#8274" class="Bound">b</a><a id="8275" class="Symbol">}</a> <a id="8277" class="Symbol">(</a><a id="8278" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="8282" class="Symbol">{</a><a id="8283" href="WellFormed.Properties.html#8283" class="Bound">n</a><a id="8284" class="Symbol">}</a> <a id="8286" href="WellFormed.Properties.html#8286" class="Bound">r</a><a id="8287" class="Symbol">)</a> <a id="8289" class="Symbol">=</a> <a id="8291" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="8306" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8310" href="WellFormed.Properties.html#8274" class="Bound">b</a>           <a id="8322" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="8325" href="WellFormed.Properties.html#5339" class="Function">s&lt;s-rd</a> <a id="8332" href="WellFormed.Properties.html#8286" class="Bound">r</a> <a id="8334" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="8338" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8342" class="Symbol">(</a><a id="8343" href="WellFormed.Properties.html#8270" class="Bound">a</a> <a id="8345" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="8347" href="WellFormed.Properties.html#8283" class="Bound">n</a> <a id="8349" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="8350" class="Symbol">)</a>   <a id="8354" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="8357" href="WellFormed.Properties.html#5301" class="Function">&lt;→s≤-rd</a> <a id="8365" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="8372" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="8376" href="WellFormed.Properties.html#8270" class="Bound">a</a>               <a id="8392" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="8394" class="Keyword">where</a> <a id="8400" class="Keyword">open</a> <a id="8405" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>

<a id="s&lt;l"></a><a id="8420" href="WellFormed.Properties.html#8420" class="Function">s&lt;l</a> <a id="8424" class="Symbol">:</a> <a id="8426" class="Symbol">⦃</a> <a id="8428" href="WellFormed.Properties.html#8428" class="Bound">_</a> <a id="8430" class="Symbol">:</a> <a id="8432" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8438" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8440" class="Symbol">⦄</a> <a id="8442" class="Symbol">→</a> <a id="8444" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8446" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8448" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8450" class="Symbol">→</a> <a id="8452" class="InductiveConstructor">suc</a> <a id="8456" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8458" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8460" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8462" href="WellFormed.Properties.html#8420" class="Function">s&lt;l</a> <a id="8466" class="Symbol">=</a> <a id="8468" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="8472" href="WellFormed.Properties.html#8209" class="Function">s&lt;l-rd</a>
</pre>
<p><strong>定理 2-1-22</strong> 直接前驱在极限序数上封闭.<br />
<strong>证明</strong> 要证对任意极限序数 <span class="math inline">a ≤ b^+</span> 有 <span class="math inline">a ≤ b</span>. 讨论 <span class="math inline">a ≤ b^+</span>.</p>
<ul>
<li>不可能有 <span class="math inline">a = b^+</span> 的情况, 因为 <span class="math inline">b^+</span> 不可能是极限序数.</li>
<li>若 <span class="math inline">a &lt; a^+</span>, 有 <span class="math inline">a = a</span>.</li>
<li>若 <span class="math inline">a &lt; b^+</span>, 必然有 <span class="math inline">a &lt; b</span>. ∎</li>
</ul>
<pre class="Agda"><a id="l≤p-rd"></a><a id="8673" href="WellFormed.Properties.html#8673" class="Function">l≤p-rd</a> <a id="8680" class="Symbol">:</a> <a id="8682" class="Symbol">⦃</a> <a id="8684" href="WellFormed.Properties.html#8684" class="Bound">_</a> <a id="8686" class="Symbol">:</a> <a id="8688" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8694" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8696" class="Symbol">⦄</a> <a id="8698" class="Symbol">→</a> <a id="8700" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8707" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8709" class="Symbol">(</a><a id="8710" class="InductiveConstructor">suc</a> <a id="8714" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8715" class="Symbol">)</a> <a id="8717" class="Symbol">→</a> <a id="8719" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8726" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8728" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8730" href="WellFormed.Properties.html#8673" class="Function">l≤p-rd</a> <a id="8737" class="Symbol">{</a><a id="8738" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8742" href="WellFormed.Properties.html#8742" class="Bound">f</a><a id="8743" class="Symbol">}</a> <a id="8745" class="Symbol">(</a><a id="8746" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8750" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a><a id="8754" class="Symbol">)</a>    <a id="8759" class="Symbol">=</a> <a id="8761" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="8765" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="8770" href="WellFormed.Properties.html#8673" class="Function">l≤p-rd</a> <a id="8777" class="Symbol">{</a><a id="8778" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8782" href="WellFormed.Properties.html#8782" class="Bound">f</a><a id="8783" class="Symbol">}</a> <a id="8785" class="Symbol">(</a><a id="8786" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8790" class="Symbol">(</a><a id="8791" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="8795" href="WellFormed.Properties.html#8795" class="Bound">r</a><a id="8796" class="Symbol">))</a> <a id="8799" class="Symbol">=</a> <a id="8801" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8805" href="WellFormed.Properties.html#8795" class="Bound">r</a>

<a id="l≤p"></a><a id="8808" href="WellFormed.Properties.html#8808" class="Function">l≤p</a> <a id="8812" class="Symbol">:</a> <a id="8814" class="Symbol">⦃</a> <a id="8816" href="WellFormed.Properties.html#8816" class="Bound">_</a> <a id="8818" class="Symbol">:</a> <a id="8820" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8826" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8828" class="Symbol">⦄</a> <a id="8830" class="Symbol">→</a> <a id="8832" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8834" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8836" class="InductiveConstructor">suc</a> <a id="8840" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8842" class="Symbol">→</a> <a id="8844" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8846" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8848" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8850" href="WellFormed.Properties.html#8808" class="Function">l≤p</a> <a id="8854" class="Symbol">{</a><a id="8855" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8859" href="WellFormed.Properties.html#8859" class="Bound">f</a><a id="8860" class="Symbol">}</a> <a id="8862" class="Symbol">(</a><a id="8863" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8867" href="WellFormed.Properties.html#8867" class="Bound">r</a><a id="8868" class="Symbol">)</a> <a id="8870" class="Symbol">=</a> <a id="8872" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="8877" class="Symbol">(</a><a id="8878" href="WellFormed.Properties.html#8673" class="Function">l≤p-rd</a> <a id="8885" class="Symbol">(</a><a id="8886" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8890" class="Symbol">(</a><a id="8891" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="8895" href="WellFormed.Properties.html#8867" class="Bound">r</a><a id="8896" class="Symbol">)))</a>
</pre>
<h2 id="ω的性质">ω的性质</h2>
<p><strong>定义 2-1-23</strong> 由定义 2-1-9, 显然 <span class="math inline">\text{fin}</span> 是良构序列, 我们把 <span class="math inline">\lim(\text{fin})</span> 记作 <span class="math inline">\omega</span>.</p>
<pre class="Agda"><a id="9007" class="Keyword">instance</a>
  <a id="fin-wf"></a><a id="9018" href="WellFormed.Properties.html#9018" class="Function">fin-wf</a> <a id="9025" class="Symbol">:</a> <a id="9027" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9030" href="WellFormed.Properties.html#2743" class="Function">fin</a>
  <a id="9036" href="WellFormed.Properties.html#9018" class="Function">fin-wf</a> <a id="9043" class="Symbol">=</a> <a id="9045" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>

<a id="ω"></a><a id="9052" href="WellFormed.Properties.html#9052" class="Function">ω</a> <a id="9054" class="Symbol">:</a> <a id="9056" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="9060" href="WellFormed.Properties.html#9052" class="Function">ω</a> <a id="9062" class="Symbol">=</a> <a id="9064" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="9068" href="WellFormed.Properties.html#2743" class="Function">fin</a>
</pre>
<p><strong>引理 2-1-24</strong> 有限序数 <span class="math inline">n</span> 都小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 由引理 2-1-15 可知零小于极限序数.</li>
<li>若 <span class="math inline">n</span> 为后继, 由定理 2-1-21 可知后继序数小于极限序数, 只要其直接前驱小于该极限序数, 而这是归纳假设. ∎</li>
</ul>
<pre class="Agda"><a id="n&lt;ω"></a><a id="9242" href="WellFormed.Properties.html#9242" class="Function">n&lt;ω</a> <a id="9246" class="Symbol">:</a> <a id="9248" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9252" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9254" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9256" href="WellFormed.Properties.html#9052" class="Function">ω</a>
<a id="9258" href="WellFormed.Properties.html#9242" class="Function">n&lt;ω</a> <a id="9262" class="Symbol">{</a><a id="9263" class="Argument">n</a> <a id="9265" class="Symbol">=</a> <a id="9267" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9271" class="Symbol">}</a>  <a id="9274" class="Symbol">=</a> <a id="9276" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
<a id="9280" href="WellFormed.Properties.html#9242" class="Function">n&lt;ω</a> <a id="9284" class="Symbol">{</a><a id="9285" class="Argument">n</a> <a id="9287" class="Symbol">=</a> <a id="9289" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9293" href="WellFormed.Properties.html#9293" class="Bound">n</a><a id="9294" class="Symbol">}</a> <a id="9296" class="Symbol">=</a> <a id="9298" href="WellFormed.Properties.html#8420" class="Function">s&lt;l</a> <a id="9302" href="WellFormed.Properties.html#9242" class="Function">n&lt;ω</a>
</pre>
<p><strong>引理 2-1-25</strong> 任意基本列的第 <span class="math inline">n</span> 项大于等于 <span class="math inline">n</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 显然 <span class="math inline">0 ≤ f(0)</span>.</li>
<li>若 <span class="math inline">n</span> 为后继, 由归纳假设 <span class="math inline">n ≤ f(n)</span> 可得 <span class="math inline">n^+ ≤ f(n)^+ &lt; f(n^+)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="n≤fn"></a><a id="9464" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="9469" class="Symbol">:</a> <a id="9471" class="Symbol">∀</a> <a id="9473" href="WellFormed.Properties.html#9473" class="Bound">f</a> <a id="9475" class="Symbol">→</a> <a id="9477" class="Symbol">⦃</a> <a id="9479" href="WellFormed.Properties.html#9479" class="Bound">_</a> <a id="9481" class="Symbol">:</a> <a id="9483" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9486" href="WellFormed.Properties.html#9473" class="Bound">f</a> <a id="9488" class="Symbol">⦄</a> <a id="9490" class="Symbol">→</a> <a id="9492" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9496" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9498" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="9500" href="WellFormed.Properties.html#9473" class="Bound">f</a> <a id="9502" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="9504" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="9509" class="Symbol">{</a><a id="9510" class="Argument">n</a> <a id="9512" class="Symbol">=</a> <a id="9514" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9518" class="Symbol">}</a> <a id="9520" href="WellFormed.Properties.html#9520" class="Bound">f</a>   <a id="9524" class="Symbol">=</a> <a id="9526" href="WellFormed.Properties.html#5141" class="Function">z≤</a>
<a id="9529" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="9534" class="Symbol">{</a><a id="9535" class="Argument">n</a> <a id="9537" class="Symbol">=</a> <a id="9539" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9543" href="WellFormed.Properties.html#9543" class="Bound">n</a><a id="9544" class="Symbol">}</a> <a id="9546" href="WellFormed.Properties.html#9546" class="Bound">f</a>  <a id="9549" class="Symbol">=</a> <a id="9551" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="9559" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9563" class="Symbol">(</a><a id="9564" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9568" href="WellFormed.Properties.html#9543" class="Bound">n</a><a id="9569" class="Symbol">)</a>         <a id="9579" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9582" href="WellFormed.Properties.html#7267" class="Function">s≤s</a> <a id="9586" class="Symbol">(</a><a id="9587" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="9592" href="WellFormed.Properties.html#9546" class="Bound">f</a><a id="9593" class="Symbol">)</a> <a id="9595" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9599" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="9603" class="Symbol">(</a><a id="9604" href="WellFormed.Properties.html#9546" class="Bound">f</a> <a id="9606" href="WellFormed.Properties.html#9543" class="Bound">n</a><a id="9607" class="Symbol">)</a>           <a id="9619" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9622" href="WellFormed.Properties.html#5368" class="Function">&lt;→s≤</a> <a id="9627" href="Function.Base.html#4736" class="Function">it</a> <a id="9630" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9634" href="WellFormed.Properties.html#9546" class="Bound">f</a> <a id="9636" class="Symbol">(</a><a id="9637" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9641" href="WellFormed.Properties.html#9543" class="Bound">n</a><a id="9642" class="Symbol">)</a>           <a id="9654" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="9656" class="Keyword">where</a> <a id="9662" class="Keyword">open</a> <a id="9667" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>推论 2-1-26</strong> 任意基本列的第 <span class="math inline">n^+</span> 项大于 <span class="math inline">n</span>.<br />
<strong>证明</strong> <span class="math inline">n ≤ f(n) &lt; f(n^+)</span>. ∎</p>
<pre class="Agda"><a id="n&lt;fs"></a><a id="9767" href="WellFormed.Properties.html#9767" class="Function">n&lt;fs</a> <a id="9772" class="Symbol">:</a> <a id="9774" class="Symbol">∀</a> <a id="9776" href="WellFormed.Properties.html#9776" class="Bound">f</a> <a id="9778" href="WellFormed.Properties.html#9778" class="Bound">n</a> <a id="9780" class="Symbol">→</a> <a id="9782" class="Symbol">⦃</a> <a id="9784" href="WellFormed.Properties.html#9784" class="Bound">_</a> <a id="9786" class="Symbol">:</a> <a id="9788" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9791" href="WellFormed.Properties.html#9776" class="Bound">f</a> <a id="9793" class="Symbol">⦄</a> <a id="9795" class="Symbol">→</a> <a id="9797" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9801" href="WellFormed.Properties.html#9778" class="Bound">n</a> <a id="9803" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9805" href="WellFormed.Properties.html#9776" class="Bound">f</a> <a id="9807" class="Symbol">(</a><a id="9808" class="InductiveConstructor">suc</a> <a id="9812" href="WellFormed.Properties.html#9778" class="Bound">n</a><a id="9813" class="Symbol">)</a>
<a id="9815" href="WellFormed.Properties.html#9767" class="Function">n&lt;fs</a> <a id="9820" href="WellFormed.Properties.html#9820" class="Bound">f</a> <a id="9822" class="Symbol">_</a> <a id="9824" class="Symbol">=</a> <a id="9826" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="9836" class="Symbol">(</a><a id="9837" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="9842" href="WellFormed.Properties.html#9820" class="Bound">f</a><a id="9843" class="Symbol">)</a> <a id="9845" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-27</strong> 没有极限序数小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 假设有这样的序数 <span class="math inline">a</span>. 由事实 2-1-12, 存在 <span class="math inline">n</span> 使得 <span class="math inline">a &lt; n</span>. 但由引理 2-1-25 又有 <span class="math inline">n ≤ a[n] &lt; a</span>. 由传递性有 <span class="math inline">n &lt; n</span>, 违反 <span class="math inline">&lt;</span> 的反自反性. ∎</p>
<pre class="Agda"><a id="l≮ω"></a><a id="10011" href="WellFormed.Properties.html#10011" class="Function">l≮ω</a> <a id="10015" class="Symbol">:</a> <a id="10017" class="Symbol">⦃</a> <a id="10019" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="10025" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10027" class="Symbol">⦄</a> <a id="10029" class="Symbol">→</a> <a id="10031" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10033" href="WellFormed.Base.html#3172" class="Function Operator">≮</a> <a id="10035" href="WellFormed.Properties.html#9052" class="Function">ω</a>
<a id="10037" href="WellFormed.Properties.html#10011" class="Function">l≮ω</a> <a id="10041" href="WellFormed.Properties.html#10041" class="Bound">a</a><a id="10042" class="Symbol">@{</a><a id="10044" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="10048" href="WellFormed.Properties.html#10048" class="Bound">f</a><a id="10049" class="Symbol">}</a> <a id="10051" href="WellFormed.Properties.html#10051" class="Bound">r</a> <a id="10053" class="Symbol">=</a> <a id="10055" class="Keyword">let</a> <a id="10059" href="WellFormed.Properties.html#10059" class="Bound">n</a> <a id="10061" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10063" href="WellFormed.Properties.html#10063" class="Bound">r</a> <a id="10065" class="Symbol">=</a> <a id="10067" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="10075" href="WellFormed.Properties.html#10051" class="Bound">r</a> <a id="10077" class="Keyword">in</a> <a id="10080" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="10089" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="10094" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10096" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="10111" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10115" href="WellFormed.Properties.html#10059" class="Bound">n</a>               <a id="10131" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="10134" href="WellFormed.Properties.html#9464" class="Function">n≤fn</a> <a id="10139" href="WellFormed.Properties.html#10048" class="Bound">f</a> <a id="10141" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="10145" href="WellFormed.Properties.html#10041" class="Bound">a</a> <a id="10147" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="10149" href="WellFormed.Properties.html#10059" class="Bound">n</a> <a id="10151" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>             <a id="10165" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10168" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a> <a id="10172" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10176" href="WellFormed.Properties.html#10041" class="Bound">a</a>                   <a id="10196" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10199" href="WellFormed.Properties.html#10063" class="Bound">r</a> <a id="10201" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10205" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10209" href="WellFormed.Properties.html#10059" class="Bound">n</a>               <a id="10225" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="10227" class="Keyword">where</a> <a id="10233" class="Keyword">open</a> <a id="10238" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>引理 2-1-28</strong> 忽略非同株, <span class="math inline">\omega</span> 是最小的极限序数.<br />
<strong>证明</strong> 对任意与 <span class="math inline">\omega</span> 同株的极限序数 <span class="math inline">a</span>, 由推论 2-0-34, 讨论 <span class="math inline">\omega</span> 与 <span class="math inline">a</span> 的大小关系. 若 <span class="math inline">a &lt; \omega</span>, 由引理 2-1-27 可得矛盾. 所以只能有 <span class="math inline">ω ≤ a</span>. ∎</p>
<pre class="Agda"><a id="ω≤l"></a><a id="10432" href="WellFormed.Properties.html#10432" class="Function">ω≤l</a> <a id="10436" class="Symbol">:</a> <a id="10438" class="Symbol">⦃</a> <a id="10440" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="10446" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10448" class="Symbol">⦄</a> <a id="10450" class="Symbol">→</a> <a id="10452" href="WellFormed.Properties.html#9052" class="Function">ω</a> <a id="10454" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10456" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10458" class="Symbol">→</a> <a id="10460" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10462" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10464" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10466" class="Symbol">→</a> <a id="10468" href="WellFormed.Properties.html#9052" class="Function">ω</a> <a id="10470" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="10472" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10474" href="WellFormed.Properties.html#10432" class="Function">ω≤l</a> <a id="10478" class="Symbol">{</a><a id="10479" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="10483" href="WellFormed.Properties.html#10483" class="Bound">f</a><a id="10484" class="Symbol">}</a> <a id="10486" href="WellFormed.Properties.html#10486" class="Bound">r</a> <a id="10488" href="WellFormed.Properties.html#10488" class="Bound">s</a> <a id="10490" class="Keyword">with</a> <a id="10495" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="10504" href="WellFormed.Properties.html#10486" class="Bound">r</a> <a id="10506" href="WellFormed.Properties.html#10488" class="Bound">s</a>
<a id="10508" class="Symbol">...</a> <a id="10512" class="Symbol">|</a> <a id="10514" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10518" href="WellFormed.Properties.html#10518" class="Bound">r</a>           <a id="10530" class="Symbol">=</a> <a id="10532" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10536" href="WellFormed.Properties.html#10518" class="Bound">r</a>
<a id="10538" class="Symbol">...</a> <a id="10542" class="Symbol">|</a> <a id="10544" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10548" class="Symbol">(</a><a id="10549" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10553" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="10557" class="Symbol">)</a>  <a id="10560" class="Symbol">=</a> <a id="10562" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10566" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10571" class="Symbol">...</a> <a id="10575" class="Symbol">|</a> <a id="10577" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10581" class="Symbol">(</a><a id="10582" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10586" href="WellFormed.Properties.html#10586" class="Bound">r</a><a id="10587" class="Symbol">)</a>     <a id="10593" class="Symbol">=</a> <a id="10595" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="10602" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10604" href="WellFormed.Properties.html#10011" class="Function">l≮ω</a> <a id="10608" href="WellFormed.Properties.html#10586" class="Bound">r</a>
</pre>
<p><strong>引理 2-1-29</strong> <span class="math inline">\text{fin}</span> 单射 <span class="math inline">=</span>.<br />
<strong>证明</strong> 对 <span class="math inline">m, n</span> 归纳即得. ∎</p>
<pre class="Agda"><a id="fin-inj"></a><a id="10685" href="WellFormed.Properties.html#10685" class="Function">fin-inj</a> <a id="10693" class="Symbol">:</a> <a id="10695" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10699" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10701" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10703" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10707" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="10709" class="Symbol">→</a> <a id="10711" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10713" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10715" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="10717" href="WellFormed.Properties.html#10685" class="Function">fin-inj</a> <a id="10725" class="Symbol">{(</a><a id="10727" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10731" class="Symbol">)}</a> <a id="10734" class="Symbol">{(</a><a id="10736" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10740" class="Symbol">)}</a> <a id="10743" href="WellFormed.Properties.html#10743" class="Bound">eq</a> <a id="10746" class="Symbol">=</a> <a id="10748" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10753" href="WellFormed.Properties.html#10685" class="Function">fin-inj</a> <a id="10761" class="Symbol">{</a><a id="10762" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10766" href="WellFormed.Properties.html#10766" class="Bound">m</a><a id="10767" class="Symbol">}</a>  <a id="10770" class="Symbol">{</a><a id="10771" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10775" href="WellFormed.Properties.html#10775" class="Bound">n</a><a id="10776" class="Symbol">}</a>  <a id="10779" href="WellFormed.Properties.html#10779" class="Bound">eq</a> <a id="10782" class="Symbol">=</a> <a id="10784" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10789" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10793" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10795" href="WellFormed.Properties.html#10685" class="Function">fin-inj</a> <a id="10803" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10805" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="10813" href="WellFormed.Properties.html#10779" class="Bound">eq</a>
</pre>
<p><strong>引理 2-1-30</strong> <span class="math inline">\text{fin}</span> 满射 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">a &lt; ω</span> 都存在 <span class="math inline">n</span> 使得 <span class="math inline">n = a</span>. 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 取 <span class="math inline">n = 0</span> 即可.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 由归纳假设可得一个 <span class="math inline">n&#39; = a&#39;</span>. 取 <span class="math inline">n = n&#39;^+</span> 即可.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 由引理 2-1-27 可得矛盾. ∎</li>
</ul>
<pre class="Agda"><a id="fin-suj"></a><a id="11043" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11051" class="Symbol">:</a> <a id="11053" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="11055" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="11057" href="WellFormed.Properties.html#9052" class="Function">ω</a> <a id="11059" class="Symbol">→</a> <a id="11061" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="11064" href="WellFormed.Properties.html#11064" class="Bound">n</a> <a id="11066" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="11068" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="11070" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="11072" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="11076" href="WellFormed.Properties.html#11064" class="Bound">n</a> <a id="11078" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11080" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="11082" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11090" class="Symbol">{(</a><a id="11092" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="11096" class="Symbol">)}</a> <a id="11099" href="WellFormed.Properties.html#11099" class="Bound">r</a>  <a id="11102" class="Symbol">=</a> <a id="11104" class="Number">0</a> <a id="11106" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11108" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11113" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11121" class="Symbol">{</a><a id="11122" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="11126" class="Symbol">_}</a>  <a id="11130" href="WellFormed.Properties.html#11130" class="Bound">r</a>  <a id="11133" class="Keyword">with</a> <a id="11138" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11146" class="Symbol">(</a><a id="11147" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11155" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11161" href="WellFormed.Properties.html#11130" class="Bound">r</a><a id="11162" class="Symbol">)</a>
<a id="11164" class="Symbol">...</a> <a id="11168" class="Symbol">|</a> <a id="11170" href="WellFormed.Properties.html#11170" class="Bound">n</a> <a id="11172" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11174" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>      <a id="11184" class="Symbol">=</a> <a id="11186" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11190" href="WellFormed.Properties.html#11170" class="Bound">n</a> <a id="11192" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11194" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11199" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11207" class="Symbol">{</a><a id="11208" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11212" href="WellFormed.Properties.html#11212" class="Bound">f</a><a id="11213" class="Symbol">}</a>  <a id="11216" href="WellFormed.Properties.html#11216" class="Bound">r</a>  <a id="11219" class="Symbol">=</a> <a id="11221" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="11228" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11230" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="11239" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11244" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11246" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="11261" href="WellFormed.Properties.html#9052" class="Function">ω</a>                   <a id="11281" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="11284" href="WellFormed.Properties.html#10432" class="Function">ω≤l</a> <a id="11288" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11294" class="Symbol">(</a><a id="11295" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11303" href="WellFormed.Properties.html#11216" class="Bound">r</a> <a id="11305" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a><a id="11310" class="Symbol">)</a> <a id="11312" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="11316" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11320" href="WellFormed.Properties.html#11212" class="Bound">f</a>               <a id="11336" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="11339" href="WellFormed.Properties.html#11216" class="Bound">r</a> <a id="11341" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="11345" href="WellFormed.Properties.html#9052" class="Function">ω</a>                   <a id="11365" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="11367" class="Keyword">where</a> <a id="11373" class="Keyword">open</a> <a id="11378" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>定理 2-1-31</strong> <span class="math inline">ℕ</span> 与小于 <span class="math inline">\omega</span> 的序数同构.<br />
<strong>证明</strong> <span class="math inline">\text{fin}</span> 提供了正映射, 引理 2-1-30 提供了逆映射. 结合引理 2-1-29 可以说明它们互逆. ∎</p>
<pre class="Agda"><a id="ℕ≡ω"></a><a id="11519" href="WellFormed.Properties.html#11519" class="Function">ℕ≡ω</a> <a id="11523" class="Symbol">:</a> <a id="11525" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="11527" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11529" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11531" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="11535" class="Symbol">(</a><a id="11536" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;</a> <a id="11539" href="WellFormed.Properties.html#9052" class="Function">ω</a><a id="11540" class="Symbol">)</a>
<a id="11542" href="WellFormed.Properties.html#11519" class="Function">ℕ≡ω</a> <a id="11546" class="Symbol">=</a> <a id="11548" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="11557" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11559" href="Cubical.Foundations.Isomorphism.html#3223" class="Function">isoToPath</a> <a id="11569" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11571" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a>
  <a id="11577" class="Symbol">(λ</a> <a id="11580" href="WellFormed.Properties.html#11580" class="Bound">n</a> <a id="11582" class="Symbol">→</a> <a id="11584" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="11588" href="WellFormed.Properties.html#11580" class="Bound">n</a> <a id="11590" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11592" href="WellFormed.Properties.html#9242" class="Function">n&lt;ω</a><a id="11595" class="Symbol">)</a>
  <a id="11599" class="Symbol">(λ</a> <a id="11602" class="Symbol">(</a><a id="11603" href="WellFormed.Properties.html#11603" class="Bound">a</a> <a id="11605" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11607" href="WellFormed.Properties.html#11607" class="Bound">a&lt;ω</a><a id="11610" class="Symbol">)</a> <a id="11612" class="Symbol">→</a> <a id="11614" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="11618" class="Symbol">(</a><a id="11619" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11627" href="WellFormed.Properties.html#11607" class="Bound">a&lt;ω</a><a id="11630" class="Symbol">))</a>
  <a id="11635" class="Symbol">(λ</a> <a id="11638" href="WellFormed.Properties.html#11638" class="Bound">a</a> <a id="11640" class="Symbol">→</a> <a id="11642" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="11649" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11651" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11660" class="Symbol">(</a><a id="11661" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11665" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11667" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11675" class="Symbol">_)</a> <a id="11678" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11680" href="Cubical.Foundations.Prelude.html#13282" class="Function">toPathP</a> <a id="11688" class="Symbol">(</a><a id="11689" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="11697" class="Symbol">_</a> <a id="11699" class="Symbol">_))</a>
  <a id="11705" class="Symbol">(λ</a> <a id="11708" href="WellFormed.Properties.html#11708" class="Bound">n</a> <a id="11710" class="Symbol">→</a> <a id="11712" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11721" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11723" href="WellFormed.Properties.html#10685" class="Function">fin-inj</a> <a id="11731" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11733" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11737" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11739" href="WellFormed.Properties.html#11043" class="Function">fin-suj</a> <a id="11747" class="Symbol">_)</a>
  <a id="11752" class="Keyword">where</a> <a id="11758" class="Keyword">open</a> <a id="11763" class="Keyword">import</a> <a id="11770" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
