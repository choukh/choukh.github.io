<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (2.1 - 良构树序数的性质)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-2.1---良构树序数的性质" id="toc-形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</a>
  <ul>
  <li><a href="#序数函数" id="toc-序数函数">序数函数</a></li>
  <li><a href="#一些约定" id="toc-一些约定">一些约定</a></li>
  <li><a href="#一些引理" id="toc-一些引理">一些引理</a></li>
  <li><a href="#ω的性质" id="toc-ω的性质">ω的性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-2.1---良构树序数的性质">形式化大数数学 (2.1 - 良构树序数的性质)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/WellFormed/Properties.lagda.md">Properties.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/WellFormed.Properties.html">Properties.html</a></p>
</blockquote>
<pre class="Agda"><a id="391" class="Symbol">{-#</a> <a id="395" class="Keyword">OPTIONS</a> <a id="403" class="Pragma">--safe</a> <a id="410" class="Pragma">--cubical</a> <a id="420" class="Pragma">--lossy-unification</a> <a id="440" class="Symbol">#-}</a>
<a id="444" class="Keyword">module</a> <a id="451" href="WellFormed.Properties.html" class="Module">WellFormed.Properties</a> <a id="473" class="Keyword">where</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="WellFormed.Base.html" class="Module">WellFormed.Base</a>
</pre>
<p><a href="https://zhuanlan.zhihu.com/p/711649863">上一篇</a>我们定义了良构树序数并证明了一些基本性质, 本文将继续讨论它的更多性质.</p>
<h2 id="序数函数">序数函数</h2>
<p>我们先定义关于序数函数的一些性质.</p>
<p><strong>定义 2-1-0</strong> 我们把序数函数的类型简记作 <span class="math inline">\text{Func}</span>, 序数的二元关系的类型简记作 <span class="math inline">\text{Rel}</span>, 并约定用大写的 <span class="math inline">F</span> 表示序数函数.</p>
<pre class="Agda"><a id="Func"></a><a id="722" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="727" class="Symbol">:</a> <a id="729" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="734" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="739" class="Symbol">=</a> <a id="741" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="745" class="Symbol">→</a> <a id="747" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>

<a id="Rel"></a><a id="752" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="756" class="Symbol">:</a> <a id="758" href="Agda.Primitive.html#388" class="Primitive">Type₁</a>
<a id="764" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="768" class="Symbol">=</a> <a id="770" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="774" class="Symbol">→</a> <a id="776" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="780" class="Symbol">→</a> <a id="782" href="Agda.Primitive.html#388" class="Primitive">Type</a>

<a id="788" class="Keyword">private</a> <a id="796" class="Keyword">variable</a> <a id="805" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="807" class="Symbol">:</a> <a id="809" href="WellFormed.Properties.html#722" class="Function">Func</a>
</pre>
<p><strong>定义 2-1-1</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>保持</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">x \sim y \to F(x) \sim F(y)</span>.</p>
<pre class="Agda"><a id="_preserves_"></a><a id="927" href="WellFormed.Properties.html#927" class="Function Operator">_preserves_</a> <a id="939" class="Symbol">:</a> <a id="941" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="946" class="Symbol">→</a> <a id="948" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="952" class="Symbol">→</a> <a id="954" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="959" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="961" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="971" href="WellFormed.Properties.html#971" class="Bound Operator">_~_</a> <a id="975" class="Symbol">=</a> <a id="977" class="Symbol">∀</a> <a id="979" class="Symbol">{</a><a id="980" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="982" href="WellFormed.Properties.html#982" class="Bound">y</a><a id="983" class="Symbol">}</a> <a id="985" class="Symbol">→</a> <a id="987" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="989" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="991" href="WellFormed.Properties.html#982" class="Bound">y</a> <a id="993" class="Symbol">→</a> <a id="995" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="997" href="WellFormed.Properties.html#980" class="Bound">x</a> <a id="999" href="WellFormed.Properties.html#971" class="Bound Operator">~</a> <a id="1001" href="WellFormed.Properties.html#959" class="Bound">F</a> <a id="1003" href="WellFormed.Properties.html#982" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-2</strong> 如果 <span class="math inline">F</span> 保持 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 保持 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-pres≤"></a><a id="1067" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1077" class="Symbol">:</a> <a id="1079" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1081" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1091" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1095" class="Symbol">→</a> <a id="1097" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1099" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="1109" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1113" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1123" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1128" class="Symbol">(</a><a id="1129" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1133" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1134" class="Symbol">)</a>    <a id="1139" class="Symbol">=</a> <a id="1141" href="WellFormed.Base.html#11879" class="Function">&lt;→≤</a> <a id="1145" class="Symbol">(</a><a id="1146" href="WellFormed.Properties.html#1123" class="Bound">pres</a> <a id="1151" href="WellFormed.Properties.html#1133" class="Bound">p</a><a id="1152" class="Symbol">)</a>
<a id="1154" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="1164" href="WellFormed.Properties.html#1164" class="Bound">pres</a> <a id="1169" class="Symbol">(</a><a id="1170" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1174" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="1178" class="Symbol">)</a> <a id="1180" class="Symbol">=</a> <a id="1182" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1186" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义 2-1-3</strong> 我们说一个序数函数 <span class="math inline">F</span> <strong>单射</strong>一个序数关系 <span class="math inline">\sim</span>, 当且仅当对任意序数 <span class="math inline">x, y</span> 都有 <span class="math inline">F(x) \sim F(y) \to x \sim y</span>.</p>
<pre class="Agda"><a id="_injects_"></a><a id="1304" href="WellFormed.Properties.html#1304" class="Function Operator">_injects_</a> <a id="1314" class="Symbol">:</a> <a id="1316" href="WellFormed.Properties.html#722" class="Function">Func</a> <a id="1321" class="Symbol">→</a> <a id="1323" href="WellFormed.Properties.html#752" class="Function">Rel</a> <a id="1327" class="Symbol">→</a> <a id="1329" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="1334" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1336" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1344" href="WellFormed.Properties.html#1344" class="Bound Operator">_~_</a> <a id="1348" class="Symbol">=</a> <a id="1350" class="Symbol">∀</a> <a id="1352" class="Symbol">{</a><a id="1353" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1355" href="WellFormed.Properties.html#1355" class="Bound">y</a><a id="1356" class="Symbol">}</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1362" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1364" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1366" href="WellFormed.Properties.html#1334" class="Bound">F</a> <a id="1368" href="WellFormed.Properties.html#1355" class="Bound">y</a> <a id="1370" class="Symbol">→</a> <a id="1372" href="WellFormed.Properties.html#1353" class="Bound">x</a> <a id="1374" href="WellFormed.Properties.html#1344" class="Bound Operator">~</a> <a id="1376" href="WellFormed.Properties.html#1355" class="Bound">y</a>
</pre>
<p><strong>事实 2-1-4</strong> 如果 <span class="math inline">F</span> 单射 <span class="math inline">\lt</span>, 那么 <span class="math inline">F</span> 单射 <span class="math inline">\leq</span>.</p>
<pre class="Agda"><a id="map-inj≤"></a><a id="1440" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1449" class="Symbol">:</a> <a id="1451" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1453" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1461" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="1465" class="Symbol">→</a> <a id="1467" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1469" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1477" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="1481" class="Symbol">→</a> <a id="1483" href="WellFormed.Properties.html#805" class="Generalizable">F</a> <a id="1485" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="1493" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="1497" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1506" href="WellFormed.Properties.html#1506" class="Bound">inj</a> <a id="1510" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1515" class="Symbol">(</a><a id="1516" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1520" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1521" class="Symbol">)</a> <a id="1523" class="Symbol">=</a> <a id="1525" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="1529" class="Symbol">(</a><a id="1530" href="WellFormed.Properties.html#1510" class="Bound">inj&lt;</a> <a id="1535" href="WellFormed.Properties.html#1520" class="Bound">p</a><a id="1536" class="Symbol">)</a>
<a id="1538" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="1547" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1551" href="WellFormed.Properties.html#1551" class="Bound">inj&lt;</a> <a id="1556" class="Symbol">(</a><a id="1557" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1561" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1562" class="Symbol">)</a> <a id="1564" class="Symbol">=</a> <a id="1566" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="1570" class="Symbol">(</a><a id="1571" href="WellFormed.Properties.html#1547" class="Bound">inj</a> <a id="1575" href="WellFormed.Properties.html#1561" class="Bound">p</a><a id="1576" class="Symbol">)</a>
</pre>
<h2 id="一些约定">一些约定</h2>
<p><strong>记法 2-1-5</strong> 隐参版极限构造子: 它们与原版的区别在于良构条件为隐式参数, 从而允许从上下文自动推断出它们, 而不用一一显式写出.</p>
<pre class="Agda"><a id="lim-"></a><a id="1673" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1678" class="Symbol">:</a> <a id="1680" class="Symbol">(</a><a id="1681" href="WellFormed.Properties.html#1681" class="Bound">f</a> <a id="1683" class="Symbol">:</a> <a id="1685" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="1688" class="Symbol">)</a> <a id="1690" class="Symbol">{</a><a id="1691" href="WellFormed.Properties.html#1691" class="Bound">w</a> <a id="1693" class="Symbol">:</a> <a id="1695" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1698" href="WellFormed.Properties.html#1681" class="Bound">f</a><a id="1699" class="Symbol">}</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="1707" href="WellFormed.Properties.html#1673" class="Function">lim-</a> <a id="1712" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1714" class="Symbol">{</a><a id="1715" href="WellFormed.Properties.html#1715" class="Bound">w</a><a id="1716" class="Symbol">}</a> <a id="1718" class="Symbol">=</a> <a id="1720" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="1724" href="WellFormed.Properties.html#1712" class="Bound">f</a> <a id="1726" class="Symbol">⦃</a> <a id="1728" href="WellFormed.Properties.html#1715" class="Bound">w</a> <a id="1730" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的路径 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 通往 <span class="math inline">\lim f</span> 的路径记作 <span class="math inline">\text{rd}[n](r)</span>.</p>
<pre class="Agda"><a id="rd[_]"></a><a id="1834" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1840" class="Symbol">:</a> <a id="1842" class="Symbol">(</a><a id="1843" href="WellFormed.Properties.html#1843" class="Bound">n</a> <a id="1845" class="Symbol">:</a> <a id="1847" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1848" class="Symbol">)</a> <a id="1850" class="Symbol">{</a><a id="1851" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1853" class="Symbol">:</a> <a id="1855" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="1858" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="1859" class="Symbol">}</a> <a id="1861" class="Symbol">→</a> <a id="1863" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1868" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1870" class="Symbol">(</a><a id="1871" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1873" href="WellFormed.Properties.html#1843" class="Bound">n</a><a id="1874" class="Symbol">)</a> <a id="1876" class="Symbol">→</a> <a id="1878" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="1883" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="1885" class="Symbol">(</a><a id="1886" class="InductiveConstructor">lim</a> <a id="1890" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="1892" class="Symbol">⦃</a> <a id="1894" href="WellFormed.Properties.html#1851" class="Bound">w</a> <a id="1896" class="Symbol">⦄)</a>
<a id="1899" href="WellFormed.Properties.html#1834" class="Function Operator">rd[_]</a> <a id="1905" href="WellFormed.Properties.html#1905" class="Bound">n</a> <a id="1907" class="Symbol">=</a> <a id="1909" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="1913" class="Symbol">{</a><a id="1914" class="Argument">n</a> <a id="1916" class="Symbol">=</a> <a id="1918" href="WellFormed.Properties.html#1905" class="Bound">n</a><a id="1919" class="Symbol">}</a> <a id="1921" class="Symbol">⦃</a> <a id="1923" class="Symbol">_</a> <a id="1925" class="Symbol">⦄</a>
</pre>
<p>如果我们有 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的序列第 <span class="math inline">n</span> 项的证明 <span class="math inline">r</span>, 那么我们把 <span class="math inline">a</span> 小于 <span class="math inline">\lim f</span> 的证明记作 <span class="math inline">\text{&lt;}[n](r)</span>.</p>
<pre class="Agda"><a id="&lt;[_]"></a><a id="2028" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2033" class="Symbol">:</a> <a id="2035" class="Symbol">(</a><a id="2036" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2038" class="Symbol">:</a> <a id="2040" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2041" class="Symbol">)</a> <a id="2043" class="Symbol">{</a><a id="2044" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2046" class="Symbol">:</a> <a id="2048" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="2051" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="2052" class="Symbol">}</a> <a id="2054" class="Symbol">→</a> <a id="2056" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2058" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2060" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2062" href="WellFormed.Properties.html#2036" class="Bound">n</a> <a id="2064" class="Symbol">→</a> <a id="2066" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2068" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2070" class="InductiveConstructor">lim</a> <a id="2074" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="2076" class="Symbol">⦃</a> <a id="2078" href="WellFormed.Properties.html#2044" class="Bound">w</a> <a id="2080" class="Symbol">⦄</a>
<a id="2082" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[_]</a> <a id="2087" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2089" class="Symbol">=</a> <a id="2091" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="2095" href="WellFormed.Properties.html#1834" class="Function Operator">rd[</a> <a id="2099" href="WellFormed.Properties.html#2087" class="Bound">n</a> <a id="2101" href="WellFormed.Properties.html#1834" class="Function Operator">]</a>
</pre>
<p><strong>约定 2-1-6</strong> 鉴于路径关系与子树关系的高度可互换性, 我们今后在自然语言中会适当地混淆两者, 例如把路径的构造说成是子树关系的证明, 或反之. 读者应该理解为是调用了上一篇的引理进行了两者的转换.</p>
<p><strong>事实 2-1-7</strong> 极限序数的判定: 树序数的归纳定义允许我们快速判断一个序数是否是极限序数.</p>
<pre class="Agda"><a id="IsLim"></a><a id="2274" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2280" class="Symbol">:</a> <a id="2282" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="2286" class="Symbol">→</a> <a id="2288" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="2293" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2299" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="2304" class="Symbol">=</a> <a id="2306" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2308" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2314" class="Symbol">(</a><a id="2315" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2319" href="WellFormed.Properties.html#2319" class="Bound">a</a><a id="2320" class="Symbol">)</a> <a id="2322" class="Symbol">=</a> <a id="2324" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="2326" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2332" class="Symbol">(</a><a id="2333" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2337" href="WellFormed.Properties.html#2337" class="Bound">f</a><a id="2338" class="Symbol">)</a> <a id="2340" class="Symbol">=</a> <a id="2342" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a>
</pre>
<p><strong>记法 2-1-8</strong> 极限序数的基本列: 如果 <span class="math inline">a</span> 是极限序数, 那么我们用 <span class="math inline">a[n]</span> 表示其基本列的第 <span class="math inline">n</span> 项. 由序数的定义有 <span class="math inline">a[n] &lt; a[n^+]</span>.</p>
<pre class="Agda"><a id="_[_]"></a><a id="2449" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2454" class="Symbol">:</a> <a id="2456" class="Symbol">(</a><a id="2457" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2459" class="Symbol">:</a> <a id="2461" href="WellFormed.Base.html#2971" class="Datatype">Ord</a><a id="2464" class="Symbol">)</a> <a id="2466" class="Symbol">→</a> <a id="2468" class="Symbol">⦃</a> <a id="2470" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2476" href="WellFormed.Properties.html#2457" class="Bound">a</a> <a id="2478" class="Symbol">⦄</a> <a id="2480" class="Symbol">→</a> <a id="2482" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2486" href="WellFormed.Properties.html#2449" class="Function Operator">_[_]</a> <a id="2491" class="Symbol">(</a><a id="2492" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2496" href="WellFormed.Properties.html#2496" class="Bound">f</a><a id="2497" class="Symbol">)</a> <a id="2499" class="Symbol">=</a> <a id="2501" href="WellFormed.Properties.html#2496" class="Bound">f</a>

<a id="[]-wf"></a><a id="2504" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2510" class="Symbol">:</a> <a id="2512" class="Symbol">⦃</a> <a id="2514" href="WellFormed.Properties.html#2514" class="Bound">_</a> <a id="2516" class="Symbol">:</a> <a id="2518" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="2524" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2526" class="Symbol">⦄</a> <a id="2528" class="Symbol">→</a> <a id="2530" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2532" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2534" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2536" href="WellFormed.Properties.html#2449" class="Function Operator">]</a> <a id="2538" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="2540" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="2542" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="2544" class="InductiveConstructor">suc</a> <a id="2548" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="2550" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="2552" href="WellFormed.Properties.html#2504" class="Function">[]-wf</a> <a id="2558" class="Symbol">{</a><a id="2559" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="2563" href="WellFormed.Properties.html#2563" class="Bound">f</a><a id="2564" class="Symbol">}</a> <a id="2566" class="Symbol">=</a> <a id="2568" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>定义 2-1-9</strong> 自然数到序数的嵌入 <span class="math inline">\text{fin} : ℕ → \text{Ord}</span></p>
<p><span class="math display">
\text{fin}(n) := \text{suc}^n(0)
</span></p>
<p>其中后继函数的上标 <span class="math inline">n</span> 表示迭代 <span class="math inline">n</span> 次.</p>
<pre class="Agda"><a id="2705" class="Keyword">open</a> <a id="2710" class="Keyword">import</a> <a id="2717" href="Lower.html" class="Module">Lower</a> <a id="2723" class="Keyword">public</a> <a id="2730" class="Keyword">using</a> <a id="2736" class="Symbol">(</a><a id="2737" href="Lower.html#1118" class="Function Operator">_∘ⁿ_</a><a id="2741" class="Symbol">)</a>
<a id="fin"></a><a id="2743" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2747" class="Symbol">:</a> <a id="2749" href="WellFormed.Base.html#3450" class="Function">Seq</a>
<a id="2753" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="2757" href="WellFormed.Properties.html#2757" class="Bound">n</a> <a id="2759" class="Symbol">=</a> <a id="2761" class="Symbol">(</a><a id="2762" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="2766" href="Lower.html#1118" class="Function Operator">∘ⁿ</a> <a id="2769" href="WellFormed.Properties.html#2757" class="Bound">n</a><a id="2770" class="Symbol">)</a> <a id="2772" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a>
</pre>
<p>非形式地, 后文中我们把 <span class="math inline">\text{fin}</span> 视作类型强转 (coercion).</p>
<p><strong>约定 2-1-10</strong> 数字字面量既可以表示自然数, 也可以表示序数. Agda 使用<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能实现该约定.</p>
<pre class="Agda"><a id="2976" class="Keyword">open</a> <a id="2981" class="Keyword">import</a> <a id="2988" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="3009" class="Keyword">public</a>
<a id="3016" class="Keyword">instance</a>
  <a id="nNat"></a><a id="3027" href="WellFormed.Properties.html#3027" class="Function">nNat</a> <a id="3032" class="Symbol">=</a> <a id="3034" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3041" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="3045" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3047" class="Keyword">record</a> <a id="3054" class="Symbol">{</a> <a id="3056" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3067" class="Symbol">=</a> <a id="3069" class="Symbol">λ</a> <a id="3071" href="WellFormed.Properties.html#3071" class="Bound">_</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3077" class="Symbol">;</a> <a id="3079" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3087" class="Symbol">=</a> <a id="3089" class="Symbol">λ</a> <a id="3091" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3093" class="Symbol">→</a> <a id="3095" href="WellFormed.Properties.html#3091" class="Bound">n</a> <a id="3097" class="Symbol">}</a>
  <a id="nOrd"></a><a id="3101" href="WellFormed.Properties.html#3101" class="Function">nOrd</a> <a id="3106" class="Symbol">=</a> <a id="3108" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="3115" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3119" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="3121" class="Keyword">record</a> <a id="3128" class="Symbol">{</a> <a id="3130" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="3141" class="Symbol">=</a> <a id="3143" class="Symbol">λ</a> <a id="3145" href="WellFormed.Properties.html#3145" class="Bound">_</a> <a id="3147" class="Symbol">→</a> <a id="3149" href="Cubical.Data.Unit.Base.html#172" class="Record">⊤</a> <a id="3151" class="Symbol">;</a> <a id="3153" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="3161" class="Symbol">=</a> <a id="3163" class="Symbol">λ</a> <a id="3165" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3167" class="Symbol">→</a> <a id="3169" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="3173" href="WellFormed.Properties.html#3165" class="Bound">n</a> <a id="3175" class="Symbol">}</a>
</pre>
<h2 id="一些引理">一些引理</h2>
<p><strong>事实 2-1-11</strong> 构造子的单射性</p>
<ul>
<li><span class="math inline">a^+ =b ^+ → a = b</span></li>
<li><span class="math inline">\lim f = \lim g → f = g</span></li>
</ul>
<pre class="Agda"><a id="suc-inj"></a><a id="3273" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3281" class="Symbol">:</a> <a id="3283" class="InductiveConstructor">suc</a> <a id="3287" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3289" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3291" class="InductiveConstructor">suc</a> <a id="3295" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3297" class="Symbol">→</a> <a id="3299" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3301" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3303" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3305" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="3313" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3318" class="Symbol">=</a> <a id="3320" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lim-inj"></a><a id="3326" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3334" class="Symbol">:</a> <a id="3336" class="Symbol">{</a><a id="3337" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3341" class="Symbol">:</a> <a id="3343" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3346" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="3347" class="Symbol">}</a> <a id="3349" class="Symbol">{</a><a id="3350" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3354" class="Symbol">:</a> <a id="3356" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3359" href="WellFormed.Base.html#3796" class="Generalizable">g</a><a id="3360" class="Symbol">}</a> <a id="3362" class="Symbol">→</a> <a id="3364" href="WellFormed.Base.html#4217" class="InductiveConstructor">Ord.lim</a> <a id="3372" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3374" class="Symbol">⦃</a> <a id="3376" href="WellFormed.Properties.html#3337" class="Bound">wff</a> <a id="3380" class="Symbol">⦄</a> <a id="3382" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3384" class="InductiveConstructor">lim</a> <a id="3388" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="3390" class="Symbol">⦃</a> <a id="3392" href="WellFormed.Properties.html#3350" class="Bound">wfg</a> <a id="3396" class="Symbol">⦄</a> <a id="3398" class="Symbol">→</a> <a id="3400" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3402" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3404" href="WellFormed.Base.html#3796" class="Generalizable">g</a>
<a id="3406" href="WellFormed.Properties.html#3326" class="Function">lim-inj</a> <a id="3414" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3419" class="Symbol">=</a> <a id="3421" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实 2-1-12</strong> 极限路径的反演: 如果 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span>, 那么存在一个自然数 <span class="math inline">n</span> 使得 <span class="math inline">b</span> 小于 <span class="math inline">a[n]</span>.</p>
<pre class="Agda"><a id="lim-inv-rd"></a><a id="3514" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3525" class="Symbol">:</a> <a id="3527" class="Symbol">⦃</a> <a id="3529" href="WellFormed.Properties.html#3529" class="Bound">_</a> <a id="3531" class="Symbol">:</a> <a id="3533" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3539" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3541" class="Symbol">⦄</a> <a id="3543" class="Symbol">→</a> <a id="3545" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3550" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3552" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3554" class="Symbol">→</a> <a id="3556" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3559" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3561" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3563" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3565" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3567" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3572" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3574" class="Symbol">(</a><a id="3575" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3577" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3579" href="WellFormed.Properties.html#3559" class="Bound">n</a> <a id="3581" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="3582" class="Symbol">)</a>
<a id="3584" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3595" class="Symbol">(</a><a id="3596" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="3600" href="WellFormed.Properties.html#3600" class="Bound">r</a><a id="3601" class="Symbol">)</a> <a id="3603" class="Symbol">=</a> <a id="3605" class="Symbol">_</a> <a id="3607" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3609" href="WellFormed.Properties.html#3600" class="Bound">r</a>

<a id="lim-inv"></a><a id="3612" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3620" class="Symbol">:</a> <a id="3622" class="Symbol">⦃</a> <a id="3624" href="WellFormed.Properties.html#3624" class="Bound">_</a> <a id="3626" class="Symbol">:</a> <a id="3628" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="3634" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3636" class="Symbol">⦄</a> <a id="3638" class="Symbol">→</a> <a id="3640" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3642" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3644" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3646" class="Symbol">→</a> <a id="3648" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3651" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3653" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3655" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3657" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3659" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3661" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3663" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3665" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="3667" href="WellFormed.Properties.html#3651" class="Bound">n</a> <a id="3669" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>
<a id="3671" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="3679" href="WellFormed.Properties.html#3679" class="Bound">r</a> <a id="3681" class="Keyword">with</a> <a id="3686" href="WellFormed.Properties.html#3514" class="Function">lim-inv-rd</a> <a id="3697" class="Symbol">(</a><a id="3698" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="3702" href="WellFormed.Properties.html#3679" class="Bound">r</a><a id="3703" class="Symbol">)</a>
<a id="3705" class="Symbol">...</a> <a id="3709" class="Symbol">|</a> <a id="3711" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3713" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3715" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3717" class="Symbol">=</a> <a id="3719" href="WellFormed.Properties.html#3711" class="Bound">n</a> <a id="3721" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3723" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3725" href="WellFormed.Properties.html#3715" class="Bound">r</a> <a id="3727" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>鉴于互递归证明的特性, 我们有时会先声明定理, 然后再证明其所需的引理, 最后再证明定理本身.</p>
<p><strong>定理 2-1-13</strong> 互递归地, 有</p>
<p><span class="math display">
\begin{aligned}
(1)&amp; \quad a &lt; b → 0 &lt; b \\
(2)&amp; \quad 0 &lt; a^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="z&lt;b-rd"></a><a id="3899" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="3906" class="Symbol">:</a> <a id="3908" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3913" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3915" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3917" class="Symbol">→</a> <a id="3919" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3924" class="Number">0</a> <a id="3926" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="z&lt;s-rd"></a><a id="3928" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="3935" class="Symbol">:</a> <a id="3937" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3942" class="Number">0</a> <a id="3944" class="Symbol">(</a><a id="3945" class="InductiveConstructor">suc</a> <a id="3949" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="3950" class="Symbol">)</a>

<a id="z&lt;b"></a><a id="3953" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3957" class="Symbol">:</a> <a id="3959" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3961" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3963" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3965" class="Symbol">→</a> <a id="3967" class="Number">0</a> <a id="3969" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3971" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="3973" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="3977" class="Symbol">=</a> <a id="3979" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="3983" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a>

<a id="z&lt;s"></a><a id="3991" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="3995" class="Symbol">:</a> <a id="3997" class="Number">0</a> <a id="3999" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4001" class="InductiveConstructor">suc</a> <a id="4005" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="4007" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a> <a id="4011" class="Symbol">=</a> <a id="4013" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="4015" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4022" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p><strong>引理 2-1-14</strong> 基本列的后继项必然大于零.<br />
<strong>证明</strong> 给定基本列 <span class="math inline">f</span>, 由于 <span class="math inline">f(n)&lt;f(n^+)</span>, 由定理 2-1-12 即证. ∎</p>
<pre class="Agda"><a id="z&lt;fs"></a><a id="4122" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4127" class="Symbol">:</a> <a id="4129" class="Symbol">∀</a> <a id="4131" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4133" href="WellFormed.Properties.html#4133" class="Bound">n</a> <a id="4135" class="Symbol">→</a> <a id="4137" class="Symbol">⦃</a> <a id="4139" href="WellFormed.Properties.html#4139" class="Bound">_</a> <a id="4141" class="Symbol">:</a> <a id="4143" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4146" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4148" class="Symbol">⦄</a> <a id="4150" class="Symbol">→</a> <a id="4152" class="Number">0</a> <a id="4154" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4156" href="WellFormed.Properties.html#4131" class="Bound">f</a> <a id="4158" class="Symbol">(</a><a id="4159" class="InductiveConstructor">suc</a> <a id="4163" href="WellFormed.Properties.html#4133" class="Bound">n</a><a id="4164" class="Symbol">)</a>
<a id="4166" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4171" href="WellFormed.Properties.html#4171" class="Bound">f</a> <a id="4173" href="WellFormed.Properties.html#4173" class="Bound">n</a> <a id="4175" class="Symbol">=</a> <a id="4177" href="WellFormed.Properties.html#3953" class="Function">z&lt;b</a> <a id="4181" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-15</strong> 极限序数必然大于零.<br />
<strong>证明</strong> 由 <span class="math inline">\text{&lt;}[1]</span>, 我们证明其基本列第 <span class="math inline">1</span> 项大于零, 而这由引理 2-1-14 即证. ∎</p>
<pre class="Agda"><a id="z&lt;l"></a><a id="4288" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a> <a id="4292" class="Symbol">:</a> <a id="4294" class="Symbol">{</a><a id="4295" href="WellFormed.Properties.html#4295" class="Bound">w</a> <a id="4297" class="Symbol">:</a> <a id="4299" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4302" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="4303" class="Symbol">}</a> <a id="4305" class="Symbol">→</a> <a id="4307" class="Number">0</a> <a id="4309" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="4311" class="InductiveConstructor">lim</a> <a id="4315" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="4317" class="Symbol">⦃</a> <a id="4319" href="WellFormed.Properties.html#4295" class="Bound">w</a> <a id="4321" class="Symbol">⦄</a>
<a id="4323" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a> <a id="4327" class="Symbol">{</a><a id="4328" href="WellFormed.Properties.html#4328" class="Bound">f</a><a id="4329" class="Symbol">}</a> <a id="4331" class="Symbol">{</a><a id="4332" href="WellFormed.Properties.html#4332" class="Bound">w</a><a id="4333" class="Symbol">}</a> <a id="4335" class="Symbol">=</a> <a id="4337" href="WellFormed.Properties.html#2028" class="Function Operator">&lt;[</a> <a id="4340" class="Number">1</a> <a id="4342" href="WellFormed.Properties.html#2028" class="Function Operator">]</a> <a id="4344" class="Symbol">(</a><a id="4345" href="WellFormed.Properties.html#4122" class="Function">z&lt;fs</a> <a id="4350" href="WellFormed.Properties.html#4328" class="Bound">f</a> <a id="4352" class="Number">0</a> <a id="4354" class="Symbol">⦃</a> <a id="4356" href="WellFormed.Properties.html#4332" class="Bound">w</a> <a id="4358" class="Symbol">⦄)</a>
</pre>
<p><strong>定理 2-1-13-(1)</strong> <span class="math inline">a &lt; b → 0 &lt; b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 由定理 2-1-13-(2) 即得 <span class="math inline">0 &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 由引理 2-1-15 即得 <span class="math inline">0 &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="4612" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4619" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="4624" class="Symbol">=</a> <a id="4626" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4633" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4640" class="Symbol">(</a><a id="4641" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4645" href="WellFormed.Properties.html#4645" class="Bound">r</a><a id="4646" class="Symbol">)</a> <a id="4648" class="Symbol">=</a> <a id="4650" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4657" href="WellFormed.Properties.html#3899" class="Function">z&lt;b-rd</a> <a id="4664" class="Symbol">(</a><a id="4665" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="4669" href="WellFormed.Properties.html#4669" class="Bound">r</a><a id="4670" class="Symbol">)</a> <a id="4672" class="Symbol">=</a> <a id="4674" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="4678" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-13-(2)</strong> <span class="math inline">0 &lt; a^+</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 有 <span class="math inline">0 : 0 &lt; 0^+</span>.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 有归纳假设 <span class="math inline">r : 0 &lt; a&#39;^+</span>, 所以 <span class="math inline">r^+ : 0 &lt; a&#39;^{++}</span>.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 要证 <span class="math inline">a &lt; \lim(f)^+</span>, 由路径构造子 <span class="math inline">\text{suc}</span> 及引理 2-1-15 即得. ∎</li>
</ul>
<pre class="Agda"><a id="4913" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4920" class="Symbol">{(</a><a id="4922" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="4926" class="Symbol">)}</a> <a id="4929" class="Symbol">=</a> <a id="4931" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="4936" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4943" class="Symbol">{</a><a id="4944" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="4948" href="WellFormed.Properties.html#4948" class="Bound">a</a><a id="4949" class="Symbol">}</a> <a id="4951" class="Symbol">=</a> <a id="4953" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4957" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a>
<a id="4964" href="WellFormed.Properties.html#3928" class="Function">z&lt;s-rd</a> <a id="4971" class="Symbol">{</a><a id="4972" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="4976" href="WellFormed.Properties.html#4976" class="Bound">f</a><a id="4977" class="Symbol">}</a> <a id="4979" class="Symbol">=</a> <a id="4981" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="4985" class="Symbol">(</a><a id="4986" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="4990" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a><a id="4993" class="Symbol">)</a>
</pre>
<p><strong>推论 2-1-16</strong> 零小于等于任何序数.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳. 零的情况由自反性, 后继的情况由2-1-13-(2), 极限的情况由引理 2-1-15 即得. ∎</p>
<pre class="Agda"><a id="z≤"></a><a id="5103" href="WellFormed.Properties.html#5103" class="Function">z≤</a> <a id="5106" class="Symbol">:</a> <a id="5108" class="Number">0</a> <a id="5110" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5112" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="5114" href="WellFormed.Properties.html#5103" class="Function">z≤</a> <a id="5117" class="Symbol">{(</a><a id="5119" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="5123" class="Symbol">)}</a> <a id="5126" class="Symbol">=</a> <a id="5128" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5132" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5137" href="WellFormed.Properties.html#5103" class="Function">z≤</a> <a id="5140" class="Symbol">{</a><a id="5141" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5145" class="Symbol">_}</a>  <a id="5149" class="Symbol">=</a> <a id="5151" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5155" href="WellFormed.Properties.html#3991" class="Function">z&lt;s</a>
<a id="5159" href="WellFormed.Properties.html#5103" class="Function">z≤</a> <a id="5162" class="Symbol">{</a><a id="5163" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5167" class="Symbol">_}</a>  <a id="5171" class="Symbol">=</a> <a id="5173" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5177" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
</pre>
<p><strong>定理 2-1-17</strong> 互递归地, 有</p>
<ul>
<li><ol type="1">
<li><span class="math inline">a &lt; b \to a^+ ≤ b</span>.</li>
</ol></li>
<li><ol start="2" type="1">
<li>后继运算保持 <span class="math inline">&lt;</span>.</li>
</ol></li>
</ul>
<pre class="Agda"><a id="&lt;→s≤-rd"></a><a id="5263" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="5271" class="Symbol">:</a> <a id="5273" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="5278" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5280" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5282" class="Symbol">→</a> <a id="5284" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="5291" class="Symbol">(</a><a id="5292" class="InductiveConstructor">suc</a> <a id="5296" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="5297" class="Symbol">)</a> <a id="5299" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="s&lt;s-rd"></a><a id="5301" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="5308" class="Symbol">:</a> <a id="5310" class="InductiveConstructor">suc</a> <a id="5314" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5324" href="WellFormed.Base.html#2987" class="Datatype">Road</a>

<a id="&lt;→s≤"></a><a id="5330" href="WellFormed.Properties.html#5330" class="Function">&lt;→s≤</a> <a id="5335" class="Symbol">:</a> <a id="5337" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5339" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="5341" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="5343" class="Symbol">→</a> <a id="5345" class="InductiveConstructor">suc</a> <a id="5349" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="5351" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="5353" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="5355" href="WellFormed.Properties.html#5330" class="Function">&lt;→s≤</a> <a id="5360" class="Symbol">=</a> <a id="5362" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="5366" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="5374" class="Symbol">(</a><a id="5375" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="5380" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5382" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a><a id="5389" class="Symbol">)</a>

<a id="s&lt;s"></a><a id="5392" href="WellFormed.Properties.html#5392" class="Function">s&lt;s</a> <a id="5396" class="Symbol">:</a> <a id="5398" class="InductiveConstructor">suc</a> <a id="5402" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="5412" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="5416" href="WellFormed.Properties.html#5392" class="Function">s&lt;s</a> <a id="5420" class="Symbol">=</a> <a id="5422" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="5426" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a>
</pre>
<p><strong>定理 2-1-17-(1)</strong> <span class="math inline">a &lt; b \to a^+ ≤ b</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 由自反性即得 <span class="math inline">a^+ ≤ a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由定理 2-1-17-(2) 即得 <span class="math inline">a^+ ≤ b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 由定理 2-1-17-(2) 有 <span class="math inline">a^+ &lt; f(n)^+</span>, 由归纳假设有 <span class="math inline">f(n)^+ ≤ f(n^+)</span>, 由传递性即得 <span class="math inline">a^+ &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="5772" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="5780" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="5785" class="Symbol">=</a> <a id="5787" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="5791" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="5796" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="5804" class="Symbol">(</a><a id="5805" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="5809" href="WellFormed.Properties.html#5809" class="Bound">r</a><a id="5810" class="Symbol">)</a> <a id="5812" class="Symbol">=</a> <a id="5814" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5818" class="Symbol">(</a><a id="5819" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="5826" href="WellFormed.Properties.html#5809" class="Bound">r</a><a id="5827" class="Symbol">)</a>
<a id="5829" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="5837" class="Symbol">{</a><a id="5838" href="WellFormed.Properties.html#5838" class="Bound">a</a><a id="5839" class="Symbol">}</a> <a id="5841" class="Symbol">(</a><a id="5842" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="5846" class="Symbol">{</a><a id="5847" href="WellFormed.Properties.html#5847" class="Bound">f</a><a id="5848" class="Symbol">}</a> <a id="5850" class="Symbol">{</a><a id="5851" href="WellFormed.Properties.html#5851" class="Bound">n</a><a id="5852" class="Symbol">}</a> <a id="5854" href="WellFormed.Properties.html#5854" class="Bound">r</a><a id="5855" class="Symbol">)</a> <a id="5857" class="Symbol">=</a> <a id="5859" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="5863" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5865" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="5880" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5884" href="WellFormed.Properties.html#5838" class="Bound">a</a>           <a id="5896" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="5899" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="5906" href="WellFormed.Properties.html#5854" class="Bound">r</a> <a id="5908" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="5912" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="5916" class="Symbol">(</a><a id="5917" href="WellFormed.Properties.html#5847" class="Bound">f</a> <a id="5919" href="WellFormed.Properties.html#5851" class="Bound">n</a><a id="5920" class="Symbol">)</a>       <a id="5928" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="5931" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="5939" class="Symbol">(</a><a id="5940" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="5944" href="Function.Base.html#4736" class="Function">it</a><a id="5946" class="Symbol">)</a> <a id="5948" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="5952" href="WellFormed.Properties.html#5847" class="Bound">f</a> <a id="5954" class="Symbol">(</a><a id="5955" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5959" href="WellFormed.Properties.html#5851" class="Bound">n</a><a id="5960" class="Symbol">)</a>       <a id="5968" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="5971" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="5978" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="5982" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="5986" href="WellFormed.Properties.html#5847" class="Bound">f</a>           <a id="5998" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6000" class="Keyword">where</a> <a id="6006" class="Keyword">open</a> <a id="6011" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-17-(2)</strong> 后继运算保持 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a &lt; b</span> 归纳, 要证 <span class="math inline">a^+ &lt; b^+</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a &lt; a^+</span>, 有 <span class="math inline">0 : a^+ &lt; a^{++}</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a &lt; b</span>. 由归纳假设即得 <span class="math inline">a^+ &lt; b^+</span>.</li>
<li>若 <span class="math inline">r = \lim(r&#39;) : a &lt; \lim(f)</span>, 则有 <span class="math inline">r&#39; : a &lt; f(n)</span>. 与定理 2-1-17-(1) 同理可证 <span class="math inline">a^+ &lt; \lim(f)</span>, 再由路径构造子 <span class="math inline">\text{suc}</span> 即得 <span class="math inline">a^+ &lt; \lim(f)^+</span>. ∎</li>
</ul>
<pre class="Agda"><a id="6360" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="6367" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6372" class="Symbol">=</a> <a id="6374" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="6379" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="6386" class="Symbol">(</a><a id="6387" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6391" href="WellFormed.Properties.html#6391" class="Bound">r</a><a id="6392" class="Symbol">)</a> <a id="6394" class="Symbol">=</a> <a id="6396" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6400" class="Symbol">(</a><a id="6401" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="6408" href="WellFormed.Properties.html#6391" class="Bound">r</a><a id="6409" class="Symbol">)</a>
<a id="6411" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="6418" class="Symbol">{</a><a id="6419" href="WellFormed.Properties.html#6419" class="Bound">x</a><a id="6420" class="Symbol">}</a> <a id="6422" class="Symbol">(</a><a id="6423" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="6427" class="Symbol">{</a><a id="6428" href="WellFormed.Properties.html#6428" class="Bound">f</a><a id="6429" class="Symbol">}</a> <a id="6431" class="Symbol">{</a><a id="6432" href="WellFormed.Properties.html#6432" class="Bound">n</a><a id="6433" class="Symbol">}</a> <a id="6435" href="WellFormed.Properties.html#6435" class="Bound">r</a><a id="6436" class="Symbol">)</a> <a id="6438" class="Symbol">=</a> <a id="6440" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6444" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6446" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="6461" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6465" href="WellFormed.Properties.html#6419" class="Bound">x</a>           <a id="6477" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6480" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="6487" href="WellFormed.Properties.html#6435" class="Bound">r</a> <a id="6489" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6493" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6497" class="Symbol">(</a><a id="6498" href="WellFormed.Properties.html#6428" class="Bound">f</a> <a id="6500" href="WellFormed.Properties.html#6432" class="Bound">n</a><a id="6501" class="Symbol">)</a>       <a id="6509" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="6512" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="6520" class="Symbol">(</a><a id="6521" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="6525" href="Function.Base.html#4736" class="Function">it</a><a id="6527" class="Symbol">)</a> <a id="6529" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="6533" href="WellFormed.Properties.html#6428" class="Bound">f</a> <a id="6535" class="Symbol">(</a><a id="6536" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6540" href="WellFormed.Properties.html#6432" class="Bound">n</a><a id="6541" class="Symbol">)</a>       <a id="6549" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="6552" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="6559" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="6563" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6567" href="WellFormed.Properties.html#6428" class="Bound">f</a>           <a id="6579" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="6581" class="Keyword">where</a> <a id="6587" class="Keyword">open</a> <a id="6592" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>
</pre>
<p><strong>定理 2-1-18</strong> 后继运算单射 <span class="math inline">&lt;</span>.<br />
<strong>证明</strong> 对路径 <span class="math inline">r : a^+ &lt; b^+</span> 归纳, 要证 <span class="math inline">a &lt; b</span>.</p>
<ul>
<li>若 <span class="math inline">r = 0 : a^+ &lt; a^{++}</span>, 有 <span class="math inline">0 : a &lt; a^+</span>.</li>
<li>若 <span class="math inline">r = r&#39;^+ : a^+ &lt; b^+</span>, 则有 <span class="math inline">r&#39; : a^+ &lt; b</span>. 由传递性即得 <span class="math inline">a &lt; a^+ &lt; b</span>.</li>
<li>没有 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 的情况, 因为 <span class="math inline">\lim(f)</span> 不可能是后继序数. ∎</li>
</ul>
<pre class="Agda"><a id="s&lt;s-inj-rd"></a><a id="6872" href="WellFormed.Properties.html#6872" class="Function">s&lt;s-inj-rd</a> <a id="6883" class="Symbol">:</a> <a id="6885" class="InductiveConstructor">suc</a> <a id="6889" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="6897" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="6902" href="WellFormed.Properties.html#6872" class="Function">s&lt;s-inj-rd</a> <a id="6913" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6918" class="Symbol">=</a> <a id="6920" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="6925" href="WellFormed.Properties.html#6872" class="Function">s&lt;s-inj-rd</a> <a id="6936" class="Symbol">(</a><a id="6937" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="6941" href="WellFormed.Properties.html#6941" class="Bound">r</a><a id="6942" class="Symbol">)</a> <a id="6944" class="Symbol">=</a> <a id="6946" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="6955" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="6960" href="WellFormed.Properties.html#6941" class="Bound">r</a>

<a id="s&lt;s-inj"></a><a id="6963" href="WellFormed.Properties.html#6963" class="Function">s&lt;s-inj</a> <a id="6971" class="Symbol">:</a> <a id="6973" class="InductiveConstructor">suc</a> <a id="6977" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="6985" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="6989" href="WellFormed.Properties.html#6963" class="Function">s&lt;s-inj</a> <a id="6997" class="Symbol">=</a> <a id="6999" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7003" href="WellFormed.Properties.html#6872" class="Function">s&lt;s-inj-rd</a>
</pre>
<p><strong>推论 2-1-19</strong> 后继运算保持 <span class="math inline">\leq</span>, 且单射 <span class="math inline">\leq</span>.<br />
<strong>证明</strong> 由事实 2-1-2 和定理 2-1-17-(2) 可证保持; 由事实 2-1-4, 事实 2-1-11 和定理 2-1-18 可证单射. ∎</p>
<pre class="Agda"><a id="s≤s"></a><a id="7149" href="WellFormed.Properties.html#7149" class="Function">s≤s</a> <a id="7153" class="Symbol">:</a> <a id="7155" class="InductiveConstructor">suc</a> <a id="7159" href="WellFormed.Properties.html#927" class="Function Operator">preserves</a> <a id="7169" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7173" href="WellFormed.Properties.html#7149" class="Function">s≤s</a> <a id="7177" class="Symbol">=</a> <a id="7179" href="WellFormed.Properties.html#1067" class="Function">map-pres≤</a> <a id="7189" href="WellFormed.Properties.html#5392" class="Function">s&lt;s</a>

<a id="s≤s-inj"></a><a id="7194" href="WellFormed.Properties.html#7194" class="Function">s≤s-inj</a> <a id="7202" class="Symbol">:</a> <a id="7204" class="InductiveConstructor">suc</a> <a id="7208" href="WellFormed.Properties.html#1304" class="Function Operator">injects</a> <a id="7216" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="7220" href="WellFormed.Properties.html#7194" class="Function">s≤s-inj</a> <a id="7228" class="Symbol">=</a> <a id="7230" href="WellFormed.Properties.html#1440" class="Function">map-inj≤</a> <a id="7239" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="7247" href="WellFormed.Properties.html#6963" class="Function">s&lt;s-inj</a>
</pre>
<p><strong>定理 2-1-20</strong> 定理 2-1-17-(1) 的逆命题 <span class="math inline">a^+ ≤ b → a &lt; b</span> 成立.<br />
<strong>证明</strong> 对 <span class="math inline">b</span> 归纳, 且讨论 <span class="math inline">r : a^+ ≤ b</span>.</p>
<ul>
<li><span class="math inline">b = 0</span> 的情况不可能.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ &lt; b&#39;^+</span>, 由推论 2-1-19 有 <span class="math inline">a &lt; b&#39;</span>, 所以 <span class="math inline">a &lt; b&#39;^+</span>.</li>
<li>若 <span class="math inline">b = b&#39;^+</span> 且 <span class="math inline">a^+ = b&#39;^+</span>, 目标改写变为 <span class="math inline">b&#39; &lt; b</span>, 显然成立.</li>
<li>若 <span class="math inline">b = \lim(f)</span>, <span class="math inline">r</span> 只能为 <span class="math inline">r = \lim(r&#39;) : a^+ &lt; \lim(f)</span> 且 <span class="math inline">r&#39; : a^+ &lt; f(n)</span>, 由传递性即得 <span class="math inline">a &lt; a^+ &lt; f(n) &lt; \lim(f)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="s≤→&lt;-rd"></a><a id="7620" href="WellFormed.Properties.html#7620" class="Function">s≤→&lt;-rd</a> <a id="7628" class="Symbol">:</a> <a id="7630" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="7637" class="Symbol">(</a><a id="7638" class="InductiveConstructor">suc</a> <a id="7642" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="7643" class="Symbol">)</a> <a id="7645" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7647" class="Symbol">→</a> <a id="7649" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="7654" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7656" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7658" href="WellFormed.Properties.html#7620" class="Function">s≤→&lt;-rd</a> <a id="7666" class="Symbol">{</a><a id="7667" class="Argument">b</a> <a id="7669" class="Symbol">=</a> <a id="7671" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7675" href="WellFormed.Properties.html#7675" class="Bound">b</a><a id="7676" class="Symbol">}</a> <a id="7678" class="Symbol">(</a><a id="7679" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7683" href="WellFormed.Properties.html#7683" class="Bound">r</a><a id="7684" class="Symbol">)</a>       <a id="7692" class="Symbol">=</a> <a id="7694" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="7698" class="Symbol">(</a><a id="7699" href="WellFormed.Properties.html#6872" class="Function">s&lt;s-inj-rd</a> <a id="7710" href="WellFormed.Properties.html#7683" class="Bound">r</a><a id="7711" class="Symbol">)</a>
<a id="7713" href="WellFormed.Properties.html#7620" class="Function">s≤→&lt;-rd</a> <a id="7721" class="Symbol">{</a><a id="7722" class="Argument">b</a> <a id="7724" class="Symbol">=</a> <a id="7726" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7730" href="WellFormed.Properties.html#7730" class="Bound">b</a><a id="7731" class="Symbol">}</a> <a id="7733" class="Symbol">(</a><a id="7734" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7738" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7742" class="Symbol">)</a>    <a id="7747" class="Symbol">=</a> <a id="7749" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
<a id="7754" href="WellFormed.Properties.html#7620" class="Function">s≤→&lt;-rd</a> <a id="7762" class="Symbol">{</a><a id="7763" class="Argument">b</a> <a id="7765" class="Symbol">=</a> <a id="7767" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="7771" href="WellFormed.Properties.html#7771" class="Bound">f</a><a id="7772" class="Symbol">}</a> <a id="7774" class="Symbol">(</a><a id="7775" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7779" class="Symbol">(</a><a id="7780" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7784" href="WellFormed.Properties.html#7784" class="Bound">r</a><a id="7785" class="Symbol">))</a> <a id="7788" class="Symbol">=</a> <a id="7790" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="7794" class="Symbol">(</a><a id="7795" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="7804" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="7809" href="WellFormed.Properties.html#7784" class="Bound">r</a><a id="7810" class="Symbol">)</a>

<a id="s≤→&lt;"></a><a id="7813" href="WellFormed.Properties.html#7813" class="Function">s≤→&lt;</a> <a id="7818" class="Symbol">:</a> <a id="7820" class="InductiveConstructor">suc</a> <a id="7824" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7826" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="7828" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="7830" class="Symbol">→</a> <a id="7832" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7834" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="7836" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="7838" href="WellFormed.Properties.html#7813" class="Function">s≤→&lt;</a> <a id="7843" class="Symbol">(</a><a id="7844" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="7848" href="WellFormed.Properties.html#7848" class="Bound">r</a><a id="7849" class="Symbol">)</a>    <a id="7854" class="Symbol">=</a> <a id="7856" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="7860" class="Symbol">(</a><a id="7861" href="WellFormed.Properties.html#7620" class="Function">s≤→&lt;-rd</a> <a id="7869" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="7871" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a><a id="7874" class="Symbol">)</a> <a id="7876" href="WellFormed.Properties.html#7848" class="Bound">r</a>
<a id="7878" href="WellFormed.Properties.html#7813" class="Function">s≤→&lt;</a> <a id="7883" class="Symbol">(</a><a id="7884" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="7888" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="7892" class="Symbol">)</a> <a id="7894" class="Symbol">=</a> <a id="7896" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>
</pre>
<p><strong>定理 2-1-21</strong> 后继运算在极限序数下封闭.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">b</span> 小于极限序数 <span class="math inline">a</span> 都有 <span class="math inline">b^+ &lt; a</span>. 讨论 <span class="math inline">r : b &lt; a</span>, 只能有 <span class="math inline">r = \lim(r&#39;) : b &lt; a</span>, 且 <span class="math inline">r&#39; : b &lt; a[n]</span>. 由定理 2-1-17 即传递性即得 <span class="math inline">b^+ &lt; a[n]^+ ≤ a</span>. ∎</p>
<pre class="Agda"><a id="s&lt;l-rd"></a><a id="8091" href="WellFormed.Properties.html#8091" class="Function">s&lt;l-rd</a> <a id="8098" class="Symbol">:</a> <a id="8100" class="Symbol">⦃</a> <a id="8102" href="WellFormed.Properties.html#8102" class="Bound">_</a> <a id="8104" class="Symbol">:</a> <a id="8106" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8112" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8114" class="Symbol">⦄</a> <a id="8116" class="Symbol">→</a> <a id="8118" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8123" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8125" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8127" class="Symbol">→</a> <a id="8129" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8134" class="Symbol">(</a><a id="8135" class="InductiveConstructor">suc</a> <a id="8139" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8140" class="Symbol">)</a> <a id="8142" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8144" href="WellFormed.Properties.html#8091" class="Function">s&lt;l-rd</a> <a id="8151" class="Symbol">{</a><a id="8152" href="WellFormed.Properties.html#8152" class="Bound">a</a><a id="8153" class="Symbol">}</a> <a id="8155" class="Symbol">{</a><a id="8156" href="WellFormed.Properties.html#8156" class="Bound">b</a><a id="8157" class="Symbol">}</a> <a id="8159" class="Symbol">(</a><a id="8160" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="8164" class="Symbol">{</a><a id="8165" href="WellFormed.Properties.html#8165" class="Bound">n</a><a id="8166" class="Symbol">}</a> <a id="8168" href="WellFormed.Properties.html#8168" class="Bound">r</a><a id="8169" class="Symbol">)</a> <a id="8171" class="Symbol">=</a> <a id="8173" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="8188" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8192" href="WellFormed.Properties.html#8156" class="Bound">b</a>           <a id="8204" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="8207" href="WellFormed.Properties.html#5301" class="Function">s&lt;s-rd</a> <a id="8214" href="WellFormed.Properties.html#8168" class="Bound">r</a> <a id="8216" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="8220" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="8224" class="Symbol">(</a><a id="8225" href="WellFormed.Properties.html#8152" class="Bound">a</a> <a id="8227" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="8229" href="WellFormed.Properties.html#8165" class="Bound">n</a> <a id="8231" href="WellFormed.Properties.html#2449" class="Function Operator">]</a><a id="8232" class="Symbol">)</a>   <a id="8236" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="8239" href="WellFormed.Properties.html#5263" class="Function">&lt;→s≤-rd</a> <a id="8247" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="8254" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="8258" href="WellFormed.Properties.html#8152" class="Bound">a</a>               <a id="8274" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="8276" class="Keyword">where</a> <a id="8282" class="Keyword">open</a> <a id="8287" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a>

<a id="s&lt;l"></a><a id="8302" href="WellFormed.Properties.html#8302" class="Function">s&lt;l</a> <a id="8306" class="Symbol">:</a> <a id="8308" class="Symbol">⦃</a> <a id="8310" href="WellFormed.Properties.html#8310" class="Bound">_</a> <a id="8312" class="Symbol">:</a> <a id="8314" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8320" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8322" class="Symbol">⦄</a> <a id="8324" class="Symbol">→</a> <a id="8326" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8328" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8330" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8332" class="Symbol">→</a> <a id="8334" class="InductiveConstructor">suc</a> <a id="8338" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8340" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="8342" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="8344" href="WellFormed.Properties.html#8302" class="Function">s&lt;l</a> <a id="8348" class="Symbol">=</a> <a id="8350" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="8354" href="WellFormed.Properties.html#8091" class="Function">s&lt;l-rd</a>
</pre>
<p><strong>定理 2-1-22</strong> 直接前驱在极限序数上封闭.<br />
<strong>证明</strong> 要证对任意极限序数 <span class="math inline">a ≤ b^+</span> 有 <span class="math inline">a ≤ b</span>. 讨论 <span class="math inline">a ≤ b^+</span>.</p>
<ul>
<li>不可能有 <span class="math inline">a = b^+</span> 的情况, 因为 <span class="math inline">b^+</span> 不可能是极限序数.</li>
<li>若 <span class="math inline">a &lt; a^+</span>, 有 <span class="math inline">a = a</span>.</li>
<li>若 <span class="math inline">a &lt; b^+</span>, 必然有 <span class="math inline">a &lt; b</span>. ∎</li>
</ul>
<pre class="Agda"><a id="l≤p-rd"></a><a id="8555" href="WellFormed.Properties.html#8555" class="Function">l≤p-rd</a> <a id="8562" class="Symbol">:</a> <a id="8564" class="Symbol">⦃</a> <a id="8566" href="WellFormed.Properties.html#8566" class="Bound">_</a> <a id="8568" class="Symbol">:</a> <a id="8570" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8576" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8578" class="Symbol">⦄</a> <a id="8580" class="Symbol">→</a> <a id="8582" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8589" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8591" class="Symbol">(</a><a id="8592" class="InductiveConstructor">suc</a> <a id="8596" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="8597" class="Symbol">)</a> <a id="8599" class="Symbol">→</a> <a id="8601" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="8608" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8610" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8612" href="WellFormed.Properties.html#8555" class="Function">l≤p-rd</a> <a id="8619" class="Symbol">{</a><a id="8620" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8624" href="WellFormed.Properties.html#8624" class="Bound">f</a><a id="8625" class="Symbol">}</a> <a id="8627" class="Symbol">(</a><a id="8628" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8632" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a><a id="8636" class="Symbol">)</a>    <a id="8641" class="Symbol">=</a> <a id="8643" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="8647" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="8652" href="WellFormed.Properties.html#8555" class="Function">l≤p-rd</a> <a id="8659" class="Symbol">{</a><a id="8660" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8664" href="WellFormed.Properties.html#8664" class="Bound">f</a><a id="8665" class="Symbol">}</a> <a id="8667" class="Symbol">(</a><a id="8668" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8672" class="Symbol">(</a><a id="8673" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="8677" href="WellFormed.Properties.html#8677" class="Bound">r</a><a id="8678" class="Symbol">))</a> <a id="8681" class="Symbol">=</a> <a id="8683" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8687" href="WellFormed.Properties.html#8677" class="Bound">r</a>

<a id="l≤p"></a><a id="8690" href="WellFormed.Properties.html#8690" class="Function">l≤p</a> <a id="8694" class="Symbol">:</a> <a id="8696" class="Symbol">⦃</a> <a id="8698" href="WellFormed.Properties.html#8698" class="Bound">_</a> <a id="8700" class="Symbol">:</a> <a id="8702" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="8708" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8710" class="Symbol">⦄</a> <a id="8712" class="Symbol">→</a> <a id="8714" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8716" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8718" class="InductiveConstructor">suc</a> <a id="8722" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="8724" class="Symbol">→</a> <a id="8726" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="8728" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="8730" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="8732" href="WellFormed.Properties.html#8690" class="Function">l≤p</a> <a id="8736" class="Symbol">{</a><a id="8737" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8741" href="WellFormed.Properties.html#8741" class="Bound">f</a><a id="8742" class="Symbol">}</a> <a id="8744" class="Symbol">(</a><a id="8745" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8749" href="WellFormed.Properties.html#8749" class="Bound">r</a><a id="8750" class="Symbol">)</a> <a id="8752" class="Symbol">=</a> <a id="8754" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="8759" class="Symbol">(</a><a id="8760" href="WellFormed.Properties.html#8555" class="Function">l≤p-rd</a> <a id="8767" class="Symbol">(</a><a id="8768" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="8772" class="Symbol">(</a><a id="8773" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="8777" href="WellFormed.Properties.html#8749" class="Bound">r</a><a id="8778" class="Symbol">)))</a>
</pre>
<h2 id="ω的性质">ω的性质</h2>
<p><strong>定义 2-1-23</strong> 由定义 2-1-9, 显然 <span class="math inline">\text{fin}</span> 是良构序列, 我们把 <span class="math inline">\lim(\text{fin})</span> 记作 <span class="math inline">\omega</span>.</p>
<pre class="Agda"><a id="8889" class="Keyword">instance</a>
  <a id="fin-wf"></a><a id="8900" href="WellFormed.Properties.html#8900" class="Function">fin-wf</a> <a id="8907" class="Symbol">:</a> <a id="8909" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="8912" href="WellFormed.Properties.html#2743" class="Function">fin</a>
  <a id="8918" href="WellFormed.Properties.html#8900" class="Function">fin-wf</a> <a id="8925" class="Symbol">=</a> <a id="8927" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>

<a id="ω"></a><a id="8934" href="WellFormed.Properties.html#8934" class="Function">ω</a> <a id="8936" class="Symbol">:</a> <a id="8938" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
<a id="8942" href="WellFormed.Properties.html#8934" class="Function">ω</a> <a id="8944" class="Symbol">=</a> <a id="8946" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="8950" href="WellFormed.Properties.html#2743" class="Function">fin</a>
</pre>
<p><strong>引理 2-1-24</strong> 有限序数 <span class="math inline">n</span> 都小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 由引理 2-1-15 可知零小于极限序数.</li>
<li>若 <span class="math inline">n</span> 为后继, 由定理 2-1-21 可知后继序数小于极限序数, 只要其直接前驱小于该极限序数, 而这是归纳假设. ∎</li>
</ul>
<pre class="Agda"><a id="n&lt;ω"></a><a id="9124" href="WellFormed.Properties.html#9124" class="Function">n&lt;ω</a> <a id="9128" class="Symbol">:</a> <a id="9130" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9134" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9136" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9138" href="WellFormed.Properties.html#8934" class="Function">ω</a>
<a id="9140" href="WellFormed.Properties.html#9124" class="Function">n&lt;ω</a> <a id="9144" class="Symbol">{</a><a id="9145" class="Argument">n</a> <a id="9147" class="Symbol">=</a> <a id="9149" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9153" class="Symbol">}</a>  <a id="9156" class="Symbol">=</a> <a id="9158" href="WellFormed.Properties.html#4288" class="Function">z&lt;l</a>
<a id="9162" href="WellFormed.Properties.html#9124" class="Function">n&lt;ω</a> <a id="9166" class="Symbol">{</a><a id="9167" class="Argument">n</a> <a id="9169" class="Symbol">=</a> <a id="9171" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9175" href="WellFormed.Properties.html#9175" class="Bound">n</a><a id="9176" class="Symbol">}</a> <a id="9178" class="Symbol">=</a> <a id="9180" href="WellFormed.Properties.html#8302" class="Function">s&lt;l</a> <a id="9184" href="WellFormed.Properties.html#9124" class="Function">n&lt;ω</a>
</pre>
<p><strong>引理 2-1-25</strong> 任意基本列的第 <span class="math inline">n</span> 项大于等于 <span class="math inline">n</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">n</span> 为零, 显然 <span class="math inline">0 ≤ f(0)</span>.</li>
<li>若 <span class="math inline">n</span> 为后继, 由归纳假设 <span class="math inline">n ≤ f(n)</span> 可得 <span class="math inline">n^+ ≤ f(n)^+ &lt; f(n^+)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="n≤fn"></a><a id="9346" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="9351" class="Symbol">:</a> <a id="9353" class="Symbol">∀</a> <a id="9355" href="WellFormed.Properties.html#9355" class="Bound">f</a> <a id="9357" class="Symbol">→</a> <a id="9359" class="Symbol">⦃</a> <a id="9361" href="WellFormed.Properties.html#9361" class="Bound">_</a> <a id="9363" class="Symbol">:</a> <a id="9365" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9368" href="WellFormed.Properties.html#9355" class="Bound">f</a> <a id="9370" class="Symbol">⦄</a> <a id="9372" class="Symbol">→</a> <a id="9374" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9378" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="9380" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="9382" href="WellFormed.Properties.html#9355" class="Bound">f</a> <a id="9384" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="9386" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="9391" class="Symbol">{</a><a id="9392" class="Argument">n</a> <a id="9394" class="Symbol">=</a> <a id="9396" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9400" class="Symbol">}</a> <a id="9402" href="WellFormed.Properties.html#9402" class="Bound">f</a>   <a id="9406" class="Symbol">=</a> <a id="9408" href="WellFormed.Properties.html#5103" class="Function">z≤</a>
<a id="9411" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="9416" class="Symbol">{</a><a id="9417" class="Argument">n</a> <a id="9419" class="Symbol">=</a> <a id="9421" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9425" href="WellFormed.Properties.html#9425" class="Bound">n</a><a id="9426" class="Symbol">}</a> <a id="9428" href="WellFormed.Properties.html#9428" class="Bound">f</a>  <a id="9431" class="Symbol">=</a> <a id="9433" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="9441" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9445" class="Symbol">(</a><a id="9446" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9450" href="WellFormed.Properties.html#9425" class="Bound">n</a><a id="9451" class="Symbol">)</a>         <a id="9461" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9464" href="WellFormed.Properties.html#7149" class="Function">s≤s</a> <a id="9468" class="Symbol">(</a><a id="9469" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="9474" href="WellFormed.Properties.html#9428" class="Bound">f</a><a id="9475" class="Symbol">)</a> <a id="9477" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9481" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="9485" class="Symbol">(</a><a id="9486" href="WellFormed.Properties.html#9428" class="Bound">f</a> <a id="9488" href="WellFormed.Properties.html#9425" class="Bound">n</a><a id="9489" class="Symbol">)</a>           <a id="9501" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="9504" href="WellFormed.Properties.html#5330" class="Function">&lt;→s≤</a> <a id="9509" href="Function.Base.html#4736" class="Function">it</a> <a id="9512" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="9516" href="WellFormed.Properties.html#9428" class="Bound">f</a> <a id="9518" class="Symbol">(</a><a id="9519" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9523" href="WellFormed.Properties.html#9425" class="Bound">n</a><a id="9524" class="Symbol">)</a>           <a id="9536" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="9538" class="Keyword">where</a> <a id="9544" class="Keyword">open</a> <a id="9549" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>推论 2-1-26</strong> 任意基本列的第 <span class="math inline">n^+</span> 项大于 <span class="math inline">n</span>.<br />
<strong>证明</strong> <span class="math inline">n ≤ f(n) &lt; f(n^+)</span>. ∎</p>
<pre class="Agda"><a id="n&lt;fs"></a><a id="9649" href="WellFormed.Properties.html#9649" class="Function">n&lt;fs</a> <a id="9654" class="Symbol">:</a> <a id="9656" class="Symbol">∀</a> <a id="9658" href="WellFormed.Properties.html#9658" class="Bound">f</a> <a id="9660" href="WellFormed.Properties.html#9660" class="Bound">n</a> <a id="9662" class="Symbol">→</a> <a id="9664" class="Symbol">⦃</a> <a id="9666" href="WellFormed.Properties.html#9666" class="Bound">_</a> <a id="9668" class="Symbol">:</a> <a id="9670" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="9673" href="WellFormed.Properties.html#9658" class="Bound">f</a> <a id="9675" class="Symbol">⦄</a> <a id="9677" class="Symbol">→</a> <a id="9679" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9683" href="WellFormed.Properties.html#9660" class="Bound">n</a> <a id="9685" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="9687" href="WellFormed.Properties.html#9658" class="Bound">f</a> <a id="9689" class="Symbol">(</a><a id="9690" class="InductiveConstructor">suc</a> <a id="9694" href="WellFormed.Properties.html#9660" class="Bound">n</a><a id="9695" class="Symbol">)</a>
<a id="9697" href="WellFormed.Properties.html#9649" class="Function">n&lt;fs</a> <a id="9702" href="WellFormed.Properties.html#9702" class="Bound">f</a> <a id="9704" class="Symbol">_</a> <a id="9706" class="Symbol">=</a> <a id="9708" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="9718" class="Symbol">(</a><a id="9719" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="9724" href="WellFormed.Properties.html#9702" class="Bound">f</a><a id="9725" class="Symbol">)</a> <a id="9727" href="Function.Base.html#4736" class="Function">it</a>
</pre>
<p><strong>引理 2-1-27</strong> 没有极限序数小于 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 假设有这样的序数 <span class="math inline">a</span>. 由事实 2-1-12, 存在 <span class="math inline">n</span> 使得 <span class="math inline">a &lt; n</span>. 但由引理 2-1-25 又有 <span class="math inline">n ≤ a[n] &lt; a</span>. 由传递性有 <span class="math inline">n &lt; n</span>, 违反 <span class="math inline">&lt;</span> 的反自反性. ∎</p>
<pre class="Agda"><a id="l≮ω"></a><a id="9893" href="WellFormed.Properties.html#9893" class="Function">l≮ω</a> <a id="9897" class="Symbol">:</a> <a id="9899" class="Symbol">⦃</a> <a id="9901" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="9907" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="9909" class="Symbol">⦄</a> <a id="9911" class="Symbol">→</a> <a id="9913" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="9915" href="WellFormed.Base.html#3172" class="Function Operator">≮</a> <a id="9917" href="WellFormed.Properties.html#8934" class="Function">ω</a>
<a id="9919" href="WellFormed.Properties.html#9893" class="Function">l≮ω</a> <a id="9923" href="WellFormed.Properties.html#9923" class="Bound">a</a><a id="9924" class="Symbol">@{</a><a id="9926" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="9930" href="WellFormed.Properties.html#9930" class="Bound">f</a><a id="9931" class="Symbol">}</a> <a id="9933" href="WellFormed.Properties.html#9933" class="Bound">r</a> <a id="9935" class="Symbol">=</a> <a id="9937" class="Keyword">let</a> <a id="9941" href="WellFormed.Properties.html#9941" class="Bound">n</a> <a id="9943" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9945" href="WellFormed.Properties.html#9945" class="Bound">r</a> <a id="9947" class="Symbol">=</a> <a id="9949" href="WellFormed.Properties.html#3612" class="Function">lim-inv</a> <a id="9957" href="WellFormed.Properties.html#9933" class="Bound">r</a> <a id="9959" class="Keyword">in</a> <a id="9962" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="9971" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9976" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9978" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="9993" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="9997" href="WellFormed.Properties.html#9941" class="Bound">n</a>               <a id="10013" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="10016" href="WellFormed.Properties.html#9346" class="Function">n≤fn</a> <a id="10021" href="WellFormed.Properties.html#9930" class="Bound">f</a> <a id="10023" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="10027" href="WellFormed.Properties.html#9923" class="Bound">a</a> <a id="10029" href="WellFormed.Properties.html#2449" class="Function Operator">[</a> <a id="10031" href="WellFormed.Properties.html#9941" class="Bound">n</a> <a id="10033" href="WellFormed.Properties.html#2449" class="Function Operator">]</a>             <a id="10047" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10050" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a> <a id="10054" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10058" href="WellFormed.Properties.html#9923" class="Bound">a</a>                   <a id="10078" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="10081" href="WellFormed.Properties.html#9945" class="Bound">r</a> <a id="10083" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="10087" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10091" href="WellFormed.Properties.html#9941" class="Bound">n</a>               <a id="10107" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="10109" class="Keyword">where</a> <a id="10115" class="Keyword">open</a> <a id="10120" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>引理 2-1-28</strong> 忽略非同株, <span class="math inline">\omega</span> 是最小的极限序数.<br />
<strong>证明</strong> 对任意与 <span class="math inline">\omega</span> 同株的极限序数 <span class="math inline">a</span>, 由推论 2-0-34, 讨论 <span class="math inline">\omega</span> 与 <span class="math inline">a</span> 的大小关系. 若 <span class="math inline">a &lt; \omega</span>, 由引理 2-1-27 可得矛盾. 所以只能有 <span class="math inline">ω ≤ a</span>. ∎</p>
<pre class="Agda"><a id="ω≤l"></a><a id="10314" href="WellFormed.Properties.html#10314" class="Function">ω≤l</a> <a id="10318" class="Symbol">:</a> <a id="10320" class="Symbol">⦃</a> <a id="10322" href="WellFormed.Properties.html#2274" class="Function">IsLim</a> <a id="10328" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10330" class="Symbol">⦄</a> <a id="10332" class="Symbol">→</a> <a id="10334" href="WellFormed.Properties.html#8934" class="Function">ω</a> <a id="10336" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10338" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10340" class="Symbol">→</a> <a id="10342" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10344" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10346" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10348" class="Symbol">→</a> <a id="10350" href="WellFormed.Properties.html#8934" class="Function">ω</a> <a id="10352" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="10354" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10356" href="WellFormed.Properties.html#10314" class="Function">ω≤l</a> <a id="10360" class="Symbol">{</a><a id="10361" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="10365" href="WellFormed.Properties.html#10365" class="Bound">f</a><a id="10366" class="Symbol">}</a> <a id="10368" href="WellFormed.Properties.html#10368" class="Bound">r</a> <a id="10370" href="WellFormed.Properties.html#10370" class="Bound">s</a> <a id="10372" class="Keyword">with</a> <a id="10377" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="10386" href="WellFormed.Properties.html#10368" class="Bound">r</a> <a id="10388" href="WellFormed.Properties.html#10370" class="Bound">s</a>
<a id="10390" class="Symbol">...</a> <a id="10394" class="Symbol">|</a> <a id="10396" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10400" href="WellFormed.Properties.html#10400" class="Bound">r</a>           <a id="10412" class="Symbol">=</a> <a id="10414" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10418" href="WellFormed.Properties.html#10400" class="Bound">r</a>
<a id="10420" class="Symbol">...</a> <a id="10424" class="Symbol">|</a> <a id="10426" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10430" class="Symbol">(</a><a id="10431" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10435" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="10439" class="Symbol">)</a>  <a id="10442" class="Symbol">=</a> <a id="10444" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10448" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10453" class="Symbol">...</a> <a id="10457" class="Symbol">|</a> <a id="10459" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="10463" class="Symbol">(</a><a id="10464" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="10468" href="WellFormed.Properties.html#10468" class="Bound">r</a><a id="10469" class="Symbol">)</a>     <a id="10475" class="Symbol">=</a> <a id="10477" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="10484" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10486" href="WellFormed.Properties.html#9893" class="Function">l≮ω</a> <a id="10490" href="WellFormed.Properties.html#10468" class="Bound">r</a>
</pre>
<p><strong>引理 2-1-29</strong> <span class="math inline">\text{fin}</span> 单射 <span class="math inline">=</span>.<br />
<strong>证明</strong> 对 <span class="math inline">m, n</span> 归纳即得. ∎</p>
<pre class="Agda"><a id="fin-inj"></a><a id="10567" href="WellFormed.Properties.html#10567" class="Function">fin-inj</a> <a id="10575" class="Symbol">:</a> <a id="10577" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10581" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10583" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10585" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10589" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="10591" class="Symbol">→</a> <a id="10593" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="10595" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10597" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="10599" href="WellFormed.Properties.html#10567" class="Function">fin-inj</a> <a id="10607" class="Symbol">{(</a><a id="10609" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10613" class="Symbol">)}</a> <a id="10616" class="Symbol">{(</a><a id="10618" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="10622" class="Symbol">)}</a> <a id="10625" href="WellFormed.Properties.html#10625" class="Bound">eq</a> <a id="10628" class="Symbol">=</a> <a id="10630" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10635" href="WellFormed.Properties.html#10567" class="Function">fin-inj</a> <a id="10643" class="Symbol">{</a><a id="10644" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10648" href="WellFormed.Properties.html#10648" class="Bound">m</a><a id="10649" class="Symbol">}</a>  <a id="10652" class="Symbol">{</a><a id="10653" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10657" href="WellFormed.Properties.html#10657" class="Bound">n</a><a id="10658" class="Symbol">}</a>  <a id="10661" href="WellFormed.Properties.html#10661" class="Bound">eq</a> <a id="10664" class="Symbol">=</a> <a id="10666" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10671" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10675" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10677" href="WellFormed.Properties.html#10567" class="Function">fin-inj</a> <a id="10685" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="10687" href="WellFormed.Properties.html#3273" class="Function">suc-inj</a> <a id="10695" href="WellFormed.Properties.html#10661" class="Bound">eq</a>
</pre>
<p><strong>引理 2-1-30</strong> <span class="math inline">\text{fin}</span> 满射 <span class="math inline">\omega</span>.<br />
<strong>证明</strong> 要证对任意 <span class="math inline">a &lt; ω</span> 都存在 <span class="math inline">n</span> 使得 <span class="math inline">n = a</span>. 对 <span class="math inline">a</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">a = 0</span>, 取 <span class="math inline">n = 0</span> 即可.</li>
<li>若 <span class="math inline">a = a&#39;^+</span>, 由归纳假设可得一个 <span class="math inline">n&#39; = a&#39;</span>. 取 <span class="math inline">n = n&#39;^+</span> 即可.</li>
<li>若 <span class="math inline">a = \lim(f)</span>, 由引理 2-1-27 可得矛盾. ∎</li>
</ul>
<pre class="Agda"><a id="fin-suj"></a><a id="10925" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="10933" class="Symbol">:</a> <a id="10935" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10937" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10939" href="WellFormed.Properties.html#8934" class="Function">ω</a> <a id="10941" class="Symbol">→</a> <a id="10943" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="10946" href="WellFormed.Properties.html#10946" class="Bound">n</a> <a id="10948" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="10950" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10952" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="10954" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="10958" href="WellFormed.Properties.html#10946" class="Bound">n</a> <a id="10960" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10962" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10964" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="10972" class="Symbol">{(</a><a id="10974" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a><a id="10978" class="Symbol">)}</a> <a id="10981" href="WellFormed.Properties.html#10981" class="Bound">r</a>  <a id="10984" class="Symbol">=</a> <a id="10986" class="Number">0</a> <a id="10988" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10990" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10995" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11003" class="Symbol">{</a><a id="11004" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="11008" class="Symbol">_}</a>  <a id="11012" href="WellFormed.Properties.html#11012" class="Bound">r</a>  <a id="11015" class="Keyword">with</a> <a id="11020" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11028" class="Symbol">(</a><a id="11029" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11037" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11043" href="WellFormed.Properties.html#11012" class="Bound">r</a><a id="11044" class="Symbol">)</a>
<a id="11046" class="Symbol">...</a> <a id="11050" class="Symbol">|</a> <a id="11052" href="WellFormed.Properties.html#11052" class="Bound">n</a> <a id="11054" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11056" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>      <a id="11066" class="Symbol">=</a> <a id="11068" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11072" href="WellFormed.Properties.html#11052" class="Bound">n</a> <a id="11074" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11076" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11081" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11089" class="Symbol">{</a><a id="11090" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11094" href="WellFormed.Properties.html#11094" class="Bound">f</a><a id="11095" class="Symbol">}</a>  <a id="11098" href="WellFormed.Properties.html#11098" class="Bound">r</a>  <a id="11101" class="Symbol">=</a> <a id="11103" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="11110" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11112" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="11121" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11126" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11128" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="11143" href="WellFormed.Properties.html#8934" class="Function">ω</a>                   <a id="11163" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">≤⟨</a> <a id="11166" href="WellFormed.Properties.html#10314" class="Function">ω≤l</a> <a id="11170" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a> <a id="11176" class="Symbol">(</a><a id="11177" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="11185" href="WellFormed.Properties.html#11098" class="Bound">r</a> <a id="11187" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a><a id="11192" class="Symbol">)</a> <a id="11194" href="Relation.Binary.Reasoning.Syntax.html#5482" class="Function">⟩</a>
  <a id="11198" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="11202" href="WellFormed.Properties.html#11094" class="Bound">f</a>               <a id="11218" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="11221" href="WellFormed.Properties.html#11098" class="Bound">r</a> <a id="11223" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="11227" href="WellFormed.Properties.html#8934" class="Function">ω</a>                   <a id="11247" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="11249" class="Keyword">where</a> <a id="11255" class="Keyword">open</a> <a id="11260" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
</pre>
<p><strong>定理 2-1-31</strong> <span class="math inline">ℕ</span> 与小于 <span class="math inline">\omega</span> 的序数同构.<br />
<strong>证明</strong> <span class="math inline">\text{fin}</span> 提供了正映射, 引理 2-1-30 提供了逆映射. 结合引理 2-1-29 可以说明它们互逆. ∎</p>
<pre class="Agda"><a id="ℕ≡ω"></a><a id="11401" href="WellFormed.Properties.html#11401" class="Function">ℕ≡ω</a> <a id="11405" class="Symbol">:</a> <a id="11407" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="11409" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11411" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11413" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="11417" class="Symbol">(</a><a id="11418" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;</a> <a id="11421" href="WellFormed.Properties.html#8934" class="Function">ω</a><a id="11422" class="Symbol">)</a>
<a id="11424" href="WellFormed.Properties.html#11401" class="Function">ℕ≡ω</a> <a id="11428" class="Symbol">=</a> <a id="11430" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="11439" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11441" href="Cubical.Foundations.Isomorphism.html#3223" class="Function">isoToPath</a> <a id="11451" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11453" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a>
  <a id="11459" class="Symbol">(λ</a> <a id="11462" href="WellFormed.Properties.html#11462" class="Bound">n</a> <a id="11464" class="Symbol">→</a> <a id="11466" href="WellFormed.Properties.html#2743" class="Function">fin</a> <a id="11470" href="WellFormed.Properties.html#11462" class="Bound">n</a> <a id="11472" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11474" href="WellFormed.Properties.html#9124" class="Function">n&lt;ω</a><a id="11477" class="Symbol">)</a>
  <a id="11481" class="Symbol">(λ</a> <a id="11484" class="Symbol">(</a><a id="11485" href="WellFormed.Properties.html#11485" class="Bound">a</a> <a id="11487" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11489" href="WellFormed.Properties.html#11489" class="Bound">a&lt;ω</a><a id="11492" class="Symbol">)</a> <a id="11494" class="Symbol">→</a> <a id="11496" href="Cubical.Data.Equality.Base.html#384" class="Field">fst</a> <a id="11500" class="Symbol">(</a><a id="11501" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11509" href="WellFormed.Properties.html#11489" class="Bound">a&lt;ω</a><a id="11512" class="Symbol">))</a>
  <a id="11517" class="Symbol">(λ</a> <a id="11520" href="WellFormed.Properties.html#11520" class="Bound">a</a> <a id="11522" class="Symbol">→</a> <a id="11524" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="11531" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11533" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11542" class="Symbol">(</a><a id="11543" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11547" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11549" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11557" class="Symbol">_)</a> <a id="11560" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11562" href="Cubical.Foundations.Prelude.html#13282" class="Function">toPathP</a> <a id="11570" class="Symbol">(</a><a id="11571" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="11579" class="Symbol">_</a> <a id="11581" class="Symbol">_))</a>
  <a id="11587" class="Symbol">(λ</a> <a id="11590" href="WellFormed.Properties.html#11590" class="Bound">n</a> <a id="11592" class="Symbol">→</a> <a id="11594" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="11603" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11605" href="WellFormed.Properties.html#10567" class="Function">fin-inj</a> <a id="11613" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11615" href="Cubical.Data.Equality.Base.html#396" class="Field">snd</a> <a id="11619" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="11621" href="WellFormed.Properties.html#10925" class="Function">fin-suj</a> <a id="11629" class="Symbol">_)</a>
  <a id="11634" class="Keyword">where</a> <a id="11640" class="Keyword">open</a> <a id="11645" class="Keyword">import</a> <a id="11652" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
