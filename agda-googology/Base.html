<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.0 - 序数, 增长层级, 不动点)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.0 - 序数, 增长层级, 不动点)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.0---序数-增长层级-不动点" id="toc-形式化大数数学-1.0---序数-增长层级-不动点">形式化大数数学 (1.0 - 序数, 增长层级, 不动点)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#目标人群" id="toc-目标人群">目标人群</a></li>
  <li><a href="#补充材料" id="toc-补充材料">补充材料</a></li>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a></li>
  <li><a href="#增长层级" id="toc-增长层级">增长层级</a>
  <ul>
  <li><a href="#快速" id="toc-快速">快速</a></li>
  <li><a href="#快速以下" id="toc-快速以下">※快速以下</a></li>
  </ul></li>
  <li><a href="#序数的递归原理" id="toc-序数的递归原理">序数的递归原理</a></li>
  <li><a href="#超限复合" id="toc-超限复合">超限复合</a></li>
  <li><a href="#序数算术" id="toc-序数算术">序数算术</a></li>
  <li><a href="#三大高阶函数" id="toc-三大高阶函数">三大高阶函数</a>
  <ul>
  <li><a href="#无穷迭代" id="toc-无穷迭代">无穷迭代</a></li>
  <li><a href="#跳出运算" id="toc-跳出运算">跳出运算</a></li>
  <li><a href="#不动点的枚举" id="toc-不动点的枚举">不动点的枚举</a></li>
  </ul></li>
  <li><a href="#ε-ζ-η-层级" id="toc-ε-ζ-η-层级">ε， ζ， η 层级</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.0---序数-增长层级-不动点">形式化大数数学 (1.0 - 序数, 增长层级, 不动点)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Base.lagda.md">Base.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Base.html">Base.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是可运行且保证停机的<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0_(%E6%95%B0%E5%AD%A6)">大数</a>计算程序的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文学编程 (literate programming)</a> 实现.</p>
<ul>
<li><strong>可运行</strong>是相对于自然语言的数学描述而言, 本文贴出的代码可以在电脑上运行.</li>
<li><strong>保证停机</strong>是相对于<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备 (Turing-complete)</a> 语言 (如C语言) 而言, 本文使用的 <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a> 语言并非图灵完备, 其自带<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/termination-checking.html">停机检查 (termination checking)</a>, 写出的程序保证停机.</li>
<li><strong>文学编程</strong>是指本文既是程序代码, 也是程序文档, 代码和文档交织在一起, 以增强可读性.
<ul>
<li>Agda 程序会自动抽取本文所有代码块中的代码, 并执行类型检查, 而忽略代码块以外的内容.</li>
<li>※ 冷知识: 文学编程的发明者<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳 (Donald Knuth)</a>, 也是大数数学入门级内容<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%B4%8D%E7%AE%AD%E8%99%9F%E8%A1%A8%E7%A4%BA%E6%B3%95">高德纳箭号</a>的发明者, 也是排版软件 <a href="https://zh.wikipedia.org/wiki/TeX">TeX</a> 的发明者.</li>
</ul></li>
</ul>
<p>也就是说, 提供足够的时间, 能量和内存, 本文介绍的大数计算程序可以真正算出一个大数. 如果真的想运行: 1. 参考 <a href="https://agda.readthedocs.io/en/latest/getting-started/installation.html">Installation</a> 安装 Agda. 2. 进本文所在Github仓库 (<a href="https://github.com/choukh/agda-googology">agda-googology</a>) 下载本文 markdown 源码. 3. 用编辑器打开源码, 确认进入了 <a href="https://agda.readthedocs.io/en/latest/tools/emacs-mode.html">agda-mode</a>, 键入 <code>C-c C-n</code> 对本文定义的任意大数 (如文末的 <code>oom</code>) 执行正规化 (normalization).</p>
<h3 id="目标人群">目标人群</h3>
<ul>
<li>大数数学已入门 (如, 看完<a href="https://www.zhihu.com/column/c_1307845959598960640">大数数学入门</a>), 对严格性和精确定义有进一步要求的读者.</li>
<li>Agda 已入门 (如, 看完 <a href="https://agda-zh.github.io/PLFA-zh/">PLFA</a>), 对大数计算程序的编程实现感兴趣的读者.</li>
</ul>
<p>只对前者感兴趣的读者, 可以忽略代码部分, 而只阅读文学部分, 它们可以看作是基于朴素类型论的数学描述, 并使用了 <span class="math inline">\LaTeX</span> 公式, 以对齐通常的数学习惯.</p>
<h3 id="补充材料">补充材料</h3>
<ul>
<li><a href="https://www.zhihu.com/column/c_1307845959598960640">core.exe - 大数数学入门</a></li>
<li><a href="https://www.zhihu.com/column/c_1697290814588301312">core.exe - 大数数学入门 - 重置版</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">oCaU - Agda大序数</a>
<ul>
<li>该文详细讨论了上至二元Veblen层级的序性质, 而本文不会讨论这些性质.</li>
</ul></li>
<li><a href="https://github.com/choukh/Googology">oCaU - LVO 的 Coq 实现</a>
<ul>
<li>纯代码, 无文学</li>
</ul></li>
</ul>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="2358" class="Symbol">{-#</a> <a id="2362" class="Keyword">OPTIONS</a> <a id="2370" class="Pragma">--safe</a> <a id="2377" class="Symbol">#-}</a>
<a id="2381" class="Keyword">module</a> <a id="2388" href="Base.html" class="Module">Base</a> <a id="2393" class="Keyword">where</a>

<a id="2400" class="Keyword">open</a> <a id="2405" class="Keyword">import</a> <a id="2412" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2421" class="Keyword">public</a> <a id="2428" class="Keyword">using</a> <a id="2434" class="Symbol">(</a><a id="2435" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2436" class="Symbol">;</a> <a id="2438" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2442" class="Symbol">;</a> <a id="2444" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2447" class="Symbol">;</a> <a id="2449" href="Data.Nat.Base.html#1095" class="InductiveConstructor">2+</a><a id="2451" class="Symbol">)</a>
<a id="2453" class="Keyword">open</a> <a id="2458" class="Keyword">import</a> <a id="2465" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="2475" class="Keyword">public</a> <a id="2482" class="Keyword">using</a> <a id="2488" class="Symbol">(</a><a id="2489" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2490" class="Symbol">;</a> <a id="2492" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="2494" class="Symbol">)</a>
<a id="2496" class="Keyword">open</a> <a id="2501" class="Keyword">import</a> <a id="2508" href="Function.html" class="Module">Function</a> <a id="2517" class="Keyword">public</a> <a id="2524" class="Keyword">using</a> <a id="2530" class="Symbol">(</a><a id="2531" href="Function.Base.html#704" class="Function">id</a><a id="2533" class="Symbol">;</a> <a id="2535" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="2538" class="Symbol">;</a> <a id="2540" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="2543" class="Symbol">;</a> <a id="2545" href="Function.Base.html#4486" class="Function Operator">_∋_</a><a id="2548" class="Symbol">)</a>
<a id="2550" class="Keyword">open</a> <a id="2555" class="Keyword">import</a> <a id="2562" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2600" class="Symbol">as</a> <a id="2603" class="Module">Eq</a> <a id="2606" class="Keyword">public</a>
  <a id="2615" class="Keyword">using</a> <a id="2621" class="Symbol">(</a><a id="2622" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2625" class="Symbol">;</a> <a id="2627" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2631" class="Symbol">;</a> <a id="2633" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a><a id="2637" class="Symbol">;</a> <a id="2639" href="Relation.Binary.PropositionalEquality.Core.html#1489" class="Function">cong-app</a><a id="2647" class="Symbol">)</a>
<a id="2649" class="Keyword">open</a> <a id="2654" href="Relation.Binary.PropositionalEquality.Properties.html#6744" class="Module">Eq.≡-Reasoning</a> <a id="2669" class="Keyword">public</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<p>我们知道自然数类型 <span class="math inline">ℕ</span> 由如下两条规则定义.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : ℕ\kern{0.17em}}
\qquad
\frac{\alpha:ℕ}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:ℕ\kern{0.17em}}
</span></p>
<p><strong>定义</strong> 我们的序数类型 <span class="math inline">\text{Ord}</span> 在 <span class="math inline">ℕ</span> 的基础上增加了第三条规则 <span class="math inline">\text{lim}</span>, 即如果 <span class="math inline">f</span> 是 <span class="math inline">ℕ</span> 到序数的函数, 那么 <span class="math inline">\text{lim}\kern{0.17em}f</span> 也是序数.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : \text{Ord}\kern{0.17em}}
\qquad
\frac{\alpha:\text{Ord}}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:\text{Ord}\kern{0.17em}}
\qquad
\frac{\kern{0.17em}f : ℕ\rightarrow\text{Ord}\kern{0.17em}}{\text{lim}\kern{0.17em}f:\text{Ord}}
</span></p>
<pre class="Agda"><a id="3256" class="Keyword">data</a> <a id="Ord"></a><a id="3261" href="Base.html#3261" class="Datatype">Ord</a> <a id="3265" class="Symbol">:</a> <a id="3267" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3271" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="3279" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="3284" class="Symbol">:</a> <a id="3286" href="Base.html#3261" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="3292" href="Base.html#3292" class="InductiveConstructor">suc</a>  <a id="3297" class="Symbol">:</a> <a id="3299" href="Base.html#3261" class="Datatype">Ord</a> <a id="3303" class="Symbol">→</a> <a id="3305" href="Base.html#3261" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="3311" href="Base.html#3311" class="InductiveConstructor">lim</a>  <a id="3316" class="Symbol">:</a> <a id="3318" class="Symbol">(</a><a id="3319" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3321" class="Symbol">→</a> <a id="3323" href="Base.html#3261" class="Datatype">Ord</a><a id="3326" class="Symbol">)</a> <a id="3328" class="Symbol">→</a> <a id="3330" href="Base.html#3261" class="Datatype">Ord</a>
</pre>
<p>这样的 <span class="math inline">f : ℕ\rightarrow\text{Ord}</span> 又叫做 <span class="math inline">\text{lim}\kern{0.17em}f</span> 的基本列 (fundamental sequence), 而 <span class="math inline">\text{lim}\kern{0.17em}f</span> 则叫做基本列 <span class="math inline">f</span> 的极限. 仅就我们将要做的事情而言, <span class="math inline">\lim</span> 可视为等同于集合论的 <span class="math inline">\sup</span>. 这样的定义允许我们很方便地讨论零, 后继序数和极限序数三种情况. 为了方便阅读, 我们会把 <span class="math inline">\text{zero}</span> 写作 <span class="math inline">0</span>, 把 <span class="math inline">\text{suc}\kern{0.17em}x</span> 写作 <span class="math inline">x^+</span>.</p>
<p><strong>注意</strong> 我们的序数类型, 学名叫布劳威尔树序数 (Brouwer tree ordinals), 比真正的递归序数宽泛很多, 体现在以下两点:</p>
<ul>
<li>树序数不要求基本列是严格递增的.
<ul>
<li>严格递增的约束对于计算本身而言无关紧要.</li>
<li>当然, 如果要保证算出的大数足够大, 那么基本列的递增性是必要的.</li>
<li>我们构造的序数的基本列都是严格递增的, 如果想要, 可以额外补上证明.</li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">Agda大序数</a>一文中证明了其中构造的上至 <span class="math inline">\Gamma_0</span> 的所有树序数的基本列都是严格递增的.</li>
</ul></li>
<li>树序数是高度外延的 (extensional), 即一个真正的递归序数可能对应树上大量的节点.
<ul>
<li>也就是说我们可以用大量不同的基本列构造出相同的序数.
<ul>
<li>但同一性证明依赖于函数外延性 (functional extensionality), 或某种商 (quotient) 机制, 如 setoid 或 cubical.</li>
</ul></li>
<li>但这并不影响大数的计算, 因为只要给出基本列就能算, 况且 FGH 大数的具体数值确实可能是依赖于特定基本列的——同一序数的不同定义方式会使基本列在起始处稍有不同.</li>
</ul></li>
</ul>
<p><strong>约定</strong> 我们用 <span class="math inline">α,β,γ</span> 表示序数, 用 <span class="math inline">n</span> 表示自然数.</p>
<pre class="Agda"><a id="4226" class="Keyword">variable</a>
  <a id="4237" href="Base.html#4237" class="Generalizable">α</a> <a id="4239" href="Base.html#4239" class="Generalizable">β</a> <a id="4241" href="Base.html#4241" class="Generalizable">γ</a> <a id="4243" class="Symbol">:</a> <a id="4245" href="Base.html#3261" class="Datatype">Ord</a>
  <a id="4251" href="Base.html#4251" class="Generalizable">n</a> <a id="4253" class="Symbol">:</a> <a id="4255" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<p><strong>约定</strong> 我们遵循类型论的习惯, 今后都会在无歧义的情况下省略函数应用的括号.</p>
<p><strong>定义</strong> 自然数到序数的嵌入函数 <span class="math inline">\text{finord} : ℕ → \text{Ord}</span> 如下</p>
<p><span class="math display">
\begin{aligned}
\text{finord}\kern{0.17em}0 &amp;= 0 \\
\text{finord}\kern{0.17em}n^+ &amp;= (\text{finord}\kern{0.17em}n)^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="finord"></a><a id="4507" href="Base.html#4507" class="Function">finord</a> <a id="4514" class="Symbol">:</a> <a id="4516" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4518" class="Symbol">→</a> <a id="4520" href="Base.html#3261" class="Datatype">Ord</a>
<a id="4524" href="Base.html#4507" class="Function">finord</a> <a id="4531" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="4536" class="Symbol">=</a> <a id="4538" href="Base.html#3279" class="InductiveConstructor">zero</a>
<a id="4543" href="Base.html#4507" class="Function">finord</a> <a id="4550" class="Symbol">(</a><a id="4551" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4555" href="Base.html#4555" class="Bound">n</a><a id="4556" class="Symbol">)</a> <a id="4558" class="Symbol">=</a> <a id="4560" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="4564" class="Symbol">(</a><a id="4565" href="Base.html#4507" class="Function">finord</a> <a id="4572" href="Base.html#4555" class="Bound">n</a><a id="4573" class="Symbol">)</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\text{finord}</span> 构成了基本列 <span class="math inline">(0, 1, 2, \ldots)</span>, 其极限定义为 <span class="math inline">ω</span></p>
<p><span class="math display">
ω := \text{lim}\kern{0.17em}\text{finord}
</span></p>
<pre class="Agda"><a id="ω"></a><a id="4700" href="Base.html#4700" class="Function">ω</a> <a id="4702" class="Symbol">=</a> <a id="4704" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="4708" href="Base.html#4507" class="Function">finord</a>
</pre>
<p><strong>非文学</strong> 以下代码调用了<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能, 允许数字字面量依据上下文自动具有自然数或序数类型.</p>
<pre class="Agda"><a id="4859" class="Keyword">open</a> <a id="4864" class="Keyword">import</a> <a id="4871" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="4892" class="Keyword">public</a>
<a id="4899" class="Keyword">instance</a>
  <a id="nOrd"></a><a id="4910" href="Base.html#4910" class="Function">nOrd</a> <a id="4915" class="Symbol">=</a> <a id="4917" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4924" href="Base.html#3261" class="Datatype">Ord</a> <a id="4928" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4930" class="Keyword">record</a> <a id="4937" class="Symbol">{</a> <a id="4939" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4950" class="Symbol">=</a> <a id="4952" class="Symbol">λ</a> <a id="4954" href="Base.html#4954" class="Bound">_</a> <a id="4956" class="Symbol">→</a> <a id="4958" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4960" class="Symbol">;</a> <a id="4962" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4970" class="Symbol">=</a> <a id="4972" class="Symbol">λ</a> <a id="4974" href="Base.html#4974" class="Bound">n</a> <a id="4976" class="Symbol">→</a> <a id="4978" href="Base.html#4507" class="Function">finord</a> <a id="4985" href="Base.html#4974" class="Bound">n</a> <a id="4987" class="Symbol">}</a>
  <a id="nNat"></a><a id="4991" href="Base.html#4991" class="Function">nNat</a> <a id="4996" class="Symbol">=</a> <a id="4998" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="5005" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="5009" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5011" class="Keyword">record</a> <a id="5018" class="Symbol">{</a> <a id="5020" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="5031" class="Symbol">=</a> <a id="5033" class="Symbol">λ</a> <a id="5035" href="Base.html#5035" class="Bound">_</a> <a id="5037" class="Symbol">→</a> <a id="5039" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="5041" class="Symbol">;</a> <a id="5043" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="5051" class="Symbol">=</a> <a id="5053" class="Symbol">λ</a> <a id="5055" href="Base.html#5055" class="Bound">n</a> <a id="5057" class="Symbol">→</a> <a id="5059" href="Base.html#5055" class="Bound">n</a> <a id="5061" class="Symbol">}</a>
</pre>
<p>以下为测试用例.</p>
<pre class="Agda"><a id="5086" href="Base.html#5086" class="Function">_</a> <a id="5088" class="Symbol">=</a> <a id="5090" href="Base.html#3261" class="Datatype">Ord</a> <a id="5094" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5096" class="Number">233</a>
<a id="5100" href="Base.html#5100" class="Function">_</a> <a id="5102" class="Symbol">=</a> <a id="5104" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="5108" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5110" class="Number">233</a>
</pre>
<p><strong>非文学</strong> 我们将 <code>suc (suc α)</code> 写作 <code>2+ α</code>.</p>
<pre class="Agda"><a id="5165" class="Keyword">pattern</a> <a id="2+"></a><a id="5173" href="Base.html#5173" class="InductiveConstructor">2+</a> <a id="5176" href="Base.html#5189" class="Bound">α</a> <a id="5178" class="Symbol">=</a> <a id="5180" class="InductiveConstructor">suc</a> <a id="5184" class="Symbol">(</a><a id="5185" class="InductiveConstructor">suc</a> <a id="5189" href="Base.html#5189" class="Bound">α</a><a id="5190" class="Symbol">)</a>
</pre>
<h2 id="增长层级">增长层级</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">A</span> 表示类型.</p>
<pre class="Agda"><a id="5236" class="Keyword">variable</a> <a id="5245" href="Base.html#5245" class="Generalizable">A</a> <a id="5247" class="Symbol">:</a> <a id="5249" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义</strong> 函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span></p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{n^+} &amp;= F \circ F^n
\end{aligned}
</span></p>
<p>其中 <span class="math inline">\text{id}</span> 是恒等函数.</p>
<pre class="Agda"><a id="_∘ⁿ_"></a><a id="5408" href="Base.html#5408" class="Function Operator">_∘ⁿ_</a> <a id="5413" class="Symbol">:</a> <a id="5415" class="Symbol">(</a><a id="5416" href="Base.html#5245" class="Generalizable">A</a> <a id="5418" class="Symbol">→</a> <a id="5420" href="Base.html#5245" class="Generalizable">A</a><a id="5421" class="Symbol">)</a> <a id="5423" class="Symbol">→</a> <a id="5425" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5427" class="Symbol">→</a> <a id="5429" class="Symbol">(</a><a id="5430" href="Base.html#5245" class="Generalizable">A</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Base.html#5245" class="Generalizable">A</a><a id="5435" class="Symbol">)</a>
<a id="5437" href="Base.html#5437" class="Bound">F</a> <a id="5439" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="5442" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="5448" class="Symbol">=</a> <a id="5450" href="Function.Base.html#704" class="Function">id</a>
<a id="5453" href="Base.html#5453" class="Bound">F</a> <a id="5455" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="5458" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5462" href="Base.html#5462" class="Bound">n</a> <a id="5464" class="Symbol">=</a> <a id="5466" class="Symbol">(</a><a id="5467" href="Base.html#5453" class="Bound">F</a> <a id="5469" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5471" class="Symbol">(</a><a id="5472" href="Base.html#5453" class="Bound">F</a> <a id="5474" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="5477" href="Base.html#5462" class="Bound">n</a><a id="5478" class="Symbol">))</a>
</pre>
<h3 id="快速">快速</h3>
<p><strong>定义</strong> 快速增长层级 (Fast Growing Hierarchy, FGH) 是一个函数族 <span class="math inline">f : \text{Ord} → ℕ → ℕ</span>, 对于每个序数 <span class="math inline">α</span>, <span class="math inline">f_α</span> 是一个从自然数到自然数的函数, 定义如下.</p>
<p><span class="math display">
\begin{aligned}
f_0 &amp;= \text{suc} \\
f_{α^+}\kern{0.17em}n &amp;= f_α^n\kern{0.17em}n \\
f_{\text{lim}\kern{0.17em}α}\kern{0.17em}n &amp;= f_{α[n]}\kern{0.17em}n
\end{aligned}
</span></p>
<p>其中在极限序数情况下的这种处理方式叫做对角化 (diagonalization).</p>
<pre class="Agda"><a id="5838" class="Keyword">module</a> <a id="FGH"></a><a id="5845" href="Base.html#5845" class="Module">FGH</a> <a id="5849" class="Keyword">where</a>
  <a id="FGH.f"></a><a id="5857" href="Base.html#5857" class="Function">f</a> <a id="5859" class="Symbol">:</a> <a id="5861" href="Base.html#3261" class="Datatype">Ord</a> <a id="5865" class="Symbol">→</a> <a id="5867" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5869" class="Symbol">→</a> <a id="5871" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="5875" href="Base.html#5857" class="Function">f</a> <a id="5877" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="5882" class="Symbol">=</a> <a id="5884" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>
  <a id="5890" href="Base.html#5857" class="Function">f</a> <a id="5892" class="Symbol">(</a><a id="5893" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="5897" href="Base.html#5897" class="Bound">α</a><a id="5898" class="Symbol">)</a> <a id="5900" href="Base.html#5900" class="Bound">n</a> <a id="5902" class="Symbol">=</a> <a id="5904" class="Symbol">(</a><a id="5905" href="Base.html#5857" class="Function">f</a> <a id="5907" href="Base.html#5897" class="Bound">α</a> <a id="5909" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="5912" href="Base.html#5900" class="Bound">n</a><a id="5913" class="Symbol">)</a> <a id="5915" href="Base.html#5900" class="Bound">n</a>
  <a id="5919" href="Base.html#5857" class="Function">f</a> <a id="5921" class="Symbol">(</a><a id="5922" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="5926" href="Base.html#5926" class="Bound">α</a><a id="5927" class="Symbol">)</a> <a id="5929" href="Base.html#5929" class="Bound">n</a> <a id="5931" class="Symbol">=</a> <a id="5933" href="Base.html#5857" class="Function">f</a> <a id="5935" class="Symbol">(</a><a id="5936" href="Base.html#5926" class="Bound">α</a> <a id="5938" href="Base.html#5929" class="Bound">n</a><a id="5939" class="Symbol">)</a> <a id="5941" href="Base.html#5929" class="Bound">n</a>
</pre>
<p><strong>例</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_0\kern{0.17em}n &amp;= n^+ \\
f_1\kern{0.17em}n &amp;= 2n \\
f_2\kern{0.17em}n &amp;= 2^n\kern{0.17em}n
\end{aligned}
</span></p>
<p>这些等式的证明只需对 <span class="math inline">n</span> 进行归纳, 是显然的. 代码方面我们只写一些实例作为测试.</p>
<pre class="Agda">  <a id="FGH.f-0-2"></a><a id="6146" href="Base.html#6146" class="Function">f-0-2</a> <a id="6152" class="Symbol">:</a> <a id="6154" href="Base.html#5857" class="Function">f</a> <a id="6156" class="Number">0</a> <a id="6158" class="Number">2</a> <a id="6160" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6162" class="Number">3</a>
  <a id="6166" href="Base.html#6146" class="Function">f-0-2</a> <a id="6172" class="Symbol">=</a> <a id="6174" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-1-2"></a><a id="6182" href="Base.html#6182" class="Function">f-1-2</a> <a id="6188" class="Symbol">:</a> <a id="6190" href="Base.html#5857" class="Function">f</a> <a id="6192" class="Number">1</a> <a id="6194" class="Number">2</a> <a id="6196" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6198" class="Number">4</a>
  <a id="6202" href="Base.html#6182" class="Function">f-1-2</a> <a id="6208" class="Symbol">=</a> <a id="6210" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-2-2"></a><a id="6218" href="Base.html#6218" class="Function">f-2-2</a> <a id="6224" class="Symbol">:</a> <a id="6226" href="Base.html#5857" class="Function">f</a> <a id="6228" class="Number">2</a> <a id="6230" class="Number">2</a> <a id="6232" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6234" class="Number">8</a>
  <a id="6238" href="Base.html#6218" class="Function">f-2-2</a> <a id="6244" class="Symbol">=</a> <a id="6246" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math inline">f_3</span> 以上的表达式越来越复杂, 但不难计算实例如 <span class="math inline">f_{3}\kern{0.17em}2=2048</span>.</p>
<pre class="Agda">  <a id="FGH.f-3-2"></a><a id="6323" href="Base.html#6323" class="Function">f-3-2</a> <a id="6329" class="Symbol">:</a> <a id="6331" href="Base.html#5857" class="Function">f</a> <a id="6333" class="Number">3</a> <a id="6335" class="Number">2</a> <a id="6337" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6339" class="Number">2048</a>
  <a id="6346" href="Base.html#6323" class="Function">f-3-2</a> <a id="6352" class="Symbol">=</a> <a id="6354" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>引理</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_{\alpha^+}\kern{0.17em}n &amp;= f_\alpha^n\kern{0.17em}n \\
f_{ω}\kern{0.17em}n &amp;= f_{n}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda">  <a id="FGH.f-suc"></a><a id="6524" href="Base.html#6524" class="Function">f-suc</a> <a id="6530" class="Symbol">:</a> <a id="6532" href="Base.html#5857" class="Function">f</a> <a id="6534" class="Symbol">(</a><a id="6535" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="6539" href="Base.html#4237" class="Generalizable">α</a><a id="6540" class="Symbol">)</a> <a id="6542" href="Base.html#4251" class="Generalizable">n</a> <a id="6544" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6546" class="Symbol">(</a><a id="6547" href="Base.html#5857" class="Function">f</a> <a id="6549" href="Base.html#4237" class="Generalizable">α</a> <a id="6551" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="6554" href="Base.html#4251" class="Generalizable">n</a><a id="6555" class="Symbol">)</a> <a id="6557" href="Base.html#4251" class="Generalizable">n</a>
  <a id="6561" href="Base.html#6524" class="Function">f-suc</a> <a id="6567" class="Symbol">=</a> <a id="6569" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-ω"></a><a id="6577" href="Base.html#6577" class="Function">f-ω</a> <a id="6581" class="Symbol">:</a> <a id="6583" href="Base.html#5857" class="Function">f</a> <a id="6585" href="Base.html#4700" class="Function">ω</a> <a id="6587" href="Base.html#4251" class="Generalizable">n</a> <a id="6589" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6591" href="Base.html#5857" class="Function">f</a> <a id="6593" class="Symbol">(</a><a id="6594" href="Base.html#4507" class="Function">finord</a> <a id="6601" href="Base.html#4251" class="Generalizable">n</a><a id="6602" class="Symbol">)</a> <a id="6604" href="Base.html#4251" class="Generalizable">n</a>
  <a id="6608" href="Base.html#6577" class="Function">f-ω</a> <a id="6612" class="Symbol">=</a> <a id="6614" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 本文出现的大部分命题的证明都是「依定义即得」的, 体现为代码中的 <code>refl</code>. 也就是说, 证明都是直接展开定义, 不需要额外的推理. 但这并不意味着所有证明是显然的, 有时候递归定义的展开会非常复杂, 这时候我们会分步展开, 逐步化简, 但每一步都 <code>refl</code> 可证.</p>
<p><strong>定理</strong> 由以上两式不难看出</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}n = f_ω^n\kern{0.17em}n
</span></p>
<pre class="Agda">  <a id="FGH.f-ω⁺"></a><a id="6849" href="Base.html#6849" class="Function">f-ω⁺</a> <a id="6854" class="Symbol">:</a> <a id="6856" href="Base.html#5857" class="Function">f</a> <a id="6858" class="Symbol">(</a><a id="6859" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="6863" href="Base.html#4700" class="Function">ω</a><a id="6864" class="Symbol">)</a> <a id="6866" href="Base.html#4251" class="Generalizable">n</a> <a id="6868" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6870" class="Symbol">(</a><a id="6871" href="Base.html#5857" class="Function">f</a> <a id="6873" href="Base.html#4700" class="Function">ω</a> <a id="6875" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="6878" href="Base.html#4251" class="Generalizable">n</a><a id="6879" class="Symbol">)</a> <a id="6881" href="Base.html#4251" class="Generalizable">n</a>
  <a id="6885" href="Base.html#6849" class="Function">f-ω⁺</a> <a id="6890" class="Symbol">=</a> <a id="6892" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>推论</strong> 特别地, 有</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}2 = f_ω\kern{0.17em}(f_ω\kern{0.17em}2)
</span></p>
<p>但此式无法在 Agda 中直接证明, 因为 Agda 想先把两边都算出再比较相等, 而这是不现实的. 如果有读者知道如何证明, 请打在评论区. 作为替代, 我们可以证明如下式子.</p>
<p><span class="math display">
f_{\alpha^+}\kern{0.17em}2 = f_\alpha\kern{0.17em}(f_\alpha\kern{0.17em}2)
</span></p>
<pre class="Agda">  <a id="FGH.f-suc-2"></a><a id="7167" href="Base.html#7167" class="Function">f-suc-2</a> <a id="7175" class="Symbol">:</a> <a id="7177" href="Base.html#5857" class="Function">f</a> <a id="7179" class="Symbol">(</a><a id="7180" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="7184" href="Base.html#4237" class="Generalizable">α</a><a id="7185" class="Symbol">)</a> <a id="7187" class="Number">2</a> <a id="7189" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7191" href="Base.html#5857" class="Function">f</a> <a id="7193" href="Base.html#4237" class="Generalizable">α</a> <a id="7195" class="Symbol">(</a><a id="7196" href="Base.html#5857" class="Function">f</a> <a id="7198" href="Base.html#4237" class="Generalizable">α</a> <a id="7200" class="Number">2</a><a id="7201" class="Symbol">)</a>
  <a id="7205" href="Base.html#7167" class="Function">f-suc-2</a> <a id="7213" class="Symbol">=</a> <a id="7215" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实</strong> <span class="math inline">f_{ω^+} 64</span> 已经大于葛立恒数.</p>
<blockquote>
<p>从这里开始, 研究大数的数学就转变成了研究快速增长函数的数学, 进而转变成研究大的序数的数学.</p>
</blockquote>
<h3 id="快速以下">※快速以下</h3>
<p>FGH 是最常用的增长层级, 除此之外, 其他常见的还有 SGH, MGH, HH. 它们的共同特征是遇到极限序数都要做对角化.</p>
<p><strong>定义</strong> 慢速增长层级 SGH</p>
<p><span class="math display">
\begin{aligned}
g_0\kern{0.17em}n &amp;= 0 \\
g_{α^+}\kern{0.17em}n &amp;= (g_α\kern{0.17em}n)^+ \\
g_{\text{lim}\kern{0.17em}α}\kern{0.17em}n &amp;= g_{α[n]}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda"><a id="7593" class="Keyword">module</a> <a id="SGH"></a><a id="7600" href="Base.html#7600" class="Module">SGH</a> <a id="7604" class="Keyword">where</a>
  <a id="SGH.g"></a><a id="7612" href="Base.html#7612" class="Function">g</a> <a id="7614" class="Symbol">:</a> <a id="7616" href="Base.html#3261" class="Datatype">Ord</a> <a id="7620" class="Symbol">→</a> <a id="7622" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7624" class="Symbol">→</a> <a id="7626" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="7630" href="Base.html#7612" class="Function">g</a> <a id="7632" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="7637" class="Symbol">_</a> <a id="7639" class="Symbol">=</a> <a id="7641" class="Number">0</a>
  <a id="7645" href="Base.html#7612" class="Function">g</a> <a id="7647" class="Symbol">(</a><a id="7648" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="7652" href="Base.html#7652" class="Bound">α</a><a id="7653" class="Symbol">)</a> <a id="7655" href="Base.html#7655" class="Bound">n</a> <a id="7657" class="Symbol">=</a> <a id="7659" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7663" class="Symbol">(</a><a id="7664" href="Base.html#7612" class="Function">g</a> <a id="7666" href="Base.html#7652" class="Bound">α</a> <a id="7668" href="Base.html#7655" class="Bound">n</a><a id="7669" class="Symbol">)</a>
  <a id="7673" href="Base.html#7612" class="Function">g</a> <a id="7675" class="Symbol">(</a><a id="7676" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="7680" href="Base.html#7680" class="Bound">α</a><a id="7681" class="Symbol">)</a> <a id="7683" href="Base.html#7683" class="Bound">n</a> <a id="7685" class="Symbol">=</a> <a id="7687" href="Base.html#7612" class="Function">g</a> <a id="7689" class="Symbol">(</a><a id="7690" href="Base.html#7680" class="Bound">α</a> <a id="7692" href="Base.html#7683" class="Bound">n</a><a id="7693" class="Symbol">)</a> <a id="7695" href="Base.html#7683" class="Bound">n</a>
</pre>
<p><strong>定义</strong> 中速增长层级 MGH</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= \text{suc} \\
m_{α^+} &amp;= m_α^2 \\
m_{\text{lim}\kern{0.17em}α}\kern{0.17em}n &amp;= m_{α[n]}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda"><a id="7876" class="Keyword">module</a> <a id="MGH"></a><a id="7883" href="Base.html#7883" class="Module">MGH</a> <a id="7887" class="Keyword">where</a>
  <a id="MGH.m"></a><a id="7895" href="Base.html#7895" class="Function">m</a> <a id="7897" class="Symbol">:</a> <a id="7899" href="Base.html#3261" class="Datatype">Ord</a> <a id="7903" class="Symbol">→</a> <a id="7905" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7907" class="Symbol">→</a> <a id="7909" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="7913" href="Base.html#7895" class="Function">m</a> <a id="7915" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="7920" class="Symbol">=</a> <a id="7922" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>
  <a id="7928" href="Base.html#7895" class="Function">m</a> <a id="7930" class="Symbol">(</a><a id="7931" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="7935" href="Base.html#7935" class="Bound">α</a><a id="7936" class="Symbol">)</a> <a id="7938" class="Symbol">=</a> <a id="7940" href="Base.html#7895" class="Function">m</a> <a id="7942" href="Base.html#7935" class="Bound">α</a> <a id="7944" href="Base.html#5408" class="Function Operator">∘ⁿ</a> <a id="7947" class="Number">2</a>
  <a id="7951" href="Base.html#7895" class="Function">m</a> <a id="7953" class="Symbol">(</a><a id="7954" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="7958" href="Base.html#7958" class="Bound">α</a><a id="7959" class="Symbol">)</a> <a id="7961" href="Base.html#7961" class="Bound">n</a> <a id="7963" class="Symbol">=</a> <a id="7965" href="Base.html#7895" class="Function">m</a> <a id="7967" class="Symbol">(</a><a id="7968" href="Base.html#7958" class="Bound">α</a> <a id="7970" href="Base.html#7961" class="Bound">n</a><a id="7971" class="Symbol">)</a> <a id="7973" href="Base.html#7961" class="Bound">n</a>
</pre>
<p><strong>定义</strong> Hardy层级 HH, 介于中速和慢速之间</p>
<p><span class="math display">
\begin{aligned}
h_0 &amp;= \text{id} \\
h_{α^+}\kern{0.17em}n &amp;= h_α\kern{0.17em}(n^+) \\
h_{\text{lim}\kern{0.17em}α}\kern{0.17em}n &amp;= h_{α[n]}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda"><a id="8194" class="Keyword">module</a> <a id="HH"></a><a id="8201" href="Base.html#8201" class="Module">HH</a> <a id="8204" class="Keyword">where</a>
  <a id="HH.h"></a><a id="8212" href="Base.html#8212" class="Function">h</a> <a id="8214" class="Symbol">:</a> <a id="8216" href="Base.html#3261" class="Datatype">Ord</a> <a id="8220" class="Symbol">→</a> <a id="8222" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8224" class="Symbol">→</a> <a id="8226" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="8230" href="Base.html#8212" class="Function">h</a> <a id="8232" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="8237" class="Symbol">=</a> <a id="8239" href="Function.Base.html#704" class="Function">id</a>
  <a id="8244" href="Base.html#8212" class="Function">h</a> <a id="8246" class="Symbol">(</a><a id="8247" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="8251" href="Base.html#8251" class="Bound">α</a><a id="8252" class="Symbol">)</a> <a id="8254" href="Base.html#8254" class="Bound">n</a> <a id="8256" class="Symbol">=</a> <a id="8258" href="Base.html#8212" class="Function">h</a> <a id="8260" href="Base.html#8251" class="Bound">α</a> <a id="8262" class="Symbol">(</a><a id="8263" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8267" href="Base.html#8254" class="Bound">n</a><a id="8268" class="Symbol">)</a>
  <a id="8272" href="Base.html#8212" class="Function">h</a> <a id="8274" class="Symbol">(</a><a id="8275" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="8279" href="Base.html#8279" class="Bound">α</a><a id="8280" class="Symbol">)</a> <a id="8282" href="Base.html#8282" class="Bound">n</a> <a id="8284" class="Symbol">=</a> <a id="8286" href="Base.html#8212" class="Function">h</a> <a id="8288" class="Symbol">(</a><a id="8289" href="Base.html#8279" class="Bound">α</a> <a id="8291" href="Base.html#8282" class="Bound">n</a><a id="8292" class="Symbol">)</a> <a id="8294" href="Base.html#8282" class="Bound">n</a>
</pre>
<h2 id="序数的递归原理">序数的递归原理</h2>
<p>为了系统性的构造大序数, 我们先证明序数归纳法, 并由此得到序数的递归原理.</p>
<p><strong>定理 序数归纳法 (transfinite induction)</strong> 对于任意性质 <span class="math inline">P : \text{Ord} → \text{Set}</span>, 如果</p>
<ol type="1">
<li><span class="math inline">P\kern{0.17em}0</span> 成立,</li>
<li>对于任意序数 <span class="math inline">α</span>, 如果 <span class="math inline">P\kern{0.17em}α</span> 成立, 则 <span class="math inline">P\kern{0.17em}α^+</span> 成立,</li>
<li>对于任意基本列 <span class="math inline">f</span>, 如果对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立, 则 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立,</li>
</ol>
<p>则对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立.</p>
<pre class="Agda"><a id="ind"></a><a id="8686" href="Base.html#8686" class="Function">ind</a> <a id="8690" class="Symbol">:</a> <a id="8692" class="Symbol">{</a><a id="8693" href="Base.html#8693" class="Bound">P</a> <a id="8695" class="Symbol">:</a> <a id="8697" href="Base.html#3261" class="Datatype">Ord</a> <a id="8701" class="Symbol">→</a> <a id="8703" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="8706" class="Symbol">}</a>
  <a id="8710" class="Symbol">→</a> <a id="8712" href="Base.html#8693" class="Bound">P</a> <a id="8714" class="InductiveConstructor">zero</a>
  <a id="8721" class="Symbol">→</a> <a id="8723" class="Symbol">(∀</a> <a id="8726" href="Base.html#8726" class="Bound">α</a> <a id="8728" class="Symbol">→</a> <a id="8730" href="Base.html#8693" class="Bound">P</a> <a id="8732" href="Base.html#8726" class="Bound">α</a> <a id="8734" class="Symbol">→</a> <a id="8736" href="Base.html#8693" class="Bound">P</a> <a id="8738" class="Symbol">(</a><a id="8739" class="InductiveConstructor">suc</a> <a id="8743" href="Base.html#8726" class="Bound">α</a><a id="8744" class="Symbol">))</a>
  <a id="8749" class="Symbol">→</a> <a id="8751" class="Symbol">(∀</a> <a id="8754" href="Base.html#8754" class="Bound">f</a> <a id="8756" class="Symbol">→</a> <a id="8758" class="Symbol">(∀</a> <a id="8761" href="Base.html#8761" class="Bound">n</a> <a id="8763" class="Symbol">→</a> <a id="8765" href="Base.html#8693" class="Bound">P</a> <a id="8767" class="Symbol">(</a><a id="8768" href="Base.html#8754" class="Bound">f</a> <a id="8770" href="Base.html#8761" class="Bound">n</a><a id="8771" class="Symbol">))</a> <a id="8774" class="Symbol">→</a> <a id="8776" href="Base.html#8693" class="Bound">P</a> <a id="8778" class="Symbol">(</a><a id="8779" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="8783" href="Base.html#8754" class="Bound">f</a><a id="8784" class="Symbol">))</a>
  <a id="8789" class="Symbol">→</a> <a id="8791" class="Symbol">∀</a> <a id="8793" href="Base.html#8793" class="Bound">α</a> <a id="8795" class="Symbol">→</a> <a id="8797" href="Base.html#8693" class="Bound">P</a> <a id="8799" href="Base.html#8793" class="Bound">α</a>
</pre>
<p><strong>(证明)</strong> 要证对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立. 归纳 <span class="math inline">α</span> 的三种情况.</p>
<ul>
<li>当 <span class="math inline">α=0</span> 时, 由条件1, <span class="math inline">P\kern{0.17em}0</span> 成立.</li>
<li>当 <span class="math inline">α=α^+</span> 时, 要证 <span class="math inline">P\,α^+</span> 成立. 由归纳假设, <span class="math inline">P\kern{0.17em}α</span> 成立. 由条件2, <span class="math inline">P\kern{0.17em}α^+</span> 成立.</li>
<li>当 <span class="math inline">α=\text{lim}\kern{0.17em}f</span> 时, 要证 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. 由归纳假设, 对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立. 由条件3, <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. ∎</li>
</ul>
<pre class="Agda"><a id="9205" href="Base.html#8686" class="Function">ind</a> <a id="9209" href="Base.html#9209" class="Bound">z</a> <a id="9211" href="Base.html#9211" class="Bound">s</a> <a id="9213" href="Base.html#9213" class="Bound">l</a> <a id="9215" href="Base.html#3279" class="InductiveConstructor">zero</a> <a id="9220" class="Symbol">=</a> <a id="9222" href="Base.html#9209" class="Bound">z</a>
<a id="9224" href="Base.html#8686" class="Function">ind</a> <a id="9228" href="Base.html#9228" class="Bound">z</a> <a id="9230" href="Base.html#9230" class="Bound">s</a> <a id="9232" href="Base.html#9232" class="Bound">l</a> <a id="9234" class="Symbol">(</a><a id="9235" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="9239" href="Base.html#9239" class="Bound">α</a><a id="9240" class="Symbol">)</a> <a id="9242" class="Symbol">=</a> <a id="9244" href="Base.html#9230" class="Bound">s</a> <a id="9246" href="Base.html#9239" class="Bound">α</a> <a id="9248" class="Symbol">(</a><a id="9249" href="Base.html#8686" class="Function">ind</a> <a id="9253" href="Base.html#9228" class="Bound">z</a> <a id="9255" href="Base.html#9230" class="Bound">s</a> <a id="9257" href="Base.html#9232" class="Bound">l</a> <a id="9259" href="Base.html#9239" class="Bound">α</a><a id="9260" class="Symbol">)</a>
<a id="9262" href="Base.html#8686" class="Function">ind</a> <a id="9266" href="Base.html#9266" class="Bound">z</a> <a id="9268" href="Base.html#9268" class="Bound">s</a> <a id="9270" href="Base.html#9270" class="Bound">l</a> <a id="9272" class="Symbol">(</a><a id="9273" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="9277" href="Base.html#9277" class="Bound">f</a><a id="9278" class="Symbol">)</a> <a id="9280" class="Symbol">=</a> <a id="9282" href="Base.html#9270" class="Bound">l</a> <a id="9284" href="Base.html#9277" class="Bound">f</a> <a id="9286" class="Symbol">λ</a> <a id="9288" href="Base.html#9288" class="Bound">n</a> <a id="9290" class="Symbol">→</a> <a id="9292" href="Base.html#8686" class="Function">ind</a> <a id="9296" href="Base.html#9266" class="Bound">z</a> <a id="9298" href="Base.html#9268" class="Bound">s</a> <a id="9300" href="Base.html#9270" class="Bound">l</a> <a id="9302" class="Symbol">(</a><a id="9303" href="Base.html#9277" class="Bound">f</a> <a id="9305" href="Base.html#9288" class="Bound">n</a><a id="9306" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 这里看起来像是循环论证, 我们实际做的事情是从类型论承诺的规则中抽取出对 <span class="math inline">\text{Ord}</span> 单独适用的部分, 并固化为了一个高阶函数 <span class="math inline">\text{ind}</span>.</p>
<p><strong>定理 序数的递归原理 (transfinite recursion)</strong> 对于任意类型 <span class="math inline">A</span>, 函数 <span class="math inline">z : A</span>, <span class="math inline">s : A → A</span>, <span class="math inline">l : (ℕ → A) → A</span>, 和任意序数 <span class="math inline">α</span>, 存在唯一的 <span class="math inline">\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α : A</span>, 满足</p>
<p><span class="math display">
\begin{aligned}
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}0 &amp;= z \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α^+ &amp;= s\kern{0.17em}(\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α) \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= l\kern{0.17em}(λ\kern{0.17em}n,\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(f\kern{0.17em}n))
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 令 <span class="math inline">P = λ\kern{0.17em}\_,A</span> 并应用序数归纳法即可. ∎</p>
<pre class="Agda"><a id="rec"></a><a id="10135" href="Base.html#10135" class="Function">rec</a> <a id="10139" class="Symbol">:</a> <a id="10141" href="Base.html#5245" class="Generalizable">A</a> <a id="10143" class="Symbol">→</a> <a id="10145" class="Symbol">(</a><a id="10146" href="Base.html#5245" class="Generalizable">A</a> <a id="10148" class="Symbol">→</a> <a id="10150" href="Base.html#5245" class="Generalizable">A</a><a id="10151" class="Symbol">)</a> <a id="10153" class="Symbol">→</a> <a id="10155" class="Symbol">((</a><a id="10157" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10159" class="Symbol">→</a> <a id="10161" href="Base.html#5245" class="Generalizable">A</a><a id="10162" class="Symbol">)</a> <a id="10164" class="Symbol">→</a> <a id="10166" href="Base.html#5245" class="Generalizable">A</a><a id="10167" class="Symbol">)</a> <a id="10169" class="Symbol">→</a> <a id="10171" href="Base.html#3261" class="Datatype">Ord</a> <a id="10175" class="Symbol">→</a> <a id="10177" href="Base.html#5245" class="Generalizable">A</a>
<a id="10179" href="Base.html#10135" class="Function">rec</a> <a id="10183" href="Base.html#10183" class="Bound">z</a> <a id="10185" href="Base.html#10185" class="Bound">s</a> <a id="10187" href="Base.html#10187" class="Bound">l</a> <a id="10189" class="Symbol">=</a> <a id="10191" href="Base.html#8686" class="Function">ind</a> <a id="10195" href="Base.html#10183" class="Bound">z</a> <a id="10197" class="Symbol">(λ</a> <a id="10200" href="Base.html#10200" class="Bound">_</a> <a id="10202" class="Symbol">→</a> <a id="10204" href="Base.html#10185" class="Bound">s</a><a id="10205" class="Symbol">)</a> <a id="10207" class="Symbol">(λ</a> <a id="10210" href="Base.html#10210" class="Bound">_</a> <a id="10212" class="Symbol">→</a> <a id="10214" href="Base.html#10187" class="Bound">l</a><a id="10215" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 序数的递归原理和序数归纳法都可视作高阶函数, 递归原理是归纳法的特例.</p>
<p><strong>注意</strong> 序数的递归原理相当强大, 因为 <span class="math inline">A</span> 可以是任意类型, 包括函数类型 <span class="math inline">\text{Ord}\rightarrow\text{Ord}</span> 与 <span class="math inline">(\text{Ord}\rightarrow\text{Ord})\rightarrow(\text{Ord}\rightarrow\text{Ord})</span> 等, 也就是说它允许定义高阶函数的递归. 本文出现的所有大序数都由 <span class="math inline">\text{rec}</span> 定义.</p>
<h2 id="超限复合">超限复合</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">F</span> 表示序数函数 <span class="math inline">\text{Ord} → \text{Ord}</span>, 用 <span class="math inline">f,g,h</span> 表示基本列 <span class="math inline">ℕ → \text{Ord}</span>.</p>
<pre class="Agda"><a id="10578" class="Keyword">variable</a>
  <a id="10589" href="Base.html#10589" class="Generalizable">F</a> <a id="10591" class="Symbol">:</a> <a id="10593" href="Base.html#3261" class="Datatype">Ord</a> <a id="10597" class="Symbol">→</a> <a id="10599" href="Base.html#3261" class="Datatype">Ord</a>
  <a id="10605" href="Base.html#10605" class="Generalizable">f</a> <a id="10607" href="Base.html#10607" class="Generalizable">g</a> <a id="10609" href="Base.html#10609" class="Generalizable">h</a> <a id="10611" class="Symbol">:</a> <a id="10613" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10615" class="Symbol">→</a> <a id="10617" href="Base.html#3261" class="Datatype">Ord</a>
</pre>
<p><strong>定义</strong> 仿照函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span>, 我们定义序数函数 <span class="math inline">F : \text{Ord} → \text{Ord}</span> 的 <span class="math inline">α</span> 次复合 <span class="math inline">F^α</span>, 但使用序数的递归原理 <span class="math inline">\text{rec}</span> 来定义.</p>
<p><span class="math display">
F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}\text{lim}\kern{0.17em}\alpha
</span></p>
<pre class="Agda"><a id="_∘^_"></a><a id="10880" href="Base.html#10880" class="Function Operator">_∘^_</a> <a id="10885" class="Symbol">:</a> <a id="10887" class="Symbol">(</a><a id="10888" href="Base.html#3261" class="Datatype">Ord</a> <a id="10892" class="Symbol">→</a> <a id="10894" href="Base.html#3261" class="Datatype">Ord</a><a id="10897" class="Symbol">)</a> <a id="10899" class="Symbol">→</a> <a id="10901" href="Base.html#3261" class="Datatype">Ord</a> <a id="10905" class="Symbol">→</a> <a id="10907" href="Base.html#3261" class="Datatype">Ord</a> <a id="10911" class="Symbol">→</a> <a id="10913" href="Base.html#3261" class="Datatype">Ord</a>
<a id="10917" class="Symbol">(</a><a id="10918" href="Base.html#10918" class="Bound">F</a> <a id="10920" href="Base.html#10880" class="Function Operator">∘^</a> <a id="10923" href="Base.html#10923" class="Bound">α</a><a id="10924" class="Symbol">)</a> <a id="10926" href="Base.html#10926" class="Bound">β</a> <a id="10928" class="Symbol">=</a> <a id="10930" href="Base.html#10135" class="Function">rec</a> <a id="10934" href="Base.html#10926" class="Bound">β</a> <a id="10936" href="Base.html#10918" class="Bound">F</a> <a id="10938" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="10942" href="Base.html#10923" class="Bound">α</a>
</pre>
<p><strong>注意</strong> 该定义不是 <span class="math inline">F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}\alpha)</span>, 此式有类型错误.</p>
<p>对于 <span class="math inline">\text{rec}</span> 的四个参数, 直观上</p>
<ul>
<li>第一个参数是初始值, 这里是 <span class="math inline">F^\alpha</span> 的输入 <span class="math inline">\beta</span>,</li>
<li>第二个参数是后继步骤, 需要指定递归迭代的函数, 这里递归迭代的就是 <span class="math inline">F</span>,</li>
<li>第三个参数是极限步骤, 需要指定将极限步对应的步骤基本列 <span class="math inline">λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta</span> 映射到序数的函数, 这里就是单纯地取其极限, 所以指定为 <span class="math inline">\text{lim}</span>,</li>
<li>第四个参数是递归的次数, 这里是 <span class="math inline">\alpha</span>.</li>
</ul>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{α^+} &amp;= F \circ F^α \\
F^{\text{lim}\kern{0.17em}f} &amp;= λ\kern{0.17em}\beta,\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta
\end{aligned}
</span></p>
<pre class="Agda"><a id="∘^-zero"></a><a id="11645" href="Base.html#11645" class="Function">∘^-zero</a> <a id="11653" class="Symbol">:</a> <a id="11655" href="Base.html#10589" class="Generalizable">F</a> <a id="11657" href="Base.html#10880" class="Function Operator">∘^</a> <a id="11660" class="InductiveConstructor">zero</a> <a id="11665" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11667" href="Function.Base.html#704" class="Function">id</a>
<a id="11670" href="Base.html#11645" class="Function">∘^-zero</a> <a id="11678" class="Symbol">=</a> <a id="11680" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-suc"></a><a id="11686" href="Base.html#11686" class="Function">∘^-suc</a> <a id="11693" class="Symbol">:</a> <a id="11695" href="Base.html#10589" class="Generalizable">F</a> <a id="11697" href="Base.html#10880" class="Function Operator">∘^</a> <a id="11700" class="InductiveConstructor">suc</a> <a id="11704" href="Base.html#4237" class="Generalizable">α</a> <a id="11706" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11708" href="Base.html#10589" class="Generalizable">F</a> <a id="11710" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="11712" class="Symbol">(</a><a id="11713" href="Base.html#10589" class="Generalizable">F</a> <a id="11715" href="Base.html#10880" class="Function Operator">∘^</a> <a id="11718" href="Base.html#4237" class="Generalizable">α</a><a id="11719" class="Symbol">)</a>
<a id="11721" href="Base.html#11686" class="Function">∘^-suc</a> <a id="11728" class="Symbol">=</a> <a id="11730" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-lim"></a><a id="11736" href="Base.html#11736" class="Function">∘^-lim</a> <a id="11743" class="Symbol">:</a> <a id="11745" href="Base.html#10589" class="Generalizable">F</a> <a id="11747" href="Base.html#10880" class="Function Operator">∘^</a> <a id="11750" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="11754" href="Base.html#10605" class="Generalizable">f</a> <a id="11756" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11758" class="Symbol">λ</a> <a id="11760" href="Base.html#11760" class="Bound">β</a> <a id="11762" class="Symbol">→</a> <a id="11764" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="11768" class="Symbol">λ</a> <a id="11770" href="Base.html#11770" class="Bound">n</a> <a id="11772" class="Symbol">→</a> <a id="11774" class="Symbol">(</a><a id="11775" href="Base.html#10589" class="Generalizable">F</a> <a id="11777" href="Base.html#10880" class="Function Operator">∘^</a> <a id="11780" class="Symbol">(</a><a id="11781" href="Base.html#10605" class="Generalizable">f</a> <a id="11783" href="Base.html#11770" class="Bound">n</a><a id="11784" class="Symbol">))</a> <a id="11787" href="Base.html#11760" class="Bound">β</a>
<a id="11789" href="Base.html#11736" class="Function">∘^-lim</a> <a id="11796" class="Symbol">=</a> <a id="11798" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> <span class="math inline">λ\kern{0.17em}\beta,\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta</span> 不能简化成 <span class="math inline">\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}</span>, 此式有类型错误.</p>
<h2 id="序数算术">序数算术</h2>
<p><strong>定义</strong> 从 <span class="math inline">α</span> 开始做 <span class="math inline">β</span> 次后继叫做序数加法, 记作 <span class="math inline">α+β</span>.</p>
<pre class="Agda"><a id="12104" class="Keyword">infixl</a> <a id="12111" class="Number">6</a> <a id="12113" href="Base.html#12117" class="Function Operator">_+_</a>
<a id="_+_"></a><a id="12117" href="Base.html#12117" class="Function Operator">_+_</a> <a id="12121" class="Symbol">:</a> <a id="12123" href="Base.html#3261" class="Datatype">Ord</a> <a id="12127" class="Symbol">→</a> <a id="12129" href="Base.html#3261" class="Datatype">Ord</a> <a id="12133" class="Symbol">→</a> <a id="12135" href="Base.html#3261" class="Datatype">Ord</a>
<a id="12139" href="Base.html#12139" class="Bound">α</a> <a id="12141" href="Base.html#12117" class="Function Operator">+</a> <a id="12143" href="Base.html#12143" class="Bound">β</a> <a id="12145" class="Symbol">=</a> <a id="12147" class="Symbol">(</a><a id="12148" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="12152" href="Base.html#10880" class="Function Operator">∘^</a> <a id="12155" href="Base.html#12143" class="Bound">β</a><a id="12156" class="Symbol">)</a> <a id="12158" href="Base.html#12139" class="Bound">α</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">0</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">+ α</span> 叫做序数乘法, 记作 <span class="math inline">α*β</span>.</p>
<pre class="Agda"><a id="12221" class="Keyword">infixl</a> <a id="12228" class="Number">7</a> <a id="12230" href="Base.html#12234" class="Function Operator">_*_</a>
<a id="_*_"></a><a id="12234" href="Base.html#12234" class="Function Operator">_*_</a> <a id="12238" class="Symbol">:</a> <a id="12240" href="Base.html#3261" class="Datatype">Ord</a> <a id="12244" class="Symbol">→</a> <a id="12246" href="Base.html#3261" class="Datatype">Ord</a> <a id="12250" class="Symbol">→</a> <a id="12252" href="Base.html#3261" class="Datatype">Ord</a>
<a id="12256" href="Base.html#12256" class="Bound">α</a> <a id="12258" href="Base.html#12234" class="Function Operator">*</a> <a id="12260" href="Base.html#12260" class="Bound">β</a> <a id="12262" class="Symbol">=</a> <a id="12264" class="Symbol">((</a><a id="12266" href="Base.html#12117" class="Function Operator">_+</a> <a id="12269" href="Base.html#12256" class="Bound">α</a><a id="12270" class="Symbol">)</a> <a id="12272" href="Base.html#10880" class="Function Operator">∘^</a> <a id="12275" href="Base.html#12260" class="Bound">β</a><a id="12276" class="Symbol">)</a> <a id="12278" class="Number">0</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">1</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">* α</span> 叫做序数幂, 记作 <span class="math inline">α^β</span>.</p>
<pre class="Agda"><a id="12340" class="Keyword">infix</a> <a id="12346" class="Number">8</a> <a id="12348" href="Base.html#12352" class="Function Operator">_^_</a>
<a id="_^_"></a><a id="12352" href="Base.html#12352" class="Function Operator">_^_</a> <a id="12356" class="Symbol">:</a> <a id="12358" href="Base.html#3261" class="Datatype">Ord</a> <a id="12362" class="Symbol">→</a> <a id="12364" href="Base.html#3261" class="Datatype">Ord</a> <a id="12368" class="Symbol">→</a> <a id="12370" href="Base.html#3261" class="Datatype">Ord</a>
<a id="12374" href="Base.html#12374" class="Bound">α</a> <a id="12376" href="Base.html#12352" class="Function Operator">^</a> <a id="12378" href="Base.html#12378" class="Bound">β</a> <a id="12380" class="Symbol">=</a> <a id="12382" class="Symbol">((</a><a id="12384" href="Base.html#12234" class="Function Operator">_*</a> <a id="12387" href="Base.html#12374" class="Bound">α</a><a id="12388" class="Symbol">)</a> <a id="12390" href="Base.html#10880" class="Function Operator">∘^</a> <a id="12393" href="Base.html#12378" class="Bound">β</a><a id="12394" class="Symbol">)</a> <a id="12396" class="Number">1</a>
</pre>
<p>关于为什么不能定义序数的第四级运算的原因可以参看<a href="https://zhuanlan.zhihu.com/p/580526275">Agda大序数(6) 迭代幂次</a>.</p>
<h2 id="三大高阶函数">三大高阶函数</h2>
<p>Veblen层级的构造需要三个重要的高阶函数</p>
<ol type="1">
<li>无穷迭代 <span class="math inline">λF,F^\omega</span></li>
<li>跳出运算 <span class="math inline">\text{jump}</span></li>
<li>不动点的枚举 <span class="math inline">\text{fixpt}</span></li>
</ol>
<p>它们都具有类型 <span class="math inline">(\text{Ord}→\text{Ord})→(\text{Ord}→\text{Ord})</span>.</p>
<h3 id="无穷迭代">无穷迭代</h3>
<p><strong>定义</strong> 我们称 <span class="math inline">F</span> 的 <span class="math inline">\omega</span> 次复合 <span class="math inline">F^\omega</span> 为 <span class="math inline">F</span> 的无穷迭代.</p>
<pre class="Agda"><a id="iterω"></a><a id="12725" href="Base.html#12725" class="Function">iterω</a> <a id="12731" class="Symbol">:</a> <a id="12733" class="Symbol">(</a><a id="12734" href="Base.html#3261" class="Datatype">Ord</a> <a id="12738" class="Symbol">→</a> <a id="12740" href="Base.html#3261" class="Datatype">Ord</a><a id="12743" class="Symbol">)</a> <a id="12745" class="Symbol">→</a> <a id="12747" href="Base.html#3261" class="Datatype">Ord</a> <a id="12751" class="Symbol">→</a> <a id="12753" href="Base.html#3261" class="Datatype">Ord</a>
<a id="12757" href="Base.html#12725" class="Function">iterω</a> <a id="12763" href="Base.html#12763" class="Bound">F</a> <a id="12765" class="Symbol">=</a> <a id="12767" href="Base.html#12763" class="Bound">F</a> <a id="12769" href="Base.html#10880" class="Function Operator">∘^</a> <a id="12772" href="Base.html#4700" class="Function">ω</a>
</pre>
<h3 id="跳出运算">跳出运算</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span>, 起始值 <span class="math inline">ι</span> 和迭代次数 <span class="math inline">α</span>, 从 <span class="math inline">F\kern{0.17em}ι</span> 开始, 每次迭代时先做一次后继再迭代 <span class="math inline">F</span>, 总共迭代 <span class="math inline">α</span> 次的运算叫做 <span class="math inline">F</span> 的从 <span class="math inline">ι</span> 开始的 <span class="math inline">α</span> 次跳出, 记作 <span class="math inline">\text{jump}_ι\kern{0.17em}F\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{jump}_ι\kern{0.17em}F\kern{0.17em}α := (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}ι)
</span></p>
<pre class="Agda"><a id="jump⟨_⟩"></a><a id="13110" href="Base.html#13110" class="Function Operator">jump⟨_⟩</a> <a id="13118" class="Symbol">:</a> <a id="13120" href="Base.html#3261" class="Datatype">Ord</a> <a id="13124" class="Symbol">→</a> <a id="13126" class="Symbol">(</a><a id="13127" href="Base.html#3261" class="Datatype">Ord</a> <a id="13131" class="Symbol">→</a> <a id="13133" href="Base.html#3261" class="Datatype">Ord</a><a id="13136" class="Symbol">)</a> <a id="13138" class="Symbol">→</a> <a id="13140" href="Base.html#3261" class="Datatype">Ord</a> <a id="13144" class="Symbol">→</a> <a id="13146" href="Base.html#3261" class="Datatype">Ord</a>
<a id="13150" href="Base.html#13110" class="Function Operator">jump⟨</a> <a id="13156" href="Base.html#13156" class="Bound">ι</a> <a id="13158" href="Base.html#13110" class="Function Operator">⟩</a> <a id="13160" href="Base.html#13160" class="Bound">F</a> <a id="13162" href="Base.html#13162" class="Bound">α</a> <a id="13164" class="Symbol">=</a> <a id="13166" class="Symbol">((</a><a id="13168" href="Base.html#13160" class="Bound">F</a> <a id="13170" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="13172" href="Base.html#3292" class="InductiveConstructor">suc</a><a id="13175" class="Symbol">)</a> <a id="13177" href="Base.html#10880" class="Function Operator">∘^</a> <a id="13180" href="Base.html#13162" class="Bound">α</a><a id="13181" class="Symbol">)</a> <a id="13183" class="Symbol">(</a><a id="13184" href="Base.html#13160" class="Bound">F</a> <a id="13186" href="Base.html#13156" class="Bound">ι</a><a id="13187" class="Symbol">)</a>
</pre>
<p>我们通常只会使用 <span class="math inline">ι = 0</span> 的版本 <span class="math inline">\text{jump}_0\kern{0.17em}F\kern{0.17em}α</span>, 简记作 <span class="math inline">\text{jump}\kern{0.17em}F\kern{0.17em}α</span>.</p>
<pre class="Agda"><a id="jump"></a><a id="13316" href="Base.html#13316" class="Function">jump</a> <a id="13321" class="Symbol">:</a> <a id="13323" class="Symbol">(</a><a id="13324" href="Base.html#3261" class="Datatype">Ord</a> <a id="13328" class="Symbol">→</a> <a id="13330" href="Base.html#3261" class="Datatype">Ord</a><a id="13333" class="Symbol">)</a> <a id="13335" class="Symbol">→</a> <a id="13337" href="Base.html#3261" class="Datatype">Ord</a> <a id="13341" class="Symbol">→</a> <a id="13343" href="Base.html#3261" class="Datatype">Ord</a>
<a id="13347" href="Base.html#13316" class="Function">jump</a> <a id="13352" href="Base.html#13352" class="Bound">F</a> <a id="13354" class="Symbol">=</a> <a id="13356" href="Base.html#13110" class="Function Operator">jump⟨</a> <a id="13362" class="Number">0</a> <a id="13364" href="Base.html#13110" class="Function Operator">⟩</a> <a id="13366" href="Base.html#13352" class="Bound">F</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}0 &amp;= F\kern{0.17em}0 \\
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{jump}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{jump}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 零和极限的情况是显然的. 对于后继的情况, 有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^{α^+}\kern{0.17em}(F\kern{0.17em}0) \\
&amp;= (F\kern{0.17em}\circ\kern{0.17em}\text{suc})((F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}0)) \\
&amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+
\end{aligned}
</span></p>
<p>∎</p>
<pre class="Agda"><a id="jump-0"></a><a id="14211" href="Base.html#14211" class="Function">jump-0</a> <a id="14218" class="Symbol">:</a> <a id="14220" href="Base.html#13316" class="Function">jump</a> <a id="14225" href="Base.html#10589" class="Generalizable">F</a> <a id="14227" class="Number">0</a> <a id="14229" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14231" href="Base.html#10589" class="Generalizable">F</a> <a id="14233" class="Number">0</a>
<a id="14235" href="Base.html#14211" class="Function">jump-0</a> <a id="14242" class="Symbol">=</a> <a id="14244" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="jump-suc"></a><a id="14250" href="Base.html#14250" class="Function">jump-suc</a> <a id="14259" class="Symbol">:</a> <a id="14261" href="Base.html#13316" class="Function">jump</a> <a id="14266" href="Base.html#10589" class="Generalizable">F</a> <a id="14268" class="Symbol">(</a><a id="14269" class="InductiveConstructor">suc</a> <a id="14273" href="Base.html#4237" class="Generalizable">α</a><a id="14274" class="Symbol">)</a> <a id="14276" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14278" href="Base.html#10589" class="Generalizable">F</a> <a id="14280" class="Symbol">(</a><a id="14281" class="InductiveConstructor">suc</a> <a id="14285" class="Symbol">(</a><a id="14286" href="Base.html#13316" class="Function">jump</a> <a id="14291" href="Base.html#10589" class="Generalizable">F</a> <a id="14293" href="Base.html#4237" class="Generalizable">α</a><a id="14294" class="Symbol">))</a>
<a id="14297" href="Base.html#14250" class="Function">jump-suc</a> <a id="14306" class="Symbol">{</a><a id="14307" href="Base.html#14307" class="Bound">F</a><a id="14308" class="Symbol">}</a> <a id="14310" class="Symbol">{</a><a id="14311" href="Base.html#14311" class="Bound">α</a><a id="14312" class="Symbol">}</a> <a id="14314" class="Symbol">=</a> <a id="14316" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="14324" href="Base.html#13316" class="Function">jump</a> <a id="14329" href="Base.html#14307" class="Bound">F</a> <a id="14331" class="Symbol">(</a><a id="14332" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="14336" href="Base.html#14311" class="Bound">α</a><a id="14337" class="Symbol">)</a>                        <a id="14362" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="14368" class="Symbol">((</a><a id="14370" href="Base.html#14307" class="Bound">F</a> <a id="14372" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="14374" href="Base.html#3292" class="InductiveConstructor">suc</a><a id="14377" class="Symbol">)</a> <a id="14379" href="Base.html#10880" class="Function Operator">∘^</a> <a id="14382" class="Symbol">(</a><a id="14383" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="14387" href="Base.html#14311" class="Bound">α</a><a id="14388" class="Symbol">))</a> <a id="14391" class="Symbol">(</a><a id="14392" href="Base.html#14307" class="Bound">F</a> <a id="14394" href="Base.html#3279" class="InductiveConstructor">zero</a><a id="14398" class="Symbol">)</a>       <a id="14406" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="14412" class="Symbol">(</a><a id="14413" href="Base.html#14307" class="Bound">F</a> <a id="14415" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="14417" href="Base.html#3292" class="InductiveConstructor">suc</a><a id="14420" class="Symbol">)</a> <a id="14422" class="Symbol">(((</a><a id="14425" href="Base.html#14307" class="Bound">F</a> <a id="14427" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="14429" href="Base.html#3292" class="InductiveConstructor">suc</a><a id="14432" class="Symbol">)</a> <a id="14434" href="Base.html#10880" class="Function Operator">∘^</a> <a id="14437" href="Base.html#14311" class="Bound">α</a><a id="14438" class="Symbol">)</a> <a id="14440" class="Symbol">(</a><a id="14441" href="Base.html#14307" class="Bound">F</a> <a id="14443" href="Base.html#3279" class="InductiveConstructor">zero</a><a id="14447" class="Symbol">))</a> <a id="14450" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="14456" href="Base.html#14307" class="Bound">F</a> <a id="14458" class="Symbol">(</a><a id="14459" href="Base.html#3292" class="InductiveConstructor">suc</a> <a id="14463" class="Symbol">(</a><a id="14464" href="Base.html#13316" class="Function">jump</a> <a id="14469" href="Base.html#14307" class="Bound">F</a> <a id="14471" href="Base.html#14311" class="Bound">α</a><a id="14472" class="Symbol">))</a>                    <a id="14494" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>

<a id="jump-lim"></a><a id="14497" href="Base.html#14497" class="Function">jump-lim</a> <a id="14506" class="Symbol">:</a> <a id="14508" href="Base.html#13316" class="Function">jump</a> <a id="14513" href="Base.html#10589" class="Generalizable">F</a> <a id="14515" class="Symbol">(</a><a id="14516" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="14520" href="Base.html#10605" class="Generalizable">f</a><a id="14521" class="Symbol">)</a> <a id="14523" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14525" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="14529" class="Symbol">λ</a> <a id="14531" href="Base.html#14531" class="Bound">n</a> <a id="14533" class="Symbol">→</a> <a id="14535" href="Base.html#13316" class="Function">jump</a> <a id="14540" href="Base.html#10589" class="Generalizable">F</a> <a id="14542" class="Symbol">(</a><a id="14543" href="Base.html#10605" class="Generalizable">f</a> <a id="14545" href="Base.html#14531" class="Bound">n</a><a id="14546" class="Symbol">)</a>
<a id="14548" href="Base.html#14497" class="Function">jump-lim</a> <a id="14557" class="Symbol">=</a> <a id="14559" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="不动点的枚举">不动点的枚举</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span>, 我们定义 <span class="math inline">F</span> 的第 <span class="math inline">α</span> 个不动点 <span class="math inline">\text{fixpt}\kern{0.17em}F\kern{0.17em}α</span> 为 <span class="math inline">F^\omega</span> 的第 <span class="math inline">α</span> 个跳出 <span class="math inline">\text{jump}\kern{0.17em}(F^\omega)\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{fixpt}\kern{0.17em}F := \text{jump}\kern{0.17em}(F^\omega)
</span></p>
<pre class="Agda"><a id="fixpt"></a><a id="14821" href="Base.html#14821" class="Function">fixpt</a> <a id="14827" class="Symbol">:</a> <a id="14829" class="Symbol">(</a><a id="14830" href="Base.html#3261" class="Datatype">Ord</a> <a id="14834" class="Symbol">→</a> <a id="14836" href="Base.html#3261" class="Datatype">Ord</a><a id="14839" class="Symbol">)</a> <a id="14841" class="Symbol">→</a> <a id="14843" href="Base.html#3261" class="Datatype">Ord</a> <a id="14847" class="Symbol">→</a> <a id="14849" href="Base.html#3261" class="Datatype">Ord</a>
<a id="14853" href="Base.html#14821" class="Function">fixpt</a> <a id="14859" href="Base.html#14859" class="Bound">F</a> <a id="14861" class="Symbol">=</a> <a id="14863" href="Base.html#13316" class="Function">jump</a> <a id="14868" class="Symbol">(</a><a id="14869" href="Base.html#12725" class="Function">iterω</a> <a id="14875" href="Base.html#14859" class="Bound">F</a><a id="14876" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{fixpt}\kern{0.17em}F\kern{0.17em}0 &amp;= F^\omega\kern{0.17em}0 \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F^\omega\kern{0.17em}(\text{fixpt}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{fixpt}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<pre class="Agda"><a id="fixpt-0"></a><a id="15319" href="Base.html#15319" class="Function">fixpt-0</a> <a id="15327" class="Symbol">:</a> <a id="15329" href="Base.html#14821" class="Function">fixpt</a> <a id="15335" href="Base.html#10589" class="Generalizable">F</a> <a id="15337" class="Number">0</a> <a id="15339" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15341" href="Base.html#12725" class="Function">iterω</a> <a id="15347" href="Base.html#10589" class="Generalizable">F</a> <a id="15349" class="Number">0</a>
<a id="15351" href="Base.html#15319" class="Function">fixpt-0</a> <a id="15359" class="Symbol">=</a> <a id="15361" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-suc"></a><a id="15367" href="Base.html#15367" class="Function">fixpt-suc</a> <a id="15377" class="Symbol">:</a> <a id="15379" href="Base.html#14821" class="Function">fixpt</a> <a id="15385" href="Base.html#10589" class="Generalizable">F</a> <a id="15387" class="Symbol">(</a><a id="15388" class="InductiveConstructor">suc</a> <a id="15392" href="Base.html#4237" class="Generalizable">α</a><a id="15393" class="Symbol">)</a> <a id="15395" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15397" href="Base.html#12725" class="Function">iterω</a> <a id="15403" href="Base.html#10589" class="Generalizable">F</a> <a id="15405" class="Symbol">(</a><a id="15406" class="InductiveConstructor">suc</a> <a id="15410" class="Symbol">(</a><a id="15411" href="Base.html#14821" class="Function">fixpt</a> <a id="15417" href="Base.html#10589" class="Generalizable">F</a> <a id="15419" href="Base.html#4237" class="Generalizable">α</a><a id="15420" class="Symbol">))</a>
<a id="15423" href="Base.html#15367" class="Function">fixpt-suc</a> <a id="15433" class="Symbol">{</a><a id="15434" href="Base.html#15434" class="Bound">F</a><a id="15435" class="Symbol">}</a> <a id="15437" class="Symbol">{</a><a id="15438" href="Base.html#15438" class="Bound">α</a><a id="15439" class="Symbol">}</a> <a id="15441" class="Symbol">=</a> <a id="15443" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-lim"></a><a id="15449" href="Base.html#15449" class="Function">fixpt-lim</a> <a id="15459" class="Symbol">:</a> <a id="15461" href="Base.html#14821" class="Function">fixpt</a> <a id="15467" href="Base.html#10589" class="Generalizable">F</a> <a id="15469" class="Symbol">(</a><a id="15470" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="15474" href="Base.html#10605" class="Generalizable">f</a><a id="15475" class="Symbol">)</a> <a id="15477" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15479" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="15483" class="Symbol">λ</a> <a id="15485" href="Base.html#15485" class="Bound">n</a> <a id="15487" class="Symbol">→</a> <a id="15489" href="Base.html#14821" class="Function">fixpt</a> <a id="15495" href="Base.html#10589" class="Generalizable">F</a> <a id="15497" class="Symbol">(</a><a id="15498" href="Base.html#10605" class="Generalizable">f</a> <a id="15500" href="Base.html#15485" class="Bound">n</a><a id="15501" class="Symbol">)</a>
<a id="15503" href="Base.html#15449" class="Function">fixpt-lim</a> <a id="15513" class="Symbol">=</a> <a id="15515" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 跳出运算并非一定搭配无穷迭代使用, 但一定会搭配极限使用. 后面我们会看到多种 <span class="math inline">\text{lim}</span> 的情况需要跳出, 以提高增长率.</p>
<h2 id="ε-ζ-η-层级">ε， ζ， η 层级</h2>
<p>我们定义三个序数函数 <span class="math inline">\varepsilon, \zeta, \eta</span> 如下.</p>
<p><strong>定义</strong> <span class="math inline">\varepsilon</span> 是函数 <span class="math inline">λα,ω^α</span> 的不动点枚举</p>
<p><span class="math display">
ε := \text{fixpt}\kern{0.17em}λα,ω\kern{0.17em}^α
</span></p>
<pre class="Agda"><a id="ε"></a><a id="15768" href="Base.html#15768" class="Function">ε</a> <a id="15770" class="Symbol">:</a> <a id="15772" href="Base.html#3261" class="Datatype">Ord</a> <a id="15776" class="Symbol">→</a> <a id="15778" href="Base.html#3261" class="Datatype">Ord</a>
<a id="15782" href="Base.html#15768" class="Function">ε</a> <a id="15784" class="Symbol">=</a> <a id="15786" href="Base.html#14821" class="Function">fixpt</a> <a id="15792" class="Symbol">(</a><a id="15793" href="Base.html#4700" class="Function">ω</a> <a id="15795" href="Base.html#12352" class="Function Operator">^_</a><a id="15797" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\varepsilon_0 &amp;= (λα,ω^α)^ω\kern{0.17em}0 =
ω^{ω^{⋰^{ω^0}}}
\\
\varepsilon_{α^+} &amp;= (λα,ω^α)^ω\kern{0.17em}({ε_α}^+) =
ω^{ω^{⋰^{ω^{({ε_α}^+)}}}}
\\
\varepsilon_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\varepsilon_{f\kern{0.17em}n} = \text{lim}(ε_{f\kern{0.17em}0},ε_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<pre class="Agda"><a id="ε-0"></a><a id="16207" href="Base.html#16207" class="Function">ε-0</a> <a id="16211" class="Symbol">:</a> <a id="16213" href="Base.html#15768" class="Function">ε</a> <a id="16215" class="Number">0</a> <a id="16217" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="16219" href="Base.html#12725" class="Function">iterω</a> <a id="16225" class="Symbol">(</a><a id="16226" href="Base.html#4700" class="Function">ω</a> <a id="16228" href="Base.html#12352" class="Function Operator">^_</a><a id="16230" class="Symbol">)</a> <a id="16232" class="Number">0</a>
<a id="16234" href="Base.html#16207" class="Function">ε-0</a> <a id="16238" class="Symbol">=</a> <a id="16240" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-suc"></a><a id="16246" href="Base.html#16246" class="Function">ε-suc</a> <a id="16252" class="Symbol">:</a> <a id="16254" href="Base.html#15768" class="Function">ε</a> <a id="16256" class="Symbol">(</a><a id="16257" class="InductiveConstructor">suc</a> <a id="16261" href="Base.html#4237" class="Generalizable">α</a><a id="16262" class="Symbol">)</a> <a id="16264" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="16266" href="Base.html#12725" class="Function">iterω</a> <a id="16272" class="Symbol">(</a><a id="16273" href="Base.html#4700" class="Function">ω</a> <a id="16275" href="Base.html#12352" class="Function Operator">^_</a><a id="16277" class="Symbol">)</a> <a id="16279" class="Symbol">(</a><a id="16280" class="InductiveConstructor">suc</a> <a id="16284" class="Symbol">(</a><a id="16285" href="Base.html#15768" class="Function">ε</a> <a id="16287" href="Base.html#4237" class="Generalizable">α</a><a id="16288" class="Symbol">))</a>
<a id="16291" href="Base.html#16246" class="Function">ε-suc</a> <a id="16297" class="Symbol">=</a> <a id="16299" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-lim"></a><a id="16305" href="Base.html#16305" class="Function">ε-lim</a> <a id="16311" class="Symbol">:</a> <a id="16313" href="Base.html#15768" class="Function">ε</a> <a id="16315" class="Symbol">(</a><a id="16316" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="16320" href="Base.html#10605" class="Generalizable">f</a><a id="16321" class="Symbol">)</a> <a id="16323" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="16325" href="Base.html#3311" class="InductiveConstructor">lim</a> <a id="16329" class="Symbol">λ</a> <a id="16331" href="Base.html#16331" class="Bound">n</a> <a id="16333" class="Symbol">→</a> <a id="16335" href="Base.html#15768" class="Function">ε</a> <a id="16337" class="Symbol">(</a><a id="16338" href="Base.html#10605" class="Generalizable">f</a> <a id="16340" href="Base.html#16331" class="Bound">n</a><a id="16341" class="Symbol">)</a>
<a id="16343" href="Base.html#16305" class="Function">ε-lim</a> <a id="16349" class="Symbol">=</a> <a id="16351" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\zeta</span> 是 <span class="math inline">ε</span> 的不动点枚举</p>
<p><span class="math display">
ζ := \text{fixpt}\kern{0.17em}ε
</span></p>
<pre class="Agda"><a id="ζ"></a><a id="16437" href="Base.html#16437" class="Function">ζ</a> <a id="16439" class="Symbol">:</a> <a id="16441" href="Base.html#3261" class="Datatype">Ord</a> <a id="16445" class="Symbol">→</a> <a id="16447" href="Base.html#3261" class="Datatype">Ord</a>
<a id="16451" href="Base.html#16437" class="Function">ζ</a> <a id="16453" class="Symbol">=</a> <a id="16455" href="Base.html#14821" class="Function">fixpt</a> <a id="16461" href="Base.html#15768" class="Function">ε</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\zeta_0 &amp;= ε^ω\kern{0.17em}0 =
ε_{ε_{⋱_{ε_0}}}
\\
\zeta_{α^+} &amp;= ε^ω\kern{0.17em}({\zeta_α}^+) =
ε_{ε_{⋱_{({\zeta_α}^+)}}}
\\
\zeta_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\zeta_{f\kern{0.17em}n} = \text{lim}(ζ_{f\kern{0.17em}0},ζ_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<p><strong>定义</strong> <span class="math inline">\eta</span> 是 <span class="math inline">\zeta</span> 的不动点枚举</p>
<p><span class="math display">
η := \text{fixpt}\kern{0.17em}ζ
</span></p>
<pre class="Agda"><a id="η"></a><a id="16906" href="Base.html#16906" class="Function">η</a> <a id="16908" class="Symbol">:</a> <a id="16910" href="Base.html#3261" class="Datatype">Ord</a> <a id="16914" class="Symbol">→</a> <a id="16916" href="Base.html#3261" class="Datatype">Ord</a>
<a id="16920" href="Base.html#16906" class="Function">η</a> <a id="16922" class="Symbol">=</a> <a id="16924" href="Base.html#14821" class="Function">fixpt</a> <a id="16930" href="Base.html#16437" class="Function">ζ</a>
</pre>
<p><strong>例</strong> 一个很大的大数:</p>
<p><span class="math display">
\text{oom} := f_{η_0} 99 = f_{
  ζ_{ζ_{⋱_{ζ_0}}}
}99
</span></p>
<p>其中 <span class="math inline">ζ_{ζ_{⋱_{ζ_0}}}</span> 是从 <span class="math inline">ζ_0</span> 开始迭代了 99 次 <span class="math inline">ζ</span>.</p>
<pre class="Agda"><a id="oom"></a><a id="17068" href="Base.html#17068" class="Function">oom</a> <a id="17072" class="Symbol">=</a> <a id="17074" href="Base.html#5857" class="Function">FGH.f</a> <a id="17080" class="Symbol">(</a><a id="17081" href="Base.html#16906" class="Function">η</a> <a id="17083" class="Number">0</a><a id="17084" class="Symbol">)</a> <a id="17086" class="Number">99</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
