<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.2 - 有限元Veblen函数)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.2 - 有限元Veblen函数)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.2---有限元veblen函数" id="toc-形式化大数数学-1.2---有限元veblen函数">形式化大数数学 (1.2 - 有限元Veblen函数)</a>
  <ul>
  <li><a href="#有限元函数类型" id="toc-有限元函数类型">有限元函数类型</a></li>
  <li><a href="#有限元veblen函数" id="toc-有限元veblen函数">有限元Veblen函数</a></li>
  <li><a href="#计算模式" id="toc-计算模式">计算模式</a></li>
  <li><a href="#svo" id="toc-svo">SVO</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.2---有限元veblen函数">形式化大数数学 (1.2 - 有限元Veblen函数)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Veblen/Finitary.lagda.md">Finitary.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Veblen.Finitary.html">Finitary.html</a></p>
</blockquote>
<pre class="Agda"><a id="381" class="Symbol">{-#</a> <a id="385" class="Keyword">OPTIONS</a> <a id="393" class="Pragma">--lossy-unification</a> <a id="413" class="Pragma">--rewriting</a> <a id="425" class="Pragma">--local-confluence-check</a> <a id="450" class="Symbol">#-}</a>
<a id="454" class="Keyword">module</a> <a id="461" href="Veblen.Finitary.html" class="Module">Veblen.Finitary</a> <a id="477" class="Keyword">where</a>
<a id="483" class="Keyword">open</a> <a id="488" class="Keyword">import</a> <a id="495" href="Veblen.Multinary.html" class="Module">Veblen.Multinary</a> <a id="512" class="Keyword">public</a>
<a id="519" class="Keyword">open</a> <a id="524" class="Keyword">import</a> <a id="531" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a> <a id="553" class="Keyword">public</a>
<a id="560" class="Keyword">open</a> <a id="565" class="Keyword">import</a> <a id="572" href="Agda.Builtin.Equality.Rewrite.html" class="Module">Agda.Builtin.Equality.Rewrite</a> <a id="602" class="Keyword">public</a>
</pre>
<p>前篇我们讲了二元, 三元和四元Veblen函数 <span class="math inline">\text{Bin}.φ,\text{Tri}.φ,\text{Qua}.φ</span>. 我们希望把元数作为一个参数, 也就是说, 定义一个函数族 <span class="math inline">φ</span>, 使得 <span class="math inline">φ_n</span> 正好是 <span class="math inline">n</span> 元Veblen函数. 这样的 <span class="math inline">φ</span> 叫做 (任意) 有限元Veblen函数 (Finitary Veblen Function), 也叫扩展Veblen函数 (Extended Veblen Function).</p>
<pre class="Agda"><a id="848" class="Keyword">module</a> <a id="Bin"></a><a id="855" href="Veblen.Finitary.html#855" class="Module">Bin</a> <a id="859" class="Symbol">=</a> <a id="861" href="Veblen.Multinary.html#2125" class="Module">BinaryVeblen</a>
<a id="874" class="Keyword">module</a> <a id="Tri"></a><a id="881" href="Veblen.Finitary.html#881" class="Module">Tri</a> <a id="885" class="Symbol">=</a> <a id="887" href="Veblen.Multinary.html#9679" class="Module">TrinaryVeblen</a>
<a id="901" class="Keyword">module</a> <a id="Qua"></a><a id="908" href="Veblen.Finitary.html#908" class="Module">Qua</a> <a id="912" class="Symbol">=</a> <a id="914" href="Veblen.Multinary.html#19844" class="Module">QuaternaryVeblen</a>
</pre>
<h2 id="有限元函数类型">有限元函数类型</h2>
<p>首先我们要把 <span class="math inline">φ</span> 的类型写出来, 它是一个依赖类型 <span class="math inline">\prod_{n:ℕ}\text{Ord}^{→n}</span>, 其中 <span class="math inline">\text{Ord}^{→n}</span> 表示 <span class="math inline">\text{Ord}</span> 上的 <span class="math inline">n</span> 元函数类型 <span class="math inline">\overbrace{\text{Ord}→...→\text{Ord}}^n →\text{Ord}</span>. 当然我们也可以采用 <span class="math inline">\text{Ord}^n →\text{Ord}</span>, 即 (<span class="math inline">\overbrace{\text{Ord}\times...\times\text{Ord}}^n)→\text{Ord}</span>. 我们选择前者是因为它有方便的<a href="https://en.wikipedia.org/wiki/Currying">柯里化 (Currying)</a> 性质, 处理起来更简单.</p>
<p><strong>定义</strong> 陪域为 <span class="math inline">A</span> 的有限元序数函数 <span class="math inline">\overbrace{\text{Ord}→...→\text{Ord}}^n →A</span>, 记作 <span class="math inline">A^{→n}</span>, 递归定义为</p>
<p><span class="math display">
\begin{aligned}
A^{→0} &amp;:= A \\
A^{→n^+} &amp;:= \text{Ord} → A^{→n}
\end{aligned}
</span></p>
<pre class="Agda"><a id="_→ⁿ_"></a><a id="1486" href="Veblen.Finitary.html#1486" class="Function Operator">_→ⁿ_</a> <a id="1491" class="Symbol">:</a> <a id="1493" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1497" class="Symbol">→</a> <a id="1499" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1501" class="Symbol">→</a> <a id="1503" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1507" href="Veblen.Finitary.html#1507" class="Bound">A</a> <a id="1509" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="1512" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="1517" class="Symbol">=</a> <a id="1519" href="Veblen.Finitary.html#1507" class="Bound">A</a>
<a id="1521" href="Veblen.Finitary.html#1521" class="Bound">A</a> <a id="1523" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="1526" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1530" href="Veblen.Finitary.html#1530" class="Bound">n</a> <a id="1532" class="Symbol">=</a> <a id="1534" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="1538" class="Symbol">→</a> <a id="1540" href="Veblen.Finitary.html#1521" class="Bound">A</a> <a id="1542" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="1545" href="Veblen.Finitary.html#1530" class="Bound">n</a>
</pre>
<p>这样, <span class="math inline">\text{Ord}^{→n}</span> 就等于 <span class="math inline">\overbrace{\text{Ord}→...→\text{Ord}}^n →\text{Ord}</span>.</p>
<p>现在, 回想四元Veblen函数的定义</p>
<p><span class="math display">
\begin{aligned}
Φ\kern{0.17em}F := \text{rec}\kern{0.17em}F\kern{0.17em}&amp;(λφ_α,\text{Tri}.Φ\kern{0.17em}(\text{Bin}.Φ\kern{0.17em}(\text{fixpt}\kern{0.17em}λβ,φ_{α,β,0}\kern{0.17em}0))) \\
&amp;(λφ,\text{Tri}.Φ\kern{0.17em}(\text{Bin}.Φ\kern{0.17em}(\text{jump}\kern{0.17em}λβ,\text{lim}\kern{0.17em}λn,φ[ n ]_{β,0}\kern{0.17em}0)))
\end{aligned}
</span></p>
<p>注意其中 <span class="math inline">φ_{α,β,0}\kern{0.17em}0</span> 的形式, 也就是说我们需要从某一位参数开始, 后面全部填零的操作. 对于 <span class="math inline">n</span> 元函数来说这种填零操作是递归完成的. 于是有如下定义.</p>
<p><strong>定义</strong> 对 <span class="math inline">n</span> 元函数 <span class="math inline">F : A^{→n}</span> 的参数全部填零所得到的 <span class="math inline">A</span> 的元素, 记作 <span class="math inline">F\kern{0.17em}\overset{.}{0} : A</span>, 递归定义为</p>
<p><span class="math display">
\begin{aligned}
(F : A^{→0})\kern{0.17em}\overset{.}{0} &amp;:= F:A \\
(F : A^{→n^+})\kern{0.17em}\overset{.}{0} &amp;:= (F\kern{0.17em}0 : A^{→n})\kern{0.17em}\overset{.}{0}
\end{aligned}
</span></p>
<pre class="Agda"><a id="_0̇"></a><a id="2399" href="Veblen.Finitary.html#2399" class="Function Operator">_0̇</a> <a id="2403" class="Symbol">:</a> <a id="2405" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="2407" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="2410" href="Veblen.Base.html#4436" class="Generalizable">n</a> <a id="2412" class="Symbol">→</a> <a id="2414" href="Veblen.Base.html#4444" class="Generalizable">A</a>
<a id="2416" href="Veblen.Finitary.html#2399" class="Function Operator">_0̇</a> <a id="2420" class="Symbol">{</a><a id="2421" class="Argument">n</a> <a id="2423" class="Symbol">=</a> <a id="2425" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2429" class="Symbol">}</a> <a id="2431" class="Symbol">=</a> <a id="2433" href="Function.Base.html#704" class="Function">id</a>
<a id="2436" href="Veblen.Finitary.html#2399" class="Function Operator">_0̇</a> <a id="2440" class="Symbol">{</a><a id="2441" class="Argument">n</a> <a id="2443" class="Symbol">=</a> <a id="2445" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2449" href="Veblen.Finitary.html#2449" class="Bound">n</a><a id="2450" class="Symbol">}</a> <a id="2452" href="Veblen.Finitary.html#2452" class="Bound">F</a> <a id="2454" class="Symbol">=</a> <a id="2456" href="Veblen.Finitary.html#2452" class="Bound">F</a> <a id="2458" class="Number">0</a> <a id="2460" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
</pre>
<p>有时候我们想要留最后一位不填或最后两位不填.</p>
<p><strong>定义</strong> 对 <span class="math inline">n^+</span> 元函数 <span class="math inline">F : A^{→n^+}</span> 的参数留最后一位不填, 其余全部填零, 所得到的函数记作 <span class="math inline">F\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}} : \text{Ord}→A</span>, 递归定义为</p>
<p><span class="math display">
\begin{aligned}
(F : A^{→1})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}} &amp;:= F:\text{Ord}→A \\
(F : A^{→n^{++}})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}} &amp;:= (F\kern{0.17em}0 : A^{→n^+})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}
\end{aligned}
</span></p>
<pre class="Agda"><a id="_0̇,_"></a><a id="2969" href="Veblen.Finitary.html#2969" class="Function Operator">_0̇,_</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="2979" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="2982" class="InductiveConstructor">suc</a> <a id="2986" href="Veblen.Base.html#4436" class="Generalizable">n</a> <a id="2988" class="Symbol">→</a> <a id="2990" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="2992" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="2995" class="Number">1</a>
<a id="2997" href="Veblen.Finitary.html#2969" class="Function Operator">_0̇,_</a> <a id="3003" class="Symbol">{</a><a id="3004" class="Argument">n</a> <a id="3006" class="Symbol">=</a> <a id="3008" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="3012" class="Symbol">}</a> <a id="3014" class="Symbol">=</a> <a id="3016" href="Function.Base.html#704" class="Function">id</a>
<a id="3019" href="Veblen.Finitary.html#2969" class="Function Operator">_0̇,_</a> <a id="3025" class="Symbol">{</a><a id="3026" class="Argument">n</a> <a id="3028" class="Symbol">=</a> <a id="3030" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3034" href="Veblen.Finitary.html#3034" class="Bound">n</a><a id="3035" class="Symbol">}</a> <a id="3037" href="Veblen.Finitary.html#3037" class="Bound">F</a> <a id="3039" class="Symbol">=</a> <a id="3041" href="Veblen.Finitary.html#3037" class="Bound">F</a> <a id="3043" class="Number">0</a> <a id="3045" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,_</a>
</pre>
<p><strong>定义</strong> 对 <span class="math inline">n^{++}</span> 元函数 <span class="math inline">F : A^{→n^{++}}</span> 的参数留最后两位不填, 其余全部填零, 所得到的函数记作 <span class="math inline">F\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}\kern{0.17em}\underline{\kern{0.5em}} : \text{Ord}→\text{Ord}→A</span>, 递归定义为</p>
<p><span class="math display">
\begin{aligned}
(F : A^{→2})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}\kern{0.17em}\underline{\kern{0.5em}} &amp;:= F:\text{Ord}→\text{Ord}→A \\
(F : A^{→n^{+++}})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}\kern{0.17em}\underline{\kern{0.5em}} &amp;:= (F\kern{0.17em}0 : A^{→n^{++}})\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}\kern{0.17em}\underline{\kern{0.5em}}
\end{aligned}
</span></p>
<pre class="Agda"><a id="_0̇,_,_"></a><a id="3712" href="Veblen.Finitary.html#3712" class="Function Operator">_0̇,_,_</a> <a id="3720" class="Symbol">:</a> <a id="3722" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="3724" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="3727" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="3730" href="Veblen.Base.html#4436" class="Generalizable">n</a> <a id="3732" class="Symbol">→</a> <a id="3734" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="3736" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="3739" class="Number">2</a>
<a id="3741" href="Veblen.Finitary.html#3712" class="Function Operator">_0̇,_,_</a> <a id="3749" class="Symbol">{</a><a id="3750" class="Argument">n</a> <a id="3752" class="Symbol">=</a> <a id="3754" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="3758" class="Symbol">}</a> <a id="3760" class="Symbol">=</a> <a id="3762" href="Function.Base.html#704" class="Function">id</a>
<a id="3765" href="Veblen.Finitary.html#3712" class="Function Operator">_0̇,_,_</a> <a id="3773" class="Symbol">{</a><a id="3774" class="Argument">n</a> <a id="3776" class="Symbol">=</a> <a id="3778" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3782" href="Veblen.Finitary.html#3782" class="Bound">n</a><a id="3783" class="Symbol">}</a> <a id="3785" href="Veblen.Finitary.html#3785" class="Bound">F</a> <a id="3787" class="Symbol">=</a> <a id="3789" href="Veblen.Finitary.html#3785" class="Bound">F</a> <a id="3791" class="Number">0</a> <a id="3793" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,_,_</a>
</pre>
<p><strong>引理</strong> 对 <span class="math inline">n^+</span> 元函数 <span class="math inline">F : A^{→n^+}</span>, 第一位先填零, 剩余再全部填零, 或者除最后一位外全部填零, 然后最后一位再填零, 这两种做法都等于一开始就全部填零.</p>
<p><span class="math display">
\begin{aligned}
(F : A^{→n^+})\kern{0.17em}\overset{.}{0} &amp;= (F\kern{0.17em}0: A^{→n})\kern{0.17em}\overset{.}{0} \\
(F : A^{→n^+})\kern{0.17em}\overset{.}{0} &amp;= (F\kern{0.17em}\overset{.}{0}:A^{→1})\kern{0.17em}0
\end{aligned}
</span></p>
<pre class="Agda"><a id="0,0̇"></a><a id="4144" href="Veblen.Finitary.html#4144" class="Function">0,0̇</a> <a id="4149" class="Symbol">:</a> <a id="4151" class="Symbol">{</a><a id="4152" href="Veblen.Finitary.html#4152" class="Bound">F</a> <a id="4154" class="Symbol">:</a> <a id="4156" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="4158" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="4161" class="InductiveConstructor">suc</a> <a id="4165" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="4166" class="Symbol">}</a> <a id="4168" class="Symbol">→</a> <a id="4170" href="Veblen.Finitary.html#4152" class="Bound">F</a> <a id="4172" class="Number">0</a> <a id="4174" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a> <a id="4177" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4179" href="Veblen.Finitary.html#4152" class="Bound">F</a> <a id="4181" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="4184" href="Veblen.Finitary.html#4144" class="Function">0,0̇</a> <a id="4189" class="Symbol">=</a> <a id="4191" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="0̇,0"></a><a id="4197" href="Veblen.Finitary.html#4197" class="Function">0̇,0</a> <a id="4202" class="Symbol">:</a> <a id="4204" class="Symbol">{</a><a id="4205" href="Veblen.Finitary.html#4205" class="Bound">F</a> <a id="4207" class="Symbol">:</a> <a id="4209" href="Veblen.Base.html#4444" class="Generalizable">A</a> <a id="4211" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="4214" class="InductiveConstructor">suc</a> <a id="4218" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="4219" class="Symbol">}</a> <a id="4221" class="Symbol">→</a> <a id="4223" href="Veblen.Finitary.html#4205" class="Bound">F</a> <a id="4225" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="4229" class="Number">0</a> <a id="4231" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4233" href="Veblen.Finitary.html#4205" class="Bound">F</a> <a id="4235" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="4238" href="Veblen.Finitary.html#4197" class="Function">0̇,0</a> <a id="4243" class="Symbol">{</a><a id="4244" class="Argument">n</a> <a id="4246" class="Symbol">=</a> <a id="4248" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="4252" class="Symbol">}</a> <a id="4254" class="Symbol">=</a> <a id="4256" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="4261" href="Veblen.Finitary.html#4197" class="Function">0̇,0</a> <a id="4266" class="Symbol">{</a><a id="4267" class="Argument">n</a> <a id="4269" class="Symbol">=</a> <a id="4271" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4275" class="Symbol">_}</a> <a id="4278" class="Symbol">{</a><a id="4279" href="Veblen.Finitary.html#4279" class="Bound">F</a><a id="4280" class="Symbol">}</a> <a id="4282" class="Symbol">=</a> <a id="4284" href="Veblen.Finitary.html#4197" class="Function">0̇,0</a> <a id="4289" class="Symbol">{</a><a id="4290" class="Argument">F</a> <a id="4292" class="Symbol">=</a> <a id="4294" href="Veblen.Finitary.html#4279" class="Bound">F</a> <a id="4296" class="Number">0</a><a id="4297" class="Symbol">}</a>
</pre>
<h2 id="有限元veblen函数">有限元Veblen函数</h2>
<p>有了以上准备, 终于可以定义有限元Veblen函数了. 回想前篇的辅助函数 <span class="math inline">\Phi</span>, 我们讲了它的二元, 三元和四元版本. 用下标表示元数, 再次列出它们的类型如下.</p>
<ul>
<li><span class="math inline">Φ_2:(\text{Ord} → \text{Ord}) → \text{Ord} → \text{Ord} → \text{Ord}</span></li>
<li><span class="math inline">Φ_3:(\text{Ord} → \text{Ord} → \text{Ord}) → \text{Ord} → \text{Ord} → \text{Ord} → \text{Ord}</span></li>
<li><span class="math inline">Φ_4:(\text{Ord} → \text{Ord} → \text{Ord} → \text{Ord}) → \text{Ord} → \text{Ord} → \text{Ord} → \text{Ord} → \text{Ord}</span></li>
<li>…</li>
</ul>
<p>自然地推广下去, 用上一节刚定义的符号, 并且让下标从一开始, 我们现在需要定义一个</p>
<p><span class="math display">
Φ_{n^+} : \text{Ord}^{→n^+} → \text{Ord}^{→n^{++}}
</span></p>
<pre class="Agda"><a id="Φₙ"></a><a id="4822" href="Veblen.Finitary.html#4822" class="Function">Φₙ</a> <a id="4825" class="Symbol">:</a> <a id="4827" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="4831" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="4834" class="InductiveConstructor">suc</a> <a id="4838" href="Veblen.Base.html#4436" class="Generalizable">n</a> <a id="4840" class="Symbol">→</a> <a id="4842" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="4846" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="4849" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="4852" href="Veblen.Base.html#4436" class="Generalizable">n</a>
</pre>
<p>回顾不动点的起点 (梦的开始) <span class="math inline">λα,ω\kern{0.17em}^α : \text{Ord}^{→1}</span>, 我们需要从它开始, 迭代 <span class="math inline">Φ_{\le n}</span>, 以得到 <span class="math inline">Φ_{n^+}</span>. 直观上该迭代具有</p>
<p><span class="math display">
Φ_{n} (... (Φ_2 (Φ_1 (Φ_1 (λα,ω\kern{0.17em}^α))))...) : \text{Ord}^{→n^+}\quad (*)
</span></p>
<p>的形式. 我们把这整个迭代过程记作 <span class="math inline">Φ</span>, 它具有类型</p>
<p><span class="math display">
Φ : \text{Ord}^{→1} → \prod_{n:ℕ}\text{Ord}^{→n^+}
</span></p>
<pre class="Agda"><a id="Φ"></a><a id="5154" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="5156" class="Symbol">:</a> <a id="5158" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="5162" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="5165" class="Number">1</a> <a id="5167" class="Symbol">→</a> <a id="5169" class="Symbol">(∀</a> <a id="5172" href="Veblen.Finitary.html#5172" class="Bound">n</a> <a id="5174" class="Symbol">→</a> <a id="5176" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="5180" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="5183" class="InductiveConstructor">suc</a> <a id="5187" href="Veblen.Finitary.html#5172" class="Bound">n</a><a id="5188" class="Symbol">)</a>
</pre>
<p>非形式地, 简洁起见, 我们将把 <span class="math inline">Φ\kern{0.17em}F\kern{0.17em}n</span> 写作 <span class="math inline">Φ^n\kern{0.17em}F</span>.</p>
<p>注意到 <span class="math inline">Φ_{n^+}</span> 的定义里就要用到 <span class="math inline">(*)</span> 式, 即 <span class="math inline">Φ</span> 的定义. 而 <span class="math inline">Φ</span> 的定义里又要用到每个 <span class="math inline">Φ_{\le n}</span>. 我们把它们写成互递归的形式, 也就是说同时定义 <span class="math inline">Φ_n</span> 和 <span class="math inline">Φ</span>.</p>
<p><strong>定义</strong> <span class="math inline">Φ_{n^+}</span> 和 <span class="math inline">Φ</span> 互递归定义如下.</p>
<p><span class="math display">
\begin{aligned}
&amp;Φ_{n^+}\kern{0.17em}F :\text{Ord}^{→n^{++}} &amp;:=&amp; \text{rec}\kern{0.17em}F \\
&amp;&amp;&amp;\quad (λ(φ_{n^+,α}:\text{Ord}^{→n^+}),Φ^n\kern{0.17em}(\text{fixpt}\kern{0.17em}λβ,φ_{n^+,α}\kern{0.17em}β\kern{0.17em}\overset{.}{0})) \\
&amp;&amp;&amp;\quad (λ(φ_{n^+,f\kern{0.17em}m}:ℕ→\text{Ord}^{→n^+}), Φ^n\kern{0.17em}(\text{jump}\kern{0.17em}λβ,\limλm,φ_{n^+,f\kern{0.17em}m}\kern{0.17em}β\kern{0.17em}\overset{.}{0})) \\
\\
&amp;Φ^0\kern{0.17em}F : \text{Ord}^{→1} &amp;:=&amp; F \\
&amp;Φ^{n^+}\kern{0.17em}F : \text{Ord}^{→n^{++}} &amp;:=&amp; Φ_{n^+}\kern{0.17em}(Φ^n\kern{0.17em}F)
\end{aligned}
</span></p>
<pre class="Agda"><a id="5998" class="Comment">-- 我们会给元数参数加一层括弧以方便辨认, 它们相当于 Φ 的上标.</a>
<a id="6034" href="Veblen.Finitary.html#4822" class="Function">Φₙ</a> <a id="6037" class="Symbol">{</a><a id="6038" href="Veblen.Finitary.html#6038" class="Bound">n</a><a id="6039" class="Symbol">}</a> <a id="6041" href="Veblen.Finitary.html#6041" class="Bound">F</a> <a id="6043" class="Symbol">=</a> <a id="6045" href="Veblen.Base.html#10243" class="Function">rec</a> <a id="6049" href="Veblen.Finitary.html#6041" class="Bound">F</a>
  <a id="6053" class="Symbol">(λ</a> <a id="6056" href="Veblen.Finitary.html#6056" class="Bound">φ-α</a>  <a id="6061" class="Symbol">→</a> <a id="6063" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6065" class="Symbol">(</a><a id="6066" href="Veblen.Base.html#15054" class="Function">fixpt</a> <a id="6072" class="Symbol">λ</a> <a id="6074" href="Veblen.Finitary.html#6074" class="Bound">β</a> <a id="6076" class="Symbol">→</a> <a id="6078" href="Veblen.Finitary.html#6056" class="Bound">φ-α</a> <a id="6082" href="Veblen.Finitary.html#6074" class="Bound">β</a> <a id="6084" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a><a id="6086" class="Symbol">)</a> <a id="6088" class="Symbol">(</a><a id="6089" href="Veblen.Finitary.html#6038" class="Bound">n</a><a id="6090" class="Symbol">))</a>
  <a id="6095" class="Symbol">(λ</a> <a id="6098" href="Veblen.Finitary.html#6098" class="Bound Operator">φ[_]</a> <a id="6103" class="Symbol">→</a> <a id="6105" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6107" class="Symbol">(</a><a id="6108" href="Veblen.Base.html#13549" class="Function">jump</a> <a id="6113" class="Symbol">λ</a> <a id="6115" href="Veblen.Finitary.html#6115" class="Bound">β</a> <a id="6117" class="Symbol">→</a> <a id="6119" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="6123" class="Symbol">λ</a> <a id="6125" href="Veblen.Finitary.html#6125" class="Bound">m</a> <a id="6127" class="Symbol">→</a> <a id="6129" href="Veblen.Finitary.html#6098" class="Bound Operator">φ[</a> <a id="6132" href="Veblen.Finitary.html#6125" class="Bound">m</a> <a id="6134" href="Veblen.Finitary.html#6098" class="Bound Operator">]</a> <a id="6136" href="Veblen.Finitary.html#6115" class="Bound">β</a> <a id="6138" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a><a id="6140" class="Symbol">)</a> <a id="6142" class="Symbol">(</a><a id="6143" href="Veblen.Finitary.html#6038" class="Bound">n</a><a id="6144" class="Symbol">))</a>

<a id="6148" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6150" href="Veblen.Finitary.html#6150" class="Bound">F</a> <a id="6152" class="Symbol">(</a><a id="6153" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="6157" class="Symbol">)</a> <a id="6159" class="Symbol">=</a> <a id="6161" href="Veblen.Finitary.html#6150" class="Bound">F</a>
<a id="6163" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6165" href="Veblen.Finitary.html#6165" class="Bound">F</a> <a id="6167" class="Symbol">((</a><a id="6169" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6173" href="Veblen.Finitary.html#6173" class="Bound">n</a><a id="6174" class="Symbol">))</a> <a id="6177" class="Symbol">=</a> <a id="6179" href="Veblen.Finitary.html#4822" class="Function">Φₙ</a> <a id="6182" class="Symbol">(</a><a id="6183" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6185" href="Veblen.Finitary.html#6165" class="Bound">F</a> <a id="6187" class="Symbol">(</a><a id="6188" href="Veblen.Finitary.html#6173" class="Bound">n</a><a id="6189" class="Symbol">))</a>
</pre>
<p><strong>注意</strong> 也可以不用互递归, 非形式地采用如下定义.</p>
<p><span class="math display">
\begin{aligned}
Φ_{n^+}\kern{0.17em}F := \text{rec}\kern{0.17em}F\kern{0.17em}&amp;(λφ_{n^+,α},Φ_{n} (... (Φ_2 (Φ_1(\text{fixpt}\kern{0.17em}λβ,φ_{n^+,α}\kern{0.17em}β\kern{0.17em}\overset{.}{0}))))...) \\
&amp;(λφ_{n^+,f\kern{0.17em}m}, Φ_{n} (... (Φ_2 (Φ_1(\text{jump}\kern{0.17em}λβ,\limλm,φ_{n^+,f\kern{0.17em}m}\kern{0.17em}β\kern{0.17em}\overset{.}{0}))))...)
\end{aligned}
</span></p>
<p>形式地, 可以把省略号换成自然数版本的 <span class="math inline">\text{ind}</span>, 这里不展开讲解.</p>
<p><strong>定义</strong> 有限元Veblen函数</p>
<p><span class="math display">
φ : \prod_{n:ℕ}\text{Ord}^{→n^{+}} := Φ\kern{0.17em}(λα,ω\kern{0.17em}^α)
</span></p>
<pre class="Agda"><a id="φ"></a><a id="6759" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="6761" class="Symbol">:</a> <a id="6763" class="Symbol">∀</a> <a id="6765" href="Veblen.Finitary.html#6765" class="Bound">n</a> <a id="6767" class="Symbol">→</a> <a id="6769" href="Veblen.Base.html#3429" class="Datatype">Ord</a> <a id="6773" href="Veblen.Finitary.html#1486" class="Function Operator">→ⁿ</a> <a id="6776" class="InductiveConstructor">suc</a> <a id="6780" href="Veblen.Finitary.html#6765" class="Bound">n</a>
<a id="6782" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="6784" class="Symbol">=</a> <a id="6786" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="6788" class="Symbol">(</a><a id="6789" href="Veblen.Base.html#5076" class="Function">ω</a> <a id="6791" href="Veblen.Base.html#12572" class="Function Operator">^_</a><a id="6793" class="Symbol">)</a>
</pre>
<p><strong>事实</strong> <span class="math inline">n^{++}</span> 元Veblen函数 <span class="math inline">φ_{n^+}</span> 等于对 <span class="math inline">n^+</span> 元Veblen函数 <span class="math inline">φ_n</span> 做一次 <span class="math inline">Φ_n</span>, 并且首位输入零的话就等于 <span class="math inline">φ_n</span>.</p>
<p><span class="math display">
\begin{aligned}
φ_{n^+} &amp;= Φ_{n^+}\kern{0.17em}φ_n \\
φ_{n^+} 0 &amp;= φ_n
\end{aligned}
</span></p>
<pre class="Agda"><a id="Φ-φ"></a><a id="6994" href="Veblen.Finitary.html#6994" class="Function">Φ-φ</a> <a id="6998" class="Symbol">:</a> <a id="7000" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7002" class="Symbol">((</a><a id="7004" class="InductiveConstructor">suc</a> <a id="7008" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="7009" class="Symbol">))</a> <a id="7012" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7014" href="Veblen.Finitary.html#4822" class="Function">Φₙ</a> <a id="7017" class="Symbol">(</a><a id="7018" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7020" class="Symbol">(</a><a id="7021" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="7022" class="Symbol">))</a>
<a id="7025" href="Veblen.Finitary.html#6994" class="Function">Φ-φ</a> <a id="7029" class="Symbol">=</a> <a id="7031" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="φ-0"></a><a id="7037" href="Veblen.Finitary.html#7037" class="Function">φ-0</a> <a id="7041" class="Symbol">:</a> <a id="7043" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7045" class="Symbol">((</a><a id="7047" class="InductiveConstructor">suc</a> <a id="7051" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="7052" class="Symbol">))</a> <a id="7055" class="Number">0</a> <a id="7057" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7059" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7061" class="Symbol">(</a><a id="7062" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="7063" class="Symbol">)</a>
<a id="7065" href="Veblen.Finitary.html#7037" class="Function">φ-0</a> <a id="7069" class="Symbol">=</a> <a id="7071" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>例</strong></p>
<p><span class="math display">
\begin{aligned}
φ_0 &amp;= λα,ω^α \\
φ_1 &amp;= \text{Bin}.φ \\
φ_2 &amp;= \text{Tri}.φ \\
φ_3 &amp;= \text{Qua}.φ
\end{aligned}
</span></p>
<pre class="Agda"><a id="φ₀"></a><a id="7216" href="Veblen.Finitary.html#7216" class="Function">φ₀</a> <a id="7219" class="Symbol">:</a> <a id="7221" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7223" class="Symbol">(</a><a id="7224" class="Number">0</a><a id="7225" class="Symbol">)</a> <a id="7227" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7229" href="Veblen.Base.html#5076" class="Function">ω</a> <a id="7231" href="Veblen.Base.html#12572" class="Function Operator">^_</a>
<a id="7234" href="Veblen.Finitary.html#7216" class="Function">φ₀</a> <a id="7237" class="Symbol">=</a> <a id="7239" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="φ₁"></a><a id="7245" href="Veblen.Finitary.html#7245" class="Function">φ₁</a> <a id="7248" class="Symbol">:</a> <a id="7250" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7252" class="Symbol">(</a><a id="7253" class="Number">1</a><a id="7254" class="Symbol">)</a> <a id="7256" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7258" href="Veblen.Multinary.html#3031" class="Function">Bin.φ</a>
<a id="7264" href="Veblen.Finitary.html#7245" class="Function">φ₁</a> <a id="7267" class="Symbol">=</a> <a id="7269" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="φ₂"></a><a id="7275" href="Veblen.Finitary.html#7275" class="Function">φ₂</a> <a id="7278" class="Symbol">:</a> <a id="7280" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7282" class="Symbol">(</a><a id="7283" class="Number">2</a><a id="7284" class="Symbol">)</a> <a id="7286" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7288" href="Veblen.Multinary.html#11094" class="Function">Tri.φ</a>
<a id="7294" href="Veblen.Finitary.html#7275" class="Function">φ₂</a> <a id="7297" class="Symbol">=</a> <a id="7299" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="φ₃"></a><a id="7305" href="Veblen.Finitary.html#7305" class="Function">φ₃</a> <a id="7308" class="Symbol">:</a> <a id="7310" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="7312" class="Symbol">(</a><a id="7313" class="Number">3</a><a id="7314" class="Symbol">)</a> <a id="7316" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7318" href="Veblen.Multinary.html#20659" class="Function">Qua.φ</a>
<a id="7324" href="Veblen.Finitary.html#7305" class="Function">φ₃</a> <a id="7327" class="Symbol">=</a> <a id="7329" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="计算模式">计算模式</h2>
<p>回想四元Veblen函数的计算模式.</p>
<p><span class="math display">
\begin{aligned}
&amp;Φ\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}0\kern{0.17em}0\kern{0.17em}0 &amp;=&amp; (λβ,Φ\kern{0.17em}F\kern{0.17em}α\kern{0.17em}β\kern{0.17em}0\kern{0.17em}0)^ω\kern{0.17em}0 \\
&amp;Φ\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}0\kern{0.17em}0\kern{0.17em}β^+ &amp;=&amp; (λβ,Φ\kern{0.17em}F\kern{0.17em}α\kern{0.17em}β\kern{0.17em}0\kern{0.17em}0)^ω\kern{0.17em}(Φ\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}0\kern{0.17em}0\kern{0.17em}β)^+ \\
&amp;Φ\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}0\kern{0.17em}0\kern{0.17em}0 &amp;=&amp; \lim λn,Φ\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)\kern{0.17em}0\kern{0.17em}0\kern{0.17em}0 \\
&amp;Φ\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}0\kern{0.17em}0\kern{0.17em}β^+ &amp;=&amp; \lim λn,Φ\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)\kern{0.17em}(Φ\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}0\kern{0.17em}0\kern{0.17em}β)^+\kern{0.17em}0\kern{0.17em}0 \\
&amp;Φ\kern{0.17em}F\kern{0.17em}α\kern{0.17em}0\kern{0.17em}0\kern{0.17em}(\lim g) &amp;=&amp; \lim λn,Φ\kern{0.17em}F\kern{0.17em}α\kern{0.17em}0\kern{0.17em}0\kern{0.17em}(g\kern{0.17em}n)
\end{aligned}
</span></p>
<p>自然推广下去, 对于 <span class="math inline">n</span> 元, 系统地, 可以通过如下方法考察计算模式. 设</p>
<ul>
<li><span class="math inline">\mathcal{S}</span> 表示任意参数序列</li>
<li><span class="math inline">\mathcal{Z}</span> 表示不特定多个零 (可能一个零都没有)</li>
<li><span class="math inline">\mathcal{z,s,l}</span> 分别表示单个零, 后继, 极限</li>
<li><span class="math inline">\mathcal{α,β}</span> 表示任意单个参数</li>
</ul>
<p>那么所有参数模式都可匹配到 <span class="math inline">(\mathcal{S,α,Z,β})</span> 的模式, 且五大模式表示为</p>
<ul>
<li><span class="math inline">(\mathcal{S,s,Z,z})</span></li>
<li><span class="math inline">(\mathcal{S,s,Z,s})</span></li>
<li><span class="math inline">(\mathcal{S,l,Z,z})</span></li>
<li><span class="math inline">(\mathcal{S,l,Z,s})</span></li>
<li><span class="math inline">(\mathcal{S,α,Z,l})</span></li>
</ul>
<p>但 Agda 无法直接像四元那样直接证出这些模式, 因为卡在了下述引理, 它的证明需要归纳元数 <span class="math inline">n</span>.</p>
<p><strong>引理</strong> <span class="math inline">(\mathcal{S,Z,α})</span></p>
<p><span class="math display">
Φ^n\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}} = F
</span></p>
<p><strong>(证明)</strong> 归纳 <span class="math inline">n</span> 即得. ∎</p>
<pre class="Agda"><a id="Φ-ż-α"></a><a id="9007" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a> <a id="9014" class="Symbol">:</a> <a id="9016" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="9018" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="9020" class="Symbol">(</a><a id="9021" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="9022" class="Symbol">)</a> <a id="9024" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,_</a> <a id="9029" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9031" href="Veblen.Base.html#10697" class="Generalizable">F</a>
<a id="9033" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a> <a id="9040" class="Symbol">{</a><a id="9041" class="Argument">n</a> <a id="9043" class="Symbol">=</a> <a id="9045" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="9049" class="Symbol">}</a> <a id="9051" class="Symbol">=</a> <a id="9053" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="9058" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a> <a id="9065" class="Symbol">{</a><a id="9066" class="Argument">n</a> <a id="9068" class="Symbol">=</a> <a id="9070" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9074" href="Veblen.Finitary.html#9074" class="Bound">n</a><a id="9075" class="Symbol">}</a> <a id="9077" class="Symbol">=</a> <a id="9079" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a> <a id="9086" class="Symbol">{</a><a id="9087" class="Argument">n</a> <a id="9089" class="Symbol">=</a> <a id="9091" href="Veblen.Finitary.html#9074" class="Bound">n</a><a id="9092" class="Symbol">}</a>
<a id="9094" class="Symbol">{-#</a> <a id="9098" class="Keyword">REWRITE</a> <a id="9106" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a> <a id="9113" class="Symbol">#-}</a>
</pre>
<p>将该引理声明为新的重写规则, 可以立即证明:</p>
<p><strong>定理</strong> 计算模式</p>
<p><span class="math display">
\begin{aligned}
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}\overset{.}{0} &amp;=&amp; (λβ,Φ^{n^+}\kern{0.17em}F\kern{0.17em}α\kern{0.17em}β\kern{0.17em}\overset{.}{0})^ω\kern{0.17em}0 \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}\overset{.}{0}\kern{0.17em}β^+ &amp;=&amp; (λβ,Φ^{n^+}\kern{0.17em}F\kern{0.17em}α\kern{0.17em}β\kern{0.17em}\overset{.}{0})^ω\kern{0.17em}(Φ^{n^+}\kern{0.17em}F\kern{0.17em}α^+\kern{0.17em}\overset{.}{0}\kern{0.17em}β)^+ \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}\overset{.}{0} &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}m)\kern{0.17em}\overset{.}{0} \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}\overset{.}{0}\kern{0.17em}β^+ &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}m)\kern{0.17em}(Φ^{n^+}\kern{0.17em}F\kern{0.17em}(\lim f)\kern{0.17em}\overset{.}{0}\kern{0.17em}β)^+\kern{0.17em}\overset{.}{0} \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}α\kern{0.17em}\overset{.}{0}\kern{0.17em}(\lim g) &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}α\kern{0.17em}\overset{.}{0}\kern{0.17em}(g\kern{0.17em}m)
\end{aligned}
</span></p>
<p>其中第五条要求前提 <span class="math inline">F\kern{0.17em}(\lim g) = \lim λm,F\kern{0.17em}(g\kern{0.17em}m)</span>.</p>
<pre class="Agda"><a id="Φ-s-ż-z"></a><a id="10358" href="Veblen.Finitary.html#10358" class="Function">Φ-s-ż-z</a> <a id="10367" class="Symbol">:</a> <a id="10369" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10371" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10373" class="Symbol">((</a><a id="10375" class="InductiveConstructor">suc</a> <a id="10379" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10380" class="Symbol">))</a> <a id="10383" class="Symbol">(</a><a id="10384" class="InductiveConstructor">suc</a> <a id="10388" href="Veblen.Base.html#4422" class="Generalizable">α</a><a id="10389" class="Symbol">)</a> <a id="10391" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10395" class="Number">0</a> <a id="10397" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10399" href="Veblen.Base.html#12958" class="Function">iterω</a> <a id="10405" class="Symbol">(λ</a> <a id="10408" href="Veblen.Finitary.html#10408" class="Bound">β</a> <a id="10410" class="Symbol">→</a> <a id="10412" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10414" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10416" class="Symbol">(_)</a> <a id="10420" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="10422" href="Veblen.Finitary.html#10408" class="Bound">β</a> <a id="10424" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a><a id="10426" class="Symbol">)</a> <a id="10428" class="Number">0</a>
<a id="10430" href="Veblen.Finitary.html#10358" class="Function">Φ-s-ż-z</a> <a id="10439" class="Symbol">=</a> <a id="10441" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-s-ż-s"></a><a id="10447" href="Veblen.Finitary.html#10447" class="Function">Φ-s-ż-s</a> <a id="10456" class="Symbol">:</a> <a id="10458" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10460" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10462" class="Symbol">((</a><a id="10464" class="InductiveConstructor">suc</a> <a id="10468" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10469" class="Symbol">))</a> <a id="10472" class="Symbol">(</a><a id="10473" class="InductiveConstructor">suc</a> <a id="10477" href="Veblen.Base.html#4422" class="Generalizable">α</a><a id="10478" class="Symbol">)</a> <a id="10480" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10484" class="InductiveConstructor">suc</a> <a id="10488" href="Veblen.Base.html#4424" class="Generalizable">β</a> <a id="10490" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10492" href="Veblen.Base.html#12958" class="Function">iterω</a> <a id="10498" class="Symbol">(λ</a> <a id="10501" href="Veblen.Finitary.html#10501" class="Bound">β</a> <a id="10503" class="Symbol">→</a> <a id="10505" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10507" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10509" class="Symbol">(_)</a> <a id="10513" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="10515" href="Veblen.Finitary.html#10501" class="Bound">β</a> <a id="10517" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a><a id="10519" class="Symbol">)</a> <a id="10521" class="Symbol">(</a><a id="10522" class="InductiveConstructor">suc</a> <a id="10526" class="Symbol">(</a><a id="10527" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10529" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10531" class="Symbol">(_)</a> <a id="10535" class="Symbol">(</a><a id="10536" class="InductiveConstructor">suc</a> <a id="10540" href="Veblen.Base.html#4422" class="Generalizable">α</a><a id="10541" class="Symbol">)</a> <a id="10543" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10547" href="Veblen.Base.html#4424" class="Generalizable">β</a><a id="10548" class="Symbol">))</a>
<a id="10551" href="Veblen.Finitary.html#10447" class="Function">Φ-s-ż-s</a> <a id="10560" class="Symbol">=</a> <a id="10562" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-l-ż-z"></a><a id="10568" href="Veblen.Finitary.html#10568" class="Function">Φ-l-ż-z</a> <a id="10577" class="Symbol">:</a> <a id="10579" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10581" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10583" class="Symbol">((</a><a id="10585" class="InductiveConstructor">suc</a> <a id="10589" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10590" class="Symbol">))</a> <a id="10593" class="Symbol">(</a><a id="10594" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10598" href="Veblen.Base.html#10713" class="Generalizable">f</a><a id="10599" class="Symbol">)</a> <a id="10601" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10605" class="Number">0</a> <a id="10607" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10609" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10613" class="Symbol">λ</a> <a id="10615" href="Veblen.Finitary.html#10615" class="Bound">m</a> <a id="10617" class="Symbol">→</a> <a id="10619" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10621" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10623" class="Symbol">((</a><a id="10625" class="InductiveConstructor">suc</a> <a id="10629" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10630" class="Symbol">))</a> <a id="10633" class="Symbol">(</a><a id="10634" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="10636" href="Veblen.Finitary.html#10615" class="Bound">m</a><a id="10637" class="Symbol">)</a> <a id="10639" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="10642" href="Veblen.Finitary.html#10568" class="Function">Φ-l-ż-z</a> <a id="10651" class="Symbol">=</a> <a id="10653" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-l-ż-s"></a><a id="10659" href="Veblen.Finitary.html#10659" class="Function">Φ-l-ż-s</a> <a id="10668" class="Symbol">:</a> <a id="10670" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10672" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10674" class="Symbol">((</a><a id="10676" class="InductiveConstructor">suc</a> <a id="10680" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10681" class="Symbol">))</a> <a id="10684" class="Symbol">(</a><a id="10685" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10689" href="Veblen.Base.html#10713" class="Generalizable">f</a><a id="10690" class="Symbol">)</a> <a id="10692" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10696" class="InductiveConstructor">suc</a> <a id="10700" href="Veblen.Base.html#4424" class="Generalizable">β</a> <a id="10702" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10704" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10708" class="Symbol">λ</a> <a id="10710" href="Veblen.Finitary.html#10710" class="Bound">m</a> <a id="10712" class="Symbol">→</a> <a id="10714" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10716" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10718" class="Symbol">(_)</a> <a id="10722" class="Symbol">(</a><a id="10723" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="10725" href="Veblen.Finitary.html#10710" class="Bound">m</a><a id="10726" class="Symbol">)</a> <a id="10728" class="Symbol">(</a><a id="10729" class="InductiveConstructor">suc</a> <a id="10733" class="Symbol">(</a><a id="10734" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10736" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10738" class="Symbol">(_)</a> <a id="10742" class="Symbol">(</a><a id="10743" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10747" href="Veblen.Base.html#10713" class="Generalizable">f</a><a id="10748" class="Symbol">)</a> <a id="10750" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10754" href="Veblen.Base.html#4424" class="Generalizable">β</a><a id="10755" class="Symbol">))</a> <a id="10758" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="10761" href="Veblen.Finitary.html#10659" class="Function">Φ-l-ż-s</a> <a id="10770" class="Symbol">=</a> <a id="10772" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-α-ż-l"></a><a id="10778" href="Veblen.Finitary.html#10778" class="Function">Φ-α-ż-l</a> <a id="10787" class="Symbol">:</a> <a id="10789" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10791" class="Symbol">(</a><a id="10792" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10796" href="Veblen.Base.html#10715" class="Generalizable">g</a><a id="10797" class="Symbol">)</a> <a id="10799" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10801" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10805" class="Symbol">(λ</a> <a id="10808" href="Veblen.Finitary.html#10808" class="Bound">m</a> <a id="10810" class="Symbol">→</a> <a id="10812" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10814" class="Symbol">(</a><a id="10815" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="10817" href="Veblen.Finitary.html#10808" class="Bound">m</a><a id="10818" class="Symbol">))</a>
  <a id="10823" class="Symbol">→</a> <a id="10825" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10827" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10829" class="Symbol">((</a><a id="10831" class="InductiveConstructor">suc</a> <a id="10835" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10836" class="Symbol">))</a> <a id="10839" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="10841" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10845" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10849" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="10851" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10853" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10857" class="Symbol">λ</a> <a id="10859" href="Veblen.Finitary.html#10859" class="Bound">m</a> <a id="10861" class="Symbol">→</a> <a id="10863" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="10865" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="10867" class="Symbol">((</a><a id="10869" class="InductiveConstructor">suc</a> <a id="10873" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="10874" class="Symbol">))</a> <a id="10877" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="10879" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="10883" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="10885" href="Veblen.Finitary.html#10859" class="Bound">m</a>
<a id="10887" href="Veblen.Finitary.html#10778" class="Function">Φ-α-ż-l</a> <a id="10896" class="Symbol">{</a><a id="10897" class="Argument">α</a> <a id="10899" class="Symbol">=</a> <a id="10901" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="10905" class="Symbol">}</a> <a id="10907" class="Symbol">=</a> <a id="10909" href="Function.Base.html#704" class="Function">id</a>
<a id="10912" href="Veblen.Finitary.html#10778" class="Function">Φ-α-ż-l</a> <a id="10921" class="Symbol">{</a><a id="10922" class="Argument">α</a> <a id="10924" class="Symbol">=</a> <a id="10926" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="10930" class="Symbol">_}</a> <a id="10933" class="Symbol">_</a> <a id="10935" class="Symbol">=</a> <a id="10937" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="10942" href="Veblen.Finitary.html#10778" class="Function">Φ-α-ż-l</a> <a id="10951" class="Symbol">{</a><a id="10952" class="Argument">α</a> <a id="10954" class="Symbol">=</a> <a id="10956" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="10960" class="Symbol">_}</a> <a id="10963" class="Symbol">_</a> <a id="10965" class="Symbol">=</a> <a id="10967" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>推论</strong> <span class="math inline">(\mathcal{α,s,Z,β})</span></p>
<p><span class="math display">
φ_{n^{++}}\kern{0.17em}α\kern{0.17em}β^+\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}=
\text{fixpt}\kern{0.17em}λγ,φ_{n^{++}}\kern{0.17em}α\kern{0.17em}β\kern{0.17em}γ\kern{0.17em}\overset{.}{0}
</span></p>
<p><strong>(证明)</strong> 讨论 <span class="math inline">α</span>, 由定理 <span class="math inline">(\mathcal{S,Z,α})</span> 即得. ∎</p>
<pre class="Agda"><a id="φ-α-s-ż-β"></a><a id="11284" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11295" class="Symbol">:</a> <a id="11297" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="11299" class="Symbol">((</a><a id="11301" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="11304" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="11305" class="Symbol">))</a> <a id="11308" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="11310" class="Symbol">(</a><a id="11311" class="InductiveConstructor">suc</a> <a id="11315" href="Veblen.Base.html#4424" class="Generalizable">β</a><a id="11316" class="Symbol">)</a> <a id="11318" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,_</a> <a id="11323" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11325" href="Veblen.Base.html#15054" class="Function">fixpt</a> <a id="11331" class="Symbol">λ</a> <a id="11333" href="Veblen.Finitary.html#11333" class="Bound">γ</a> <a id="11335" class="Symbol">→</a> <a id="11337" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="11339" class="Symbol">((</a><a id="11341" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="11344" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="11345" class="Symbol">))</a> <a id="11348" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="11350" href="Veblen.Base.html#4424" class="Generalizable">β</a> <a id="11352" href="Veblen.Finitary.html#11333" class="Bound">γ</a> <a id="11354" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="11357" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11368" class="Symbol">{</a><a id="11369" class="Argument">n</a> <a id="11371" class="Symbol">=</a> <a id="11373" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="11377" class="Symbol">}</a> <a id="11379" class="Symbol">{</a><a id="11380" class="Argument">α</a> <a id="11382" class="Symbol">=</a> <a id="11384" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="11388" class="Symbol">}</a> <a id="11390" class="Symbol">=</a> <a id="11392" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11397" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11408" class="Symbol">{</a><a id="11409" class="Argument">n</a> <a id="11411" class="Symbol">=</a> <a id="11413" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="11417" class="Symbol">}</a> <a id="11419" class="Symbol">{</a><a id="11420" class="Argument">α</a> <a id="11422" class="Symbol">=</a> <a id="11424" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="11428" class="Symbol">_}</a> <a id="11431" class="Symbol">=</a> <a id="11433" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11438" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11449" class="Symbol">{</a><a id="11450" class="Argument">n</a> <a id="11452" class="Symbol">=</a> <a id="11454" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="11458" class="Symbol">}</a> <a id="11460" class="Symbol">{</a><a id="11461" class="Argument">α</a> <a id="11463" class="Symbol">=</a> <a id="11465" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="11469" class="Symbol">_}</a> <a id="11472" class="Symbol">=</a> <a id="11474" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11479" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11490" class="Symbol">{</a><a id="11491" class="Argument">n</a> <a id="11493" class="Symbol">=</a> <a id="11495" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11499" href="Veblen.Finitary.html#11499" class="Bound">n</a><a id="11500" class="Symbol">}</a> <a id="11502" class="Symbol">{</a><a id="11503" class="Argument">α</a> <a id="11505" class="Symbol">=</a> <a id="11507" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="11511" class="Symbol">}</a> <a id="11513" class="Symbol">=</a> <a id="11515" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
<a id="11522" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11533" class="Symbol">{</a><a id="11534" class="Argument">n</a> <a id="11536" class="Symbol">=</a> <a id="11538" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11542" href="Veblen.Finitary.html#11542" class="Bound">n</a><a id="11543" class="Symbol">}</a> <a id="11545" class="Symbol">{</a><a id="11546" class="Argument">α</a> <a id="11548" class="Symbol">=</a> <a id="11550" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="11554" class="Symbol">_}</a> <a id="11557" class="Symbol">=</a> <a id="11559" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
<a id="11566" href="Veblen.Finitary.html#11284" class="Function">φ-α-s-ż-β</a> <a id="11577" class="Symbol">{</a><a id="11578" class="Argument">n</a> <a id="11580" class="Symbol">=</a> <a id="11582" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="11586" href="Veblen.Finitary.html#11586" class="Bound">n</a><a id="11587" class="Symbol">}</a> <a id="11589" class="Symbol">{</a><a id="11590" class="Argument">α</a> <a id="11592" class="Symbol">=</a> <a id="11594" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="11598" class="Symbol">_}</a> <a id="11601" class="Symbol">=</a> <a id="11603" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
</pre>
<p><strong>推论</strong> <span class="math inline">(\mathcal{α,l,Z,β})</span></p>
<p><span class="math display">
φ_{n^{++}}\kern{0.17em}α\kern{0.17em}(\lim f)\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}=
\text{jump}\kern{0.17em}λδ,\limλm,φ_{n^{++}}\kern{0.17em}α\kern{0.17em}(f\kern{0.17em}m)\kern{0.17em}δ\kern{0.17em}\overset{.}{0}
</span></p>
<p><strong>(证明)</strong> 讨论 <span class="math inline">α</span>, 由定理 <span class="math inline">(\mathcal{S,Z,α})</span> 即得. ∎</p>
<pre class="Agda"><a id="φ-α-l-ż-β"></a><a id="11949" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="11960" class="Symbol">:</a> <a id="11962" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="11964" class="Symbol">((</a><a id="11966" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="11969" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="11970" class="Symbol">))</a> <a id="11973" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="11975" class="Symbol">(</a><a id="11976" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="11980" href="Veblen.Base.html#10713" class="Generalizable">f</a><a id="11981" class="Symbol">)</a> <a id="11983" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,_</a> <a id="11988" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11990" href="Veblen.Base.html#13549" class="Function">jump</a> <a id="11995" class="Symbol">λ</a> <a id="11997" href="Veblen.Finitary.html#11997" class="Bound">δ</a> <a id="11999" class="Symbol">→</a> <a id="12001" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="12005" class="Symbol">λ</a> <a id="12007" href="Veblen.Finitary.html#12007" class="Bound">m</a> <a id="12009" class="Symbol">→</a> <a id="12011" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="12013" class="Symbol">((</a><a id="12015" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="12018" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="12019" class="Symbol">))</a> <a id="12022" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="12024" class="Symbol">(</a><a id="12025" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="12027" href="Veblen.Finitary.html#12007" class="Bound">m</a><a id="12028" class="Symbol">)</a> <a id="12030" href="Veblen.Finitary.html#11997" class="Bound">δ</a> <a id="12032" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
<a id="12035" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12046" class="Symbol">{</a><a id="12047" class="Argument">n</a> <a id="12049" class="Symbol">=</a> <a id="12051" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="12055" class="Symbol">}</a> <a id="12057" class="Symbol">{</a><a id="12058" class="Argument">α</a> <a id="12060" class="Symbol">=</a> <a id="12062" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="12066" class="Symbol">}</a> <a id="12068" class="Symbol">=</a> <a id="12070" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12075" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12086" class="Symbol">{</a><a id="12087" class="Argument">n</a> <a id="12089" class="Symbol">=</a> <a id="12091" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="12095" class="Symbol">}</a> <a id="12097" class="Symbol">{</a><a id="12098" class="Argument">α</a> <a id="12100" class="Symbol">=</a> <a id="12102" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="12106" class="Symbol">_}</a> <a id="12109" class="Symbol">=</a> <a id="12111" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12116" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12127" class="Symbol">{</a><a id="12128" class="Argument">n</a> <a id="12130" class="Symbol">=</a> <a id="12132" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="12136" class="Symbol">}</a> <a id="12138" class="Symbol">{</a><a id="12139" class="Argument">α</a> <a id="12141" class="Symbol">=</a> <a id="12143" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="12147" class="Symbol">_}</a> <a id="12150" class="Symbol">=</a> <a id="12152" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12157" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12168" class="Symbol">{</a><a id="12169" class="Argument">n</a> <a id="12171" class="Symbol">=</a> <a id="12173" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12177" href="Veblen.Finitary.html#12177" class="Bound">n</a><a id="12178" class="Symbol">}</a> <a id="12180" class="Symbol">{</a><a id="12181" class="Argument">α</a> <a id="12183" class="Symbol">=</a> <a id="12185" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="12189" class="Symbol">}</a> <a id="12191" class="Symbol">=</a> <a id="12193" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
<a id="12200" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12211" class="Symbol">{</a><a id="12212" class="Argument">n</a> <a id="12214" class="Symbol">=</a> <a id="12216" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12220" href="Veblen.Finitary.html#12220" class="Bound">n</a><a id="12221" class="Symbol">}</a> <a id="12223" class="Symbol">{</a><a id="12224" class="Argument">α</a> <a id="12226" class="Symbol">=</a> <a id="12228" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="12232" class="Symbol">_}</a> <a id="12235" class="Symbol">=</a> <a id="12237" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
<a id="12244" href="Veblen.Finitary.html#11949" class="Function">φ-α-l-ż-β</a> <a id="12255" class="Symbol">{</a><a id="12256" class="Argument">n</a> <a id="12258" class="Symbol">=</a> <a id="12260" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12264" href="Veblen.Finitary.html#12264" class="Bound">n</a><a id="12265" class="Symbol">}</a> <a id="12267" class="Symbol">{</a><a id="12268" class="Argument">α</a> <a id="12270" class="Symbol">=</a> <a id="12272" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="12276" class="Symbol">_}</a> <a id="12279" class="Symbol">=</a> <a id="12281" href="Veblen.Finitary.html#9007" class="Function">Φ-ż-α</a>
</pre>
<p><strong>推论</strong> <span class="math inline">(\mathcal{α,Z,l})</span></p>
<p><span class="math display">
φ_{n^{++}}\kern{0.17em}α\kern{0.17em}0\kern{0.17em}(\lim g)=\limλm,φ_{n^{++}}\kern{0.17em}α\kern{0.17em}0\kern{0.17em}(g\kern{0.17em}m)
</span></p>
<p><strong>(证明)</strong> 由定理 <span class="math inline">(\mathcal{S,α,Z,l})</span> 即得. ∎</p>
<pre class="Agda"><a id="φ-α-ż-l"></a><a id="12514" href="Veblen.Finitary.html#12514" class="Function">φ-α-ż-l</a> <a id="12523" class="Symbol">:</a> <a id="12525" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="12527" class="Symbol">((</a><a id="12529" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="12532" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="12533" class="Symbol">))</a> <a id="12536" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="12538" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="12542" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="12546" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="12548" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12550" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="12554" class="Symbol">λ</a> <a id="12556" href="Veblen.Finitary.html#12556" class="Bound">m</a> <a id="12558" class="Symbol">→</a> <a id="12560" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="12562" class="Symbol">((</a><a id="12564" href="Veblen.Base.html#5549" class="InductiveConstructor">2+</a> <a id="12567" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="12568" class="Symbol">))</a> <a id="12571" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="12573" href="Veblen.Finitary.html#2969" class="Function Operator">0̇,</a> <a id="12577" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="12579" href="Veblen.Finitary.html#12556" class="Bound">m</a>
<a id="12581" href="Veblen.Finitary.html#12514" class="Function">φ-α-ż-l</a> <a id="12590" class="Symbol">=</a> <a id="12592" href="Veblen.Finitary.html#10778" class="Function">Φ-α-ż-l</a> <a id="12601" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p>类似 <span class="math inline">(\mathcal{S,Z,α})</span>, 我们还可以有</p>
<p><strong>引理</strong> <span class="math inline">(\mathcal{S,Z,α,β})</span></p>
<p><span class="math display">
Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}\underline{\kern{0.5em}}\kern{0.17em}\underline{\kern{0.5em}} = Φ^{1}\kern{0.17em}F
</span></p>
<p><strong>(证明)</strong> 归纳 <span class="math inline">n</span> 即得. ∎</p>
<pre class="Agda"><a id="Φ-ż-α-β"></a><a id="12856" href="Veblen.Finitary.html#12856" class="Function">Φ-ż-α-β</a> <a id="12865" class="Symbol">:</a> <a id="12867" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="12869" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="12871" class="Symbol">((</a><a id="12873" class="InductiveConstructor">suc</a> <a id="12877" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="12878" class="Symbol">))</a> <a id="12881" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,_,_</a> <a id="12888" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12890" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="12892" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="12894" class="Symbol">(</a><a id="12895" class="Number">1</a><a id="12896" class="Symbol">)</a>
<a id="12898" href="Veblen.Finitary.html#12856" class="Function">Φ-ż-α-β</a> <a id="12907" class="Symbol">{</a><a id="12908" class="Argument">n</a> <a id="12910" class="Symbol">=</a> <a id="12912" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="12916" class="Symbol">}</a> <a id="12918" class="Symbol">=</a> <a id="12920" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12925" href="Veblen.Finitary.html#12856" class="Function">Φ-ż-α-β</a> <a id="12934" class="Symbol">{</a><a id="12935" class="Argument">n</a> <a id="12937" class="Symbol">=</a> <a id="12939" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12943" href="Veblen.Finitary.html#12943" class="Bound">n</a><a id="12944" class="Symbol">}</a> <a id="12946" class="Symbol">=</a> <a id="12948" href="Veblen.Finitary.html#12856" class="Function">Φ-ż-α-β</a> <a id="12957" class="Symbol">{</a><a id="12958" class="Argument">n</a> <a id="12960" class="Symbol">=</a> <a id="12962" href="Veblen.Finitary.html#12943" class="Bound">n</a><a id="12963" class="Symbol">}</a>
<a id="12965" class="Symbol">{-#</a> <a id="12969" class="Keyword">REWRITE</a> <a id="12977" href="Veblen.Finitary.html#12856" class="Function">Φ-ż-α-β</a> <a id="12986" class="Symbol">#-}</a>
</pre>
<p><strong>定理</strong> 计算模式</p>
<p><span class="math display">
\begin{aligned}
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α^+\kern{0.17em}\overset{.}{0} &amp;=&amp; (Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α\kern{0.17em}\underline{\kern{0.5em}})^ω\kern{0.17em}0 \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α^+\kern{0.17em}β^+ &amp;=&amp; (Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α\kern{0.17em}\underline{\kern{0.5em}})^ω\kern{0.17em}(Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α^+\kern{0.17em}β)^+ \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}(\lim f)\kern{0.17em}0 &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}(f\kern{0.17em}m)\kern{0.17em}0 \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}(\lim f)\kern{0.17em}β^+ &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}(f\kern{0.17em}m)\kern{0.17em}(Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}(\lim f)\kern{0.17em}β)^+ \\
&amp;Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α\kern{0.17em}(\lim g) &amp;=&amp; \lim λm,Φ^{n^+}\kern{0.17em}F\kern{0.17em}\overset{.}{0}\kern{0.17em}α\kern{0.17em}(g\kern{0.17em}m)
\end{aligned}
</span></p>
<p>其中第五条要求前提 <span class="math inline">F\kern{0.17em}(\lim g) = \lim λm,F\kern{0.17em}(g\kern{0.17em}m)</span>.</p>
<pre class="Agda"><a id="Φ-ż-s-0"></a><a id="14302" href="Veblen.Finitary.html#14302" class="Function">Φ-ż-s-0</a> <a id="14311" class="Symbol">:</a> <a id="14313" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14315" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14317" class="Symbol">((</a><a id="14319" class="InductiveConstructor">suc</a> <a id="14323" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14324" class="Symbol">))</a> <a id="14327" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14331" class="InductiveConstructor">suc</a> <a id="14335" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14337" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14339" class="Number">0</a> <a id="14341" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14343" href="Veblen.Base.html#12958" class="Function">iterω</a> <a id="14349" class="Symbol">(</a><a id="14350" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14352" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14354" class="Symbol">((</a><a id="14356" class="InductiveConstructor">suc</a> <a id="14360" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14361" class="Symbol">))</a> <a id="14364" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14368" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14370" href="Veblen.Finitary.html#3712" class="Function Operator">,_</a><a id="14372" class="Symbol">)</a> <a id="14374" class="Number">0</a>
<a id="14376" href="Veblen.Finitary.html#14302" class="Function">Φ-ż-s-0</a> <a id="14385" class="Symbol">=</a> <a id="14387" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-ż-s-s"></a><a id="14393" href="Veblen.Finitary.html#14393" class="Function">Φ-ż-s-s</a> <a id="14402" class="Symbol">:</a> <a id="14404" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14406" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14408" class="Symbol">((</a><a id="14410" class="InductiveConstructor">suc</a> <a id="14414" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14415" class="Symbol">))</a> <a id="14418" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14422" class="InductiveConstructor">suc</a> <a id="14426" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14428" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14430" class="InductiveConstructor">suc</a> <a id="14434" href="Veblen.Base.html#4424" class="Generalizable">β</a> <a id="14436" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14438" href="Veblen.Base.html#12958" class="Function">iterω</a> <a id="14444" class="Symbol">(</a><a id="14445" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14447" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14449" class="Symbol">((</a><a id="14451" class="InductiveConstructor">suc</a> <a id="14455" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14456" class="Symbol">))</a> <a id="14459" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14463" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14465" href="Veblen.Finitary.html#3712" class="Function Operator">,_</a><a id="14467" class="Symbol">)</a> <a id="14469" class="Symbol">(</a><a id="14470" class="InductiveConstructor">suc</a> <a id="14474" class="Symbol">(</a><a id="14475" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14477" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14479" class="Symbol">((</a><a id="14481" class="InductiveConstructor">suc</a> <a id="14485" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14486" class="Symbol">))</a> <a id="14489" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14493" class="Symbol">(</a><a id="14494" class="InductiveConstructor">suc</a> <a id="14498" href="Veblen.Base.html#4422" class="Generalizable">α</a><a id="14499" class="Symbol">)</a> <a id="14501" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14503" href="Veblen.Base.html#4424" class="Generalizable">β</a><a id="14504" class="Symbol">))</a>
<a id="14507" href="Veblen.Finitary.html#14393" class="Function">Φ-ż-s-s</a> <a id="14516" class="Symbol">=</a> <a id="14518" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-ż-l-0"></a><a id="14524" href="Veblen.Finitary.html#14524" class="Function">Φ-ż-l-0</a> <a id="14533" class="Symbol">:</a> <a id="14535" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14537" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14539" class="Symbol">((</a><a id="14541" class="InductiveConstructor">suc</a> <a id="14545" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14546" class="Symbol">))</a> <a id="14549" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14553" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14557" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="14559" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14561" class="Number">0</a> <a id="14563" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14565" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14569" class="Symbol">λ</a> <a id="14571" href="Veblen.Finitary.html#14571" class="Bound">m</a> <a id="14573" class="Symbol">→</a> <a id="14575" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14577" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14579" class="Symbol">((</a><a id="14581" class="InductiveConstructor">suc</a> <a id="14585" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14586" class="Symbol">))</a> <a id="14589" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14593" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="14595" href="Veblen.Finitary.html#14571" class="Bound">m</a> <a id="14597" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14599" class="Number">0</a>
<a id="14601" href="Veblen.Finitary.html#14524" class="Function">Φ-ż-l-0</a> <a id="14610" class="Symbol">=</a> <a id="14612" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-ż-l-s"></a><a id="14618" href="Veblen.Finitary.html#14618" class="Function">Φ-ż-l-s</a> <a id="14627" class="Symbol">:</a> <a id="14629" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14631" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14633" class="Symbol">((</a><a id="14635" class="InductiveConstructor">suc</a> <a id="14639" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14640" class="Symbol">))</a> <a id="14643" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14647" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14651" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="14653" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14655" class="InductiveConstructor">suc</a> <a id="14659" href="Veblen.Base.html#4424" class="Generalizable">β</a> <a id="14661" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14663" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14667" class="Symbol">λ</a> <a id="14669" href="Veblen.Finitary.html#14669" class="Bound">m</a> <a id="14671" class="Symbol">→</a> <a id="14673" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14675" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14677" class="Symbol">((</a><a id="14679" class="InductiveConstructor">suc</a> <a id="14683" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14684" class="Symbol">))</a> <a id="14687" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14691" href="Veblen.Base.html#10713" class="Generalizable">f</a> <a id="14693" href="Veblen.Finitary.html#14669" class="Bound">m</a> <a id="14695" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14697" class="InductiveConstructor">suc</a> <a id="14701" class="Symbol">(</a><a id="14702" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14704" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14706" class="Symbol">((</a><a id="14708" class="InductiveConstructor">suc</a> <a id="14712" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14713" class="Symbol">))</a> <a id="14716" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14720" class="Symbol">(</a><a id="14721" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14725" href="Veblen.Base.html#10713" class="Generalizable">f</a><a id="14726" class="Symbol">)</a> <a id="14728" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14730" href="Veblen.Base.html#4424" class="Generalizable">β</a><a id="14731" class="Symbol">)</a>
<a id="14733" href="Veblen.Finitary.html#14618" class="Function">Φ-ż-l-s</a> <a id="14742" class="Symbol">=</a> <a id="14744" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="Φ-ż-α-l"></a><a id="14750" href="Veblen.Finitary.html#14750" class="Function">Φ-ż-α-l</a> <a id="14759" class="Symbol">:</a> <a id="14761" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14763" class="Symbol">(</a><a id="14764" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14768" href="Veblen.Base.html#10715" class="Generalizable">g</a><a id="14769" class="Symbol">)</a> <a id="14771" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14773" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14777" class="Symbol">(λ</a> <a id="14780" href="Veblen.Finitary.html#14780" class="Bound">m</a> <a id="14782" class="Symbol">→</a> <a id="14784" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14786" class="Symbol">(</a><a id="14787" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="14789" href="Veblen.Finitary.html#14780" class="Bound">m</a><a id="14790" class="Symbol">))</a>
  <a id="14795" class="Symbol">→</a> <a id="14797" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14799" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14801" class="Symbol">((</a><a id="14803" class="InductiveConstructor">suc</a> <a id="14807" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14808" class="Symbol">))</a> <a id="14811" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14815" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14817" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14819" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14823" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="14825" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14827" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14831" class="Symbol">λ</a> <a id="14833" href="Veblen.Finitary.html#14833" class="Bound">m</a> <a id="14835" class="Symbol">→</a> <a id="14837" href="Veblen.Finitary.html#5154" class="Function">Φ</a> <a id="14839" href="Veblen.Base.html#10697" class="Generalizable">F</a> <a id="14841" class="Symbol">((</a><a id="14843" class="InductiveConstructor">suc</a> <a id="14847" href="Veblen.Base.html#4436" class="Generalizable">n</a><a id="14848" class="Symbol">))</a> <a id="14851" href="Veblen.Finitary.html#3712" class="Function Operator">0̇,</a> <a id="14855" href="Veblen.Base.html#4422" class="Generalizable">α</a> <a id="14857" href="Veblen.Finitary.html#3712" class="Function Operator">,</a> <a id="14859" href="Veblen.Base.html#10715" class="Generalizable">g</a> <a id="14861" href="Veblen.Finitary.html#14833" class="Bound">m</a>
<a id="14863" href="Veblen.Finitary.html#14750" class="Function">Φ-ż-α-l</a> <a id="14872" class="Symbol">{</a><a id="14873" class="Argument">α</a> <a id="14875" class="Symbol">=</a> <a id="14877" href="Veblen.Base.html#3447" class="InductiveConstructor">zero</a><a id="14881" class="Symbol">}</a> <a id="14883" class="Symbol">=</a> <a id="14885" href="Function.Base.html#704" class="Function">id</a>
<a id="14888" href="Veblen.Finitary.html#14750" class="Function">Φ-ż-α-l</a> <a id="14897" class="Symbol">{</a><a id="14898" class="Argument">α</a> <a id="14900" class="Symbol">=</a> <a id="14902" href="Veblen.Base.html#3460" class="InductiveConstructor">suc</a> <a id="14906" class="Symbol">_}</a> <a id="14909" class="Symbol">_</a> <a id="14911" class="Symbol">=</a> <a id="14913" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="14918" href="Veblen.Finitary.html#14750" class="Function">Φ-ż-α-l</a> <a id="14927" class="Symbol">{</a><a id="14928" class="Argument">α</a> <a id="14930" class="Symbol">=</a> <a id="14932" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="14936" class="Symbol">_}</a> <a id="14939" class="Symbol">_</a> <a id="14941" class="Symbol">=</a> <a id="14943" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="svo">SVO</h2>
<p><strong>定义</strong> 有限元Veblen序数的能力极限叫做 SVO (<del>Subject–Verb–Object</del>(不是) Small Veblen Ordinal).</p>
<p><span class="math display">
\begin{aligned}
\text{SVO} := &amp;\lim λ n,φ_n\kern{0.17em}1\kern{0.17em}\overset{.}{0} \\
= &amp;\lim\kern{0.17em}(φ_0(1),φ_1(1,0),φ_2(1,0,0),...)
\end{aligned}
</span></p>
<pre class="Agda"><a id="SVO"></a><a id="15214" href="Veblen.Finitary.html#15214" class="Function">SVO</a> <a id="15218" class="Symbol">:</a> <a id="15220" href="Veblen.Base.html#3429" class="Datatype">Ord</a>
<a id="15224" href="Veblen.Finitary.html#15214" class="Function">SVO</a> <a id="15228" class="Symbol">=</a> <a id="15230" href="Veblen.Base.html#3479" class="InductiveConstructor">lim</a> <a id="15234" class="Symbol">λ</a> <a id="15236" href="Veblen.Finitary.html#15236" class="Bound">n</a> <a id="15238" class="Symbol">→</a> <a id="15240" href="Veblen.Finitary.html#6759" class="Function">φ</a> <a id="15242" class="Symbol">(</a><a id="15243" href="Veblen.Finitary.html#15236" class="Bound">n</a><a id="15244" class="Symbol">)</a> <a id="15246" class="Number">1</a> <a id="15248" href="Veblen.Finitary.html#2399" class="Function Operator">0̇</a>
</pre>
<p>一个很大的大数:</p>
<p><span class="math display">
\text{svo}_{99}:=f_\text{SVO}(99)
</span></p>
<pre class="Agda"><a id="svo₉₉"></a><a id="15315" href="Veblen.Finitary.html#15315" class="Function">svo₉₉</a> <a id="15321" class="Symbol">=</a> <a id="15323" href="Veblen.Base.html#5965" class="Function">FGH.f</a> <a id="15329" href="Veblen.Finitary.html#15214" class="Function">SVO</a> <a id="15333" class="Number">99</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
