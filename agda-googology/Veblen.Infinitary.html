<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.4 - 无限元Veblen函数)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.4 - 无限元Veblen函数)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.4---无限元veblen函数" id="toc-形式化大数数学-1.4---无限元veblen函数">形式化大数数学 (1.4 - 无限元Veblen函数)</a>
  <ul>
  <li><a href="#ω元veblen函数" id="toc-ω元veblen函数">ω元Veblen函数</a></li>
  <li><a href="#ω元veblen函数-1" id="toc-ω元veblen函数-1">ω⁺元Veblen函数</a></li>
  <li><a href="#ω元veblen函数-2" id="toc-ω元veblen函数-2">ω⁺⁺元Veblen函数</a></li>
  <li><a href="#ω元veblen函数-3" id="toc-ω元veblen函数-3">2ω元Veblen函数</a></li>
  <li><a href="#ω元veblen函数-4" id="toc-ω元veblen函数-4">(2ω)⁺元Veblen函数</a></li>
  <li><a href="#ω元veblen函数-5" id="toc-ω元veblen函数-5">3ω元Veblen函数</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.4---无限元veblen函数">形式化大数数学 (1.4 - 无限元Veblen函数)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Veblen/Infinitary.lagda.md">Infinitary.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Veblen.Infinitary.html">Infinitary.html</a></p>
</blockquote>
<pre class="Agda"><a id="339" class="Symbol">{-#</a> <a id="343" class="Keyword">OPTIONS</a> <a id="351" class="Pragma">--lossy-unification</a> <a id="371" class="Pragma">--rewriting</a> <a id="383" class="Symbol">#-}</a>
<a id="387" class="Keyword">module</a> <a id="394" href="Veblen.Infinitary.html" class="Module">Veblen.Infinitary</a> <a id="412" class="Keyword">where</a>
<a id="418" class="Keyword">open</a> <a id="423" class="Keyword">import</a> <a id="430" href="Veblen.Basic.html" class="Module">Veblen.Basic</a> <a id="443" class="Keyword">public</a> <a id="450" class="Keyword">hiding</a> <a id="457" class="Symbol">(</a><a id="458" href="Veblen.Basic.html#9520" class="Generalizable">F</a><a id="459" class="Symbol">)</a>
</pre>
<p>本篇要讲的无限元Veblen函数, 并不是超限元或者说序元 (以序数作为元数) Veblen函数. 我们将踏入这个层次, 但还没有完全覆盖. 从有限到超限的过程中, 有一个里程碑式的层级—— <span class="math inline">ω+n</span> 元Veblen函数, 我们称为无限元Veblen函数.</p>
<h2 id="ω元veblen函数">ω元Veblen函数</h2>
<p>我们先来搞清楚: 「什么叫 <span class="math inline">ω</span> 元?」. 首先这决不意味着我们有真无穷的信息, 否则可能就成黑洞了. 也就是说 <span class="math inline">ω</span> 元里的大部分信息是被「压缩」了的. 如何压缩? 就是用上一篇讲的填零操作 <span class="math inline">\overset{.}{0}:A^{→n}→A</span> 压缩的.</p>
<pre class="Agda"><a id="751" class="Keyword">import</a> <a id="758" href="Veblen.Finitary.html" class="Module">Veblen.Finitary</a> <a id="774" class="Symbol">as</a> <a id="777" class="Module">Fin</a>
<a id="781" class="Keyword">open</a> <a id="786" href="Veblen.Finitary.html" class="Module">Fin</a> <a id="790" class="Keyword">using</a> <a id="796" class="Symbol">(</a><a id="797" href="Veblen.Finitary.html#1471" class="Function Operator">_→ⁿ_</a><a id="801" class="Symbol">;</a> <a id="803" href="Veblen.Finitary.html#2384" class="Function Operator">_0̇</a><a id="806" class="Symbol">;</a> <a id="808" href="Veblen.Finitary.html#2954" class="Function Operator">_0̇,_</a><a id="813" class="Symbol">)</a>
</pre>
<p>也就是说, 我们只有有限个非零参数, 而有无限个零参数. 这就是无限元的真相. 确实, 也只有这样, 才能保证可计算性.</p>
<p>回想我们在首篇定义的 <span class="math inline">ω := \lim\text{finord}</span>. 其中的极限 <span class="math inline">\lim</span> 相当于一种原语, 它没有进一步的定义. 类型论的规则只不过是保证它可以对应到一种有限的计算过程 (对角化), 而没有公理保证它里面有无穷多的元素, 也不需要此种保证. 无公理类型论中的一切函数都可以看作是某种真有限的计算过程.</p>
<p>回到 <span class="math inline">ω</span> 元. 上面说到会有无限个零作为参数, 这无限个零肯定不可能排在最前面, 因为这样的话它们就失效了. 也就是说, 必须有一个非零排在无限个零的<strong>前</strong>面. 通常认为, 排在无限之<strong>后</strong>的下一个数是 <span class="math inline">ω^+</span>. 这里的<strong>前后</strong>无关紧要, 可以认为是一回事. 基于此, 我们认为, 其实, 没有 <span class="math inline">ω</span> 元Veblen函数. 无限元Veblen函数应该是从 <span class="math inline">ω^+</span> 元开始的.</p>
<p>或者, 我们也可以认为, <span class="math inline">ω</span> 元Veblen函数其实已经定义完了. 它就是上一篇讲的有限元Veblen函数 <span class="math inline">φ_{n}</span>. 这里违和感的根源在于非形式说法的模糊性. 如果把 <span class="math inline">φ_n</span> 的 <span class="math inline">n</span> 看作是任意给定的 (arbitrary), 那么 <span class="math inline">φ_{n} : \text{Ord}^{n^+}</span> 就是一个真有限元函数. 但如果把 <span class="math inline">n</span> 看作一个变量, 那么我们认为 <span class="math inline">φ_{n} : \Pi_{n:ℕ}\text{Ord}^{n^+}</span> 是一个无限元函数. 这种意义上的 <span class="math inline">φ_{n}</span> 我们特别记作 <span class="math inline">φ_{\lt ω}</span>, 以明确区别.</p>
<p><strong>定义</strong> <span class="math inline">ω</span> 元和 <span class="math inline">ω^+</span> 元序数函数类型</p>
<p><span class="math display">
\begin{aligned}
\text{Ord}^{→ω} &amp;:= \Pi_{n:ℕ}\text{Ord}^{n^+} \\
\text{Ord}^{→ω^+} &amp;:= \text{Ord} → \text{Ord}^{→ω}
\end{aligned}
</span></p>
<pre class="Agda"><a id="Ord→^ω"></a><a id="1702" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a> <a id="Ord→^ω⁺"></a><a id="1709" href="Veblen.Infinitary.html#1709" class="Function">Ord→^ω⁺</a> <a id="1717" class="Symbol">:</a> <a id="1719" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1723" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a> <a id="1730" class="Symbol">=</a> <a id="1732" class="Symbol">∀</a> <a id="1734" class="Symbol">{</a><a id="1735" href="Veblen.Infinitary.html#1735" class="Bound">n</a><a id="1736" class="Symbol">}</a> <a id="1738" class="Symbol">→</a> <a id="1740" href="Veblen.Basic.html#3285" class="Datatype">Ord</a> <a id="1744" href="Veblen.Finitary.html#1471" class="Function Operator">→ⁿ</a> <a id="1747" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1751" href="Veblen.Infinitary.html#1735" class="Bound">n</a>
<a id="1753" href="Veblen.Infinitary.html#1709" class="Function">Ord→^ω⁺</a> <a id="1761" class="Symbol">=</a> <a id="1763" href="Veblen.Basic.html#3285" class="Datatype">Ord</a> <a id="1767" class="Symbol">→</a> <a id="1769" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a>
</pre>
<p><strong>定义</strong> <span class="math inline">ω</span> 元Veblen函数</p>
<p><span class="math display">
φ_{\lt ω} := φ_n : \text{Ord}^{→ω}
</span></p>
<pre class="Agda"><a id="1853" class="Keyword">module</a> <a id="OmegaryVeblen"></a><a id="1860" href="Veblen.Infinitary.html#1860" class="Module">OmegaryVeblen</a> <a id="1874" class="Keyword">where</a>
  <a id="OmegaryVeblen.φ"></a><a id="1882" href="Veblen.Infinitary.html#1882" class="Function">φ</a> <a id="1884" class="Symbol">:</a> <a id="1886" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a>
  <a id="1895" href="Veblen.Infinitary.html#1882" class="Function">φ</a> <a id="1897" class="Symbol">=</a> <a id="1899" href="Veblen.Finitary.html#6565" class="Function">Fin.φ</a>
</pre>
<p>注意我们的下标是一贯的:</p>
<ul>
<li><span class="math inline">φ_{0}</span> 是一元函数</li>
<li><span class="math inline">φ_{1}</span> 是二元函数</li>
<li>…</li>
</ul>
<p>也就是说下标是元数的直接前驱, 但 <span class="math inline">ω</span> 没有直接前驱, 所以 <span class="math inline">ω</span> 元函数的下标不是一个具体的数. 但 <span class="math inline">ω⁺</span> 元函数的下标将是 <span class="math inline">ω</span>.</p>
<ul>
<li><span class="math inline">φ_{\lt ω}</span> 是 <span class="math inline">ω</span> 元函数</li>
<li><span class="math inline">φ_{ω}</span> 是 <span class="math inline">ω⁺</span> 元函数</li>
<li><span class="math inline">φ_{ω⁺}</span> 是 <span class="math inline">ω⁺⁺</span> 元函数</li>
<li>…</li>
</ul>
<h2 id="ω元veblen函数-1">ω⁺元Veblen函数</h2>
<pre class="Agda"><a id="2137" class="Keyword">module</a> <a id="OmegaUnaryVeblen"></a><a id="2144" href="Veblen.Infinitary.html#2144" class="Module">OmegaUnaryVeblen</a> <a id="2161" class="Keyword">where</a>
</pre>
<p><span class="math inline">ω^+</span> 元Veblen函数具有跟一元函数 <span class="math inline">λα,ω^α:\text{Ord}→\text{Ord}</span> 同等的地位, 它是新的「梦的开始」. 也因此, 它的构造是特殊的, 在它之前没有直接参考物. 但我们可以如下考虑:</p>
<p>首先, 参考 <span class="math inline">Φ_n</span> 的类型</p>
<p><span class="math display">
Φ_n : \text{Ord}^{→n^+} → \text{Ord}^{→n^{++}}
</span></p>
<p>对 <span class="math inline">Φ_ω</span> 应该有</p>
<p><span class="math display">
Φ_ω : \text{Ord}^{→ω} → (\text{Ord} → \text{Ord}^{→ω})
</span></p>
<pre class="Agda">  <a id="OmegaUnaryVeblen.Φ"></a><a id="2442" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="2444" class="Symbol">:</a> <a id="2446" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a> <a id="2453" class="Symbol">→</a> <a id="2455" href="Veblen.Basic.html#3285" class="Datatype">Ord</a> <a id="2459" class="Symbol">→</a> <a id="2461" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a>
</pre>
<p>其输入将会是 <span class="math inline">φ_{\lt ω} : \text{Ord}^{→ω}</span>.</p>
<p>其次, 如果我们希望</p>
<p><span class="math display">
φ_{ω}\kern{0.17em}1\kern{0.17em}\overset{.}{0} = \text{SVO} = \lim λn,φ_{n}\kern{0.17em}1\kern{0.17em}\overset{.}{0}
</span></p>
<p>那么 <span class="math inline">Φ_{ω}</span> 的递归定义的后继步骤应该包含 <span class="math inline">\lim</span> 的形式, 且我们知道 <span class="math inline">\lim</span> 必然搭配跳出, 于是有</p>
<p><span class="math display">
\text{jump}_1\kern{0.17em}λβ,\lim λn,φ_{ω,α,n}\kern{0.17em}\beta\kern{0.17em}\overset{.}{0}
</span></p>
<p>其中 <span class="math inline">φ_{ω,α} : \text{Ord}^{→ω}</span> 是递归的上一步的结果. 注意此处的跳出很特殊, 要从 <span class="math inline">1</span> 开始, 而不是通常的 <span class="math inline">0</span> 开始, 以吻合 <span class="math inline">\text{SVO}</span>.</p>
<p>最后, 我们知道 <span class="math inline">Φ_n</span> 迭代的是 <span class="math inline">Φ_{\lt n}</span>, 于是 <span class="math inline">Φ_ω</span> 应该迭代 <span class="math inline">Φ_{\lt ω}</span>, 所以有</p>
<p><span class="math display">
Φ_{\lt ω}(\text{jump}_1\kern{0.17em}λβ,\lim λn,φ_{ω,α,n}\kern{0.17em}\beta\kern{0.17em}\overset{.}{0})
</span></p>
<p>这就是后继步骤的定义. 而极限步骤从通常的定义直接推广即可</p>
<p><span class="math display">
Φ_{\lt ω}(\text{jump}\kern{0.17em}λβ,\lim λn,φ_{ω,f\kern{0.17em}m}[m]\kern{0.17em}\beta\kern{0.17em}\overset{.}{0})
</span></p>
<p>完整写出:</p>
<p><strong>定义</strong> <span class="math inline">Φ_{ω}</span></p>
<p><span class="math display">
\begin{aligned}
Φ_{ω}\kern{0.17em}F &amp;= \text{rec}\kern{0.17em}F \\
&amp;\quad(λφ_{ω,α},Φ_{\lt ω}(\text{jump}_1\kern{0.17em}λβ,\lim λn,φ_{ω,α,n}\kern{0.17em}\beta\kern{0.17em}\overset{.}{0})) \\
&amp;\quad(λφ_{ω,f\kern{0.17em}m},Φ_{\lt ω}(\text{jump}\kern{0.17em}λβ,\lim λn,φ_{ω,f\kern{0.17em}m}[m]\kern{0.17em}\beta\kern{0.17em}\overset{.}{0}))
\end{aligned}
</span></p>
<pre class="Agda">  <a id="3631" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="3633" href="Veblen.Infinitary.html#3633" class="Bound">F</a> <a id="3635" class="Symbol">=</a> <a id="3637" href="Veblen.Basic.html#9066" class="Function">rec</a> <a id="3641" href="Veblen.Infinitary.html#3633" class="Bound">F</a>
    <a id="3647" class="Symbol">(λ</a> <a id="3650" href="Veblen.Infinitary.html#3650" class="Bound">φ-α</a>  <a id="3655" class="Symbol">→</a> <a id="3657" href="Veblen.Finitary.html#5134" class="Function">Fin.Φⁿ</a> <a id="3664" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3666" href="Veblen.Basic.html#12041" class="Function Operator">jump⟨</a> <a id="3672" class="Number">1</a> <a id="3674" href="Veblen.Basic.html#12041" class="Function Operator">⟩</a> <a id="3676" class="Symbol">λ</a> <a id="3678" href="Veblen.Infinitary.html#3678" class="Bound">β</a> <a id="3680" class="Symbol">→</a> <a id="3682" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="3686" class="Symbol">λ</a> <a id="3688" href="Veblen.Infinitary.html#3688" class="Bound">n</a> <a id="3690" class="Symbol">→</a> <a id="3692" href="Veblen.Infinitary.html#3650" class="Bound">φ-α</a> <a id="3696" class="Symbol">{</a><a id="3697" href="Veblen.Infinitary.html#3688" class="Bound">n</a><a id="3698" class="Symbol">}</a> <a id="3700" href="Veblen.Infinitary.html#3678" class="Bound">β</a> <a id="3702" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a><a id="3704" class="Symbol">)</a>
    <a id="3710" class="Symbol">(λ</a> <a id="3713" href="Veblen.Infinitary.html#3713" class="Bound Operator">φ[_]</a> <a id="3718" class="Symbol">→</a> <a id="3720" href="Veblen.Finitary.html#5134" class="Function">Fin.Φⁿ</a> <a id="3727" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3729" href="Veblen.Basic.html#12247" class="Function">jump</a> <a id="3734" class="Symbol">λ</a> <a id="3736" href="Veblen.Infinitary.html#3736" class="Bound">β</a> <a id="3738" class="Symbol">→</a> <a id="3740" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="3744" class="Symbol">λ</a> <a id="3746" href="Veblen.Infinitary.html#3746" class="Bound">n</a> <a id="3748" class="Symbol">→</a> <a id="3750" href="Veblen.Infinitary.html#3713" class="Bound Operator">φ[</a> <a id="3753" href="Veblen.Infinitary.html#3746" class="Bound">n</a> <a id="3755" href="Veblen.Infinitary.html#3713" class="Bound Operator">]</a> <a id="3757" class="Symbol">{</a><a id="3758" href="Veblen.Infinitary.html#3746" class="Bound">n</a><a id="3759" class="Symbol">}</a> <a id="3761" href="Veblen.Infinitary.html#3736" class="Bound">β</a> <a id="3763" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a><a id="3765" class="Symbol">)</a>
</pre>
<pre class="Agda">  <a id="OmegaUnaryVeblen.φ"></a><a id="3782" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3784" class="Symbol">:</a> <a id="3786" href="Veblen.Basic.html#3285" class="Datatype">Ord</a> <a id="3790" class="Symbol">→</a> <a id="3792" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a>
  <a id="3801" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3803" class="Symbol">=</a> <a id="3805" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="3807" href="Veblen.Finitary.html#6565" class="Function">Fin.φ</a>
</pre>
<pre class="Agda">  <a id="OmegaUnaryVeblen.φ-0"></a><a id="3828" href="Veblen.Infinitary.html#3828" class="Function">φ-0</a> <a id="3832" class="Symbol">:</a> <a id="3834" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3836" class="Number">0</a> <a id="3838" class="Symbol">{</a><a id="3839" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="3840" class="Symbol">}</a> <a id="3842" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3844" href="Veblen.Finitary.html#6565" class="Function">Fin.φ</a>
  <a id="3852" href="Veblen.Infinitary.html#3828" class="Function">φ-0</a> <a id="3856" class="Symbol">=</a> <a id="3858" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.φ-1⋯0"></a><a id="3866" href="Veblen.Infinitary.html#3866" class="Function">φ-1⋯0</a> <a id="3872" class="Symbol">:</a> <a id="3874" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3876" class="Number">1</a> <a id="3878" class="Number">0</a> <a id="3880" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3882" href="Veblen.Finitary.html#14760" class="Function">Fin.SVO</a>
  <a id="3892" href="Veblen.Infinitary.html#3866" class="Function">φ-1⋯0</a> <a id="3898" class="Symbol">=</a> <a id="3900" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda">  <a id="OmegaUnaryVeblen.φ-1⋯0-0"></a><a id="3920" href="Veblen.Infinitary.html#3920" class="Function">φ-1⋯0-0</a> <a id="3928" class="Symbol">:</a> <a id="3930" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3932" class="Number">1</a> <a id="3934" class="Number">0</a> <a id="3936" class="Number">0</a> <a id="3938" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3940" href="Veblen.Finitary.html#14760" class="Function">Fin.SVO</a>
  <a id="3950" href="Veblen.Infinitary.html#3920" class="Function">φ-1⋯0-0</a> <a id="3958" class="Symbol">=</a> <a id="3960" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.φ-1⋯0-0-0"></a><a id="3968" href="Veblen.Infinitary.html#3968" class="Function">φ-1⋯0-0-0</a> <a id="3978" class="Symbol">:</a> <a id="3980" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="3982" class="Number">1</a> <a id="3984" class="Number">0</a> <a id="3986" class="Number">0</a> <a id="3988" class="Number">0</a> <a id="3990" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3992" href="Veblen.Finitary.html#14760" class="Function">Fin.SVO</a>
  <a id="4002" href="Veblen.Infinitary.html#3968" class="Function">φ-1⋯0-0-0</a> <a id="4012" class="Symbol">=</a> <a id="4014" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda">  <a id="OmegaUnaryVeblen.φ-1⋯ż-z"></a><a id="4034" href="Veblen.Infinitary.html#4034" class="Function">φ-1⋯ż-z</a> <a id="4043" class="Symbol">:</a> <a id="4045" href="Veblen.Infinitary.html#3782" class="Function">φ</a> <a id="4047" class="Number">1</a> <a id="4049" class="Symbol">{</a><a id="4050" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4051" class="Symbol">}</a> <a id="4053" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4057" class="Number">0</a> <a id="4059" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4061" href="Veblen.Finitary.html#14760" class="Function">Fin.SVO</a>
  <a id="4071" href="Veblen.Infinitary.html#4034" class="Function">φ-1⋯ż-z</a> <a id="4080" class="Symbol">=</a> <a id="4082" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda">  <a id="4102" class="Keyword">private</a> <a id="4110" class="Keyword">variable</a> <a id="4119" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4121" class="Symbol">:</a> <a id="4123" href="Veblen.Infinitary.html#1702" class="Function">Ord→^ω</a>

  <a id="OmegaUnaryVeblen.Φ-s⋯ż-z"></a><a id="4133" href="Veblen.Infinitary.html#4133" class="Function">Φ-s⋯ż-z</a> <a id="4142" class="Symbol">:</a> <a id="4144" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4146" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4148" class="Symbol">(</a><a id="4149" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4153" href="Veblen.Basic.html#4263" class="Generalizable">α</a><a id="4154" class="Symbol">)</a> <a id="4156" class="Symbol">{</a><a id="4157" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4158" class="Symbol">}</a> <a id="4160" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4164" class="Number">0</a> <a id="4166" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4168" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4172" class="Symbol">λ</a> <a id="4174" href="Veblen.Infinitary.html#4174" class="Bound">n</a> <a id="4176" class="Symbol">→</a> <a id="4178" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4180" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4182" href="Veblen.Basic.html#4263" class="Generalizable">α</a> <a id="4184" class="Number">1</a> <a id="4186" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a>
  <a id="4191" href="Veblen.Infinitary.html#4133" class="Function">Φ-s⋯ż-z</a> <a id="4200" class="Symbol">=</a> <a id="4202" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.Φ-s⋯ż-s"></a><a id="4210" href="Veblen.Infinitary.html#4210" class="Function">Φ-s⋯ż-s</a> <a id="4219" class="Symbol">:</a> <a id="4221" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4223" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4225" class="Symbol">(</a><a id="4226" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4230" href="Veblen.Basic.html#4263" class="Generalizable">α</a><a id="4231" class="Symbol">)</a> <a id="4233" class="Symbol">{</a><a id="4234" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4235" class="Symbol">}</a> <a id="4237" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4241" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4245" href="Veblen.Basic.html#4265" class="Generalizable">β</a> <a id="4247" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4249" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4253" class="Symbol">λ</a> <a id="4255" href="Veblen.Infinitary.html#4255" class="Bound">n</a> <a id="4257" class="Symbol">→</a> <a id="4259" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4261" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4263" href="Veblen.Basic.html#4263" class="Generalizable">α</a> <a id="4265" class="Symbol">(</a><a id="4266" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4270" class="Symbol">(</a><a id="4271" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4273" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4275" class="Symbol">(</a><a id="4276" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4280" href="Veblen.Basic.html#4263" class="Generalizable">α</a><a id="4281" class="Symbol">)</a> <a id="4283" class="Symbol">{</a><a id="4284" href="Veblen.Infinitary.html#4255" class="Bound">n</a><a id="4285" class="Symbol">}</a> <a id="4287" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4291" href="Veblen.Basic.html#4265" class="Generalizable">β</a><a id="4292" class="Symbol">))</a> <a id="4295" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a>
  <a id="4300" href="Veblen.Infinitary.html#4210" class="Function">Φ-s⋯ż-s</a> <a id="4309" class="Symbol">=</a> <a id="4311" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.Φ-l⋯ż-z"></a><a id="4319" href="Veblen.Infinitary.html#4319" class="Function">Φ-l⋯ż-z</a> <a id="4328" class="Symbol">:</a> <a id="4330" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4332" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4334" class="Symbol">(</a><a id="4335" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4339" href="Veblen.Basic.html#9536" class="Generalizable">f</a><a id="4340" class="Symbol">)</a> <a id="4342" class="Symbol">{</a><a id="4343" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4344" class="Symbol">}</a> <a id="4346" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4350" class="Number">0</a> <a id="4352" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4354" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4358" class="Symbol">λ</a> <a id="4360" href="Veblen.Infinitary.html#4360" class="Bound">n</a> <a id="4362" class="Symbol">→</a> <a id="4364" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4366" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Veblen.Basic.html#9536" class="Generalizable">f</a> <a id="4371" href="Veblen.Infinitary.html#4360" class="Bound">n</a><a id="4372" class="Symbol">)</a> <a id="4374" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a>
  <a id="4379" href="Veblen.Infinitary.html#4319" class="Function">Φ-l⋯ż-z</a> <a id="4388" class="Symbol">=</a> <a id="4390" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.Φ-l⋯ż-s"></a><a id="4398" href="Veblen.Infinitary.html#4398" class="Function">Φ-l⋯ż-s</a> <a id="4407" class="Symbol">:</a> <a id="4409" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4411" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4413" class="Symbol">(</a><a id="4414" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4418" href="Veblen.Basic.html#9536" class="Generalizable">f</a><a id="4419" class="Symbol">)</a> <a id="4421" class="Symbol">{</a><a id="4422" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4423" class="Symbol">}</a> <a id="4425" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4429" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4433" href="Veblen.Basic.html#4265" class="Generalizable">β</a> <a id="4435" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4437" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4441" class="Symbol">λ</a> <a id="4443" href="Veblen.Infinitary.html#4443" class="Bound">n</a> <a id="4445" class="Symbol">→</a> <a id="4447" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4449" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4451" class="Symbol">(</a><a id="4452" href="Veblen.Basic.html#9536" class="Generalizable">f</a> <a id="4454" href="Veblen.Infinitary.html#4443" class="Bound">n</a><a id="4455" class="Symbol">)</a> <a id="4457" class="Symbol">(</a><a id="4458" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4462" class="Symbol">(</a><a id="4463" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4465" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4467" class="Symbol">(</a><a id="4468" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4472" href="Veblen.Basic.html#9536" class="Generalizable">f</a><a id="4473" class="Symbol">)</a> <a id="4475" class="Symbol">{</a><a id="4476" href="Veblen.Infinitary.html#4443" class="Bound">n</a><a id="4477" class="Symbol">}</a> <a id="4479" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4483" href="Veblen.Basic.html#4265" class="Generalizable">β</a><a id="4484" class="Symbol">))</a> <a id="4487" href="Veblen.Finitary.html#2384" class="Function Operator">0̇</a>
  <a id="4492" href="Veblen.Infinitary.html#4398" class="Function">Φ-l⋯ż-s</a> <a id="4501" class="Symbol">=</a> <a id="4503" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="OmegaUnaryVeblen.Φ-α⋯ż-l"></a><a id="4511" href="Veblen.Infinitary.html#4511" class="Function">Φ-α⋯ż-l</a> <a id="4520" class="Symbol">:</a> <a id="4522" class="Symbol">(</a><a id="4523" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4525" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4527" class="Number">0</a> <a id="4529" class="Symbol">{</a><a id="4530" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4531" class="Symbol">}</a> <a id="4533" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4537" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4541" href="Veblen.Basic.html#9538" class="Generalizable">g</a><a id="4542" class="Symbol">)</a> <a id="4544" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4546" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4550" class="Symbol">(λ</a> <a id="4553" href="Veblen.Infinitary.html#4553" class="Bound">m</a> <a id="4555" class="Symbol">→</a> <a id="4557" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4559" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4561" class="Number">0</a> <a id="4563" class="Symbol">{</a><a id="4564" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4565" class="Symbol">}</a> <a id="4567" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4571" href="Veblen.Basic.html#9538" class="Generalizable">g</a> <a id="4573" href="Veblen.Infinitary.html#4553" class="Bound">m</a><a id="4574" class="Symbol">)</a>
    <a id="4580" class="Symbol">→</a> <a id="4582" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4584" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4586" href="Veblen.Basic.html#4263" class="Generalizable">α</a> <a id="4588" class="Symbol">{</a><a id="4589" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4590" class="Symbol">}</a> <a id="4592" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4596" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4600" href="Veblen.Basic.html#9538" class="Generalizable">g</a> <a id="4602" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4604" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4608" class="Symbol">λ</a> <a id="4610" href="Veblen.Infinitary.html#4610" class="Bound">m</a> <a id="4612" class="Symbol">→</a> <a id="4614" href="Veblen.Infinitary.html#2442" class="Function">Φ</a> <a id="4616" href="Veblen.Infinitary.html#4119" class="Generalizable">F</a> <a id="4618" href="Veblen.Basic.html#4263" class="Generalizable">α</a> <a id="4620" class="Symbol">{</a><a id="4621" href="Veblen.Basic.html#4281" class="Generalizable">n</a><a id="4622" class="Symbol">}</a> <a id="4624" href="Veblen.Finitary.html#2954" class="Function Operator">0̇,</a> <a id="4628" href="Veblen.Basic.html#9538" class="Generalizable">g</a> <a id="4630" href="Veblen.Infinitary.html#4610" class="Bound">m</a>
  <a id="4634" href="Veblen.Infinitary.html#4511" class="Function">Φ-α⋯ż-l</a> <a id="4643" class="Symbol">{</a><a id="4644" class="Argument">α</a> <a id="4646" class="Symbol">=</a> <a id="4648" href="Veblen.Basic.html#3303" class="InductiveConstructor">zero</a><a id="4652" class="Symbol">}</a> <a id="4654" class="Symbol">=</a> <a id="4656" href="Function.Base.html#704" class="Function">id</a>
  <a id="4661" href="Veblen.Infinitary.html#4511" class="Function">Φ-α⋯ż-l</a> <a id="4670" class="Symbol">{</a><a id="4671" class="Argument">α</a> <a id="4673" class="Symbol">=</a> <a id="4675" href="Veblen.Basic.html#3316" class="InductiveConstructor">suc</a> <a id="4679" href="Veblen.Infinitary.html#4679" class="Bound">α</a><a id="4680" class="Symbol">}</a> <a id="4682" class="Symbol">_</a> <a id="4684" class="Symbol">=</a> <a id="4686" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="4693" href="Veblen.Infinitary.html#4511" class="Function">Φ-α⋯ż-l</a> <a id="4702" class="Symbol">{</a><a id="4703" class="Argument">α</a> <a id="4705" class="Symbol">=</a> <a id="4707" href="Veblen.Basic.html#3335" class="InductiveConstructor">lim</a> <a id="4711" href="Veblen.Infinitary.html#4711" class="Bound">x</a><a id="4712" class="Symbol">}</a> <a id="4714" class="Symbol">_</a> <a id="4716" class="Symbol">=</a> <a id="4718" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="ω元veblen函数-2">ω⁺⁺元Veblen函数</h2>
<pre class="Agda"><a id="4753" class="Keyword">module</a> <a id="OmegaBinaryVeblen"></a><a id="4760" href="Veblen.Infinitary.html#4760" class="Module">OmegaBinaryVeblen</a> <a id="4778" class="Keyword">where</a>
</pre>
<h2 id="ω元veblen函数-3">2ω元Veblen函数</h2>
<h2 id="ω元veblen函数-4">(2ω)⁺元Veblen函数</h2>
<h2 id="ω元veblen函数-5">3ω元Veblen函数</h2>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
