<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>OCF.BTBO</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-3.0---布劳威尔树壁垒序数" id="toc-形式化大数数学-3.0---布劳威尔树壁垒序数">形式化大数数学 (3.0 - 布劳威尔树壁垒序数)</a>
  <ul>
  <li><a href="#布劳威尔树" id="toc-布劳威尔树">布劳威尔树</a></li>
  <li><a href="#自然数层布劳威尔树" id="toc-自然数层布劳威尔树">自然数层布劳威尔树</a></li>
  <li><a href="#omega-cdot-2-层布劳威尔树" id="toc-omega-cdot-2-层布劳威尔树"><span class="math inline">\omega \cdot 2</span> 层布劳威尔树</a></li>
  <li><a href="#内-omega-数" id="toc-内-omega-数">内 <span class="math inline">\Omega</span> 数</a></li>
  <li><a href="#可数序数的有界三歧性" id="toc-可数序数的有界三歧性">可数序数的有界三歧性</a></li>
  <li><a href="#可数序数层布劳威尔树" id="toc-可数序数层布劳威尔树">可数序数层布劳威尔树</a></li>
  <li><a href="#布劳威尔树的折叠" id="toc-布劳威尔树的折叠">布劳威尔树的折叠</a></li>
  <li><a href="#参考" id="toc-参考">参考</a></li>
  <li><a href="#附录" id="toc-附录">附录</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-3.0---布劳威尔树壁垒序数">形式化大数数学 (3.0 - 布劳威尔树壁垒序数)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/OCF/BTBO.lagda.md">BTBO.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/OCF.BTBO.html">BTBO.html</a><br />
纯代码版: <a href="https://gist.github.com/choukh/d7ca58dd90ee112162debce78eb7ad78">BTBO.agda</a></p>
</blockquote>
<p>我们主张的形式化大数基于以下纲领:</p>
<ol type="1">
<li>序数先行
<ul>
<li>先实现序数再折叠成大数</li>
<li>排除很难分析序数上下界的函数以及非序数增长率函数</li>
</ul></li>
<li>理想计算机可运行
<ul>
<li>在以类型论为基础的证明助理中无公理地写出定义</li>
</ul></li>
<li>保证停机
<ul>
<li>通过证明助理的自动停机检查器保证停机</li>
</ul></li>
</ol>
<p>本文可能是《形式化大数》系列的最后一篇, 因为遵循该纲领, 我们目前卡在了 <span class="math inline">\psi(\Omega_\Omega)</span>. 为了引起关注, 我们将其命名为布劳威尔树壁垒序数 (Brouwer Tree Barrier Ordinal), 简称 BTBO. 本文将介绍该序数的实现.</p>
<pre class="Agda"><a id="609" class="Symbol">{-#</a> <a id="613" class="Keyword">OPTIONS</a> <a id="621" class="Pragma">--safe</a> <a id="628" class="Pragma">--without-K</a> <a id="640" class="Pragma">--lossy-unification</a> <a id="660" class="Symbol">#-}</a>
<a id="664" class="Keyword">module</a> <a id="671" href="OCF.BTBO.html" class="Module">OCF.BTBO</a> <a id="680" class="Keyword">where</a>
<a id="686" class="Keyword">open</a> <a id="691" class="Keyword">import</a> <a id="698" href="Function.html" class="Module">Function</a> <a id="707" class="Keyword">using</a> <a id="713" class="Symbol">(</a><a id="714" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="717" class="Symbol">;</a> <a id="719" href="Function.Base.html#4736" class="Function">it</a><a id="721" class="Symbol">)</a>
</pre>
<h2 id="布劳威尔树">布劳威尔树</h2>
<p>什么是布劳威尔树? 从零开始 (字面意义), 我们能看得更清晰一些.</p>
<p><strong>定义 (布劳威尔树)</strong></p>
<p><span class="math display">
\begin{align}
\mathbf{0}&amp;:=
\\[2em]
\mathbf{1}&amp;:=\cfrac{\;\mathbf{0}\to\mathbf{1}\;}{\mathbf{1}}\;\mathsf{zero}
\\[2em]
\mathbb{N}&amp;:=\cfrac{\;\mathbf{0}\to\mathbb{N}\;}{\mathbb{N}}\;\mathsf{zero}\;\;\;\;\cfrac{\;\mathbf{1}\to\mathbb{N}\;}{\mathbb{N}}\;\mathsf{suc}
\\[2em]
\mathbb{O}_0&amp;:=\cfrac{\;\mathbf{0}\to\mathbb{O}_0\;}{\mathbb{O}_0}\;\mathsf{zero}\;\;\;\;\cfrac{\;\mathbf{1}\to\mathbb{O}_0\;}{\mathbb{O}_0}\;\mathsf{suc}\;\;\;\;\cfrac{\;\mathbb{N}\to\mathbb{O}_0\;}{\mathbb{O}_0}\;\mathsf{lim}
\\[2em]
\mathbb{O}_1&amp;:=\cfrac{\;\mathbf{0}\to\mathbb{O}_1\;}{\mathbb{O}_1}\;\mathsf{zero}\;\;\;\;\cfrac{\;\mathbf{1}\to\mathbb{O}_1\;}{\mathbb{O}_1}\;\mathsf{suc}\;\;\;\;\cfrac{\;\mathbb{N}\to\mathbb{O}_1\;}{\mathbb{O}_1}\;\mathsf{lim}\;\;\;\;\cfrac{\;\mathbb{O}_0\to\mathbb{O}_1\;}{\mathbb{O}_1}\;\mathsf{lim}_1
\end{align}
</span></p>
<pre class="Agda"><a id="1633" class="Keyword">module</a> <a id="Brw_basic"></a><a id="1640" href="OCF.BTBO.html#1640" class="Module Operator">Brw_basic</a> <a id="1650" class="Keyword">where</a>

  <a id="1659" class="Keyword">data</a> <a id="Brw_basic.𝟎"></a><a id="1664" href="OCF.BTBO.html#1664" class="Datatype">𝟎</a> <a id="1666" class="Symbol">:</a> <a id="1668" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1672" class="Keyword">where</a>

  <a id="1681" class="Keyword">data</a> <a id="Brw_basic.𝟏"></a><a id="1686" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a> <a id="1688" class="Symbol">:</a> <a id="1690" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1694" class="Keyword">where</a>
    <a id="Brw_basic.𝟏.zero"></a><a id="1704" href="OCF.BTBO.html#1704" class="InductiveConstructor">zero</a>  <a id="1710" class="Symbol">:</a> <a id="1712" class="Symbol">(</a><a id="1713" href="OCF.BTBO.html#1664" class="Datatype">𝟎</a> <a id="1715" class="Symbol">→</a> <a id="1717" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a><a id="1718" class="Symbol">)</a> <a id="1720" class="Symbol">→</a> <a id="1722" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a>

  <a id="1727" class="Keyword">data</a> <a id="Brw_basic.ℕ"></a><a id="1732" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a> <a id="1734" class="Symbol">:</a> <a id="1736" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1740" class="Keyword">where</a>
    <a id="Brw_basic.ℕ.zero"></a><a id="1750" href="OCF.BTBO.html#1750" class="InductiveConstructor">zero</a>  <a id="1756" class="Symbol">:</a> <a id="1758" class="Symbol">(</a><a id="1759" href="OCF.BTBO.html#1664" class="Datatype">𝟎</a> <a id="1761" class="Symbol">→</a> <a id="1763" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a><a id="1764" class="Symbol">)</a> <a id="1766" class="Symbol">→</a> <a id="1768" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a>
    <a id="Brw_basic.ℕ.suc"></a><a id="1774" href="OCF.BTBO.html#1774" class="InductiveConstructor">suc</a>   <a id="1780" class="Symbol">:</a> <a id="1782" class="Symbol">(</a><a id="1783" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a> <a id="1785" class="Symbol">→</a> <a id="1787" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a><a id="1788" class="Symbol">)</a> <a id="1790" class="Symbol">→</a> <a id="1792" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a>

  <a id="1797" class="Keyword">data</a> <a id="Brw_basic.O₀"></a><a id="1802" href="OCF.BTBO.html#1802" class="Datatype">O₀</a> <a id="1805" class="Symbol">:</a> <a id="1807" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1811" class="Keyword">where</a>
    <a id="Brw_basic.O₀.zero"></a><a id="1821" href="OCF.BTBO.html#1821" class="InductiveConstructor">zero</a>  <a id="1827" class="Symbol">:</a> <a id="1829" class="Symbol">(</a><a id="1830" href="OCF.BTBO.html#1664" class="Datatype">𝟎</a> <a id="1832" class="Symbol">→</a> <a id="1834" href="OCF.BTBO.html#1802" class="Datatype">O₀</a><a id="1836" class="Symbol">)</a> <a id="1838" class="Symbol">→</a> <a id="1840" href="OCF.BTBO.html#1802" class="Datatype">O₀</a>
    <a id="Brw_basic.O₀.suc"></a><a id="1847" href="OCF.BTBO.html#1847" class="InductiveConstructor">suc</a>   <a id="1853" class="Symbol">:</a> <a id="1855" class="Symbol">(</a><a id="1856" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a> <a id="1858" class="Symbol">→</a> <a id="1860" href="OCF.BTBO.html#1802" class="Datatype">O₀</a><a id="1862" class="Symbol">)</a> <a id="1864" class="Symbol">→</a> <a id="1866" href="OCF.BTBO.html#1802" class="Datatype">O₀</a>
    <a id="Brw_basic.O₀.lim"></a><a id="1873" href="OCF.BTBO.html#1873" class="InductiveConstructor">lim</a>   <a id="1879" class="Symbol">:</a> <a id="1881" class="Symbol">(</a><a id="1882" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a> <a id="1884" class="Symbol">→</a> <a id="1886" href="OCF.BTBO.html#1802" class="Datatype">O₀</a><a id="1888" class="Symbol">)</a> <a id="1890" class="Symbol">→</a> <a id="1892" href="OCF.BTBO.html#1802" class="Datatype">O₀</a>

  <a id="1898" class="Keyword">data</a> <a id="Brw_basic.O₁"></a><a id="1903" href="OCF.BTBO.html#1903" class="Datatype">O₁</a> <a id="1906" class="Symbol">:</a> <a id="1908" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1912" class="Keyword">where</a>
    <a id="Brw_basic.O₁.zero"></a><a id="1922" href="OCF.BTBO.html#1922" class="InductiveConstructor">zero</a>  <a id="1928" class="Symbol">:</a> <a id="1930" class="Symbol">(</a><a id="1931" href="OCF.BTBO.html#1664" class="Datatype">𝟎</a> <a id="1933" class="Symbol">→</a> <a id="1935" href="OCF.BTBO.html#1903" class="Datatype">O₁</a><a id="1937" class="Symbol">)</a> <a id="1939" class="Symbol">→</a> <a id="1941" href="OCF.BTBO.html#1903" class="Datatype">O₁</a>
    <a id="Brw_basic.O₁.suc"></a><a id="1948" href="OCF.BTBO.html#1948" class="InductiveConstructor">suc</a>   <a id="1954" class="Symbol">:</a> <a id="1956" class="Symbol">(</a><a id="1957" href="OCF.BTBO.html#1686" class="Datatype">𝟏</a> <a id="1959" class="Symbol">→</a> <a id="1961" href="OCF.BTBO.html#1903" class="Datatype">O₁</a><a id="1963" class="Symbol">)</a> <a id="1965" class="Symbol">→</a> <a id="1967" href="OCF.BTBO.html#1903" class="Datatype">O₁</a>
    <a id="Brw_basic.O₁.lim"></a><a id="1974" href="OCF.BTBO.html#1974" class="InductiveConstructor">lim</a>   <a id="1980" class="Symbol">:</a> <a id="1982" class="Symbol">(</a><a id="1983" href="OCF.BTBO.html#1732" class="Datatype">ℕ</a> <a id="1985" class="Symbol">→</a> <a id="1987" href="OCF.BTBO.html#1903" class="Datatype">O₁</a><a id="1989" class="Symbol">)</a> <a id="1991" class="Symbol">→</a> <a id="1993" href="OCF.BTBO.html#1903" class="Datatype">O₁</a>
    <a id="Brw_basic.O₁.lim₁"></a><a id="2000" href="OCF.BTBO.html#2000" class="InductiveConstructor">lim₁</a>  <a id="2006" class="Symbol">:</a> <a id="2008" class="Symbol">(</a><a id="2009" href="OCF.BTBO.html#1802" class="Datatype">O₀</a> <a id="2012" class="Symbol">→</a> <a id="2014" href="OCF.BTBO.html#1903" class="Datatype">O₁</a><a id="2016" class="Symbol">)</a> <a id="2018" class="Symbol">→</a> <a id="2020" href="OCF.BTBO.html#1903" class="Datatype">O₁</a>
</pre>
<p>这样的一系列类型就叫<strong>布劳威尔树</strong>, 它们的项所能表示的序数就叫布劳威尔树序数. 不难看出</p>
<ul>
<li><code>𝟎</code> 与标准库的 <code>⊥</code> 同构</li>
<li><code>𝟏</code> 与标准库的 <code>⊤</code> 同构</li>
<li><code>ℕ</code> 与标准库的 <code>ℕ</code> 同构</li>
</ul>
<pre class="Agda"><a id="2143" class="Keyword">open</a> <a id="2148" class="Keyword">import</a> <a id="2155" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="2166" class="Keyword">using</a> <a id="2172" class="Symbol">(</a><a id="2173" href="Data.Empty.html#914" class="Function">⊥</a><a id="2174" class="Symbol">)</a>
<a id="2176" class="Keyword">open</a> <a id="2181" class="Keyword">import</a> <a id="2188" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="2198" class="Keyword">using</a> <a id="2204" class="Symbol">(</a><a id="2205" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2206" class="Symbol">)</a>
<a id="2208" class="Keyword">open</a> <a id="2213" class="Keyword">import</a> <a id="2220" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2229" class="Keyword">using</a> <a id="2235" class="Symbol">(</a><a id="2236" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2237" class="Symbol">;</a> <a id="2239" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2243" class="Symbol">;</a> <a id="2245" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2248" class="Symbol">)</a>
</pre>
<p>而 <code>O₀</code> 和 <code>O₁</code> 又与如下定义的 <code>Ord₀</code>, <code>Ord₁</code> 同构</p>
<pre class="Agda"><a id="2304" class="Keyword">module</a> <a id="Ord_basic"></a><a id="2311" href="OCF.BTBO.html#2311" class="Module Operator">Ord_basic</a> <a id="2321" class="Keyword">where</a>
  <a id="2329" class="Keyword">data</a> <a id="Ord_basic.Ord₀"></a><a id="2334" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a> <a id="2339" class="Symbol">:</a> <a id="2341" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="2345" class="Keyword">where</a>
    <a id="Ord_basic.Ord₀.zero"></a><a id="2355" href="OCF.BTBO.html#2355" class="InductiveConstructor">zero</a> <a id="2360" class="Symbol">:</a> <a id="2362" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a>
    <a id="Ord_basic.Ord₀.suc"></a><a id="2371" href="OCF.BTBO.html#2371" class="InductiveConstructor">suc</a> <a id="2375" class="Symbol">:</a> <a id="2377" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a> <a id="2382" class="Symbol">→</a> <a id="2384" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a>
    <a id="Ord_basic.Ord₀.lim"></a><a id="2393" href="OCF.BTBO.html#2393" class="InductiveConstructor">lim</a> <a id="2397" class="Symbol">:</a> <a id="2399" class="Symbol">(</a><a id="2400" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2402" class="Symbol">→</a> <a id="2404" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a><a id="2408" class="Symbol">)</a> <a id="2410" class="Symbol">→</a> <a id="2412" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a>

  <a id="2420" class="Keyword">data</a> <a id="Ord_basic.Ord₁"></a><a id="2425" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a> <a id="2430" class="Symbol">:</a> <a id="2432" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="2436" class="Keyword">where</a>
    <a id="Ord_basic.Ord₁.zero"></a><a id="2446" href="OCF.BTBO.html#2446" class="InductiveConstructor">zero</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a>
    <a id="Ord_basic.Ord₁.suc"></a><a id="2462" href="OCF.BTBO.html#2462" class="InductiveConstructor">suc</a> <a id="2466" class="Symbol">:</a> <a id="2468" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a> <a id="2473" class="Symbol">→</a> <a id="2475" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a>
    <a id="Ord_basic.Ord₁.lim₀"></a><a id="2484" href="OCF.BTBO.html#2484" class="InductiveConstructor">lim₀</a> <a id="2489" class="Symbol">:</a> <a id="2491" class="Symbol">(</a><a id="2492" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2494" class="Symbol">→</a> <a id="2496" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a><a id="2500" class="Symbol">)</a> <a id="2502" class="Symbol">→</a> <a id="2504" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a>
    <a id="Ord_basic.Ord₁.lim₁"></a><a id="2513" href="OCF.BTBO.html#2513" class="InductiveConstructor">lim₁</a> <a id="2518" class="Symbol">:</a> <a id="2520" class="Symbol">(</a><a id="2521" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a> <a id="2526" class="Symbol">→</a> <a id="2528" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a><a id="2532" class="Symbol">)</a> <a id="2534" class="Symbol">→</a> <a id="2536" href="OCF.BTBO.html#2425" class="Datatype">Ord₁</a>
</pre>
<p><code>O₀</code>, <code>O₁</code> 的定义方便往上归纳定义 <span class="math inline">\mathsf{Brw}_\alpha</span>, 而 <code>Ord₀</code>, <code>Ord₁</code> 则方便直接使用.</p>
<p>为了方便表述, 我们把这些类型记作 <span class="math inline">\mathsf{Brw}_\alpha</span> 或者 <span class="math inline">\mathsf{Ord}_\alpha</span>. 它们有如下关系</p>
<p><span class="math display">
\mathsf{Ord}_\alpha :=
\begin{cases}
   \mathsf{Brw}_{\alpha+3} &amp;\text{if } \alpha &lt; \omega \\
   \mathsf{Brw}_\alpha &amp;\text{if } \alpha\ge\omega
\end{cases}
</span></p>
<p>当然这里的下标 <span class="math inline">\alpha</span> 的类型目前是非形式地, 根据上下文它可能是自然数, 可能是某个小于 <span class="math inline">\omega_\beta</span> 的数, 而这里的 <span class="math inline">\beta</span> 也跟 <span class="math inline">\alpha</span> 一样类型未定. 为了讨论我们总得先往前说.</p>
<p>将布劳威尔树 <span class="math inline">\mathsf{Brw}_\alpha</span> 所能表示的序数的上确界记作 <span class="math inline">\sup(\mathsf{Brw}_\alpha)</span>, 并按 Buchholz 的惯例令</p>
<p><span class="math display">
\Omega_\alpha :=
\begin{cases}
   1 &amp;\text{if } \alpha = 0 \\
   \omega_\alpha &amp;\text{if } \alpha &gt; 0
\end{cases}
</span></p>
<p>其中 <span class="math inline">\Omega_1</span> 简记作 <span class="math inline">\Omega</span>, 则有</p>
<p><span class="math display">
\begin{align}
\sup(\mathsf{Brw}_0) &amp;= 0 \\
\sup(\mathsf{Brw}_1) &amp;= 1 \\
\sup(\mathsf{Brw}_2) &amp;= \omega \\
\sup(\mathsf{Brw}_3) &amp;= \Omega \\
\sup(\mathsf{Brw}_4) &amp;= \Omega_2 \\
...
\end{align}
</span></p>
<p><strong>约定</strong> 如果一个类型 <code>A</code> 被当作序数, 我们指该类型所能表示的序数的上确界 <span class="math inline">\sup(A)</span>.</p>
<p>考虑 <span class="math inline">\mathsf{Brw}_{\alpha^+}</span> 到 <span class="math inline">\mathsf{Brw}_{\alpha}</span> 的折叠. 从最底层开始, <span class="math inline">\mathsf{Brw}_1</span> 到 <span class="math inline">\mathsf{Brw}_0</span> 以及 <span class="math inline">\mathsf{Brw}_2</span> 到 <span class="math inline">\mathsf{Brw}_1</span> 的折叠是平凡的. 而 <span class="math inline">\mathsf{Brw}_3</span> 到 <span class="math inline">\mathsf{Brw}_2</span> 的折叠就是各种增长层级. 再往后的折叠就是通常所说的 OCF.</p>
<p>只不过通常的 OCF 使用集合论语言的非直谓定义, 而我们这里需要具体的递归算法一层一层往下: 从 <span class="math inline">\mathsf{Brw}_\alpha</span> 到 … 到 <span class="math inline">\mathsf{Brw}_4</span> 到 <span class="math inline">\mathsf{Brw}_3</span> (大可数序数), 最后到 <span class="math inline">\mathsf{Brw}_2</span> (大自然数).</p>
<p>因此我们的任务主要分解成两部分, 一是写出很大的 <span class="math inline">\mathsf{Brw}_\alpha</span>, 二是一层层折叠到 <span class="math inline">\mathsf{Brw}_2</span>. 只考虑任务一的话是相对简单的, 难点在于我们后面会看到任务二会给任务一附加很多要求. 我们一步步来.</p>
<h2 id="自然数层布劳威尔树">自然数层布劳威尔树</h2>
<p>我们需要等号 <code>_≡_</code> 及其性质.</p>
<pre class="Agda"><a id="4021" class="Keyword">open</a> <a id="4026" class="Keyword">import</a> <a id="4033" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="4071" class="Keyword">using</a> <a id="4077" class="Symbol">(</a><a id="4078" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="4081" class="Symbol">;</a> <a id="4083" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="4087" class="Symbol">;</a> <a id="4089" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="4093" class="Symbol">)</a>

<a id="transport"></a><a id="4096" href="OCF.BTBO.html#4096" class="Function">transport</a> <a id="4106" class="Symbol">:</a> <a id="4108" class="Symbol">{</a><a id="4109" href="OCF.BTBO.html#4109" class="Bound">A</a> <a id="4111" href="OCF.BTBO.html#4111" class="Bound">B</a> <a id="4113" class="Symbol">:</a> <a id="4115" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4118" class="Symbol">}</a> <a id="4120" class="Symbol">→</a> <a id="4122" href="OCF.BTBO.html#4109" class="Bound">A</a> <a id="4124" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4126" href="OCF.BTBO.html#4111" class="Bound">B</a> <a id="4128" class="Symbol">→</a> <a id="4130" href="OCF.BTBO.html#4109" class="Bound">A</a> <a id="4132" class="Symbol">→</a> <a id="4134" href="OCF.BTBO.html#4111" class="Bound">B</a>
<a id="4136" href="OCF.BTBO.html#4096" class="Function">transport</a> <a id="4146" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4151" href="OCF.BTBO.html#4151" class="Bound">x</a> <a id="4153" class="Symbol">=</a> <a id="4155" href="OCF.BTBO.html#4151" class="Bound">x</a>
</pre>
<p><strong>定义</strong> 自然数上的 <span class="math inline">&lt;</span> 序</p>
<p><span class="math display">
\cfrac{}{\;n&lt;n^+\;}\;\;\mathsf{zero}\;\;\;\;\;\;\;\cfrac{n&lt;m}{\;n&lt;m^+\;}\;\;\mathsf{suc}
</span></p>
<pre class="Agda"><a id="4288" class="Keyword">module</a> <a id="Nat_lt"></a><a id="4295" href="OCF.BTBO.html#4295" class="Module Operator">Nat_lt</a> <a id="4302" class="Keyword">where</a>
  <a id="4310" class="Keyword">variable</a> <a id="4319" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="4321" href="OCF.BTBO.html#4321" class="Generalizable">m</a> <a id="4323" href="OCF.BTBO.html#4323" class="Generalizable">o</a> <a id="4325" class="Symbol">:</a> <a id="4327" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>

  <a id="4332" class="Keyword">data</a> <a id="Nat_lt._&lt;_"></a><a id="4337" href="OCF.BTBO.html#4337" class="Datatype Operator">_&lt;_</a> <a id="4341" class="Symbol">:</a> <a id="4343" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4345" class="Symbol">→</a> <a id="4347" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4349" class="Symbol">→</a> <a id="4351" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4355" class="Keyword">where</a>
    <a id="Nat_lt._&lt;_.zero"></a><a id="4365" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="4370" class="Symbol">:</a> <a id="4372" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="4374" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="4376" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4380" href="OCF.BTBO.html#4319" class="Generalizable">n</a>
    <a id="Nat_lt._&lt;_.suc"></a><a id="4386" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a>  <a id="4391" class="Symbol">:</a> <a id="4393" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="4395" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="4397" href="OCF.BTBO.html#4321" class="Generalizable">m</a> <a id="4399" class="Symbol">→</a> <a id="4401" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="4403" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="4405" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4409" href="OCF.BTBO.html#4321" class="Generalizable">m</a>
</pre>
<p><strong>约定</strong> 为了简化表述, 我们采用以下记法约定:</p>
<ul>
<li>项 <span class="math inline">\mathsf{zero}</span> 可简记为 <span class="math inline">0</span>.</li>
<li>项 <span class="math inline">\mathsf{suc}(x)</span> 可简记为 <span class="math inline">x^+</span>.</li>
<li>当它们为布劳威尔树项之间关系的证明时, 同样采用此约定.</li>
</ul>
<p>因此我们可以写 <span class="math inline">0_x:x&lt;x^+</span>, 以及 <span class="math inline">p^+:x&lt;y^+</span> (此时有 <span class="math inline">p:x&lt;y</span>).</p>
<p>由开篇的代码, 通过简单的复制粘贴我们可以写出任意 <span class="math inline">\mathsf{Brw}_n</span>. 伪代码如下</p>
<pre class="pseudocode"><code>data Brw₀ : Set where
data Brwₖ₊₁ : Set where
  cf₀ : (Brw₀ → Brwₖ₊₁) → Brwₖ₊₁
  cf₁ : (Brw₁ → Brwₖ₊₁) → Brwₖ₊₁
  ...
  cfₖ : (Brwₖ → Brwₖ₊₁) → Brwₖ₊₁</code></pre>
<p>其中 <code>Brwₖ₊₁</code> 的下标 <code>k + 1</code> 代表了该类型的构造子的个数, 而下标为 <code>k</code> 的构造子 <code>cfₖ</code> 则构造了共尾度 (基本列的长度) 为 <code>Brwₖ</code> 的序数.</p>
<ul>
<li><code>cf₀</code> 构造了共尾度为 <span class="math inline">0</span> 的序数, 它只有一个, 就是空列 <code>λ ()</code>, 代表序数 <span class="math inline">0</span></li>
<li><code>cf₁</code> 构造了共尾度为 <span class="math inline">1</span> 的序数, 即后继序数.</li>
<li><code>cf₂</code> 构造了共尾度为 <span class="math inline">\omega</span> 的序数, 可表示可数极限序数.</li>
<li><code>cf₃</code> 构造了共尾度为 <span class="math inline">\Omega</span> 的序数, 可表示不可数极限序数.</li>
<li><code>cf₄</code> 构造了共尾度为 <span class="math inline">\Omega_2</span> 的序数, 可表示更高阶的不可数极限序数.</li>
<li>…</li>
</ul>
<p>归纳这个模式, 我们可以定义 <code>Brw : ℕ → Set</code> 这个类型族. 核心思想是通过类似类型论塔斯基宇宙的形式来定义自然数索引的布劳威尔树族。对于给定的层数 <span class="math inline">n</span>, 我们首先假设所有更低层的树 <span class="math inline">\mathsf{Brw}_{&lt;i}</span>（其中 <span class="math inline">i &lt; n</span>）都已经定义好, 然后定义第 <span class="math inline">n</span> 层的树 <span class="math inline">\mathsf{Brw}_n</span>。具体地, <span class="math inline">\mathsf{Brw}_n</span> 的每个元素都可以通过构造子 <span class="math inline">\mathsf{cf}</span> 来构造, 该构造子接受一个证明 <span class="math inline">p : i &lt; n</span> 和一个函数 <span class="math inline">f : \mathsf{Brw}_{&lt;i} \to \mathsf{Brw}_n</span>, 表示该元素的共尾度为 <span class="math inline">\mathsf{Brw}_{&lt;i}</span>。函数 <code>Brw&lt;</code> 处理了层次之间的依赖关系, 而 <code>Brw</code> 则是对外的接口, 将第 <span class="math inline">n</span> 层的树定义为 <span class="math inline">\mathsf{Brw}_{&lt;n, 0_n}</span>。</p>
<p><strong>定义 (自然数层布劳威尔树)</strong></p>
<p><span class="math display">
\begin{align}
\mathsf{Brw}_+(n, \mathsf{Brw}_{&lt;}) &amp;:= \cfrac{\;(p:i&lt;n)\;\;\;(f:\mathsf{Brw}_{&lt;}(i,p)\to\mathsf{Brw}_+)\;}{\mathsf{Brw}_+}\;\mathsf{cf}
\\[1.5em]
\mathsf{Brw}_{&lt;}(i, p) &amp;:=
\begin{cases}
   \mathsf{Brw}_+(i, \mathsf{Brw}_{&lt;}) &amp;\text{if } p = (0_i:i&lt;i^+) \\
   \mathsf{Brw}_{&lt;}(i, q) &amp;\text{if } p = (q^+:i&lt;m^+)
\end{cases}
\\[1.5em]
\mathsf{Brw}_n &amp;:= \mathsf{Brw}_{&lt;}(n,0_n)
\end{align}
</span></p>
<pre class="Agda"><a id="5981" class="Keyword">module</a> <a id="Brw_nat"></a><a id="5988" href="OCF.BTBO.html#5988" class="Module Operator">Brw_nat</a> <a id="5996" class="Keyword">where</a>
  <a id="6004" class="Keyword">open</a> <a id="6009" href="OCF.BTBO.html#4295" class="Module Operator">Nat_lt</a>
  <a id="6018" class="Keyword">private</a> <a id="6026" class="Keyword">variable</a> <a id="6035" href="OCF.BTBO.html#6035" class="Generalizable">i</a> <a id="6037" class="Symbol">:</a> <a id="6039" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>

  <a id="6044" class="Comment">-- 假设下标为 `i &lt; n` 的任意树 `Brw&lt; i` 已经定义完成, 定义下标为 `n` 的树 `Brw₊`</a>
  <a id="6105" class="Keyword">module</a> <a id="6112" href="OCF.BTBO.html#6112" class="Module">_</a> <a id="6114" class="Symbol">(</a><a id="6115" href="OCF.BTBO.html#6115" class="Bound">n</a> <a id="6117" class="Symbol">:</a> <a id="6119" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="6120" class="Symbol">)</a> <a id="6122" class="Symbol">(</a><a id="6123" href="OCF.BTBO.html#6123" class="Bound">Brw&lt;</a> <a id="6128" class="Symbol">:</a> <a id="6130" class="Symbol">∀</a> <a id="6132" href="OCF.BTBO.html#6132" class="Bound">i</a> <a id="6134" class="Symbol">→</a> <a id="6136" href="OCF.BTBO.html#6132" class="Bound">i</a> <a id="6138" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="6140" href="OCF.BTBO.html#6115" class="Bound">n</a> <a id="6142" class="Symbol">→</a> <a id="6144" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="6147" class="Symbol">)</a> <a id="6149" class="Keyword">where</a>
    <a id="6159" class="Keyword">data</a> <a id="6164" href="OCF.BTBO.html#6164" class="Datatype">Brw₊</a> <a id="6169" class="Symbol">:</a> <a id="6171" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="6175" class="Keyword">where</a>
      <a id="6187" class="Comment">-- `Brw₊` 的元素的共尾度为任意满足 `i &lt; n` 的 `Brw&lt; i`</a>
      <a id="6235" href="OCF.BTBO.html#6235" class="InductiveConstructor">cf</a> <a id="6238" class="Symbol">:</a> <a id="6240" class="Symbol">(</a><a id="6241" href="OCF.BTBO.html#6241" class="Bound">p</a> <a id="6243" class="Symbol">:</a> <a id="6245" href="OCF.BTBO.html#6035" class="Generalizable">i</a> <a id="6247" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="6249" href="OCF.BTBO.html#6115" class="Bound">n</a><a id="6250" class="Symbol">)</a> <a id="6252" class="Symbol">(</a><a id="6253" href="OCF.BTBO.html#6253" class="Bound">f</a> <a id="6255" class="Symbol">:</a> <a id="6257" href="OCF.BTBO.html#6123" class="Bound">Brw&lt;</a> <a id="6262" href="OCF.BTBO.html#6035" class="Generalizable">i</a> <a id="6264" href="OCF.BTBO.html#6241" class="Bound">p</a> <a id="6266" class="Symbol">→</a> <a id="6268" href="OCF.BTBO.html#6164" class="Datatype">Brw₊</a><a id="6272" class="Symbol">)</a> <a id="6274" class="Symbol">→</a> <a id="6276" href="OCF.BTBO.html#6164" class="Datatype">Brw₊</a>

  <a id="6284" class="Comment">-- 给定 `n`, 递归定义满足 `p : i &lt; n` 的任意 `i` 所给出的树 `Brw&lt; i p`</a>
  <a id="Brw_nat.Brw&lt;"></a><a id="6341" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a> <a id="6346" class="Symbol">:</a> <a id="6348" class="Symbol">∀</a> <a id="6350" href="OCF.BTBO.html#6350" class="Bound">i</a> <a id="6352" class="Symbol">→</a> <a id="6354" href="OCF.BTBO.html#6350" class="Bound">i</a> <a id="6356" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="6358" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="6360" class="Symbol">→</a> <a id="6362" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="6368" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a> <a id="6373" href="OCF.BTBO.html#6373" class="Bound">i</a> <a id="6375" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="6380" class="Symbol">=</a> <a id="6382" href="OCF.BTBO.html#6164" class="Datatype">Brw₊</a> <a id="6387" href="OCF.BTBO.html#6373" class="Bound">i</a> <a id="6389" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a>
  <a id="6396" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a> <a id="6401" href="OCF.BTBO.html#6401" class="Bound">i</a> <a id="6403" class="Symbol">(</a><a id="6404" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="6408" href="OCF.BTBO.html#6408" class="Bound">p</a><a id="6409" class="Symbol">)</a> <a id="6411" class="Symbol">=</a> <a id="6413" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a> <a id="6418" href="OCF.BTBO.html#6401" class="Bound">i</a> <a id="6420" href="OCF.BTBO.html#6408" class="Bound">p</a>

  <a id="6425" class="Comment">-- 消掉 `i &lt; n` 条件</a>
  <a id="Brw_nat.Brw"></a><a id="6444" href="OCF.BTBO.html#6444" class="Function">Brw</a> <a id="6448" class="Symbol">:</a> <a id="6450" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="6452" class="Symbol">→</a> <a id="6454" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="6460" href="OCF.BTBO.html#6444" class="Function">Brw</a> <a id="6464" href="OCF.BTBO.html#6464" class="Bound">n</a> <a id="6466" class="Symbol">=</a> <a id="6468" href="OCF.BTBO.html#6341" class="Function">Brw&lt;</a> <a id="6473" href="OCF.BTBO.html#6464" class="Bound">n</a> <a id="6475" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>
</pre>
<p>这样我们就定义了任意 <span class="math inline">\mathsf{Brw}_n</span>. 虽然它只需要一个构造子“族”, 非常优雅, 但不方便使用. 从现在起我们改用 <span class="math inline">\mathsf{Ord}_n</span> 层级, 显式写出最初的三个构造子 <code>zero</code>, <code>suc</code>, <code>lim</code>, 其后才使用 <code>limᵢ</code> 族.</p>
<p><strong>定义 (显式构造子的布劳威尔树族)</strong></p>
<p><span class="math display">
\begin{align}
\mathsf{Ord}_+(n, \mathsf{Ord}_{&lt;}) &amp;:=
\cfrac{}{\mathsf{Ord}_+}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_+\;}{\mathsf{Ord}_+}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_+\;}{\mathsf{Ord}_+}\;\mathsf{lim}
\\[2em]
&amp;\;\;\;\;\cfrac{\;(p:i&lt;n)\;\;\;(\mathsf{Ord}_{&lt;}(i,p)\to\mathsf{Ord}_+)\;}{\mathsf{Ord}_+}\;\mathsf{lim}_i
\end{align}
</span></p>
<pre class="Agda"><a id="7033" class="Keyword">module</a> <a id="Ord_nat"></a><a id="7040" href="OCF.BTBO.html#7040" class="Module Operator">Ord_nat</a> <a id="7048" class="Keyword">where</a>
  <a id="7056" class="Keyword">open</a> <a id="7061" href="OCF.BTBO.html#4295" class="Module Operator">Nat_lt</a> <a id="7068" class="Keyword">public</a>
  <a id="7077" class="Keyword">private</a> <a id="7085" class="Keyword">variable</a> <a id="7094" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="7096" class="Symbol">:</a> <a id="7098" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>

  <a id="7103" class="Keyword">module</a> <a id="7110" href="OCF.BTBO.html#7110" class="Module">_</a> <a id="7112" class="Symbol">(</a><a id="7113" href="OCF.BTBO.html#7113" class="Bound">n</a> <a id="7115" class="Symbol">:</a> <a id="7117" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="7118" class="Symbol">)</a> <a id="7120" class="Symbol">(</a><a id="7121" href="OCF.BTBO.html#7121" class="Bound">Ord&lt;</a> <a id="7126" class="Symbol">:</a> <a id="7128" class="Symbol">∀</a> <a id="7130" href="OCF.BTBO.html#7130" class="Bound">i</a> <a id="7132" class="Symbol">→</a> <a id="7134" href="OCF.BTBO.html#7130" class="Bound">i</a> <a id="7136" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="7138" href="OCF.BTBO.html#7113" class="Bound">n</a> <a id="7140" class="Symbol">→</a> <a id="7142" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="7145" class="Symbol">)</a> <a id="7147" class="Keyword">where</a>
    <a id="7157" class="Keyword">data</a> <a id="7162" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a> <a id="7167" class="Symbol">:</a> <a id="7169" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="7173" class="Keyword">where</a>
      <a id="7185" href="OCF.BTBO.html#7185" class="InductiveConstructor">zero</a> <a id="7190" class="Symbol">:</a> <a id="7192" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a>
      <a id="7203" href="OCF.BTBO.html#7203" class="InductiveConstructor">suc</a>  <a id="7208" class="Symbol">:</a> <a id="7210" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a> <a id="7215" class="Symbol">→</a> <a id="7217" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a>
      <a id="7228" href="OCF.BTBO.html#7228" class="InductiveConstructor">lim</a>  <a id="7233" class="Symbol">:</a> <a id="7235" class="Symbol">(</a><a id="7236" href="OCF.BTBO.html#7236" class="Bound">f</a> <a id="7238" class="Symbol">:</a> <a id="7240" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7242" class="Symbol">→</a> <a id="7244" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a><a id="7248" class="Symbol">)</a> <a id="7250" class="Symbol">→</a> <a id="7252" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a>
      <a id="7263" href="OCF.BTBO.html#7263" class="InductiveConstructor">limᵢ</a> <a id="7268" class="Symbol">:</a> <a id="7270" class="Symbol">(</a><a id="7271" href="OCF.BTBO.html#7271" class="Bound">p</a> <a id="7273" class="Symbol">:</a> <a id="7275" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="7277" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="7279" href="OCF.BTBO.html#7113" class="Bound">n</a><a id="7280" class="Symbol">)</a> <a id="7282" class="Symbol">(</a><a id="7283" href="OCF.BTBO.html#7283" class="Bound">f</a> <a id="7285" class="Symbol">:</a> <a id="7287" href="OCF.BTBO.html#7121" class="Bound">Ord&lt;</a> <a id="7292" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="7294" href="OCF.BTBO.html#7271" class="Bound">p</a> <a id="7296" class="Symbol">→</a> <a id="7298" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a><a id="7302" class="Symbol">)</a> <a id="7304" class="Symbol">→</a> <a id="7306" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a>
</pre>
<p>剩下的定义跟 <span class="math inline">\mathsf{Brw}_n</span> 是一样的. 给定 <span class="math inline">n</span>, 我们递归定义满足 <span class="math inline">p:i&lt;n</span> 的任意 <span class="math inline">i</span> 所给出的树</p>
<p><span class="math display">
\mathsf{Ord}_{&lt;}(i, p) :=
\begin{cases}
   \mathsf{Ord}_+(i, \mathsf{Ord}_{&lt;}) &amp;\text{if } p = (0_i:i&lt;i^+) \\
   \mathsf{Ord}_{&lt;}(i, q) &amp;\text{if } p = (q^+:i&lt;m^+)
\end{cases}
</span></p>
<p>并定义</p>
<p><span class="math display">
\mathsf{Ord}_n := \mathsf{Ord}_{&lt;}(n,0_n)
</span></p>
<pre class="Agda">  <a id="Ord_nat.Ord&lt;"></a><a id="7634" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="7639" class="Symbol">:</a> <a id="7641" class="Symbol">∀</a> <a id="7643" href="OCF.BTBO.html#7643" class="Bound">i</a> <a id="7645" class="Symbol">→</a> <a id="7647" href="OCF.BTBO.html#7643" class="Bound">i</a> <a id="7649" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="7651" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="7653" class="Symbol">→</a> <a id="7655" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="7661" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="7666" href="OCF.BTBO.html#7666" class="Bound">i</a> <a id="7668" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="7673" class="Symbol">=</a> <a id="7675" href="OCF.BTBO.html#7162" class="Datatype">Ord₊</a> <a id="7680" href="OCF.BTBO.html#7666" class="Bound">i</a> <a id="7682" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a>
  <a id="7689" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="7694" href="OCF.BTBO.html#7694" class="Bound">i</a> <a id="7696" class="Symbol">(</a><a id="7697" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="7701" href="OCF.BTBO.html#7701" class="Bound">p</a><a id="7702" class="Symbol">)</a> <a id="7704" class="Symbol">=</a> <a id="7706" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="7711" href="OCF.BTBO.html#7694" class="Bound">i</a> <a id="7713" href="OCF.BTBO.html#7701" class="Bound">p</a>

  <a id="Ord_nat.Ord"></a><a id="7718" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="7722" class="Symbol">:</a> <a id="7724" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7726" class="Symbol">→</a> <a id="7728" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="7734" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="7738" href="OCF.BTBO.html#7738" class="Bound">n</a> <a id="7740" class="Symbol">=</a> <a id="7742" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="7747" href="OCF.BTBO.html#7738" class="Bound">n</a> <a id="7749" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>
</pre>
<p><strong>定理</strong> <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;p:i&lt;n)</span> 与 <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;q:i&lt;m)</span> 表示相同的树.<br />
<strong>证明</strong> 对证明 <span class="math inline">p:i&lt;n</span> 和 <span class="math inline">q:i&lt;m</span> 归纳. 由 <span class="math inline">\mathsf{Ord}_{&lt;}</span> 的定义:</p>
<ul>
<li>若 <span class="math inline">p=(0_i:i&lt;i^+),\;q=(0_i:i&lt;i^+)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_+(i, \mathsf{Ord}_{&lt;}) = \mathsf{Ord}_{&lt;}(i,q)</span>.</li>
<li>若 <span class="math inline">p=(p&#39;^+:i&lt;n^+),\;q=(0_i:i&lt;i^+)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,p&#39;)</span>, 由归纳假设 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p&#39;) = \mathsf{Ord}_{&lt;}(i,q)</span>.</li>
<li>若 <span class="math inline">p:i&lt;n,\;q=q&#39;^+:i&lt;m^+</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,q) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>, 由归纳假设直接得 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>. ∎</li>
</ul>
<pre class="Agda">  <a id="Ord_nat.Ord&lt;-≡"></a><a id="8322" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8329" class="Symbol">:</a> <a id="8331" class="Symbol">(</a><a id="8332" href="OCF.BTBO.html#8332" class="Bound">p</a> <a id="8334" class="Symbol">:</a> <a id="8336" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8338" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="8340" href="OCF.BTBO.html#4319" class="Generalizable">n</a><a id="8341" class="Symbol">)</a> <a id="8343" class="Symbol">(</a><a id="8344" href="OCF.BTBO.html#8344" class="Bound">q</a> <a id="8346" class="Symbol">:</a> <a id="8348" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8350" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="8352" href="OCF.BTBO.html#4321" class="Generalizable">m</a><a id="8353" class="Symbol">)</a> <a id="8355" class="Symbol">→</a> <a id="8357" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="8362" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8364" href="OCF.BTBO.html#8332" class="Bound">p</a> <a id="8366" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8368" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="8373" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8375" href="OCF.BTBO.html#8344" class="Bound">q</a>
  <a id="8379" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8386" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="8391" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>      <a id="8401" class="Symbol">=</a> <a id="8403" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="8410" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8417" class="Symbol">(</a><a id="8418" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="8422" href="OCF.BTBO.html#8422" class="Bound">p</a><a id="8423" class="Symbol">)</a> <a id="8425" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>   <a id="8432" class="Symbol">=</a> <a id="8434" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8441" href="OCF.BTBO.html#8422" class="Bound">p</a> <a id="8443" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>
  <a id="8450" href="OCF.BTBO.html#8322" class="CatchallClause Function">Ord&lt;-≡</a><a id="8456" class="CatchallClause"> </a><a id="8457" href="OCF.BTBO.html#8457" class="CatchallClause Bound">p</a><a id="8458" class="CatchallClause"> </a><a id="8459" class="CatchallClause Symbol">(</a><a id="8460" href="OCF.BTBO.html#4386" class="CatchallClause InductiveConstructor">suc</a><a id="8463" class="CatchallClause"> </a><a id="8464" href="OCF.BTBO.html#8464" class="CatchallClause Bound">q</a><a id="8465" class="CatchallClause Symbol">)</a>      <a id="8472" class="Symbol">=</a> <a id="8474" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8481" href="OCF.BTBO.html#8457" class="Bound">p</a> <a id="8483" href="OCF.BTBO.html#8464" class="Bound">q</a>
</pre>
<p>也就是说 <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;p:i&lt;n)</span> 与 <span class="math inline">p</span> 和 <span class="math inline">n</span> 无关, 我们改记作 <span class="math inline">\mathsf{Ord}_{&lt;i&lt;\_}</span>.</p>
<pre class="Agda">  <a id="Ord_nat.coe"></a><a id="8582" href="OCF.BTBO.html#8582" class="Function">coe</a> <a id="8586" class="Symbol">:</a> <a id="8588" class="Symbol">{</a><a id="8589" href="OCF.BTBO.html#8589" class="Bound">p</a> <a id="8591" class="Symbol">:</a> <a id="8593" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8595" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="8597" href="OCF.BTBO.html#4319" class="Generalizable">n</a><a id="8598" class="Symbol">}</a> <a id="8600" class="Symbol">{</a><a id="8601" href="OCF.BTBO.html#8601" class="Bound">q</a> <a id="8603" class="Symbol">:</a> <a id="8605" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8607" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="8609" href="OCF.BTBO.html#4321" class="Generalizable">m</a><a id="8610" class="Symbol">}</a> <a id="8612" class="Symbol">→</a> <a id="8614" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="8619" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8621" href="OCF.BTBO.html#8589" class="Bound">p</a> <a id="8623" class="Symbol">→</a> <a id="8625" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="8630" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8632" href="OCF.BTBO.html#8601" class="Bound">q</a>
  <a id="8636" href="OCF.BTBO.html#8582" class="Function">coe</a> <a id="8640" class="Symbol">{</a><a id="8641" href="OCF.BTBO.html#8641" class="Bound">p</a><a id="8642" class="Symbol">}</a> <a id="8644" class="Symbol">{</a><a id="8645" href="OCF.BTBO.html#8645" class="Bound">q</a><a id="8646" class="Symbol">}</a> <a id="8648" class="Symbol">=</a> <a id="8650" href="OCF.BTBO.html#4096" class="Function">transport</a> <a id="8660" class="Symbol">(</a><a id="8661" href="OCF.BTBO.html#8322" class="Function">Ord&lt;-≡</a> <a id="8668" href="OCF.BTBO.html#8641" class="Bound">p</a> <a id="8670" href="OCF.BTBO.html#8645" class="Bound">q</a><a id="8671" class="Symbol">)</a>

  <a id="Ord_nat.coe₀"></a><a id="8676" href="OCF.BTBO.html#8676" class="Function">coe₀</a> <a id="8681" class="Symbol">:</a> <a id="8683" class="Symbol">{</a><a id="8684" href="OCF.BTBO.html#8684" class="Bound">p</a> <a id="8686" class="Symbol">:</a> <a id="8688" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8690" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="8692" href="OCF.BTBO.html#4321" class="Generalizable">m</a><a id="8693" class="Symbol">}</a> <a id="8695" class="Symbol">→</a> <a id="8697" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="8701" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8703" class="Symbol">→</a> <a id="8705" href="OCF.BTBO.html#7634" class="Function">Ord&lt;</a> <a id="8710" href="OCF.BTBO.html#7094" class="Generalizable">i</a> <a id="8712" href="OCF.BTBO.html#8684" class="Bound">p</a>
  <a id="8716" href="OCF.BTBO.html#8676" class="Function">coe₀</a> <a id="8721" class="Symbol">=</a> <a id="8723" href="OCF.BTBO.html#8582" class="Function">coe</a> <a id="8727" class="Symbol">{</a><a id="8728" class="Argument">p</a> <a id="8730" class="Symbol">=</a> <a id="8732" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a><a id="8736" class="Symbol">}</a>
</pre>
<h2 id="omega-cdot-2-层布劳威尔树"><span class="math inline">\omega \cdot 2</span> 层布劳威尔树</h2>
<p>继续往上, 把 <code>Ord : ℕ → Set</code> 封装进构造子 <span class="math inline">\mathsf{lim}_n</span>, 它允许构造共尾度为任意 <span class="math inline">\sup(\mathsf{Ord}_n)</span> 的序数, 这样就得到了 <span class="math inline">\mathsf{Ord}_\omega</span>.</p>
<p><strong>定义 (<span class="math inline">\omega</span>层树)</strong></p>
<p><span class="math display">
\mathsf{Ord}_\omega :=
\cfrac{}{\mathsf{Ord}_\omega}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_\omega\;}{\mathsf{Ord}_\omega}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_\omega\;}{\mathsf{Ord}_\omega}\;\mathsf{lim}
\;\;\;\;
\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_n\to\mathsf{Ord}_\omega)\;}{\mathsf{Ord}_\omega}\;\mathsf{lim}_n
</span></p>
<pre class="Agda">  <a id="9282" class="Keyword">data</a> <a id="Ord_nat.Ordω"></a><a id="9287" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a> <a id="9292" class="Symbol">:</a> <a id="9294" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="9298" class="Keyword">where</a>
    <a id="Ord_nat.Ordω.zero"></a><a id="9308" href="OCF.BTBO.html#9308" class="InductiveConstructor">zero</a> <a id="9313" class="Symbol">:</a> <a id="9315" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
    <a id="Ord_nat.Ordω.suc"></a><a id="9324" href="OCF.BTBO.html#9324" class="InductiveConstructor">suc</a>  <a id="9329" class="Symbol">:</a> <a id="9331" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a> <a id="9336" class="Symbol">→</a> <a id="9338" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
    <a id="Ord_nat.Ordω.lim"></a><a id="9347" href="OCF.BTBO.html#9347" class="InductiveConstructor">lim</a>  <a id="9352" class="Symbol">:</a> <a id="9354" class="Symbol">(</a><a id="9355" href="OCF.BTBO.html#9355" class="Bound">f</a> <a id="9357" class="Symbol">:</a> <a id="9359" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9361" class="Symbol">→</a> <a id="9363" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a><a id="9367" class="Symbol">)</a> <a id="9369" class="Symbol">→</a> <a id="9371" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
    <a id="Ord_nat.Ordω.limₙ"></a><a id="9380" href="OCF.BTBO.html#9380" class="InductiveConstructor">limₙ</a> <a id="9385" class="Symbol">:</a> <a id="9387" class="Symbol">(</a><a id="9388" href="OCF.BTBO.html#9388" class="Bound">n</a> <a id="9390" class="Symbol">:</a> <a id="9392" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="9393" class="Symbol">)</a> <a id="9395" class="Symbol">(</a><a id="9396" href="OCF.BTBO.html#9396" class="Bound">f</a> <a id="9398" class="Symbol">:</a> <a id="9400" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="9404" href="OCF.BTBO.html#9388" class="Bound">n</a> <a id="9406" class="Symbol">→</a> <a id="9408" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a><a id="9412" class="Symbol">)</a> <a id="9414" class="Symbol">→</a> <a id="9416" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
</pre>
<p>再添加共尾度为 <span class="math inline">\sup(\mathsf{Ord}_\omega)</span> 的序数, 就得到了 <span class="math inline">\mathsf{Ord}_{\omega+1}</span>.</p>
<p><strong>定义 (<span class="math inline">\omega+1</span> 层树)</strong></p>
<p><span class="math display">
\begin{align}
\mathsf{Ord}_{\omega+1} &amp;:=
\cfrac{}{\mathsf{Ord}_{\omega+1}}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_{\omega+1}\;}{\mathsf{Ord}_{\omega+1}}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_{\omega+1}\;}{\mathsf{Ord}_{\omega+1}}\;\mathsf{lim}
\\[1em]
&amp;\;\;\;\;\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_n\to\mathsf{Ord}_{\omega+1})\;}{\mathsf{Ord}_{\omega+1}}\;\mathsf{lim}_n
\;\;\;\;
\cfrac{\;\mathsf{Ord}_\omega\to\mathsf{Ord}_{\omega+1}\;}{\mathsf{Ord}_{\omega+1}}\;\mathsf{lim}_\omega
\end{align}
</span></p>
<pre class="Agda">  <a id="10074" class="Keyword">data</a> <a id="Ord_nat.Ordω+1"></a><a id="10079" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a> <a id="10086" class="Symbol">:</a> <a id="10088" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="10092" class="Keyword">where</a>
    <a id="Ord_nat.Ordω+1.zero"></a><a id="10102" href="OCF.BTBO.html#10102" class="InductiveConstructor">zero</a> <a id="10107" class="Symbol">:</a> <a id="10109" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a>
    <a id="Ord_nat.Ordω+1.suc"></a><a id="10120" href="OCF.BTBO.html#10120" class="InductiveConstructor">suc</a>  <a id="10125" class="Symbol">:</a> <a id="10127" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a> <a id="10134" class="Symbol">→</a> <a id="10136" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a>
    <a id="Ord_nat.Ordω+1.lim"></a><a id="10147" href="OCF.BTBO.html#10147" class="InductiveConstructor">lim</a>  <a id="10152" class="Symbol">:</a> <a id="10154" class="Symbol">(</a><a id="10155" href="OCF.BTBO.html#10155" class="Bound">f</a> <a id="10157" class="Symbol">:</a> <a id="10159" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10161" class="Symbol">→</a> <a id="10163" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a><a id="10169" class="Symbol">)</a> <a id="10171" class="Symbol">→</a> <a id="10173" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a>
    <a id="Ord_nat.Ordω+1.limₙ"></a><a id="10184" href="OCF.BTBO.html#10184" class="InductiveConstructor">limₙ</a> <a id="10189" class="Symbol">:</a> <a id="10191" class="Symbol">(</a><a id="10192" href="OCF.BTBO.html#10192" class="Bound">n</a> <a id="10194" class="Symbol">:</a> <a id="10196" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="10197" class="Symbol">)</a> <a id="10199" class="Symbol">(</a><a id="10200" href="OCF.BTBO.html#10200" class="Bound">f</a> <a id="10202" class="Symbol">:</a> <a id="10204" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="10208" href="OCF.BTBO.html#10192" class="Bound">n</a> <a id="10210" class="Symbol">→</a> <a id="10212" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a><a id="10218" class="Symbol">)</a> <a id="10220" class="Symbol">→</a> <a id="10222" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a>
    <a id="Ord_nat.Ordω+1.limω"></a><a id="10233" href="OCF.BTBO.html#10233" class="InductiveConstructor">limω</a> <a id="10238" class="Symbol">:</a> <a id="10240" class="Symbol">(</a><a id="10241" href="OCF.BTBO.html#10241" class="Bound">f</a> <a id="10243" class="Symbol">:</a> <a id="10245" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a> <a id="10250" class="Symbol">→</a> <a id="10252" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a><a id="10258" class="Symbol">)</a> <a id="10260" class="Symbol">→</a> <a id="10262" href="OCF.BTBO.html#10079" class="Datatype">Ordω+1</a>
</pre>
<p>重复上述过程可以得到 <span class="math inline">\mathsf{Ord}_{\omega+n}</span>, <span class="math inline">\mathsf{Ord}_{\omega \cdot 2}</span> 和 <span class="math inline">\mathsf{Ord}_{\omega \cdot 2+1}</span>.</p>
<p><strong>定义 (<span class="math inline">\omega \cdot 2</span> 层树)</strong></p>
<p><span class="math display">
\begin{align}
\mathsf{Ord}_{\omega+}(n, \mathsf{Ord}_{\omega&lt;}) &amp;:=
\cfrac{}{\mathsf{Ord}_{\omega+}}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_{\omega+}\;}{\mathsf{Ord}_{\omega+}}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_{\omega+}\;}{\mathsf{Ord}_{\omega+}}\;\mathsf{lim}
\\[1em]
&amp;\;\;\;\;\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_n\to\mathsf{Ord}_{\omega+})\;}{\mathsf{Ord}_{\omega+}}\;\mathsf{lim}_n
\;\;\;\;
\cfrac{\;(k:\mathbb{N})\;(p:k&lt;n)\;\;\;(\mathsf{Ord}_{\omega&lt;}(k,p)\to\mathsf{Ord}_{\omega+})\;}{\mathsf{Ord}_{\omega+}}\;\mathsf{lim}_{\omega+k}
\\[2em]
\mathsf{Ord}_{\omega&lt;}(k, p) &amp;:=
\begin{cases}
   \mathsf{Ord}_{\omega+}(k, \mathsf{Ord}_{\omega&lt;}) &amp;\text{if } p = (0_k:k&lt;k^+) \\
   \mathsf{Ord}_{\omega&lt;}(k, q) &amp;\text{if } p = (q^+:k&lt;m^+)
\end{cases}
\\[1em]
\mathsf{Ord}_{\omega+n} &amp;:= \mathsf{Ord}_{\omega&lt;}(n,0_n)
\\[2em]
\mathsf{Ord}_{\omega \cdot 2} &amp;:=
\cfrac{}{\mathsf{Ord}_{\omega \cdot 2}}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_{\omega \cdot 2}\;}{\mathsf{Ord}_{\omega \cdot 2}}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_{\omega \cdot 2}\;}{\mathsf{Ord}_{\omega \cdot 2}}\;\mathsf{lim}
\\[1em]
&amp;\;\;\;\;\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_n\to\mathsf{Ord}_{\omega \cdot 2})\;}{\mathsf{Ord}_{\omega \cdot 2}}\;\mathsf{lim}_n
\;\;\;\;
\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_{\omega+n}\to\mathsf{Ord}_{\omega \cdot 2})\;}{\mathsf{Ord}_{\omega \cdot 2}}\;\mathsf{lim}_{\omega+n}
\\[2em]
\mathsf{Ord}_{\omega \cdot 2+1} &amp;:=
\cfrac{}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_{\omega \cdot 2+1}\;}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_{\omega \cdot 2+1}\;}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{lim}
\\[1em]
&amp;\;\;\;\;\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_n\to\mathsf{Ord}_{\omega \cdot 2+1})\;}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{lim}_n
\;\;\;\;
\cfrac{\;(n:\mathbb{N})\;\;\;(\mathsf{Ord}_{\omega+n}\to\mathsf{Ord}_{\omega \cdot 2+1})\;}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{lim}_{\omega+n}
\\[1em]
&amp;\;\;\;\;\cfrac{\;\mathsf{Ord}_{\omega \cdot 2}\to\mathsf{Ord}_{\omega \cdot 2+1}\;}{\mathsf{Ord}_{\omega \cdot 2+1}}\;\mathsf{lim}_{\omega \cdot 2}
\end{align}
</span></p>
<pre class="Agda">  <a id="12683" class="Keyword">module</a> <a id="12690" href="OCF.BTBO.html#12690" class="Module">_</a> <a id="12692" class="Symbol">(</a><a id="12693" href="OCF.BTBO.html#12693" class="Bound">n</a> <a id="12695" class="Symbol">:</a> <a id="12697" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="12698" class="Symbol">)</a> <a id="12700" class="Symbol">(</a><a id="12701" href="OCF.BTBO.html#12701" class="Bound">Ordω&lt;</a> <a id="12707" class="Symbol">:</a> <a id="12709" class="Symbol">∀</a> <a id="12711" href="OCF.BTBO.html#12711" class="Bound">k</a> <a id="12713" class="Symbol">→</a> <a id="12715" href="OCF.BTBO.html#12711" class="Bound">k</a> <a id="12717" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="12719" href="OCF.BTBO.html#12693" class="Bound">n</a> <a id="12721" class="Symbol">→</a> <a id="12723" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="12726" class="Symbol">)</a> <a id="12728" class="Keyword">where</a>
    <a id="12738" class="Keyword">data</a> <a id="12743" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a> <a id="12749" class="Symbol">:</a> <a id="12751" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="12755" class="Keyword">where</a>
      <a id="12767" href="OCF.BTBO.html#12767" class="InductiveConstructor">zero</a>  <a id="12773" class="Symbol">:</a> <a id="12775" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a>
      <a id="12787" href="OCF.BTBO.html#12787" class="InductiveConstructor">suc</a>   <a id="12793" class="Symbol">:</a> <a id="12795" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a> <a id="12801" class="Symbol">→</a> <a id="12803" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a>
      <a id="12815" href="OCF.BTBO.html#12815" class="InductiveConstructor">lim</a>   <a id="12821" class="Symbol">:</a> <a id="12823" class="Symbol">(</a><a id="12824" href="OCF.BTBO.html#12824" class="Bound">f</a> <a id="12826" class="Symbol">:</a> <a id="12828" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12830" class="Symbol">→</a> <a id="12832" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a><a id="12837" class="Symbol">)</a> <a id="12839" class="Symbol">→</a> <a id="12841" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a>
      <a id="12853" href="OCF.BTBO.html#12853" class="InductiveConstructor">limₙ</a>  <a id="12859" class="Symbol">:</a> <a id="12861" class="Symbol">(</a><a id="12862" href="OCF.BTBO.html#12862" class="Bound">n</a> <a id="12864" class="Symbol">:</a> <a id="12866" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="12867" class="Symbol">)</a> <a id="12869" class="Symbol">(</a><a id="12870" href="OCF.BTBO.html#12870" class="Bound">f</a> <a id="12872" class="Symbol">:</a> <a id="12874" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="12878" href="OCF.BTBO.html#12862" class="Bound">n</a> <a id="12880" class="Symbol">→</a> <a id="12882" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a><a id="12887" class="Symbol">)</a> <a id="12889" class="Symbol">→</a> <a id="12891" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a>
      <a id="12903" href="OCF.BTBO.html#12903" class="InductiveConstructor">limω+</a> <a id="12909" class="Symbol">:</a> <a id="12911" class="Symbol">(</a><a id="12912" href="OCF.BTBO.html#12912" class="Bound">k</a> <a id="12914" class="Symbol">:</a> <a id="12916" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="12917" class="Symbol">)</a> <a id="12919" class="Symbol">(</a><a id="12920" href="OCF.BTBO.html#12920" class="Bound">p</a> <a id="12922" class="Symbol">:</a> <a id="12924" href="OCF.BTBO.html#12912" class="Bound">k</a> <a id="12926" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="12928" href="OCF.BTBO.html#12693" class="Bound">n</a><a id="12929" class="Symbol">)</a> <a id="12931" class="Symbol">(</a><a id="12932" href="OCF.BTBO.html#12932" class="Bound">f</a> <a id="12934" class="Symbol">:</a> <a id="12936" href="OCF.BTBO.html#12701" class="Bound">Ordω&lt;</a> <a id="12942" href="OCF.BTBO.html#12912" class="Bound">k</a> <a id="12944" href="OCF.BTBO.html#12920" class="Bound">p</a> <a id="12946" class="Symbol">→</a> <a id="12948" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a><a id="12953" class="Symbol">)</a> <a id="12955" class="Symbol">→</a> <a id="12957" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a>

  <a id="Ord_nat.Ordω&lt;"></a><a id="12966" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a> <a id="12972" class="Symbol">:</a> <a id="12974" class="Symbol">∀</a> <a id="12976" class="Symbol">{</a><a id="12977" href="OCF.BTBO.html#12977" class="Bound">n</a><a id="12978" class="Symbol">}</a> <a id="12980" href="OCF.BTBO.html#12980" class="Bound">k</a> <a id="12982" class="Symbol">→</a> <a id="12984" href="OCF.BTBO.html#12980" class="Bound">k</a> <a id="12986" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="12988" href="OCF.BTBO.html#12977" class="Bound">n</a> <a id="12990" class="Symbol">→</a> <a id="12992" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="12998" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a> <a id="13004" href="OCF.BTBO.html#13004" class="Bound">k</a> <a id="13006" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="13011" class="Symbol">=</a> <a id="13013" href="OCF.BTBO.html#12743" class="Datatype">Ordω₊</a> <a id="13019" href="OCF.BTBO.html#13004" class="Bound">k</a> <a id="13021" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a>
  <a id="13029" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a> <a id="13035" href="OCF.BTBO.html#13035" class="Bound">k</a> <a id="13037" class="Symbol">(</a><a id="13038" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="13042" href="OCF.BTBO.html#13042" class="Bound">p</a><a id="13043" class="Symbol">)</a> <a id="13045" class="Symbol">=</a> <a id="13047" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a> <a id="13053" href="OCF.BTBO.html#13035" class="Bound">k</a> <a id="13055" href="OCF.BTBO.html#13042" class="Bound">p</a>

  <a id="Ord_nat.Ordω+"></a><a id="13060" href="OCF.BTBO.html#13060" class="Function">Ordω+</a> <a id="13066" class="Symbol">:</a> <a id="13068" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="13070" class="Symbol">→</a> <a id="13072" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="13078" href="OCF.BTBO.html#13060" class="Function">Ordω+</a> <a id="13084" href="OCF.BTBO.html#13084" class="Bound">n</a> <a id="13086" class="Symbol">=</a> <a id="13088" href="OCF.BTBO.html#12966" class="Function">Ordω&lt;</a> <a id="13094" href="OCF.BTBO.html#13084" class="Bound">n</a> <a id="13096" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>

  <a id="13104" class="Keyword">data</a> <a id="Ord_nat.Ordω2"></a><a id="13109" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a> <a id="13115" class="Symbol">:</a> <a id="13117" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="13121" class="Keyword">where</a>
    <a id="Ord_nat.Ordω2.zero"></a><a id="13131" href="OCF.BTBO.html#13131" class="InductiveConstructor">zero</a>  <a id="13137" class="Symbol">:</a> <a id="13139" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a>
    <a id="Ord_nat.Ordω2.suc"></a><a id="13149" href="OCF.BTBO.html#13149" class="InductiveConstructor">suc</a>   <a id="13155" class="Symbol">:</a> <a id="13157" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a> <a id="13163" class="Symbol">→</a> <a id="13165" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a>
    <a id="Ord_nat.Ordω2.lim"></a><a id="13175" href="OCF.BTBO.html#13175" class="InductiveConstructor">lim</a>   <a id="13181" class="Symbol">:</a> <a id="13183" class="Symbol">(</a><a id="13184" href="OCF.BTBO.html#13184" class="Bound">f</a> <a id="13186" class="Symbol">:</a> <a id="13188" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="13190" class="Symbol">→</a> <a id="13192" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a><a id="13197" class="Symbol">)</a> <a id="13199" class="Symbol">→</a> <a id="13201" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a>
    <a id="Ord_nat.Ordω2.limₙ"></a><a id="13211" href="OCF.BTBO.html#13211" class="InductiveConstructor">limₙ</a>  <a id="13217" class="Symbol">:</a> <a id="13219" class="Symbol">(</a><a id="13220" href="OCF.BTBO.html#13220" class="Bound">n</a> <a id="13222" class="Symbol">:</a> <a id="13224" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13225" class="Symbol">)</a> <a id="13227" class="Symbol">(</a><a id="13228" href="OCF.BTBO.html#13228" class="Bound">f</a> <a id="13230" class="Symbol">:</a> <a id="13232" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="13236" href="OCF.BTBO.html#13220" class="Bound">n</a> <a id="13238" class="Symbol">→</a> <a id="13240" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a><a id="13245" class="Symbol">)</a> <a id="13247" class="Symbol">→</a> <a id="13249" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a>
    <a id="Ord_nat.Ordω2.limω+"></a><a id="13259" href="OCF.BTBO.html#13259" class="InductiveConstructor">limω+</a> <a id="13265" class="Symbol">:</a> <a id="13267" class="Symbol">(</a><a id="13268" href="OCF.BTBO.html#13268" class="Bound">n</a> <a id="13270" class="Symbol">:</a> <a id="13272" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13273" class="Symbol">)</a> <a id="13275" class="Symbol">(</a><a id="13276" href="OCF.BTBO.html#13276" class="Bound">f</a> <a id="13278" class="Symbol">:</a> <a id="13280" href="OCF.BTBO.html#13060" class="Function">Ordω+</a> <a id="13286" href="OCF.BTBO.html#13268" class="Bound">n</a> <a id="13288" class="Symbol">→</a> <a id="13290" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a><a id="13295" class="Symbol">)</a> <a id="13297" class="Symbol">→</a> <a id="13299" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a>

  <a id="13308" class="Keyword">data</a> <a id="Ord_nat.Ordω2+1"></a><a id="13313" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a> <a id="13321" class="Symbol">:</a> <a id="13323" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="13327" class="Keyword">where</a>
    <a id="Ord_nat.Ordω2+1.zero"></a><a id="13337" href="OCF.BTBO.html#13337" class="InductiveConstructor">zero</a>  <a id="13343" class="Symbol">:</a> <a id="13345" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
    <a id="Ord_nat.Ordω2+1.suc"></a><a id="13357" href="OCF.BTBO.html#13357" class="InductiveConstructor">suc</a>   <a id="13363" class="Symbol">:</a> <a id="13365" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a> <a id="13373" class="Symbol">→</a> <a id="13375" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
    <a id="Ord_nat.Ordω2+1.lim"></a><a id="13387" href="OCF.BTBO.html#13387" class="InductiveConstructor">lim</a>   <a id="13393" class="Symbol">:</a> <a id="13395" class="Symbol">(</a><a id="13396" href="OCF.BTBO.html#13396" class="Bound">f</a> <a id="13398" class="Symbol">:</a> <a id="13400" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="13402" class="Symbol">→</a> <a id="13404" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a><a id="13411" class="Symbol">)</a> <a id="13413" class="Symbol">→</a> <a id="13415" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
    <a id="Ord_nat.Ordω2+1.limₙ"></a><a id="13427" href="OCF.BTBO.html#13427" class="InductiveConstructor">limₙ</a>  <a id="13433" class="Symbol">:</a> <a id="13435" class="Symbol">(</a><a id="13436" href="OCF.BTBO.html#13436" class="Bound">n</a> <a id="13438" class="Symbol">:</a> <a id="13440" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13441" class="Symbol">)</a> <a id="13443" class="Symbol">(</a><a id="13444" href="OCF.BTBO.html#13444" class="Bound">f</a> <a id="13446" class="Symbol">:</a> <a id="13448" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="13452" href="OCF.BTBO.html#13436" class="Bound">n</a> <a id="13454" class="Symbol">→</a> <a id="13456" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a><a id="13463" class="Symbol">)</a> <a id="13465" class="Symbol">→</a> <a id="13467" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
    <a id="Ord_nat.Ordω2+1.limω+"></a><a id="13479" href="OCF.BTBO.html#13479" class="InductiveConstructor">limω+</a> <a id="13485" class="Symbol">:</a> <a id="13487" class="Symbol">(</a><a id="13488" href="OCF.BTBO.html#13488" class="Bound">n</a> <a id="13490" class="Symbol">:</a> <a id="13492" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13493" class="Symbol">)</a> <a id="13495" class="Symbol">(</a><a id="13496" href="OCF.BTBO.html#13496" class="Bound">f</a> <a id="13498" class="Symbol">:</a> <a id="13500" href="OCF.BTBO.html#13060" class="Function">Ordω+</a> <a id="13506" href="OCF.BTBO.html#13488" class="Bound">n</a> <a id="13508" class="Symbol">→</a> <a id="13510" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a><a id="13517" class="Symbol">)</a> <a id="13519" class="Symbol">→</a> <a id="13521" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
    <a id="Ord_nat.Ordω2+1.limω2"></a><a id="13533" href="OCF.BTBO.html#13533" class="InductiveConstructor">limω2</a> <a id="13539" class="Symbol">:</a> <a id="13541" class="Symbol">(</a><a id="13542" href="OCF.BTBO.html#13542" class="Bound">f</a> <a id="13544" class="Symbol">:</a> <a id="13546" href="OCF.BTBO.html#13109" class="Datatype">Ordω2</a> <a id="13552" class="Symbol">→</a> <a id="13554" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a><a id="13561" class="Symbol">)</a> <a id="13563" class="Symbol">→</a> <a id="13565" href="OCF.BTBO.html#13313" class="Datatype">Ordω2+1</a>
</pre>
<h2 id="内-omega-数">内 <span class="math inline">\Omega</span> 数</h2>
<p>前面说过, 一个布劳威尔树类型 <code>Ord n</code> 本身可以视作一个 <span class="math inline">\Omega</span> 数, 代表该类型的项所能表示的序数的上确界. 现在我们转而研究该类型的项所能表示的 <span class="math inline">\Omega</span> 数, 我们称为<strong>内 <span class="math inline">\Omega</span> 数</strong>. 其中最大的那个, 称为最大内 <span class="math inline">\Omega</span> 数.</p>
<p><strong>定义 (层级提升函数)</strong> 对任意 <span class="math inline">n : \mathbb{N}</span>, 递归定义 <span class="math inline">\text{Ord}_n</span> 到 <span class="math inline">\text{Ord}_{n^+}</span> 的嵌入 <span class="math inline">↑_+</span> 如下:</p>
<ul>
<li>如果 <span class="math inline">a : \text{Ord}_n</span> 由 <span class="math inline">\mathsf{zero}</span>, <span class="math inline">\mathsf{suc}</span> 或 <span class="math inline">\mathsf{lim}</span> 构造, 我们直接使用 <span class="math inline">\text{Ord}_{n^+}</span> 的同名构造子递归构造 <span class="math inline">↑_+a</span>.</li>
<li>如果 <span class="math inline">a = \mathsf{lim}_n(p,f)</span>, 其中 <span class="math inline">p:i&lt;n</span> 且 <span class="math inline">f:\mathsf{Ord}_{&lt;}(i,\;p)\to\text{Ord}_n</span>, 则 <span class="math inline">↑_+a:=\mathsf{lim}_n(p^+,↑_+\circ f)</span>, 其中 <span class="math inline">p^+:i&lt;n^+</span> 且 <span class="math inline">(↑_+\circ f):\mathsf{Ord}_{&lt;}(i,\;p)\to\text{Ord}_{n^+}</span>.</li>
</ul>
<pre class="Agda">  <a id="Ord_nat.↑₊"></a><a id="14177" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14180" class="Symbol">:</a> <a id="14182" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="14186" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="14188" class="Symbol">→</a> <a id="14190" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="14194" class="Symbol">(</a><a id="14195" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14199" href="OCF.BTBO.html#4319" class="Generalizable">n</a><a id="14200" class="Symbol">)</a>
  <a id="14204" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14207" href="OCF.BTBO.html#7185" class="InductiveConstructor">zero</a> <a id="14212" class="Symbol">=</a> <a id="14214" href="OCF.BTBO.html#7185" class="InductiveConstructor">zero</a>
  <a id="14221" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14224" class="Symbol">(</a><a id="14225" href="OCF.BTBO.html#7203" class="InductiveConstructor">suc</a> <a id="14229" href="OCF.BTBO.html#14229" class="Bound">a</a><a id="14230" class="Symbol">)</a> <a id="14232" class="Symbol">=</a> <a id="14234" href="OCF.BTBO.html#7203" class="InductiveConstructor">suc</a> <a id="14238" class="Symbol">(</a><a id="14239" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14242" href="OCF.BTBO.html#14229" class="Bound">a</a><a id="14243" class="Symbol">)</a>
  <a id="14247" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14250" class="Symbol">(</a><a id="14251" href="OCF.BTBO.html#7228" class="InductiveConstructor">lim</a> <a id="14255" href="OCF.BTBO.html#14255" class="Bound">f</a><a id="14256" class="Symbol">)</a> <a id="14258" class="Symbol">=</a> <a id="14260" href="OCF.BTBO.html#7228" class="InductiveConstructor">lim</a> <a id="14264" class="Symbol">(</a><a id="14265" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14268" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="14270" href="OCF.BTBO.html#14255" class="Bound">f</a><a id="14271" class="Symbol">)</a>
  <a id="14275" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14278" class="Symbol">(</a><a id="14279" href="OCF.BTBO.html#7263" class="InductiveConstructor">limᵢ</a> <a id="14284" href="OCF.BTBO.html#14284" class="Bound">p</a> <a id="14286" href="OCF.BTBO.html#14286" class="Bound">f</a><a id="14287" class="Symbol">)</a> <a id="14289" class="Symbol">=</a> <a id="14291" href="OCF.BTBO.html#7263" class="InductiveConstructor">limᵢ</a> <a id="14296" class="Symbol">(</a><a id="14297" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="14301" href="OCF.BTBO.html#14284" class="Bound">p</a><a id="14302" class="Symbol">)</a> <a id="14304" class="Symbol">(</a><a id="14305" href="OCF.BTBO.html#14177" class="Function">↑₊</a> <a id="14308" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="14310" href="OCF.BTBO.html#14286" class="Bound">f</a><a id="14311" class="Symbol">)</a>
</pre>
<p>向上嵌入允许我们在 <span class="math inline">\text{Ord}_{n^+}</span> 中表达 <span class="math inline">↑_+:\text{Ord}_{n}\to\text{Ord}_{n^+}</span> 的极限, 该极限就是我们所需的最大内 <span class="math inline">\Omega</span> 数.</p>
<p><strong>定义 (Ω数)</strong> 遵循 <a href="https://en.wikipedia.org/wiki/Buchholz_psi_functions">Buchholz</a> 的定义</p>
<p><span class="math display">
\Omega_n :=
\begin{cases}
   1 &amp;\text{if } n = 0 \\
   \mathsf{lim}_{n&#39;}(0_{n&#39;},↑_+) &amp;\text{if } n = n&#39;^+
\end{cases}
</span></p>
<pre class="Agda">  <a id="Ord_nat.Ω"></a><a id="14645" href="OCF.BTBO.html#14645" class="Function">Ω</a> <a id="14647" class="Symbol">:</a> <a id="14649" class="Symbol">(</a><a id="14650" href="OCF.BTBO.html#14650" class="Bound">n</a> <a id="14652" class="Symbol">:</a> <a id="14654" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="14655" class="Symbol">)</a> <a id="14657" class="Symbol">→</a> <a id="14659" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="14663" href="OCF.BTBO.html#14650" class="Bound">n</a>
  <a id="14667" href="OCF.BTBO.html#14645" class="Function">Ω</a> <a id="14669" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="14677" class="Symbol">=</a> <a id="14679" href="OCF.BTBO.html#7203" class="InductiveConstructor">suc</a> <a id="14683" href="OCF.BTBO.html#7185" class="InductiveConstructor">zero</a>
  <a id="14690" href="OCF.BTBO.html#14645" class="Function">Ω</a> <a id="14692" class="Symbol">(</a><a id="14693" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14697" href="OCF.BTBO.html#14697" class="Bound">n</a><a id="14698" class="Symbol">)</a> <a id="14700" class="Symbol">=</a> <a id="14702" href="OCF.BTBO.html#7263" class="InductiveConstructor">limᵢ</a> <a id="14707" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a> <a id="14712" href="OCF.BTBO.html#14177" class="Function">↑₊</a>
</pre>
<p>继续往上, 与 <span class="math inline">↑_+</span> 类似地</p>
<p><strong>定义 (层级提升函数)</strong> 对任意 <span class="math inline">n : \mathbb{N}</span>, 递归定义 <span class="math inline">\text{Ord}_n</span> 到 <span class="math inline">\text{Ord}_\omega</span> 的嵌入 <span class="math inline">↑_\omega</span> 如下:</p>
<p><span class="math display">
↑_\omega a :=
\begin{cases}
   \mathsf{zero} &amp;\text{if } a = \mathsf{zero} \\
   \mathsf{suc}(↑_\omega a&#39;) &amp;\text{if } a = \mathsf{suc}(a&#39;) \\
   \mathsf{lim}(↑_\omega \circ f) &amp;\text{if } a = \mathsf{lim}(f) \\
   \mathsf{lim}_i(↑_\omega \circ f) &amp;\text{if } a = \mathsf{lim}_i(p:i&lt;n, f)
\end{cases}
</span></p>
<pre class="Agda">  <a id="Ord_nat.↑ω"></a><a id="15159" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15162" class="Symbol">:</a> <a id="15164" href="OCF.BTBO.html#7718" class="Function">Ord</a> <a id="15168" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="15170" class="Symbol">→</a> <a id="15172" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
  <a id="15179" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15182" href="OCF.BTBO.html#7185" class="InductiveConstructor">zero</a> <a id="15187" class="Symbol">=</a> <a id="15189" href="OCF.BTBO.html#9308" class="InductiveConstructor">zero</a>
  <a id="15196" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15199" class="Symbol">(</a><a id="15200" href="OCF.BTBO.html#7203" class="InductiveConstructor">suc</a> <a id="15204" href="OCF.BTBO.html#15204" class="Bound">a</a><a id="15205" class="Symbol">)</a> <a id="15207" class="Symbol">=</a> <a id="15209" href="OCF.BTBO.html#9324" class="InductiveConstructor">suc</a> <a id="15213" class="Symbol">(</a><a id="15214" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15217" href="OCF.BTBO.html#15204" class="Bound">a</a><a id="15218" class="Symbol">)</a>
  <a id="15222" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15225" class="Symbol">(</a><a id="15226" href="OCF.BTBO.html#7228" class="InductiveConstructor">lim</a> <a id="15230" href="OCF.BTBO.html#15230" class="Bound">f</a><a id="15231" class="Symbol">)</a> <a id="15233" class="Symbol">=</a> <a id="15235" href="OCF.BTBO.html#9347" class="InductiveConstructor">lim</a> <a id="15239" class="Symbol">(</a><a id="15240" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15243" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="15245" href="OCF.BTBO.html#15230" class="Bound">f</a><a id="15246" class="Symbol">)</a>
  <a id="15250" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15253" class="Symbol">(</a><a id="15254" href="OCF.BTBO.html#7263" class="InductiveConstructor">limᵢ</a> <a id="15259" href="OCF.BTBO.html#15259" class="Bound">p</a> <a id="15261" href="OCF.BTBO.html#15261" class="Bound">f</a><a id="15262" class="Symbol">)</a> <a id="15264" class="Symbol">=</a> <a id="15266" href="OCF.BTBO.html#9380" class="InductiveConstructor">limₙ</a> <a id="15271" class="Symbol">_</a> <a id="15273" class="Symbol">(</a><a id="15274" href="OCF.BTBO.html#15159" class="Function">↑ω</a> <a id="15277" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="15279" href="OCF.BTBO.html#15261" class="Bound">f</a> <a id="15281" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="15283" href="OCF.BTBO.html#8676" class="Function">coe₀</a><a id="15287" class="Symbol">)</a>
</pre>
<p>由此, 对每个 <span class="math inline">n</span>, 我们可以表达 <span class="math inline">↑_ω : \text{Ord}_n\to\text{Ord}_\omega</span> 的 <span class="math inline">\mathsf{lim}_n</span> 极限, 它们都是 <span class="math inline">\text{Ord}_\omega</span> 的内 <span class="math inline">\Omega</span> 数, 但都不是最大的那个. 在 <span class="math inline">\text{Ord}_\omega</span> 里可以取它们的 <span class="math inline">\mathsf{lim}</span> 极限, 得到的就是 <span class="math inline">\text{Ord}_\omega</span> 的最大内 <span class="math inline">\Omega</span> 数 <span class="math inline">\Omega_\omega</span>.</p>
<p><strong>定义 (<span class="math inline">\Omega_\omega</span>)</strong> <span class="math inline">\text{Ord}_\omega</span> 的最大内 <span class="math inline">\Omega</span> 数定义为:</p>
<p><span class="math display">
\Omega_\omega := \mathsf{lim}(n \mapsto \mathsf{lim}_n(↑_\omega))
</span></p>
<pre class="Agda">  <a id="Ord_nat.Ωω"></a><a id="15689" href="OCF.BTBO.html#15689" class="Function">Ωω</a> <a id="15692" class="Symbol">:</a> <a id="15694" href="OCF.BTBO.html#9287" class="Datatype">Ordω</a>
  <a id="15701" href="OCF.BTBO.html#15689" class="Function">Ωω</a> <a id="15704" class="Symbol">=</a> <a id="15706" href="OCF.BTBO.html#9347" class="InductiveConstructor">lim</a> <a id="15710" class="Symbol">(λ</a> <a id="15713" href="OCF.BTBO.html#15713" class="Bound">n</a> <a id="15715" class="Symbol">→</a> <a id="15717" href="OCF.BTBO.html#9380" class="InductiveConstructor">limₙ</a> <a id="15722" href="OCF.BTBO.html#15713" class="Bound">n</a> <a id="15724" href="OCF.BTBO.html#15159" class="Function">↑ω</a><a id="15726" class="Symbol">)</a>
</pre>
<p>类似地可以定义 <span class="math inline">\Omega_{\omega+n}</span> 和 <span class="math inline">\Omega_{\omega \cdot 2}</span>. 因为这些都会在后面由更一般化的定义给出, 这里就省略不写了.</p>
<p>目前的成果可以总结如下:</p>
<p><span class="math display">
\begin{array}{|c|c|c|c|}
\hline
\text{type} &amp; \text{supermun} &amp; \text{max inner }\Omega &amp; \text{cofinality} \\
\hline
\mathbb{0} &amp; 0 &amp; \text{n/a} &amp; \text{n/a} \\
\hline
\mathbb{1} &amp; 1 &amp; 0 &amp; 0 \\
\hline
\mathbb{N} &amp; \omega &amp; 1 &amp; 1 \\
\hline
\mathsf{Ord}_0 &amp; \Omega &amp; \omega &amp; \omega \\
\hline
\mathsf{Ord}_1 &amp; \Omega_2 &amp; \Omega &amp; \Omega \\
\hline
\mathsf{Ord}_2 &amp; \Omega_3 &amp; \Omega_2 &amp; \Omega_2 \\
\hline
\mathsf{Ord}_n &amp; \Omega_{n+1} &amp; \Omega_n &amp; \Omega_n \\
\hline
\mathsf{Ord}_{\omega} &amp; \Omega_{\omega+1} &amp; \Omega_\omega &amp; \omega \\
\hline
\mathsf{Ord}_{\omega+1} &amp; \Omega_{\omega+2} &amp; \Omega_{\omega+1} &amp; \Omega_{\omega+1} \\
\hline
\mathsf{Ord}_{\omega+n} &amp; \Omega_{\omega+n+1} &amp; \Omega_{\omega+n} &amp; \Omega_{\omega+n} \\
\hline
\mathsf{Ord}_{\omega \cdot 2} &amp; \Omega_{\omega \cdot 2+1} &amp; \Omega_{\omega \cdot 2} &amp; \omega \\
\hline
\mathsf{Ord}_{\omega \cdot 2+1} &amp; \Omega_{\omega \cdot 2+2} &amp; \Omega_{\omega \cdot 2+1} &amp; \Omega_{\omega \cdot 2+1} \\
\hline
\end{array}
</span></p>
<h2 id="可数序数的有界三歧性">可数序数的有界三歧性</h2>
<p>为了一劳永逸地定义 <span class="math inline">\mathsf{Ord}_\alpha</span> (其中 <span class="math inline">\alpha &lt; \Omega</span>), 我们要以可数序数 <span class="math inline">\mathsf{Ord}_0</span> 为下标, 写出一个新的类型族 <code>Ord : Ord₀ → Set</code>. 但是我们现有的 <code>Ord₀</code> 太过于宽泛了, 缺乏一些关键性质, 不能直接作为索引类型, 否则会导致后续无法折叠. 为此我们将专门定义具有所谓<strong>有界三歧性 (bounded decidability)</strong> 的可数序数类型 <span class="math inline">\mathsf{Ord}^\mathsf{D}</span>, 它也是我们在 <a href="https://zhuanlan.zhihu.com/p/711649863">2.0系列</a> 介绍的良构序数的简化版本.</p>
<p>为了表达三歧性, 我们引入和类型.</p>
<pre class="Agda"><a id="17185" class="Keyword">open</a> <a id="17190" class="Keyword">import</a> <a id="17197" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="17206" class="Keyword">using</a> <a id="17212" class="Symbol">(</a><a id="17213" href="Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="17216" class="Symbol">;</a> <a id="17218" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="17222" class="Symbol">;</a> <a id="17224" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="17228" class="Symbol">)</a>

<a id="17231" class="Keyword">pattern</a> <a id="injᵃ"></a><a id="17239" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="17244" href="OCF.BTBO.html#17253" class="Bound">x</a> <a id="17246" class="Symbol">=</a> <a id="17248" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="17253" href="OCF.BTBO.html#17253" class="Bound">x</a>
<a id="17255" class="Keyword">pattern</a> <a id="injᵇ"></a><a id="17263" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="17268" href="OCF.BTBO.html#17283" class="Bound">x</a> <a id="17270" class="Symbol">=</a> <a id="17272" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="17277" class="Symbol">(</a><a id="17278" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="17283" href="OCF.BTBO.html#17283" class="Bound">x</a><a id="17284" class="Symbol">)</a>
<a id="17286" class="Keyword">pattern</a> <a id="injᶜ"></a><a id="17294" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="17299" href="OCF.BTBO.html#17314" class="Bound">x</a> <a id="17301" class="Symbol">=</a> <a id="17303" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="17308" class="Symbol">(</a><a id="17309" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="17314" href="OCF.BTBO.html#17314" class="Bound">x</a><a id="17315" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 在自然数上</p>
<ul>
<li><ol type="1">
<li>零小于后继</li>
</ol></li>
<li><ol start="2" type="1">
<li>后继运算保持小于关系</li>
</ol></li>
</ul>
<p><strong>证明</strong></p>
<ol type="1">
<li>要证 <span class="math inline">0 &lt; n^+</span>, 对 <span class="math inline">n</span> 归纳.</li>
</ol>
<ul>
<li>若 <span class="math inline">n = 0</span>, 则 <span class="math inline">0 &lt; 0^+ = 1</span>, 由 <span class="math inline">&lt;</span> 的定义 <span class="math inline">\mathsf{zero}</span> 直接得出.</li>
<li>若 <span class="math inline">n = m^+</span>, 则要证 <span class="math inline">0 &lt; (m^+)^+ = m^{++}</span>. 由归纳假设 <span class="math inline">0 &lt; m^+</span>, 应用 <span class="math inline">&lt;</span> 的构造子 <span class="math inline">\mathsf{suc}</span> 得 <span class="math inline">0 &lt; m^{++}</span>.</li>
</ul>
<ol start="2" type="1">
<li>要证 <span class="math inline">n &lt; m \to n^+ &lt; m^+</span>, 对 <span class="math inline">n &lt; m</span> 的证明 <span class="math inline">p</span> 归纳.</li>
</ol>
<ul>
<li>若 <span class="math inline">p = (0_n:n &lt; n^+)</span>, 则要证 <span class="math inline">n^+ &lt; (n^+)^+ = n^{++}</span>, 由 <span class="math inline">&lt;</span> 的定义 <span class="math inline">\mathsf{zero}</span> 直接得出.</li>
<li>若 <span class="math inline">p = (p&#39;^+:n &lt; m^+)</span>, 其中 <span class="math inline">p&#39; : n &lt; m</span>, 则要证 <span class="math inline">n^+ &lt; (m^+)^+ = m^{++}</span>. 由归纳假设得 <span class="math inline">n^+ &lt; m^+</span>, 应用构造子 <span class="math inline">\mathsf{suc}</span> 得 <span class="math inline">n^+ &lt; m^{++}</span>. ∎</li>
</ul>
<pre class="Agda"><a id="17852" class="Keyword">module</a> <a id="Nat"></a><a id="17859" href="OCF.BTBO.html#17859" class="Module">Nat</a> <a id="17863" class="Keyword">where</a>
  <a id="17871" class="Keyword">open</a> <a id="17876" href="OCF.BTBO.html#4295" class="Module Operator">Nat_lt</a> <a id="17883" class="Keyword">public</a>

  <a id="Nat.z&lt;s"></a><a id="17893" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="17897" class="Symbol">:</a> <a id="17899" class="Symbol">∀</a> <a id="17901" href="OCF.BTBO.html#17901" class="Bound">n</a> <a id="17903" class="Symbol">→</a> <a id="17905" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="17910" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="17912" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17916" href="OCF.BTBO.html#17901" class="Bound">n</a>
  <a id="17920" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="17924" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="17932" class="Symbol">=</a> <a id="17934" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>
  <a id="17941" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="17945" class="Symbol">(</a><a id="17946" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17950" href="OCF.BTBO.html#17950" class="Bound">n</a><a id="17951" class="Symbol">)</a> <a id="17953" class="Symbol">=</a> <a id="17955" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="17959" class="Symbol">(</a><a id="17960" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="17964" href="OCF.BTBO.html#17950" class="Bound">n</a><a id="17965" class="Symbol">)</a>

  <a id="Nat.s&lt;s"></a><a id="17970" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="17974" class="Symbol">:</a> <a id="17976" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="17978" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="17980" href="OCF.BTBO.html#4321" class="Generalizable">m</a> <a id="17982" class="Symbol">→</a> <a id="17984" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17988" href="OCF.BTBO.html#4319" class="Generalizable">n</a> <a id="17990" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="17992" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17996" href="OCF.BTBO.html#4321" class="Generalizable">m</a>
  <a id="18000" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="18004" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>    <a id="18012" class="Symbol">=</a> <a id="18014" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>
  <a id="18021" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="18025" class="Symbol">(</a><a id="18026" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="18030" href="OCF.BTBO.html#18030" class="Bound">p</a><a id="18031" class="Symbol">)</a> <a id="18033" class="Symbol">=</a> <a id="18035" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="18039" class="Symbol">(</a><a id="18040" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="18044" href="OCF.BTBO.html#18030" class="Bound">p</a><a id="18045" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 自然数的 <span class="math inline">&lt;</span> 满足<strong>无条件三歧性 (unconditional decidability)</strong>, 即对任意 <span class="math inline">n,m</span>, 都有 <span class="math inline">(n &lt; m) \lor (m &lt; n) \lor (n = m)</span>.<br />
<strong>证明</strong> 对 <span class="math inline">n,m</span> 归纳.</p>
<ul>
<li><p>若 <span class="math inline">n=0,\;m=0</span>, 显然 <span class="math inline">n=m</span>.</p></li>
<li><p>若 <span class="math inline">n=0,\;m=m&#39;^+</span>, 显然 <span class="math inline">n&lt;m</span>.</p></li>
<li><p>若 <span class="math inline">n=n&#39;^+,\;m=0</span>, 显然 <span class="math inline">m&lt;n</span>.</p></li>
<li><p>若 <span class="math inline">n=n&#39;^+,\;m=m&#39;^+</span>, 有归纳假设 <span class="math inline">n&#39;&lt;m&#39;</span> 或 <span class="math inline">m&#39;&lt;n&#39;</span> 或 <span class="math inline">n&#39;=m&#39;</span>, 讨论它们.</p>
<ul>
<li>如果 <span class="math inline">n&#39;&lt;m&#39;</span>, 则有 <span class="math inline">n&lt;m</span>.</li>
<li>如果 <span class="math inline">m&#39;&lt;n&#39;</span>, 则有 <span class="math inline">m&lt;n</span>.</li>
<li>如果 <span class="math inline">n&#39;=m&#39;</span>, 则有 <span class="math inline">n=m</span>. ∎</li>
</ul></li>
</ul>
<pre class="Agda">  <a id="Nat.&lt;-dec"></a><a id="18428" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18434" class="Symbol">:</a> <a id="18436" class="Symbol">∀</a> <a id="18438" href="OCF.BTBO.html#18438" class="Bound">n</a> <a id="18440" href="OCF.BTBO.html#18440" class="Bound">m</a> <a id="18442" class="Symbol">→</a> <a id="18444" href="OCF.BTBO.html#18438" class="Bound">n</a> <a id="18446" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="18448" href="OCF.BTBO.html#18440" class="Bound">m</a> <a id="18450" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="18452" href="OCF.BTBO.html#18440" class="Bound">m</a> <a id="18454" href="OCF.BTBO.html#4337" class="Datatype Operator">&lt;</a> <a id="18456" href="OCF.BTBO.html#18438" class="Bound">n</a> <a id="18458" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="18460" href="OCF.BTBO.html#18438" class="Bound">n</a> <a id="18462" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="18464" href="OCF.BTBO.html#18440" class="Bound">m</a>
  <a id="18468" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18474" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="18479" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="18484" class="Symbol">=</a> <a id="18486" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="18491" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="18498" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18504" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="18509" class="Symbol">(</a><a id="18510" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18514" href="OCF.BTBO.html#18514" class="Bound">m</a><a id="18515" class="Symbol">)</a> <a id="18517" class="Symbol">=</a> <a id="18519" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="18524" class="Symbol">(</a><a id="18525" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="18529" href="OCF.BTBO.html#18514" class="Bound">m</a><a id="18530" class="Symbol">)</a>
  <a id="18534" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18540" class="Symbol">(</a><a id="18541" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18545" href="OCF.BTBO.html#18545" class="Bound">n</a><a id="18546" class="Symbol">)</a> <a id="18548" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="18553" class="Symbol">=</a> <a id="18555" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="18560" class="Symbol">(</a><a id="18561" href="OCF.BTBO.html#17893" class="Function">z&lt;s</a> <a id="18565" href="OCF.BTBO.html#18545" class="Bound">n</a><a id="18566" class="Symbol">)</a>
  <a id="18570" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18576" class="Symbol">(</a><a id="18577" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18581" href="OCF.BTBO.html#18581" class="Bound">n</a><a id="18582" class="Symbol">)</a> <a id="18584" class="Symbol">(</a><a id="18585" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18589" href="OCF.BTBO.html#18589" class="Bound">m</a><a id="18590" class="Symbol">)</a> <a id="18592" class="Keyword">with</a> <a id="18597" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="18603" href="OCF.BTBO.html#18581" class="Bound">n</a> <a id="18605" href="OCF.BTBO.html#18589" class="Bound">m</a>
  <a id="18609" class="Symbol">...</a> <a id="18613" class="Symbol">|</a> <a id="18615" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="18620" href="OCF.BTBO.html#18620" class="Bound">p</a> <a id="18622" class="Symbol">=</a> <a id="18624" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="18629" class="Symbol">(</a><a id="18630" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="18634" href="OCF.BTBO.html#18620" class="Bound">p</a><a id="18635" class="Symbol">)</a>
  <a id="18639" class="Symbol">...</a> <a id="18643" class="Symbol">|</a> <a id="18645" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="18650" href="OCF.BTBO.html#18650" class="Bound">p</a> <a id="18652" class="Symbol">=</a> <a id="18654" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="18659" class="Symbol">(</a><a id="18660" href="OCF.BTBO.html#17970" class="Function">s&lt;s</a> <a id="18664" href="OCF.BTBO.html#18650" class="Bound">p</a><a id="18665" class="Symbol">)</a>
  <a id="18669" class="Symbol">...</a> <a id="18673" class="Symbol">|</a> <a id="18675" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="18680" href="OCF.BTBO.html#18680" class="Bound">p</a> <a id="18682" class="Symbol">=</a> <a id="18684" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="18689" class="Symbol">(</a><a id="18690" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="18695" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18699" href="OCF.BTBO.html#18680" class="Bound">p</a><a id="18700" class="Symbol">)</a>
</pre>
<p><strong>定义 (有界三歧可数序数)</strong> 互归纳定义 <span class="math inline">\mathsf{Ord}^\mathsf{D}</span> 及其上的 <span class="math inline">&lt;</span> 序.</p>
<ul>
<li><span class="math inline">\mathsf{Ord}^\mathsf{D}</span> 的定义与 <span class="math inline">\mathsf{Ord}_0</span> 类似, 只不过要求基本列 <span class="math inline">f:\mathbb{N}\to\mathsf{Ord}^\mathsf{D}</span> 单调.</li>
<li><span class="math inline">&lt;</span> 的定义在自然数的 <span class="math inline">&lt;</span> 的基础上推广到了极限序数.</li>
</ul>
<p><span class="math display">
\cfrac{a&lt;f(n)}{\;a&lt;\mathsf{lim}(f,m_f)\;}\;\;\mathsf{lim}
</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">m_f</span> 是 <span class="math inline">f</span> 的单调性证明, 通常省略不写.</li>
<li><span class="math inline">f</span> 的单调性是指: 对任意 <span class="math inline">n,m:\mathbb{N}</span>, 如果 <span class="math inline">n&lt;m</span>, 那么 <span class="math inline">f(n)&lt;f(m)</span>. ∎</li>
</ul>
<pre class="Agda"><a id="19084" class="Keyword">module</a> <a id="Ordᴰ"></a><a id="19091" href="OCF.BTBO.html#19091" class="Module">Ordᴰ</a> <a id="19096" class="Keyword">where</a>
  <a id="19104" class="Keyword">open</a> <a id="19109" href="OCF.BTBO.html#17859" class="Module">Nat</a> <a id="19113" class="Keyword">renaming</a> <a id="19122" class="Symbol">(</a><a id="19123" href="OCF.BTBO.html#4337" class="Datatype Operator">_&lt;_</a> <a id="19127" class="Symbol">to</a> <a id="19130" class="Datatype Operator">_&lt;ᴺ_</a><a id="19134" class="Symbol">;</a> <a id="19136" href="OCF.BTBO.html#18428" class="Function">&lt;-dec</a> <a id="19142" class="Symbol">to</a> <a id="19145" class="Function">&lt;ᴺ-dec</a><a id="19151" class="Symbol">)</a>

  <a id="19156" class="Keyword">infix</a> <a id="19162" class="Number">10</a> <a id="19165" href="OCF.BTBO.html#19194" class="Datatype Operator">_&lt;_</a>
  <a id="19171" class="Keyword">data</a> <a id="Ordᴰ.Ordᴰ"></a><a id="19176" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="19181" class="Symbol">:</a> <a id="19183" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="19189" class="Keyword">data</a> <a id="Ordᴰ._&lt;_"></a><a id="19194" href="OCF.BTBO.html#19194" class="Datatype Operator">_&lt;_</a> <a id="19198" class="Symbol">:</a> <a id="19200" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="19205" class="Symbol">→</a> <a id="19207" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="19212" class="Symbol">→</a> <a id="19214" href="Agda.Primitive.html#388" class="Primitive">Set</a>

  <a id="Ordᴰ.monotonic"></a><a id="19221" href="OCF.BTBO.html#19221" class="Function">monotonic</a> <a id="19231" class="Symbol">:</a> <a id="19233" class="Symbol">(</a><a id="19234" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="19236" class="Symbol">→</a> <a id="19238" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="19242" class="Symbol">)</a> <a id="19244" class="Symbol">→</a> <a id="19246" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="19252" href="OCF.BTBO.html#19221" class="Function">monotonic</a> <a id="19262" href="OCF.BTBO.html#19262" class="Bound">f</a> <a id="19264" class="Symbol">=</a> <a id="19266" class="Symbol">∀</a> <a id="19268" class="Symbol">{</a><a id="19269" href="OCF.BTBO.html#19269" class="Bound">n</a> <a id="19271" href="OCF.BTBO.html#19271" class="Bound">m</a><a id="19272" class="Symbol">}</a> <a id="19274" class="Symbol">→</a> <a id="19276" href="OCF.BTBO.html#19269" class="Bound">n</a> <a id="19278" href="OCF.BTBO.html#19130" class="Datatype Operator">&lt;ᴺ</a> <a id="19281" href="OCF.BTBO.html#19271" class="Bound">m</a> <a id="19283" class="Symbol">→</a> <a id="19285" href="OCF.BTBO.html#19262" class="Bound">f</a> <a id="19287" href="OCF.BTBO.html#19269" class="Bound">n</a> <a id="19289" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19291" href="OCF.BTBO.html#19262" class="Bound">f</a> <a id="19293" href="OCF.BTBO.html#19271" class="Bound">m</a>

  <a id="19298" class="Keyword">private</a> <a id="19306" class="Keyword">variable</a>
    <a id="19319" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19321" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="19323" href="OCF.BTBO.html#19323" class="Generalizable">c</a> <a id="19325" class="Symbol">:</a> <a id="19327" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
    <a id="19336" href="OCF.BTBO.html#19336" class="Generalizable">f</a> <a id="19338" class="Symbol">:</a>  <a id="19341" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="19343" class="Symbol">→</a> <a id="19345" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
    <a id="19354" href="OCF.BTBO.html#19354" class="Generalizable">mono</a> <a id="19359" class="Symbol">:</a> <a id="19361" href="OCF.BTBO.html#19221" class="Function">monotonic</a> <a id="19371" href="OCF.BTBO.html#19336" class="Generalizable">f</a>

  <a id="19376" class="Keyword">data</a> <a id="19381" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="19386" class="Keyword">where</a>
    <a id="Ordᴰ.Ordᴰ.zero"></a><a id="19396" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a> <a id="19401" class="Symbol">:</a> <a id="19403" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
    <a id="Ordᴰ.Ordᴰ.suc"></a><a id="19412" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a>  <a id="19417" class="Symbol">:</a> <a id="19419" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="19424" class="Symbol">→</a> <a id="19426" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
    <a id="Ordᴰ.Ordᴰ.lim"></a><a id="19435" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a>  <a id="19440" class="Symbol">:</a> <a id="19442" class="Symbol">(</a><a id="19443" href="OCF.BTBO.html#19443" class="Bound">f</a> <a id="19445" class="Symbol">:</a> <a id="19447" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="19449" class="Symbol">→</a> <a id="19451" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="19455" class="Symbol">)</a> <a id="19457" class="Symbol">(</a><a id="19458" href="OCF.BTBO.html#19458" class="Bound">mono</a> <a id="19463" class="Symbol">:</a> <a id="19465" href="OCF.BTBO.html#19221" class="Function">monotonic</a> <a id="19475" href="OCF.BTBO.html#19443" class="Bound">f</a><a id="19476" class="Symbol">)</a> <a id="19478" class="Symbol">→</a> <a id="19480" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>

  <a id="19488" class="Keyword">data</a> <a id="19493" href="OCF.BTBO.html#19194" class="Datatype Operator">_&lt;_</a> <a id="19497" class="Keyword">where</a>
    <a id="Ordᴰ._&lt;_.zero"></a><a id="19507" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="19512" class="Symbol">:</a> <a id="19514" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19516" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19518" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="19522" href="OCF.BTBO.html#19319" class="Generalizable">a</a>
    <a id="Ordᴰ._&lt;_.suc"></a><a id="19528" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a>  <a id="19533" class="Symbol">:</a> <a id="19535" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19537" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19539" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="19541" class="Symbol">→</a> <a id="19543" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19545" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19547" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="19551" href="OCF.BTBO.html#19321" class="Generalizable">b</a>
    <a id="Ordᴰ._&lt;_.lim"></a><a id="19557" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a>  <a id="19562" class="Symbol">:</a> <a id="19564" class="Symbol">∀</a> <a id="19566" href="OCF.BTBO.html#19566" class="Bound">n</a> <a id="19568" class="Symbol">→</a> <a id="19570" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19572" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19574" href="OCF.BTBO.html#19336" class="Generalizable">f</a> <a id="19576" href="OCF.BTBO.html#19566" class="Bound">n</a> <a id="19578" class="Symbol">→</a> <a id="19580" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="19582" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19584" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="19588" href="OCF.BTBO.html#19336" class="Generalizable">f</a> <a id="19590" href="OCF.BTBO.html#19354" class="Generalizable">mono</a>
</pre>
<p><strong>引理</strong> 对任意单调的 <span class="math inline">f:\mathbb{N}\to\mathsf{Ord}^\mathsf{D}</span> 和 <span class="math inline">n:\mathbb{N}</span>, 有 <span class="math inline">f(n)&lt;\mathsf{lim}(f)</span>.<br />
<strong>证明</strong> <span class="math inline">f(n)&lt;f(n^+)&lt;\mathsf{lim}(f)</span>. ∎</p>
<pre class="Agda">  <a id="Ordᴰ.f&lt;l"></a><a id="19752" href="OCF.BTBO.html#19752" class="Function">f&lt;l</a> <a id="19756" class="Symbol">:</a> <a id="19758" class="Symbol">∀</a> <a id="19760" href="OCF.BTBO.html#19760" class="Bound">n</a> <a id="19762" class="Symbol">→</a> <a id="19764" href="OCF.BTBO.html#19336" class="Generalizable">f</a> <a id="19766" href="OCF.BTBO.html#19760" class="Bound">n</a> <a id="19768" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="19770" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="19774" href="OCF.BTBO.html#19336" class="Generalizable">f</a> <a id="19776" href="OCF.BTBO.html#19354" class="Generalizable">mono</a>
  <a id="19783" href="OCF.BTBO.html#19752" class="Function">f&lt;l</a> <a id="19787" class="Symbol">{</a><a id="19788" href="OCF.BTBO.html#19788" class="Bound">mono</a><a id="19792" class="Symbol">}</a> <a id="19794" href="OCF.BTBO.html#19794" class="Bound">n</a> <a id="19796" class="Symbol">=</a> <a id="19798" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="19802" class="Symbol">(</a><a id="19803" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="19807" href="OCF.BTBO.html#19794" class="Bound">n</a><a id="19808" class="Symbol">)</a> <a id="19810" class="Symbol">(</a><a id="19811" href="OCF.BTBO.html#19788" class="Bound">mono</a> <a id="19816" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a><a id="19820" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> <span class="math inline">\mathsf{Ord}^\mathsf{D}</span> 上的 <span class="math inline">&lt;</span> 满足传递性.<br />
<strong>证明</strong> 令 <span class="math inline">p:a&lt;b</span> 且 <span class="math inline">q:b&lt;c</span>, 要证 <span class="math inline">a&lt;c</span>. 对 <span class="math inline">q</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">q=0</span>, 则有 <span class="math inline">c=b^+</span>, 所以 <span class="math inline">p^+:a&lt;c</span>.</li>
<li>若 <span class="math inline">q=q&#39;^+</span>, 则有 <span class="math inline">c=c&#39;^+</span> 且 <span class="math inline">q&#39;:b&lt;c&#39;</span>. 此时有归纳假设 <span class="math inline">ih:a&lt;c&#39;</span>, 所以 <span class="math inline">ih^+:a&lt;c</span>.</li>
<li>若 <span class="math inline">q=\mathsf{lim}(n,q&#39;)</span>, 则有 <span class="math inline">c=\mathsf{lim}(f,\_)</span> 且 <span class="math inline">q&#39;:b&lt;f(n)</span>. 此时有归纳假设 <span class="math inline">ih:a&lt;f(n)</span>, 所以 <span class="math inline">\mathsf{lim}(n,ih):a&lt;c</span>. ∎</li>
</ul>
<pre class="Agda">  <a id="Ordᴰ.&lt;-trans"></a><a id="20167" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20175" class="Symbol">:</a> <a id="20177" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="20179" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20181" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="20183" class="Symbol">→</a> <a id="20185" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="20187" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20189" href="OCF.BTBO.html#19323" class="Generalizable">c</a> <a id="20191" class="Symbol">→</a> <a id="20193" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="20195" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20197" href="OCF.BTBO.html#19323" class="Generalizable">c</a>
  <a id="20201" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20209" href="OCF.BTBO.html#20209" class="Bound">p</a> <a id="20211" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>      <a id="20221" class="Symbol">=</a> <a id="20223" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="20227" href="OCF.BTBO.html#20209" class="Bound">p</a>
  <a id="20231" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20239" href="OCF.BTBO.html#20239" class="Bound">p</a> <a id="20241" class="Symbol">(</a><a id="20242" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="20246" href="OCF.BTBO.html#20246" class="Bound">q</a><a id="20247" class="Symbol">)</a>   <a id="20251" class="Symbol">=</a> <a id="20253" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="20257" class="Symbol">(</a><a id="20258" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20266" href="OCF.BTBO.html#20239" class="Bound">p</a> <a id="20268" href="OCF.BTBO.html#20246" class="Bound">q</a><a id="20269" class="Symbol">)</a>
  <a id="20273" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20281" href="OCF.BTBO.html#20281" class="Bound">p</a> <a id="20283" class="Symbol">(</a><a id="20284" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="20288" href="OCF.BTBO.html#20288" class="Bound">n</a> <a id="20290" href="OCF.BTBO.html#20290" class="Bound">q</a><a id="20291" class="Symbol">)</a> <a id="20293" class="Symbol">=</a> <a id="20295" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="20299" href="OCF.BTBO.html#20288" class="Bound">n</a> <a id="20301" class="Symbol">(</a><a id="20302" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="20310" href="OCF.BTBO.html#20281" class="Bound">p</a> <a id="20312" href="OCF.BTBO.html#20290" class="Bound">q</a><a id="20313" class="Symbol">)</a>
</pre>
<p><strong>定理 (有界三歧性)</strong> 对任意 <span class="math inline">a,b:\mathsf{Ord}^\mathsf{D}</span>, 如果它们小于一个共同的序数, 那么它们满足三歧性.<br />
<strong>证明</strong> 令 <span class="math inline">p:a&lt;c</span> 且 <span class="math inline">q:b&lt;c</span>, 对它们归纳.</p>
<ul>
<li>若 <span class="math inline">p=0,\;q=0</span>, 则 <span class="math inline">c=a^+</span> 且 <span class="math inline">c=b^+</span>, 所以 <span class="math inline">a=b</span>.</li>
<li>若 <span class="math inline">p=0,\;q=q&#39;^+</span>, 则 <span class="math inline">c=a^+</span>, 此时 <span class="math inline">q&#39;:b&lt;a</span>.</li>
<li>若 <span class="math inline">p=p&#39;^+,\;q=0</span>, 则 <span class="math inline">c=b^+</span>, 此时 <span class="math inline">p&#39;:a&lt;b</span>.</li>
<li>若 <span class="math inline">p=\mathsf{lim}(n,p&#39;),\;q=\mathsf{lim}(m,q&#39;)</span>, 则存在单调的 <span class="math inline">f</span> 使得 <span class="math inline">c=\mathsf{lim}(f)</span>, 且有 <span class="math inline">p&#39;:a&lt;f(n),\;q&#39;:b&lt;f(m)</span>. 由自然数的无条件三歧性, 讨论 <span class="math inline">n,m</span> 的大小关系.
<ul>
<li>如果 <span class="math inline">n&lt;m</span>, 由 <span class="math inline">f</span> 的单调性有 <span class="math inline">f(n)&lt;f(m)</span>, 所以 <span class="math inline">a,b</span> 都小于 <span class="math inline">f(m)</span>, 由归纳假设可知 <span class="math inline">a,b</span> 的大小关系.</li>
<li>如果 <span class="math inline">m&lt;n</span>, 由 <span class="math inline">f</span> 的单调性有 <span class="math inline">f(m)&lt;f(n)</span>, 所以 <span class="math inline">a,b</span> 都小于 <span class="math inline">f(n)</span>, 由归纳假设可知 <span class="math inline">a,b</span> 的大小关系.</li>
<li>如果 <span class="math inline">n=m</span>, 则 <span class="math inline">a,b</span> 都小于 <span class="math inline">f(n) = f(m)</span>, 由归纳假设可知 <span class="math inline">a,b</span> 的大小关系. ∎</li>
</ul></li>
</ul>
<pre class="Agda">  <a id="Ordᴰ.&lt;-dec"></a><a id="20950" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="20956" class="Symbol">:</a> <a id="20958" class="Symbol">∀</a> <a id="20960" class="Symbol">{</a><a id="20961" href="OCF.BTBO.html#20961" class="Bound">a</a> <a id="20963" href="OCF.BTBO.html#20963" class="Bound">b</a> <a id="20965" href="OCF.BTBO.html#20965" class="Bound">c</a><a id="20966" class="Symbol">}</a> <a id="20968" class="Symbol">→</a> <a id="20970" href="OCF.BTBO.html#20961" class="Bound">a</a> <a id="20972" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20974" href="OCF.BTBO.html#20965" class="Bound">c</a> <a id="20976" class="Symbol">→</a> <a id="20978" href="OCF.BTBO.html#20963" class="Bound">b</a> <a id="20980" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20982" href="OCF.BTBO.html#20965" class="Bound">c</a> <a id="20984" class="Symbol">→</a> <a id="20986" href="OCF.BTBO.html#20961" class="Bound">a</a> <a id="20988" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20990" href="OCF.BTBO.html#20963" class="Bound">b</a> <a id="20992" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="20994" href="OCF.BTBO.html#20963" class="Bound">b</a> <a id="20996" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="20998" href="OCF.BTBO.html#20961" class="Bound">a</a> <a id="21000" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="21002" href="OCF.BTBO.html#20961" class="Bound">a</a> <a id="21004" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="21006" href="OCF.BTBO.html#20963" class="Bound">b</a>
  <a id="21010" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21016" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="21021" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>       <a id="21032" class="Symbol">=</a> <a id="21034" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="21039" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="21046" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21052" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="21057" class="Symbol">(</a><a id="21058" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="21062" href="OCF.BTBO.html#21062" class="Bound">q</a><a id="21063" class="Symbol">)</a>    <a id="21068" class="Symbol">=</a> <a id="21070" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="21075" href="OCF.BTBO.html#21062" class="Bound">q</a>
  <a id="21079" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21085" class="Symbol">(</a><a id="21086" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="21090" href="OCF.BTBO.html#21090" class="Bound">p</a><a id="21091" class="Symbol">)</a> <a id="21093" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>    <a id="21101" class="Symbol">=</a> <a id="21103" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="21108" href="OCF.BTBO.html#21090" class="Bound">p</a>
  <a id="21112" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21118" class="Symbol">(</a><a id="21119" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="21123" href="OCF.BTBO.html#21123" class="Bound">p</a><a id="21124" class="Symbol">)</a> <a id="21126" class="Symbol">(</a><a id="21127" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="21131" href="OCF.BTBO.html#21131" class="Bound">q</a><a id="21132" class="Symbol">)</a> <a id="21134" class="Symbol">=</a> <a id="21136" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21142" href="OCF.BTBO.html#21123" class="Bound">p</a> <a id="21144" href="OCF.BTBO.html#21131" class="Bound">q</a>
  <a id="21148" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21154" class="Symbol">(</a><a id="21155" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="21159" class="Symbol">{</a><a id="21160" href="OCF.BTBO.html#21160" class="Bound">mono</a><a id="21164" class="Symbol">}</a> <a id="21166" href="OCF.BTBO.html#21166" class="Bound">n</a> <a id="21168" href="OCF.BTBO.html#21168" class="Bound">p</a><a id="21169" class="Symbol">)</a> <a id="21171" class="Symbol">(</a><a id="21172" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="21176" href="OCF.BTBO.html#21176" class="Bound">m</a> <a id="21178" href="OCF.BTBO.html#21178" class="Bound">q</a><a id="21179" class="Symbol">)</a> <a id="21181" class="Keyword">with</a> <a id="21186" href="OCF.BTBO.html#19145" class="Function">&lt;ᴺ-dec</a> <a id="21193" href="OCF.BTBO.html#21166" class="Bound">n</a> <a id="21195" href="OCF.BTBO.html#21176" class="Bound">m</a>
  <a id="21199" class="Symbol">...</a> <a id="21203" class="Symbol">|</a> <a id="21205" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="21210" href="OCF.BTBO.html#21210" class="Bound">n&lt;m</a>  <a id="21215" class="Symbol">=</a> <a id="21217" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21223" class="Symbol">(</a><a id="21224" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="21232" class="Bound">p</a> <a id="21234" class="Symbol">(</a><a id="21235" class="Bound">mono</a> <a id="21240" href="OCF.BTBO.html#21210" class="Bound">n&lt;m</a><a id="21243" class="Symbol">))</a> <a id="21246" class="Bound">q</a>
  <a id="21250" class="Symbol">...</a> <a id="21254" class="Symbol">|</a> <a id="21256" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="21261" href="OCF.BTBO.html#21261" class="Bound">m&lt;n</a>  <a id="21266" class="Symbol">=</a> <a id="21268" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21274" class="Bound">p</a> <a id="21276" class="Symbol">(</a><a id="21277" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="21285" class="Bound">q</a> <a id="21287" class="Symbol">(</a><a id="21288" class="Bound">mono</a> <a id="21293" href="OCF.BTBO.html#21261" class="Bound">m&lt;n</a><a id="21296" class="Symbol">))</a>
  <a id="21301" class="Symbol">...</a> <a id="21305" class="Symbol">|</a> <a id="21307" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="21312" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="21317" class="Symbol">=</a> <a id="21319" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="21325" class="Bound">p</a> <a id="21327" class="Bound">q</a>
</pre>
<p>达成 <span class="math inline">\psi(\Omega_\Omega)</span> 的关键是让 <span class="math inline">\psi</span> 输出的大可数序数成为 <span class="math inline">\Omega</span> 的下标, 从而迭代 <span class="math inline">\psi(\Omega_x)</span> 得到 <span class="math inline">\psi(\Omega_\Omega)</span>. 问题在于, <span class="math inline">\Omega</span> 的下标的类型必须是我们现在构筑的 <span class="math inline">\mathsf{Ord}^\mathsf{D}</span>, 而 <span class="math inline">\psi</span> 的输出并不是, 因为通常的 OCF 的定义并不保证输出的序数所用的基本列是“遗传地”单调的. 本小节接下来的构筑将提供此问题的一个简易的解决方案.</p>
<p><strong>定义 (可数序数加法)</strong> 互递归地定义 <span class="math inline">\mathsf{Ord}^\mathsf{D}</span> 上的加法并证明右侧加法 (<span class="math inline">x \mapsto a + x</span>) 保持 <span class="math inline">&lt;</span> 关系.</p>
<p><span class="math display">
a + b := \begin{cases}
   a &amp;\text{if } b=0 \\
   (a+b&#39;)^+ &amp;\text{if } b=b&#39;^+ \\
   \mathsf{lim}(n\mapsto a+f(n)) &amp;\text{if } b=\mathsf{lim}(f)
\end{cases}
</span></p>
<p>其中 <span class="math inline">n\mapsto a+f(n)</span> 要求满足单调性, 因为有 <span class="math inline">f</span> 的单调性, 只要证 <span class="math inline">x \mapsto a + x</span> 保持 <span class="math inline">&lt;</span> 关系即可.</p>
<p><strong>证明</strong> 令 <span class="math inline">p : b &lt; c</span>, 对 <span class="math inline">p</span> 归纳.</p>
<ul>
<li>若 <span class="math inline">p = 0</span>, 则 <span class="math inline">c = b^+</span>, 要证 <span class="math inline">a + b &lt; a + b^+ = (a + b)^+</span>, 应用 <span class="math inline">\mathsf{zero}</span> 即可.</li>
<li>若 <span class="math inline">p = p&#39;^+</span>, 则 <span class="math inline">c = c&#39;^+</span> 且 <span class="math inline">p&#39; : b &lt; c&#39;</span>, 要证 <span class="math inline">a + b &lt; a + c^+ = (a + c&#39;)^+</span>. 由归纳假设 <span class="math inline">a + b &lt; a + c&#39;</span>, 应用 <span class="math inline">\mathsf{suc}</span> 即可.</li>
<li>若 <span class="math inline">p = \mathsf{lim}(n, p&#39;)</span>, 则 <span class="math inline">c = \mathsf{lim}(f)</span> 且 <span class="math inline">p&#39; : b &lt; f(n)</span>, 要证 <span class="math inline">a + b &lt; a + \mathsf{lim}(f) = \mathsf{lim}(m \mapsto a + f(m))</span>. 由归纳假设 <span class="math inline">a + b &lt; a + f(n)</span>, 应用 <span class="math inline">\mathsf{lim}</span> 即可. ∎</li>
</ul>
<pre class="Agda">  <a id="22371" class="Keyword">mutual</a>
    <a id="Ordᴰ._+_"></a><a id="22382" href="OCF.BTBO.html#22382" class="Function Operator">_+_</a> <a id="22386" class="Symbol">:</a> <a id="22388" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="22393" class="Symbol">→</a> <a id="22395" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="22400" class="Symbol">→</a> <a id="22402" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
    <a id="22411" href="OCF.BTBO.html#22411" class="Bound">a</a> <a id="22413" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22415" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a>          <a id="22429" class="Symbol">=</a> <a id="22431" href="OCF.BTBO.html#22411" class="Bound">a</a>
    <a id="22437" href="OCF.BTBO.html#22437" class="Bound">a</a> <a id="22439" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22441" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="22445" href="OCF.BTBO.html#22445" class="Bound">b</a>         <a id="22455" class="Symbol">=</a> <a id="22457" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="22461" class="Symbol">(</a><a id="22462" href="OCF.BTBO.html#22437" class="Bound">a</a> <a id="22464" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22466" href="OCF.BTBO.html#22445" class="Bound">b</a><a id="22467" class="Symbol">)</a>
    <a id="22473" href="OCF.BTBO.html#22473" class="Bound">a</a> <a id="22475" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22477" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="22481" href="OCF.BTBO.html#22481" class="Bound">f</a> <a id="22483" href="OCF.BTBO.html#22483" class="Bound">f-mono</a>  <a id="22491" class="Symbol">=</a> <a id="22493" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="22497" class="Symbol">(λ</a> <a id="22500" href="OCF.BTBO.html#22500" class="Bound">n</a> <a id="22502" class="Symbol">→</a> <a id="22504" href="OCF.BTBO.html#22473" class="Bound">a</a> <a id="22506" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22508" href="OCF.BTBO.html#22481" class="Bound">f</a> <a id="22510" href="OCF.BTBO.html#22500" class="Bound">n</a><a id="22511" class="Symbol">)</a> <a id="22513" class="Symbol">(</a><a id="22514" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22521" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="22523" href="OCF.BTBO.html#22483" class="Bound">f-mono</a><a id="22529" class="Symbol">)</a>

    <a id="Ordᴰ.+-mono"></a><a id="22536" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22543" class="Symbol">:</a> <a id="22545" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="22547" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="22549" href="OCF.BTBO.html#19323" class="Generalizable">c</a> <a id="22551" class="Symbol">→</a> <a id="22553" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="22555" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22557" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="22559" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="22561" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="22563" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="22565" href="OCF.BTBO.html#19323" class="Generalizable">c</a>
    <a id="22571" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22578" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>       <a id="22589" class="Symbol">=</a> <a id="22591" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>
    <a id="22600" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22607" class="Symbol">(</a><a id="22608" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="22612" href="OCF.BTBO.html#22612" class="Bound">p</a><a id="22613" class="Symbol">)</a>    <a id="22618" class="Symbol">=</a> <a id="22620" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="22624" class="Symbol">(</a><a id="22625" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22632" href="OCF.BTBO.html#22612" class="Bound">p</a><a id="22633" class="Symbol">)</a>
    <a id="22639" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22646" class="Symbol">(</a><a id="22647" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="22651" href="OCF.BTBO.html#22651" class="Bound">n</a> <a id="22653" href="OCF.BTBO.html#22653" class="Bound">p</a><a id="22654" class="Symbol">)</a>  <a id="22657" class="Symbol">=</a> <a id="22659" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="22663" href="OCF.BTBO.html#22651" class="Bound">n</a> <a id="22665" class="Symbol">(</a><a id="22666" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="22673" href="OCF.BTBO.html#22653" class="Bound">p</a><a id="22674" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 如果 <span class="math inline">a\neq 0</span>, 那么 <span class="math inline">a&gt;0</span>.<br />
<strong>证明</strong> 对 <span class="math inline">a</span> 归纳</p>
<ul>
<li>若 <span class="math inline">a = 0^+</span>, 则 <span class="math inline">0_0:0&lt;0^+</span>.</li>
<li>若 <span class="math inline">a = a&#39;^{++}</span>, 显然 <span class="math inline">a&#39;^+\neq 0</span>, 有归纳假设 <span class="math inline">ih : 0 &lt; a&#39;^+</span>, 所以 <span class="math inline">ih^+ : 0 &lt; a&#39;^{++}</span>.</li>
<li>若 <span class="math inline">a = (\mathsf{lim}(f))^+</span>, 显然 <span class="math inline">\mathsf{lim}(f)\neq 0</span>, 有归纳假设 <span class="math inline">ih : 0 &lt; \mathsf{lim}(f)</span>, 所以 <span class="math inline">ih^+ : 0 &lt; (\mathsf{lim}(f))^+</span>.</li>
<li>若 <span class="math inline">a = \mathsf{lim}(f)</span>, 则由 <span class="math inline">f</span> 的单调性 <span class="math inline">m_f</span> 有 <span class="math inline">m_f(0) : f(0) &lt; f(1)</span>. 此时 <span class="math inline">f(1) \neq 0</span>, 故由归纳假设 <span class="math inline">ih : 0 &lt; f(1)</span>, 因此 <span class="math inline">\mathsf{lim}(1, ih) : 0 &lt; \mathsf{lim}(f)</span>. ∎</li>
</ul>
<pre class="Agda">  <a id="Ordᴰ.NonZero"></a><a id="23149" href="OCF.BTBO.html#23149" class="Function">NonZero</a> <a id="23157" class="Symbol">:</a> <a id="23159" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="23164" class="Symbol">→</a> <a id="23166" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="23172" href="OCF.BTBO.html#23149" class="Function">NonZero</a> <a id="23180" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a> <a id="23185" class="Symbol">=</a> <a id="23187" href="Data.Empty.html#914" class="Function">⊥</a>
  <a id="23191" href="OCF.BTBO.html#23149" class="CatchallClause Function">NonZero</a><a id="23198" class="CatchallClause"> </a><a id="23199" class="CatchallClause Symbol">_</a>    <a id="23204" class="Symbol">=</a> <a id="23206" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

  <a id="Ordᴰ.sth&lt;nz"></a><a id="23211" href="OCF.BTBO.html#23211" class="Function">sth&lt;nz</a> <a id="23218" class="Symbol">:</a> <a id="23220" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="23222" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="23224" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="23226" class="Symbol">→</a> <a id="23228" href="OCF.BTBO.html#23149" class="Function">NonZero</a> <a id="23236" href="OCF.BTBO.html#19321" class="Generalizable">b</a>
  <a id="23240" href="OCF.BTBO.html#23211" class="Function">sth&lt;nz</a> <a id="23247" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>       <a id="23258" class="Symbol">=</a> <a id="23260" class="Symbol">_</a>
  <a id="23264" href="OCF.BTBO.html#23211" class="Function">sth&lt;nz</a> <a id="23271" class="Symbol">(</a><a id="23272" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="23276" class="Symbol">_)</a>    <a id="23282" class="Symbol">=</a> <a id="23284" class="Symbol">_</a>
  <a id="23288" href="OCF.BTBO.html#23211" class="Function">sth&lt;nz</a> <a id="23295" class="Symbol">(</a><a id="23296" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="23300" class="Symbol">_</a> <a id="23302" class="Symbol">_)</a>  <a id="23306" class="Symbol">=</a> <a id="23308" class="Symbol">_</a>

  <a id="Ordᴰ.z&lt;nz"></a><a id="23313" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23318" class="Symbol">:</a> <a id="23320" href="OCF.BTBO.html#23149" class="Function">NonZero</a> <a id="23328" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="23330" class="Symbol">→</a> <a id="23332" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a> <a id="23337" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="23339" href="OCF.BTBO.html#19319" class="Generalizable">a</a>
  <a id="23343" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23348" class="Symbol">{</a><a id="23349" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="23353" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a><a id="23357" class="Symbol">}</a>         <a id="23367" class="Symbol">_</a> <a id="23369" class="Symbol">=</a> <a id="23371" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>
  <a id="23378" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23383" class="Symbol">{</a><a id="23384" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="23388" class="Symbol">(</a><a id="23389" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="23393" href="OCF.BTBO.html#23393" class="Bound">a</a><a id="23394" class="Symbol">)}</a>      <a id="23402" class="Symbol">_</a> <a id="23404" class="Symbol">=</a> <a id="23406" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="23410" class="Symbol">(</a><a id="23411" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23416" class="Symbol">_)</a>
  <a id="23421" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23426" class="Symbol">{</a><a id="23427" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="23431" class="Symbol">(</a><a id="23432" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="23436" href="OCF.BTBO.html#23436" class="Bound">f</a> <a id="23438" href="OCF.BTBO.html#23438" class="Bound">mono</a><a id="23442" class="Symbol">)}</a> <a id="23445" class="Symbol">_</a> <a id="23447" class="Symbol">=</a> <a id="23449" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="23453" class="Symbol">(</a><a id="23454" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23459" class="Symbol">_)</a>
  <a id="23464" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23469" class="Symbol">{</a><a id="23470" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="23474" href="OCF.BTBO.html#23474" class="Bound">f</a> <a id="23476" href="OCF.BTBO.html#23476" class="Bound">mono</a><a id="23480" class="Symbol">}</a>       <a id="23488" class="Symbol">_</a> <a id="23490" class="Symbol">=</a> <a id="23492" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="23496" class="Number">1</a> <a id="23498" class="Symbol">(</a><a id="23499" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23504" class="Symbol">(</a><a id="23505" href="OCF.BTBO.html#23211" class="Function">sth&lt;nz</a> <a id="23512" class="Symbol">(</a><a id="23513" href="OCF.BTBO.html#23476" class="Bound">mono</a> <a id="23518" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a><a id="23522" class="Symbol">)))</a>
</pre>
<p><strong>引理</strong> 如果 <span class="math inline">b \neq 0</span>, 那么 <span class="math inline">a &lt; a + b</span>.<br />
<strong>证明</strong> 由引理知若 <span class="math inline">b \neq 0</span> 则 <span class="math inline">0 &lt; b</span>, 再由加法保持 <span class="math inline">&lt;</span> 关系即得 <span class="math inline">a + 0 &lt; a + b</span>, 即 <span class="math inline">a &lt; a + b</span>. ∎</p>
<pre class="Agda">  <a id="Ordᴰ.a&lt;a+b"></a><a id="23667" href="OCF.BTBO.html#23667" class="Function">a&lt;a+b</a> <a id="23673" class="Symbol">:</a> <a id="23675" class="Symbol">⦃</a> <a id="23677" href="OCF.BTBO.html#23677" class="Symbol">_</a> <a id="23679" class="Symbol">:</a> <a id="23681" href="OCF.BTBO.html#23149" class="Function">NonZero</a> <a id="23689" href="OCF.BTBO.html#19321" class="Generalizable">b</a> <a id="23691" class="Symbol">⦄</a> <a id="23693" class="Symbol">→</a> <a id="23695" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="23697" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="23699" href="OCF.BTBO.html#19319" class="Generalizable">a</a> <a id="23701" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="23703" href="OCF.BTBO.html#19321" class="Generalizable">b</a>
  <a id="23707" href="OCF.BTBO.html#23667" class="Function">a&lt;a+b</a> <a id="23713" class="Symbol">=</a> <a id="23715" href="OCF.BTBO.html#22536" class="Function">+-mono</a> <a id="23722" class="Symbol">(</a><a id="23723" href="OCF.BTBO.html#23313" class="Function">z&lt;nz</a> <a id="23728" href="Function.Base.html#4736" class="Function">it</a><a id="23730" class="Symbol">)</a>
</pre>
<p><strong>定义 (累积和)</strong> 定义高阶函数 <span class="math inline">f\mapsto f^+</span> 如下:</p>
<p><span class="math display">
f^{+}(n) :=
\begin{cases}
   f(0) &amp;\text{if } n = 0 \\
   f^{+}(m) + (f(n))^+ &amp;\text{if } n = m^+
\end{cases}
</span></p>
<pre class="Agda">  <a id="23907" class="Comment">-- cumulative sum</a>
  <a id="Ordᴰ.cumsum"></a><a id="23927" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="23934" class="Symbol">:</a> <a id="23936" class="Symbol">(</a><a id="23937" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="23939" class="Symbol">→</a> <a id="23941" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="23945" class="Symbol">)</a> <a id="23947" class="Symbol">→</a> <a id="23949" class="Symbol">(</a><a id="23950" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="23952" class="Symbol">→</a> <a id="23954" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="23958" class="Symbol">)</a>
  <a id="23962" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="23969" href="OCF.BTBO.html#23969" class="Bound">f</a> <a id="23971" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="23980" class="Symbol">=</a> <a id="23982" href="OCF.BTBO.html#23969" class="Bound">f</a> <a id="23984" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="23991" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="23998" href="OCF.BTBO.html#23998" class="Bound">f</a> <a id="24000" class="Symbol">(</a><a id="24001" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24005" href="OCF.BTBO.html#24005" class="Bound">n</a><a id="24006" class="Symbol">)</a>  <a id="24009" class="Symbol">=</a> <a id="24011" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="24018" href="OCF.BTBO.html#23998" class="Bound">f</a> <a id="24020" href="OCF.BTBO.html#24005" class="Bound">n</a> <a id="24022" href="OCF.BTBO.html#22382" class="Function Operator">+</a> <a id="24024" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="24028" class="Symbol">(</a><a id="24029" href="OCF.BTBO.html#23998" class="Bound">f</a> <a id="24031" class="Symbol">(</a><a id="24032" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24036" href="OCF.BTBO.html#24005" class="Bound">n</a><a id="24037" class="Symbol">))</a>
</pre>
<p><strong>定理</strong> 对任意 <span class="math inline">f</span>, <span class="math inline">f^{+}</span> 单调.<br />
<strong>证明</strong> 要证 <span class="math inline">f^{+}</span> 单调, 即对任意 <span class="math inline">n &lt; m</span> 有 <span class="math inline">f^{+}(n) &lt; f^{+}(m)</span>. 对 <span class="math inline">n &lt; m</span> 的证明归纳:</p>
<ul>
<li>若 <span class="math inline">n &lt; n^+</span>, 要证 <span class="math inline">f^{+}(n) &lt; f^{+}(n^+) = f^{+}(n) + (f(n^+))^+</span>, 由引理 <code>a&lt;a+b</code> 得证.</li>
<li>若 <span class="math inline">n &lt; m^+</span> 且 <span class="math inline">n &lt; m</span>, 要证 <span class="math inline">f^{+}(n) &lt; f^{+}(m^+) = f^{+}(m) + (f(m^+))^+</span>. 由归纳假设 <span class="math inline">f^{+}(n) &lt; f^{+}(m)</span>, 再由传递性和引理 <code>a&lt;a+b</code> 得证. ∎</li>
</ul>
<pre class="Agda">  <a id="Ordᴰ.cumsum-mono"></a><a id="24376" href="OCF.BTBO.html#24376" class="Function">cumsum-mono</a> <a id="24388" class="Symbol">:</a> <a id="24390" class="Symbol">(</a><a id="24391" href="OCF.BTBO.html#24391" class="Bound">f</a> <a id="24393" class="Symbol">:</a> <a id="24395" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="24397" class="Symbol">→</a> <a id="24399" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="24403" class="Symbol">)</a> <a id="24405" class="Symbol">→</a> <a id="24407" href="OCF.BTBO.html#19221" class="Function">monotonic</a> <a id="24417" class="Symbol">(</a><a id="24418" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="24425" href="OCF.BTBO.html#24391" class="Bound">f</a><a id="24426" class="Symbol">)</a>
  <a id="24430" href="OCF.BTBO.html#24376" class="Function">cumsum-mono</a> <a id="24442" href="OCF.BTBO.html#24442" class="Bound">f</a> <a id="24444" href="OCF.BTBO.html#4365" class="InductiveConstructor">zero</a>    <a id="24452" class="Symbol">=</a> <a id="24454" href="OCF.BTBO.html#23667" class="Function">a&lt;a+b</a>
  <a id="24462" href="OCF.BTBO.html#24376" class="Function">cumsum-mono</a> <a id="24474" href="OCF.BTBO.html#24474" class="Bound">f</a> <a id="24476" class="Symbol">(</a><a id="24477" href="OCF.BTBO.html#4386" class="InductiveConstructor">suc</a> <a id="24481" href="OCF.BTBO.html#24481" class="Bound">p</a><a id="24482" class="Symbol">)</a> <a id="24484" class="Symbol">=</a> <a id="24486" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="24494" class="Symbol">(</a><a id="24495" href="OCF.BTBO.html#24376" class="Function">cumsum-mono</a> <a id="24507" href="OCF.BTBO.html#24474" class="Bound">f</a> <a id="24509" href="OCF.BTBO.html#24481" class="Bound">p</a><a id="24510" class="Symbol">)</a> <a id="24512" href="OCF.BTBO.html#23667" class="Function">a&lt;a+b</a>
</pre>
<p>累积和可能会使某些基本列的极限值往上偏移, 但应该不改变我们对这套方法的最终极限的估值 (<span class="math inline">\psi(\Omega_\Omega)</span>).</p>
<h2 id="可数序数层布劳威尔树">可数序数层布劳威尔树</h2>
<p>现在我们将自然数层推广到可数序数层. 对任意可数序数 <span class="math inline">\ell : \mathsf{Ord}^\mathsf{D}</span>, 我们定义布劳威尔树类型 <span class="math inline">\mathsf{Ord}_\ell</span>.</p>
<p><strong>定义 (可数序数层布劳威尔树)</strong></p>
<p><span class="math display">
\begin{align}
\mathsf{Ord}_+(\ell, \mathsf{Ord}_{&lt;}) &amp;:=
\cfrac{}{\mathsf{Ord}_+}\;\mathsf{zero}
\;\;\;\;
\cfrac{\;\mathsf{Ord}_+\;}{\mathsf{Ord}_+}\;\mathsf{suc}
\;\;\;\;
\cfrac{\;\mathbb{N}\to\mathsf{Ord}_+\;}{\mathsf{Ord}_+}\;\mathsf{lim}
\\[1em]
&amp;\;\;\;\;\cfrac{\;(p:i&lt;\ell)\;\;\;(\mathsf{Ord}_{&lt;}(i,p)\to\mathsf{Ord}_+)\;}{\mathsf{Ord}_+}\;\mathsf{lim}_i
\\[2em]
\mathsf{Ord}_{&lt;}(i, p) &amp;:=
\begin{cases}
   \mathsf{Ord}_+(i, \mathsf{Ord}_{&lt;}) &amp;\text{if } p = (0_i:i&lt;i^+) \\
   \mathsf{Ord}_{&lt;}(i, q) &amp;\text{if } p = (q^+:i&lt;m^+) \\
   \mathsf{Ord}_{&lt;}(i, q) &amp;\text{if } p = (\mathsf{lim}(n,q):i&lt;\mathsf{lim}(f))
\end{cases}
\\[2em]
\mathsf{Ord}_\ell &amp;:= \mathsf{Ord}_{&lt;}(\ell,0_\ell)
\end{align}
</span></p>
<pre class="Agda"><a id="25443" class="Keyword">module</a> <a id="Ord_ord"></a><a id="25450" href="OCF.BTBO.html#25450" class="Module Operator">Ord_ord</a> <a id="25458" class="Keyword">where</a>
  <a id="25466" class="Keyword">open</a> <a id="25471" href="OCF.BTBO.html#19091" class="Module">Ordᴰ</a> <a id="25476" class="Keyword">hiding</a> <a id="25483" class="Symbol">(</a><a id="25484" href="OCF.BTBO.html#22382" class="Function Operator">_+_</a><a id="25487" class="Symbol">)</a>
  <a id="25491" class="Keyword">private</a> <a id="25499" class="Keyword">variable</a> <a id="25508" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="25510" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="25512" href="OCF.BTBO.html#25512" class="Generalizable">ℓ₁</a> <a id="25515" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a> <a id="25518" class="Symbol">:</a> <a id="25520" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>

  <a id="25528" class="Keyword">module</a> <a id="25535" href="OCF.BTBO.html#25535" class="Module">_</a> <a id="25537" class="Symbol">(</a><a id="25538" href="OCF.BTBO.html#25538" class="Bound">ℓ</a> <a id="25540" class="Symbol">:</a> <a id="25542" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="25546" class="Symbol">)</a> <a id="25548" class="Symbol">(</a><a id="25549" href="OCF.BTBO.html#25549" class="Bound">Ord&lt;</a> <a id="25554" class="Symbol">:</a> <a id="25556" class="Symbol">(</a><a id="25557" href="OCF.BTBO.html#25557" class="Bound">i</a> <a id="25559" class="Symbol">:</a> <a id="25561" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="25565" class="Symbol">)</a> <a id="25567" class="Symbol">(</a><a id="25568" href="OCF.BTBO.html#25568" class="Bound">p</a> <a id="25570" class="Symbol">:</a> <a id="25572" href="OCF.BTBO.html#25557" class="Bound">i</a> <a id="25574" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="25576" href="OCF.BTBO.html#25538" class="Bound">ℓ</a><a id="25577" class="Symbol">)</a> <a id="25579" class="Symbol">→</a> <a id="25581" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="25584" class="Symbol">)</a> <a id="25586" class="Keyword">where</a>
    <a id="25596" class="Keyword">data</a> <a id="25601" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a> <a id="25606" class="Symbol">:</a> <a id="25608" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="25612" class="Keyword">where</a>
      <a id="25624" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>  <a id="25630" class="Symbol">:</a> <a id="25632" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a>
      <a id="25643" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a>   <a id="25649" class="Symbol">:</a> <a id="25651" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a> <a id="25656" class="Symbol">→</a> <a id="25658" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a>
      <a id="25669" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a>   <a id="25675" class="Symbol">:</a> <a id="25677" class="Symbol">(</a><a id="25678" href="OCF.BTBO.html#25678" class="Bound">f</a> <a id="25680" class="Symbol">:</a> <a id="25682" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="25684" class="Symbol">→</a> <a id="25686" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a><a id="25690" class="Symbol">)</a> <a id="25692" class="Symbol">→</a> <a id="25694" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a>
      <a id="25705" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a>  <a id="25711" class="Symbol">:</a> <a id="25713" class="Symbol">(</a><a id="25714" href="OCF.BTBO.html#25714" class="Bound">p</a> <a id="25716" class="Symbol">:</a> <a id="25718" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="25720" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="25722" href="OCF.BTBO.html#25538" class="Bound">ℓ</a><a id="25723" class="Symbol">)</a> <a id="25725" class="Symbol">(</a><a id="25726" href="OCF.BTBO.html#25726" class="Bound">f</a> <a id="25728" class="Symbol">:</a> <a id="25730" href="OCF.BTBO.html#25549" class="Bound">Ord&lt;</a> <a id="25735" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="25737" href="OCF.BTBO.html#25714" class="Bound">p</a> <a id="25739" class="Symbol">→</a> <a id="25741" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a><a id="25745" class="Symbol">)</a> <a id="25747" class="Symbol">→</a> <a id="25749" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a>

  <a id="Ord_ord.Ord&lt;"></a><a id="25757" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25762" class="Symbol">:</a> <a id="25764" class="Symbol">(</a><a id="25765" href="OCF.BTBO.html#25765" class="Bound">i</a> <a id="25767" class="Symbol">:</a> <a id="25769" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="25773" class="Symbol">)</a> <a id="25775" class="Symbol">(</a><a id="25776" href="OCF.BTBO.html#25776" class="Bound">p</a> <a id="25778" class="Symbol">:</a> <a id="25780" href="OCF.BTBO.html#25765" class="Bound">i</a> <a id="25782" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="25784" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a><a id="25785" class="Symbol">)</a> <a id="25787" class="Symbol">→</a> <a id="25789" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="25795" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25800" href="OCF.BTBO.html#25800" class="Bound">i</a> <a id="25802" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>      <a id="25812" class="Symbol">=</a> <a id="25814" href="OCF.BTBO.html#25601" class="Datatype">Ord₊</a> <a id="25819" href="OCF.BTBO.html#25800" class="Bound">i</a> <a id="25821" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a>
  <a id="25828" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25833" href="OCF.BTBO.html#25833" class="Bound">i</a> <a id="25835" class="Symbol">(</a><a id="25836" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="25840" href="OCF.BTBO.html#25840" class="Bound">p</a><a id="25841" class="Symbol">)</a>   <a id="25845" class="Symbol">=</a> <a id="25847" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25852" href="OCF.BTBO.html#25833" class="Bound">i</a> <a id="25854" href="OCF.BTBO.html#25840" class="Bound">p</a>
  <a id="25858" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25863" href="OCF.BTBO.html#25863" class="Bound">i</a> <a id="25865" class="Symbol">(</a><a id="25866" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="25870" href="OCF.BTBO.html#25870" class="Bound">n</a> <a id="25872" href="OCF.BTBO.html#25872" class="Bound">p</a><a id="25873" class="Symbol">)</a> <a id="25875" class="Symbol">=</a> <a id="25877" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25882" href="OCF.BTBO.html#25863" class="Bound">i</a> <a id="25884" href="OCF.BTBO.html#25872" class="Bound">p</a>

  <a id="Ord_ord.Ord"></a><a id="25889" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="25893" class="Symbol">:</a> <a id="25895" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a> <a id="25900" class="Symbol">→</a> <a id="25902" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="25908" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="25912" href="OCF.BTBO.html#25912" class="Bound">ℓ</a> <a id="25914" class="Symbol">=</a> <a id="25916" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="25921" href="OCF.BTBO.html#25912" class="Bound">ℓ</a> <a id="25923" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>

  <a id="Ord_ord.Ord₀"></a><a id="25931" href="OCF.BTBO.html#25931" class="Function">Ord₀</a> <a id="25936" class="Symbol">:</a> <a id="25938" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="25944" href="OCF.BTBO.html#25931" class="Function">Ord₀</a> <a id="25949" class="Symbol">=</a> <a id="25951" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="25955" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a>
</pre>
<p>这里 <span class="math inline">\mathsf{Ord}_{&lt;}(i, p)</span> 的定义体现了<strong>证明无关性 (proof irrelevance)</strong>: 无论 <span class="math inline">p</span> 是如何证明 <span class="math inline">i &lt; \ell</span> 的, 只要 <span class="math inline">i</span> 相同, 得到的类型都是一样的. 具体来说:</p>
<ul>
<li>当 <span class="math inline">p</span> 是基础证明 <span class="math inline">0_i:i&lt;i^+</span> 时, 我们得到 <span class="math inline">\mathsf{Ord}_+(i, \mathsf{Ord}_{&lt;})</span></li>
<li>当 <span class="math inline">p</span> 是后继证明 <span class="math inline">q^+:i&lt;m^+</span> 时, 我们”剥掉”外层的后继, 递归到 <span class="math inline">\mathsf{Ord}_{&lt;}(i, q)</span></li>
<li>当 <span class="math inline">p</span> 是极限证明 <span class="math inline">\mathsf{lim}(n,q):i&lt;\mathsf{lim}(f)</span> 时, 我们同样”剥掉”外层的极限, 递归到 <span class="math inline">\mathsf{Ord}_{&lt;}(i, q)</span></li>
</ul>
<p>最终所有证明都会被”剥掉”到基础情况, 因此 <span class="math inline">\mathsf{Ord}_{&lt;}(i, p)</span> 实际上只依赖于 <span class="math inline">i</span>, 而与具体的证明 <span class="math inline">p</span> 无关.</p>
<p><strong>定理</strong> <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;p:i&lt;\ell_1)</span> 与 <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;q:i&lt;\ell_2)</span> 表示相同的树.<br />
<strong>证明</strong> 对证明 <span class="math inline">p:i&lt;\ell_1</span> 和 <span class="math inline">q:i&lt;\ell_2</span> 归纳. 由 <span class="math inline">\mathsf{Ord}_{&lt;}</span> 的定义:</p>
<ul>
<li>若 <span class="math inline">p=(0_i:i&lt;i^+),\;q=(0_i:i&lt;i^+)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_+(i, \mathsf{Ord}_{&lt;}) = \mathsf{Ord}_{&lt;}(i,q)</span>.</li>
<li>若 <span class="math inline">p=(p&#39;^+:i&lt;\ell_1^+),\;q=(0_i:i&lt;i^+)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,p&#39;)</span>, 由归纳假设 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p&#39;) = \mathsf{Ord}_{&lt;}(i,q)</span>.</li>
<li>若 <span class="math inline">p=(\mathsf{lim}(n,p&#39;):i&lt;\mathsf{lim}(f)),\;q=(0_i:i&lt;i^+)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,p&#39;)</span>, 由归纳假设 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p&#39;) = \mathsf{Ord}_{&lt;}(i,q)</span>.</li>
<li>若 <span class="math inline">p:i&lt;\ell_1,\;q=q&#39;^+:i&lt;\ell_2^+</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,q) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>, 由归纳假设直接得 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>.</li>
<li>若 <span class="math inline">p:i&lt;\ell_1,\;q=\mathsf{lim}(n,q&#39;):i&lt;\mathsf{lim}(g)</span>, 则 <span class="math inline">\mathsf{Ord}_{&lt;}(i,q) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>, 由归纳假设直接得 <span class="math inline">\mathsf{Ord}_{&lt;}(i,p) = \mathsf{Ord}_{&lt;}(i,q&#39;)</span>. ∎</li>
</ul>
<pre class="Agda">  <a id="Ord_ord.Ord&lt;-≡"></a><a id="27349" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27356" class="Symbol">:</a> <a id="27358" class="Symbol">(</a><a id="27359" href="OCF.BTBO.html#27359" class="Bound">p</a> <a id="27361" class="Symbol">:</a> <a id="27363" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27365" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="27367" href="OCF.BTBO.html#25512" class="Generalizable">ℓ₁</a><a id="27369" class="Symbol">)</a> <a id="27371" class="Symbol">(</a><a id="27372" href="OCF.BTBO.html#27372" class="Bound">q</a> <a id="27374" class="Symbol">:</a> <a id="27376" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27378" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="27380" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a><a id="27382" class="Symbol">)</a> <a id="27384" class="Symbol">→</a> <a id="27386" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="27391" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27393" href="OCF.BTBO.html#27359" class="Bound">p</a> <a id="27395" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="27397" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="27402" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27404" href="OCF.BTBO.html#27372" class="Bound">q</a>
  <a id="27408" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27415" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="27420" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>      <a id="27430" class="Symbol">=</a> <a id="27432" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="27439" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27446" class="Symbol">(</a><a id="27447" href="OCF.BTBO.html#19528" class="InductiveConstructor">suc</a> <a id="27451" href="OCF.BTBO.html#27451" class="Bound">p</a><a id="27452" class="Symbol">)</a> <a id="27454" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>   <a id="27461" class="Symbol">=</a> <a id="27463" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27470" href="OCF.BTBO.html#27451" class="Bound">p</a> <a id="27472" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>
  <a id="27479" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27486" class="Symbol">(</a><a id="27487" href="OCF.BTBO.html#19557" class="InductiveConstructor">lim</a> <a id="27491" href="OCF.BTBO.html#27491" class="Bound">n</a> <a id="27493" href="OCF.BTBO.html#27493" class="Bound">p</a><a id="27494" class="Symbol">)</a> <a id="27496" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="27501" class="Symbol">=</a> <a id="27503" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27510" href="OCF.BTBO.html#27493" class="Bound">p</a> <a id="27512" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a>
  <a id="27519" href="OCF.BTBO.html#27349" class="CatchallClause Function">Ord&lt;-≡</a><a id="27525" class="CatchallClause"> </a><a id="27526" href="OCF.BTBO.html#27526" class="CatchallClause Bound">p</a><a id="27527" class="CatchallClause"> </a><a id="27528" class="CatchallClause Symbol">(</a><a id="27529" href="OCF.BTBO.html#19528" class="CatchallClause InductiveConstructor">suc</a><a id="27532" class="CatchallClause"> </a><a id="27533" href="OCF.BTBO.html#27533" class="CatchallClause Bound">q</a><a id="27534" class="CatchallClause Symbol">)</a>      <a id="27541" class="Symbol">=</a> <a id="27543" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27550" href="OCF.BTBO.html#27526" class="Bound">p</a> <a id="27552" href="OCF.BTBO.html#27533" class="Bound">q</a>
  <a id="27556" href="OCF.BTBO.html#27349" class="CatchallClause Function">Ord&lt;-≡</a><a id="27562" class="CatchallClause"> </a><a id="27563" href="OCF.BTBO.html#27563" class="CatchallClause Bound">p</a><a id="27564" class="CatchallClause"> </a><a id="27565" class="CatchallClause Symbol">(</a><a id="27566" href="OCF.BTBO.html#19557" class="CatchallClause InductiveConstructor">lim</a><a id="27569" class="CatchallClause"> </a><a id="27570" href="OCF.BTBO.html#27570" class="CatchallClause Bound">n</a><a id="27571" class="CatchallClause"> </a><a id="27572" href="OCF.BTBO.html#27572" class="CatchallClause Bound">q</a><a id="27573" class="CatchallClause Symbol">)</a>    <a id="27578" class="Symbol">=</a> <a id="27580" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27587" href="OCF.BTBO.html#27563" class="Bound">p</a> <a id="27589" href="OCF.BTBO.html#27572" class="Bound">q</a>
</pre>
<p>也就是说 <span class="math inline">\mathsf{Ord}_{&lt;}(i,\;p:i&lt;\ell)</span> 与 <span class="math inline">p</span> 和 <span class="math inline">\ell</span> 无关, 我们改记作 <span class="math inline">\mathsf{Ord}_{&lt;i&lt;\_}</span>.</p>
<pre class="Agda">  <a id="Ord_ord.coe"></a><a id="27694" href="OCF.BTBO.html#27694" class="Function">coe</a> <a id="27698" class="Symbol">:</a> <a id="27700" class="Symbol">{</a><a id="27701" href="OCF.BTBO.html#27701" class="Bound">p</a> <a id="27703" class="Symbol">:</a> <a id="27705" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27707" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="27709" href="OCF.BTBO.html#25512" class="Generalizable">ℓ₁</a><a id="27711" class="Symbol">}</a> <a id="27713" class="Symbol">{</a><a id="27714" href="OCF.BTBO.html#27714" class="Bound">q</a> <a id="27716" class="Symbol">:</a> <a id="27718" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27720" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="27722" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a><a id="27724" class="Symbol">}</a> <a id="27726" class="Symbol">→</a> <a id="27728" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="27733" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27735" href="OCF.BTBO.html#27701" class="Bound">p</a> <a id="27737" class="Symbol">→</a> <a id="27739" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="27744" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27746" href="OCF.BTBO.html#27714" class="Bound">q</a>
  <a id="27750" href="OCF.BTBO.html#27694" class="Function">coe</a> <a id="27754" class="Symbol">{</a><a id="27755" href="OCF.BTBO.html#27755" class="Bound">p</a><a id="27756" class="Symbol">}</a> <a id="27758" class="Symbol">{</a><a id="27759" href="OCF.BTBO.html#27759" class="Bound">q</a><a id="27760" class="Symbol">}</a> <a id="27762" class="Symbol">=</a> <a id="27764" href="OCF.BTBO.html#4096" class="Function">transport</a> <a id="27774" class="Symbol">(</a><a id="27775" href="OCF.BTBO.html#27349" class="Function">Ord&lt;-≡</a> <a id="27782" href="OCF.BTBO.html#27755" class="Bound">p</a> <a id="27784" href="OCF.BTBO.html#27759" class="Bound">q</a><a id="27785" class="Symbol">)</a>

  <a id="Ord_ord.coe₀"></a><a id="27790" href="OCF.BTBO.html#27790" class="Function">coe₀</a> <a id="27795" class="Symbol">:</a> <a id="27797" class="Symbol">{</a><a id="27798" href="OCF.BTBO.html#27798" class="Bound">p</a> <a id="27800" class="Symbol">:</a> <a id="27802" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27804" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="27806" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a><a id="27808" class="Symbol">}</a> <a id="27810" class="Symbol">→</a> <a id="27812" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="27816" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27818" class="Symbol">→</a> <a id="27820" href="OCF.BTBO.html#25757" class="Function">Ord&lt;</a> <a id="27825" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="27827" href="OCF.BTBO.html#27798" class="Bound">p</a>
  <a id="27831" href="OCF.BTBO.html#27790" class="Function">coe₀</a> <a id="27836" class="Symbol">=</a> <a id="27838" href="OCF.BTBO.html#27694" class="Function">coe</a> <a id="27842" class="Symbol">{</a><a id="27843" class="Argument">p</a> <a id="27845" class="Symbol">=</a> <a id="27847" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a><a id="27851" class="Symbol">}</a>
</pre>
<p><strong>定义 (层级提升函数)</strong> 给定证明 <span class="math inline">p:\ell_1&lt;\ell_2</span>, 递归定义 <span class="math inline">\mathsf{Ord}_{\ell_1}</span> 到 <span class="math inline">\mathsf{Ord}_{\ell_2}</span> 的嵌入 <span class="math inline">\uparrow_p</span> 如下:</p>
<p><span class="math display">
\uparrow_p a :=
\begin{cases}
   0 &amp;\text{if } a = 0 \\
   (\uparrow_p a&#39;)^+ &amp;\text{if } a = a&#39;^+ \\
   \mathsf{lim}(\uparrow_p \circ f) &amp;\text{if } a = \mathsf{lim}(f) \\
   \mathsf{lim}_i(r:i&lt;\ell_2, \uparrow_p \circ f) &amp;\text{if } a = \mathsf{lim}_i(q:i&lt;\ell_1, f)
\end{cases}
</span></p>
<p>其中 <span class="math inline">r:i&lt;\ell_2</span> 由 <span class="math inline">p,q</span> 和 <span class="math inline">&lt;</span> 的传递性得到.</p>
<pre class="Agda">  <a id="Ord_ord.↑"></a><a id="28313" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28315" class="Symbol">:</a> <a id="28317" href="OCF.BTBO.html#25512" class="Generalizable">ℓ₁</a> <a id="28320" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="28322" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a> <a id="28325" class="Symbol">→</a> <a id="28327" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="28331" href="OCF.BTBO.html#25512" class="Generalizable">ℓ₁</a> <a id="28334" class="Symbol">→</a> <a id="28336" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="28340" href="OCF.BTBO.html#25515" class="Generalizable">ℓ₂</a>
  <a id="28345" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28347" href="OCF.BTBO.html#28347" class="Bound">p</a> <a id="28349" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>        <a id="28361" class="Symbol">=</a> <a id="28363" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>
  <a id="28370" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28372" href="OCF.BTBO.html#28372" class="Bound">p</a> <a id="28374" class="Symbol">(</a><a id="28375" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="28379" href="OCF.BTBO.html#28379" class="Bound">a</a><a id="28380" class="Symbol">)</a>     <a id="28386" class="Symbol">=</a> <a id="28388" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="28392" class="Symbol">(</a><a id="28393" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28395" href="OCF.BTBO.html#28372" class="Bound">p</a> <a id="28397" href="OCF.BTBO.html#28379" class="Bound">a</a><a id="28398" class="Symbol">)</a>
  <a id="28402" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28404" href="OCF.BTBO.html#28404" class="Bound">p</a> <a id="28406" class="Symbol">(</a><a id="28407" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="28411" href="OCF.BTBO.html#28411" class="Bound">f</a><a id="28412" class="Symbol">)</a>     <a id="28418" class="Symbol">=</a> <a id="28420" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="28424" class="Symbol">(</a><a id="28425" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28427" href="OCF.BTBO.html#28404" class="Bound">p</a> <a id="28429" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28431" href="OCF.BTBO.html#28411" class="Bound">f</a><a id="28432" class="Symbol">)</a>
  <a id="28436" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28438" href="OCF.BTBO.html#28438" class="Bound">p</a> <a id="28440" class="Symbol">(</a><a id="28441" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="28446" href="OCF.BTBO.html#28446" class="Bound">q</a> <a id="28448" href="OCF.BTBO.html#28448" class="Bound">f</a><a id="28449" class="Symbol">)</a>  <a id="28452" class="Symbol">=</a> <a id="28454" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="28459" class="Symbol">(</a><a id="28460" href="OCF.BTBO.html#20167" class="Function">&lt;-trans</a> <a id="28468" href="OCF.BTBO.html#28446" class="Bound">q</a> <a id="28470" href="OCF.BTBO.html#28438" class="Bound">p</a><a id="28471" class="Symbol">)</a> <a id="28473" class="Symbol">(</a><a id="28474" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="28476" href="OCF.BTBO.html#28438" class="Bound">p</a> <a id="28478" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28480" href="OCF.BTBO.html#28448" class="Bound">f</a> <a id="28482" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28484" href="OCF.BTBO.html#27694" class="Function">coe</a><a id="28487" class="Symbol">)</a>
</pre>
<p><strong>定义 (<span class="math inline">\Omega</span> 数)</strong> 遵循 <a href="https://en.wikipedia.org/wiki/Buchholz_psi_functions">Buchholz</a> 的定义, 对任意层级 <span class="math inline">\ell:\mathsf{Ord}^\mathsf{D}</span>, 递归定义 <span class="math inline">\Omega:\mathsf{Ord}^\mathsf{D}\to\mathsf{Ord}_\ell</span> 如下:</p>
<p><span class="math display">
\Omega_\ell :=
\begin{cases}
   0^+ &amp;\text{if } \ell = 0 \\
   \mathsf{lim}_{\ell&#39;}(0_{\ell&#39;}, \uparrow_{0_{\ell&#39;}}) &amp;\text{if } \ell = \ell&#39;^+ \\
   \mathsf{lim}(n\mapsto\uparrow_{p:f(n)&lt;\ell} \Omega_{f(n)} &amp;\text{if } \ell = \mathsf{lim}(f, \_)
\end{cases}
</span></p>
<p>其中 <span class="math inline">p:f(n)&lt;\ell</span> 由引理 <code>f&lt;l</code> 得到.</p>
<pre class="Agda">  <a id="Ord_ord.Ω"></a><a id="28998" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="29000" class="Symbol">:</a> <a id="29002" class="Symbol">(</a><a id="29003" href="OCF.BTBO.html#29003" class="Bound">ℓ</a> <a id="29005" class="Symbol">:</a> <a id="29007" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a><a id="29011" class="Symbol">)</a> <a id="29013" class="Symbol">→</a> <a id="29015" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="29019" href="OCF.BTBO.html#29003" class="Bound">ℓ</a>
  <a id="29023" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="29025" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a>      <a id="29035" class="Symbol">=</a> <a id="29037" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="29041" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>
  <a id="29048" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="29050" class="Symbol">(</a><a id="29051" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="29055" href="OCF.BTBO.html#29055" class="Bound">ℓ</a><a id="29056" class="Symbol">)</a>   <a id="29060" class="Symbol">=</a> <a id="29062" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="29067" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="29072" class="Symbol">(</a><a id="29073" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="29075" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a><a id="29079" class="Symbol">)</a>
  <a id="29083" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="29085" class="Symbol">(</a><a id="29086" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="29090" href="OCF.BTBO.html#29090" class="Bound">f</a> <a id="29092" class="Symbol">_)</a> <a id="29095" class="Symbol">=</a> <a id="29097" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="29101" class="Symbol">(λ</a> <a id="29104" href="OCF.BTBO.html#29104" class="Bound">n</a> <a id="29106" class="Symbol">→</a> <a id="29108" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="29110" class="Symbol">(</a><a id="29111" href="OCF.BTBO.html#19752" class="Function">f&lt;l</a> <a id="29115" href="OCF.BTBO.html#29104" class="Bound">n</a><a id="29116" class="Symbol">)</a> <a id="29118" class="Symbol">(</a><a id="29119" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="29121" class="Symbol">(</a><a id="29122" href="OCF.BTBO.html#29090" class="Bound">f</a> <a id="29124" href="OCF.BTBO.html#29104" class="Bound">n</a><a id="29125" class="Symbol">)))</a>
</pre>
<h2 id="布劳威尔树的折叠">布劳威尔树的折叠</h2>
<p><strong>定义 (序数加法)</strong> 对任意 <span class="math inline">a,b:\mathsf{Ord}_\ell</span>, 递归定义加法运算 <span class="math inline">+:\mathsf{Ord}_\ell\to\mathsf{Ord}_\ell\to\mathsf{Ord}_\ell</span> 如下:</p>
<p><span class="math display">
a + b :=
\begin{cases}
   a &amp;\text{if } b = 0 \\
   (a + b&#39;)^+ &amp;\text{if } b = b&#39;^+ \\
   \mathsf{lim}(n \mapsto a + f(n)) &amp;\text{if } b = \mathsf{lim}(f) \\
   \mathsf{lim}_i(p, x \mapsto a + f(x)) &amp;\text{if } b = \mathsf{lim}_i(p, f)
\end{cases}
</span></p>
<pre class="Agda">  <a id="Ord_ord._+_"></a><a id="29533" href="OCF.BTBO.html#29533" class="Function Operator">_+_</a> <a id="29537" class="Symbol">:</a> <a id="29539" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="29543" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="29545" class="Symbol">→</a> <a id="29547" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="29551" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="29553" class="Symbol">→</a> <a id="29555" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="29559" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a>
  <a id="29563" href="OCF.BTBO.html#29563" class="Bound">a</a> <a id="29565" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29567" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a> <a id="29572" class="Symbol">=</a> <a id="29574" href="OCF.BTBO.html#29563" class="Bound">a</a>
  <a id="29578" href="OCF.BTBO.html#29578" class="Bound">a</a> <a id="29580" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29582" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="29586" href="OCF.BTBO.html#29586" class="Bound">b</a> <a id="29588" class="Symbol">=</a> <a id="29590" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="29594" class="Symbol">(</a><a id="29595" href="OCF.BTBO.html#29578" class="Bound">a</a> <a id="29597" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29599" href="OCF.BTBO.html#29586" class="Bound">b</a><a id="29600" class="Symbol">)</a>
  <a id="29604" href="OCF.BTBO.html#29604" class="Bound">a</a> <a id="29606" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29608" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="29612" href="OCF.BTBO.html#29612" class="Bound">f</a> <a id="29614" class="Symbol">=</a> <a id="29616" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="29620" class="Symbol">(λ</a> <a id="29623" href="OCF.BTBO.html#29623" class="Bound">n</a> <a id="29625" class="Symbol">→</a> <a id="29627" href="OCF.BTBO.html#29604" class="Bound">a</a> <a id="29629" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29631" href="OCF.BTBO.html#29612" class="Bound">f</a> <a id="29633" href="OCF.BTBO.html#29623" class="Bound">n</a><a id="29634" class="Symbol">)</a>
  <a id="29638" href="OCF.BTBO.html#29638" class="Bound">a</a> <a id="29640" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29642" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="29647" href="OCF.BTBO.html#29647" class="Bound">p</a> <a id="29649" href="OCF.BTBO.html#29649" class="Bound">f</a> <a id="29651" class="Symbol">=</a> <a id="29653" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="29658" href="OCF.BTBO.html#29647" class="Bound">p</a> <a id="29660" class="Symbol">(λ</a> <a id="29663" href="OCF.BTBO.html#29663" class="Bound">x</a> <a id="29665" class="Symbol">→</a> <a id="29667" href="OCF.BTBO.html#29638" class="Bound">a</a> <a id="29669" href="OCF.BTBO.html#29533" class="Function Operator">+</a> <a id="29671" href="OCF.BTBO.html#29649" class="Bound">f</a> <a id="29673" href="OCF.BTBO.html#29663" class="Bound">x</a><a id="29674" class="Symbol">)</a>
</pre>
<p><strong>定义 (迭代和最小不动点)</strong> 定义迭代函数 <span class="math inline">(f,a,n)\mapsto f^n(a)</span> 和最小不动点构造 <span class="math inline">g \mapsto \mathsf{lfp}(g)</span> 如下:</p>
<p><span class="math display">
\begin{align}
f^n(a) &amp;:=
\begin{cases}
   a &amp;\text{if } n = 0 \\
   f(f^{n&#39;}(a)) &amp;\text{if } n = n&#39;^+
\end{cases}\\[2em]
\mathsf{lfp}(g) &amp;:= \mathsf{lim}(n \mapsto g^n(0))
\end{align}
</span></p>
<pre class="Agda">  <a id="Ord_ord.iter"></a><a id="29975" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="29980" class="Symbol">:</a> <a id="29982" class="Symbol">{</a><a id="29983" href="OCF.BTBO.html#29983" class="Bound">T</a> <a id="29985" class="Symbol">:</a> <a id="29987" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="29990" class="Symbol">}</a> <a id="29992" class="Symbol">(</a><a id="29993" href="OCF.BTBO.html#29993" class="Bound">f</a> <a id="29995" class="Symbol">:</a> <a id="29997" href="OCF.BTBO.html#29983" class="Bound">T</a> <a id="29999" class="Symbol">→</a> <a id="30001" href="OCF.BTBO.html#29983" class="Bound">T</a><a id="30002" class="Symbol">)</a> <a id="30004" class="Symbol">(</a><a id="30005" href="OCF.BTBO.html#30005" class="Bound">init</a> <a id="30010" class="Symbol">:</a> <a id="30012" href="OCF.BTBO.html#29983" class="Bound">T</a><a id="30013" class="Symbol">)</a> <a id="30015" class="Symbol">(</a><a id="30016" href="OCF.BTBO.html#30016" class="Bound">times</a> <a id="30022" class="Symbol">:</a> <a id="30024" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="30025" class="Symbol">)</a> <a id="30027" class="Symbol">→</a> <a id="30029" href="OCF.BTBO.html#29983" class="Bound">T</a>
  <a id="30033" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="30038" href="OCF.BTBO.html#30038" class="Bound">f</a> <a id="30040" href="OCF.BTBO.html#30040" class="Bound">a</a> <a id="30042" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="30050" class="Symbol">=</a> <a id="30052" href="OCF.BTBO.html#30040" class="Bound">a</a>
  <a id="30056" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="30061" href="OCF.BTBO.html#30061" class="Bound">f</a> <a id="30063" href="OCF.BTBO.html#30063" class="Bound">a</a> <a id="30065" class="Symbol">(</a><a id="30066" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="30070" href="OCF.BTBO.html#30070" class="Bound">n</a><a id="30071" class="Symbol">)</a> <a id="30073" class="Symbol">=</a> <a id="30075" href="OCF.BTBO.html#30061" class="Bound">f</a> <a id="30077" class="Symbol">(</a><a id="30078" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="30083" href="OCF.BTBO.html#30061" class="Bound">f</a> <a id="30085" href="OCF.BTBO.html#30063" class="Bound">a</a> <a id="30087" href="OCF.BTBO.html#30070" class="Bound">n</a><a id="30088" class="Symbol">)</a>

  <a id="Ord_ord.lfp"></a><a id="30093" href="OCF.BTBO.html#30093" class="Function">lfp</a> <a id="30097" class="Symbol">:</a> <a id="30099" class="Symbol">(</a><a id="30100" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="30104" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="30106" class="Symbol">→</a> <a id="30108" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="30112" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a><a id="30113" class="Symbol">)</a> <a id="30115" class="Symbol">→</a> <a id="30117" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="30121" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a>
  <a id="30125" href="OCF.BTBO.html#30093" class="Function">lfp</a> <a id="30129" href="OCF.BTBO.html#30129" class="Bound">f</a> <a id="30131" class="Symbol">=</a> <a id="30133" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="30137" class="Symbol">(</a><a id="30138" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="30143" href="OCF.BTBO.html#30129" class="Bound">f</a> <a id="30145" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a><a id="30149" class="Symbol">)</a>
</pre>
<p><strong>定义 (Buchholz’s <span class="math inline">\psi_i</span>)</strong> 给定证明 <span class="math inline">p:i&lt;\ell</span>, 递归定义序数折叠函数 <span class="math inline">\psi_{p}:\mathsf{Ord}_\ell\to\mathsf{Ord}_i</span> 如下:</p>
<p><span class="math display">
\psi_{p}(a) :=
\begin{cases}
   \Omega_i &amp;\text{if } a = 0 \\
   \mathsf{lfp}(x\mapsto\psi_{p}(a&#39;) + x) &amp;\text{if } a = a&#39;^+ \\
   \mathsf{lim}(\psi_{p} \circ f)) &amp;\text{if } a = \mathsf{lim}(f) \\
   \begin{cases}
      \mathsf{lim}_j(q,\;\psi_{p} \circ f) &amp;\text{if } r:j &lt; i \\
      \mathsf{lfp}(\psi_{p} \circ f \circ \uparrow_{r}) &amp;\text{if } r:i &lt; j \\
      \mathsf{lfp}(\psi_{p} \circ f) &amp;\text{if } r:i = j
   \end{cases} &amp;\text{if } a = \mathsf{lim}_j(q:j&lt;\ell, f)
\end{cases}
</span></p>
<p>其中, 我们能判定 <span class="math inline">i,j</span> 的大小关系是因为它们都小于 <span class="math inline">\ell</span>, 允许应用有界三歧性.</p>
<pre class="Agda">  <a id="30821" class="Comment">-- Buchholz&#39;s ψ</a>
  <a id="Ord_ord.ψ&lt;"></a><a id="30839" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30842" class="Symbol">:</a> <a id="30844" href="OCF.BTBO.html#25508" class="Generalizable">i</a> <a id="30846" href="OCF.BTBO.html#19194" class="Datatype Operator">&lt;</a> <a id="30848" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="30850" class="Symbol">→</a> <a id="30852" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="30856" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="30858" class="Symbol">→</a> <a id="30860" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="30864" href="OCF.BTBO.html#25508" class="Generalizable">i</a>
  <a id="30868" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30871" href="OCF.BTBO.html#30871" class="Bound">p</a> <a id="30873" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>     <a id="30882" class="Symbol">=</a> <a id="30884" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="30886" class="Symbol">_</a>
  <a id="30890" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30893" href="OCF.BTBO.html#30893" class="Bound">p</a> <a id="30895" class="Symbol">(</a><a id="30896" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="30900" href="OCF.BTBO.html#30900" class="Bound">a</a><a id="30901" class="Symbol">)</a>  <a id="30904" class="Symbol">=</a> <a id="30906" href="OCF.BTBO.html#30093" class="Function">lfp</a> <a id="30910" class="Symbol">(</a><a id="30911" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30914" href="OCF.BTBO.html#30893" class="Bound">p</a> <a id="30916" href="OCF.BTBO.html#30900" class="Bound">a</a> <a id="30918" href="OCF.BTBO.html#29533" class="Function Operator">+_</a><a id="30920" class="Symbol">)</a>
  <a id="30924" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30927" href="OCF.BTBO.html#30927" class="Bound">p</a> <a id="30929" class="Symbol">(</a><a id="30930" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="30934" href="OCF.BTBO.html#30934" class="Bound">f</a><a id="30935" class="Symbol">)</a>  <a id="30938" class="Symbol">=</a> <a id="30940" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="30944" class="Symbol">(</a><a id="30945" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30948" href="OCF.BTBO.html#30927" class="Bound">p</a> <a id="30950" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="30952" href="OCF.BTBO.html#30934" class="Bound">f</a><a id="30953" class="Symbol">)</a>
  <a id="30957" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="30960" class="Symbol">{</a><a id="30961" href="OCF.BTBO.html#30961" class="Bound">i</a><a id="30962" class="Symbol">}</a> <a id="30964" class="Symbol">{</a><a id="30965" href="OCF.BTBO.html#30965" class="Bound">ℓ</a><a id="30966" class="Symbol">}</a> <a id="30968" href="OCF.BTBO.html#30968" class="Bound">p</a> <a id="30970" class="Symbol">(</a><a id="30971" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="30976" class="Symbol">{</a><a id="30977" class="Argument">i</a> <a id="30979" class="Symbol">=</a> <a id="30981" href="OCF.BTBO.html#30981" class="Bound">j</a><a id="30982" class="Symbol">}</a> <a id="30984" href="OCF.BTBO.html#30984" class="Bound">q</a> <a id="30986" href="OCF.BTBO.html#30986" class="Bound">f</a><a id="30987" class="Symbol">)</a> <a id="30989" class="Keyword">with</a> <a id="30994" href="OCF.BTBO.html#20950" class="Function">&lt;-dec</a> <a id="31000" href="OCF.BTBO.html#30984" class="Bound">q</a> <a id="31002" href="OCF.BTBO.html#30968" class="Bound">p</a>
  <a id="31006" class="Symbol">...</a> <a id="31010" class="Symbol">|</a> <a id="31012" href="OCF.BTBO.html#17239" class="InductiveConstructor">injᵃ</a> <a id="31017" href="OCF.BTBO.html#31017" class="Bound">j&lt;i</a>  <a id="31022" class="Symbol">=</a> <a id="31024" href="OCF.BTBO.html#25705" class="InductiveConstructor">limᵢ</a> <a id="31029" href="OCF.BTBO.html#31017" class="Bound">j&lt;i</a> <a id="31033" class="Symbol">(</a><a id="31034" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="31037" class="Bound">p</a> <a id="31039" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31041" class="Bound">f</a> <a id="31043" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31045" href="OCF.BTBO.html#27694" class="Function">coe</a><a id="31048" class="Symbol">)</a>
  <a id="31052" class="Symbol">...</a> <a id="31056" class="Symbol">|</a> <a id="31058" href="OCF.BTBO.html#17263" class="InductiveConstructor">injᵇ</a> <a id="31063" href="OCF.BTBO.html#31063" class="Bound">i&lt;j</a>  <a id="31068" class="Symbol">=</a> <a id="31070" href="OCF.BTBO.html#30093" class="Function">lfp</a> <a id="31074" class="Symbol">(</a><a id="31075" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="31078" class="Bound">p</a> <a id="31080" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31082" class="Bound">f</a> <a id="31084" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31086" href="OCF.BTBO.html#27790" class="Function">coe₀</a> <a id="31091" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31093" href="OCF.BTBO.html#28313" class="Function">↑</a> <a id="31095" href="OCF.BTBO.html#31063" class="Bound">i&lt;j</a><a id="31098" class="Symbol">)</a>
  <a id="31102" class="Symbol">...</a> <a id="31106" class="Symbol">|</a> <a id="31108" href="OCF.BTBO.html#17294" class="InductiveConstructor">injᶜ</a> <a id="31113" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="31118" class="Symbol">=</a> <a id="31120" href="OCF.BTBO.html#30093" class="Function">lfp</a> <a id="31124" class="Symbol">(</a><a id="31125" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="31128" class="Bound">p</a> <a id="31130" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31132" class="Bound">f</a> <a id="31134" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="31136" href="OCF.BTBO.html#27790" class="Function">coe₀</a><a id="31140" class="Symbol">)</a>
</pre>
<p><strong>定义 (Buchholz’s <span class="math inline">\psi_0</span>)</strong> 递归定义 <span class="math inline">\psi_0:\mathsf{Ord}_\ell\to\mathsf{Ord}_0</span> 如下:</p>
<p><span class="math display">
\psi_0(a) :=
\begin{cases}
   a &amp;\text{if } \ell = 0 \\
   \psi_0(\psi_{0_{\ell&#39;}}(a)) &amp;\text{if } \ell = \ell&#39;^+ \\
   \mathsf{lim}(n \mapsto \psi_0(\psi_{p}(a))) &amp;\text{if } \ell = \mathsf{lim}(f, \_)
\end{cases}
</span></p>
<p>其中 <span class="math inline">p:f(n)&lt;\ell</span> 由引理 <code>f&lt;l</code> 得到.</p>
<pre class="Agda">  <a id="Ord_ord.ψ₀"></a><a id="31496" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31499" class="Symbol">:</a> <a id="31501" href="OCF.BTBO.html#25889" class="Function">Ord</a> <a id="31505" href="OCF.BTBO.html#25510" class="Generalizable">ℓ</a> <a id="31507" class="Symbol">→</a> <a id="31509" href="OCF.BTBO.html#25931" class="Function">Ord₀</a>
  <a id="31516" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31519" class="Symbol">{</a><a id="31520" class="Argument">ℓ</a> <a id="31522" class="Symbol">=</a> <a id="31524" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a><a id="31528" class="Symbol">}</a>    <a id="31533" href="OCF.BTBO.html#31533" class="Bound">a</a> <a id="31535" class="Symbol">=</a> <a id="31537" href="OCF.BTBO.html#31533" class="Bound">a</a>
  <a id="31541" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31544" class="Symbol">{</a><a id="31545" class="Argument">ℓ</a> <a id="31547" class="Symbol">=</a> <a id="31549" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="31553" href="OCF.BTBO.html#31553" class="Bound">ℓ</a><a id="31554" class="Symbol">}</a>   <a id="31558" href="OCF.BTBO.html#31558" class="Bound">a</a> <a id="31560" class="Symbol">=</a> <a id="31562" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31565" class="Symbol">(</a><a id="31566" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="31569" href="OCF.BTBO.html#19507" class="InductiveConstructor">zero</a> <a id="31574" href="OCF.BTBO.html#31558" class="Bound">a</a><a id="31575" class="Symbol">)</a>
  <a id="31579" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31582" class="Symbol">{</a><a id="31583" class="Argument">ℓ</a> <a id="31585" class="Symbol">=</a> <a id="31587" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="31591" href="OCF.BTBO.html#31591" class="Bound">f</a> <a id="31593" class="Symbol">_}</a> <a id="31596" href="OCF.BTBO.html#31596" class="Bound">a</a> <a id="31598" class="Symbol">=</a> <a id="31600" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="31604" class="Symbol">(λ</a> <a id="31607" href="OCF.BTBO.html#31607" class="Bound">n</a> <a id="31609" class="Symbol">→</a> <a id="31611" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="31614" class="Symbol">(</a><a id="31615" href="OCF.BTBO.html#30839" class="Function">ψ&lt;</a> <a id="31618" class="Symbol">(</a><a id="31619" href="OCF.BTBO.html#19752" class="Function">f&lt;l</a> <a id="31623" href="OCF.BTBO.html#31607" class="Bound">n</a><a id="31624" class="Symbol">)</a> <a id="31626" href="OCF.BTBO.html#31596" class="Bound">a</a><a id="31627" class="Symbol">))</a>
</pre>
<p><strong>定义 (单调化嵌入)</strong> 递归定义 <span class="math inline">\mathsf{Ord}_0</span> 到 <span class="math inline">\mathsf{Ord}^\mathsf{D}</span> 的嵌入 <span class="math inline">\mathsf{ord}^\mathsf{D}:\mathsf{Ord}_0\to\mathsf{Ord}^\mathsf{D}</span> 如下:</p>
<p><span class="math display">
\mathsf{ord}^\mathsf{D}(a) :=
\begin{cases}
   0 &amp;\text{if } a = 0 \\
   (\mathsf{ord}^\mathsf{D}(a&#39;))^+ &amp;\text{if } a = a&#39;^+ \\
   \mathsf{lim}((\mathsf{ord}^\mathsf{D}\circ f)^+, m_{(\mathsf{ord}^\mathsf{D}\circ f)^+}) &amp;\text{if } a = \mathsf{lim}(f)
\end{cases}
</span></p>
<p>其中 <span class="math inline">m_{(\mathsf{ord}^\mathsf{D}\circ f)^+}</span> 由引理 <code>cumsum-mono</code> 给出.</p>
<pre class="Agda">  <a id="Ord_ord.ordᴰ"></a><a id="32127" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32132" class="Symbol">:</a> <a id="32134" href="OCF.BTBO.html#25931" class="Function">Ord₀</a> <a id="32139" class="Symbol">→</a> <a id="32141" href="OCF.BTBO.html#19176" class="Datatype">Ordᴰ</a>
  <a id="32148" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32153" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>     <a id="32162" class="Symbol">=</a> <a id="32164" href="OCF.BTBO.html#19396" class="InductiveConstructor">zero</a>
  <a id="32171" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32176" class="Symbol">(</a><a id="32177" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="32181" href="OCF.BTBO.html#32181" class="Bound">a</a><a id="32182" class="Symbol">)</a>  <a id="32185" class="Symbol">=</a> <a id="32187" href="OCF.BTBO.html#19412" class="InductiveConstructor">suc</a> <a id="32191" class="Symbol">(</a><a id="32192" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32197" href="OCF.BTBO.html#32181" class="Bound">a</a><a id="32198" class="Symbol">)</a>
  <a id="32202" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32207" class="Symbol">(</a><a id="32208" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="32212" href="OCF.BTBO.html#32212" class="Bound">f</a><a id="32213" class="Symbol">)</a>  <a id="32216" class="Symbol">=</a> <a id="32218" href="OCF.BTBO.html#19435" class="InductiveConstructor">lim</a> <a id="32222" class="Symbol">(</a><a id="32223" href="OCF.BTBO.html#23927" class="Function">cumsum</a> <a id="32230" class="Symbol">(</a><a id="32231" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32236" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="32238" href="OCF.BTBO.html#32212" class="Bound">f</a><a id="32239" class="Symbol">))</a> <a id="32242" class="Symbol">(</a><a id="32243" href="OCF.BTBO.html#24376" class="Function">cumsum-mono</a> <a id="32255" class="Symbol">(</a><a id="32256" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a> <a id="32261" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="32263" href="OCF.BTBO.html#32212" class="Bound">f</a><a id="32264" class="Symbol">))</a>
</pre>
<p><strong>定义 (迭代 <span class="math inline">\psi_0</span>)</strong> 定义 <span class="math inline">\psi^n:\mathbb{N}\to\mathsf{Ord}_0</span> 为 <span class="math inline">\psi_0 \circ \Omega \circ \mathsf{ord}^\mathsf{D}</span> 的 <span class="math inline">n</span> 次迭代:</p>
<p><span class="math display">
\psi^n(0) := (\psi_0 \circ \Omega \circ \mathsf{ord}^\mathsf{D})^n(0)
</span></p>
<pre class="Agda">  <a id="32488" class="Comment">-- n-iteration of ψ₀(Ω_x)</a>
  <a id="Ord_ord.ψⁿ"></a><a id="32516" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32519" class="Symbol">:</a> <a id="32521" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="32523" class="Symbol">→</a> <a id="32525" href="OCF.BTBO.html#25931" class="Function">Ord₀</a>
  <a id="32532" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32535" class="Symbol">=</a> <a id="32537" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="32542" class="Symbol">(</a><a id="32543" href="OCF.BTBO.html#31496" class="Function">ψ₀</a> <a id="32546" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="32548" href="OCF.BTBO.html#28998" class="Function">Ω</a> <a id="32550" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="32552" href="OCF.BTBO.html#32127" class="Function">ordᴰ</a><a id="32556" class="Symbol">)</a> <a id="32558" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>
</pre>
<p><strong>例 (关键序数)</strong></p>
<p><span class="math display">
\begin{align}
\psi^1(0) &amp;= \omega \\
\psi^2(0) &amp;= \mathsf{BO} \\
\psi^3(0) &amp;= \psi(\Omega_{\mathsf{BO}}) \\
\psi^4(0) &amp;= \psi(\Omega_{\psi(\Omega_{\mathsf{BO}})})
\end{align}
</span></p>
<pre class="Agda">  <a id="Ord_ord.ex1"></a><a id="32776" href="OCF.BTBO.html#32776" class="Function">ex1</a> <a id="32780" class="Symbol">=</a> <a id="32782" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32785" class="Number">1</a>    <a id="32790" class="Comment">-- ω</a>
  <a id="Ord_ord.ex2"></a><a id="32797" href="OCF.BTBO.html#32797" class="Function">ex2</a> <a id="32801" class="Symbol">=</a> <a id="32803" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32806" class="Number">2</a>    <a id="32811" class="Comment">-- Buchholz&#39;s ordinal</a>
  <a id="Ord_ord.ex3"></a><a id="32835" href="OCF.BTBO.html#32835" class="Function">ex3</a> <a id="32839" class="Symbol">=</a> <a id="32841" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32844" class="Number">3</a>    <a id="32849" class="Comment">-- ψ(Ω_BO)</a>
  <a id="Ord_ord.ex4"></a><a id="32862" href="OCF.BTBO.html#32862" class="Function">ex4</a> <a id="32866" class="Symbol">=</a> <a id="32868" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="32871" class="Number">4</a>    <a id="32876" class="Comment">-- ψ(Ω_ψ(Ω_BO))</a>
</pre>
<p><strong>定义 (布劳威尔树壁垒序数)</strong></p>
<p><span class="math display">
\mathsf{BTBO} := \mathsf{lim}(n\mapsto\psi^n(0)) = \psi(\Omega_\Omega)
</span></p>
<p>这是 <span class="math inline">\psi^n(0)</span> 序列的极限, 也就是我们能达到的最大序数 <span class="math inline">\psi(\Omega_\Omega)</span>.</p>
<pre class="Agda">  <a id="33067" class="Comment">-- Brouwer tree barrier ordinal</a>
  <a id="Ord_ord.BTBO"></a><a id="33101" href="OCF.BTBO.html#33101" class="Function">BTBO</a> <a id="33106" class="Symbol">:</a> <a id="33108" href="OCF.BTBO.html#25931" class="Function">Ord₀</a>
  <a id="33115" href="OCF.BTBO.html#33101" class="Function">BTBO</a> <a id="33120" class="Symbol">=</a> <a id="33122" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="33126" href="OCF.BTBO.html#32516" class="Function">ψⁿ</a> <a id="33129" class="Comment">-- ψ(Ω_Ω)</a>
</pre>
<p>最后, 遵循传统, 我们写出大数.</p>
<p><strong>定义 (快速增长层级)</strong> 递归定义 <span class="math inline">\mathfrak{f}:\mathsf{Ord}_0\to\mathbb{N}\to\mathbb{N}</span> 如下:</p>
<p><span class="math display">
\mathfrak{f}_\alpha(n) :=
\begin{cases}
   n^+ &amp;\text{if } \alpha = 0 \\
   (\mathfrak{f}_{\alpha&#39;})^n(n) &amp;\text{if } \alpha = \alpha&#39;^+ \\
   \mathfrak{f}_{f(n)}(n) &amp;\text{if } \alpha = \mathsf{lim}(f)
\end{cases}
</span></p>
<pre class="Agda">  <a id="Ord_ord.FGH"></a><a id="33479" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33483" class="Symbol">:</a> <a id="33485" href="OCF.BTBO.html#25931" class="Function">Ord₀</a> <a id="33490" class="Symbol">→</a> <a id="33492" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="33494" class="Symbol">→</a> <a id="33496" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="33500" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33504" href="OCF.BTBO.html#25624" class="InductiveConstructor">zero</a>    <a id="33512" href="OCF.BTBO.html#33512" class="Bound">n</a> <a id="33514" class="Symbol">=</a> <a id="33516" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="33520" href="OCF.BTBO.html#33512" class="Bound">n</a>
  <a id="33524" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33528" class="Symbol">(</a><a id="33529" href="OCF.BTBO.html#25643" class="InductiveConstructor">suc</a> <a id="33533" href="OCF.BTBO.html#33533" class="Bound">a</a><a id="33534" class="Symbol">)</a> <a id="33536" href="OCF.BTBO.html#33536" class="Bound">n</a> <a id="33538" class="Symbol">=</a> <a id="33540" href="OCF.BTBO.html#29975" class="Function">iter</a> <a id="33545" class="Symbol">(</a><a id="33546" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33550" href="OCF.BTBO.html#33533" class="Bound">a</a><a id="33551" class="Symbol">)</a> <a id="33553" href="OCF.BTBO.html#33536" class="Bound">n</a> <a id="33555" href="OCF.BTBO.html#33536" class="Bound">n</a>
  <a id="33559" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33563" class="Symbol">(</a><a id="33564" href="OCF.BTBO.html#25669" class="InductiveConstructor">lim</a> <a id="33568" href="OCF.BTBO.html#33568" class="Bound">a</a><a id="33569" class="Symbol">)</a> <a id="33571" href="OCF.BTBO.html#33571" class="Bound">n</a> <a id="33573" class="Symbol">=</a> <a id="33575" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33579" class="Symbol">(</a><a id="33580" href="OCF.BTBO.html#33568" class="Bound">a</a> <a id="33582" href="OCF.BTBO.html#33571" class="Bound">n</a><a id="33583" class="Symbol">)</a> <a id="33585" href="OCF.BTBO.html#33571" class="Bound">n</a>
</pre>
<p><strong>定义 (BTBO大数)</strong> 应用快速增长层级于 BTBO:</p>
<p><span class="math display">
\mathfrak{f}_\mathsf{BTBO}(99)
</span></p>
<p>这是一个基于布劳威尔树壁垒序数的具体大数.</p>
<pre class="Agda">  <a id="33698" href="OCF.BTBO.html#33698" class="Function">_</a> <a id="33700" class="Symbol">:</a> <a id="33702" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="33706" class="Symbol">_</a> <a id="33708" class="Symbol">=</a> <a id="33710" href="OCF.BTBO.html#33479" class="Function">FGH</a> <a id="33714" href="OCF.BTBO.html#33101" class="Function">BTBO</a> <a id="33719" class="Number">99</a>
</pre>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://gist.github.com/AndrasKovacs/8d445c8457ea0967e807c726b2ce5a3a?permalink_comment_id=5617267">Andras Kovacs - Large countable ordinals and numbers in Agda</a></li>
<li><a href="https://github.com/ccz181078/googology">ccz181078 - googology</a></li>
<li><a href="https://www.cse.chalmers.se/~coquand/prague1.pdf">Thierry Coquand - Inductive Definitions and Constructive Mathematics</a></li>
<li><a href="https://googology.fandom.com/wiki/Ordinal_collapsing_function">Googology Wiki - Ordinal collapsing function</a></li>
<li><a href="https://googology.fandom.com/ja/wiki/ユーザーブログ:Hexirp/ブラウワー順序数の制限と拡張">ユーザーブログ:Hexirp - ブラウワー順序数の制限と拡張</a></li>
<li><a href="https://googology.fandom.com/ja/wiki/ユーザーブログ:Hexirp/2024-12-25_のメモ">ユーザーブログ:Hexirp - 2024-12-25 のメモ</a></li>
</ul>
<h2 id="附录">附录</h2>
<p><a href="https://github.com/ccz181078">ccz181078</a> 使用<a href="https://github.com/ccz181078/googology/blob/main/BuchholzOCF.v">另一种类似的方法</a> 实现了 <span class="math inline">\mathsf{Ord}_n</span>, 但似乎更难以往上推广. 我们给出该方法的 Agda 版本, 以供参考.</p>
<pre class="Agda"><a id="34602" class="Keyword">module</a> <a id="Ord_nat_ccz181078"></a><a id="34609" href="OCF.BTBO.html#34609" class="Module Operator">Ord_nat_ccz181078</a> <a id="34627" class="Keyword">where</a>
  <a id="34635" class="Keyword">open</a> <a id="34640" href="OCF.BTBO.html#2311" class="Module Operator">Ord_basic</a>

  <a id="34653" class="Comment">-- 假设某 `X = Ordₙ` 已完成, 并且已知任意 `x : X` 的共尾度 `cf x`</a>
  <a id="34705" class="Keyword">module</a> <a id="34712" href="OCF.BTBO.html#34712" class="Module">_</a> <a id="34714" class="Symbol">{</a><a id="34715" href="OCF.BTBO.html#34715" class="Bound">X</a> <a id="34717" class="Symbol">:</a> <a id="34719" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="34722" class="Symbol">}</a> <a id="34724" class="Symbol">(</a><a id="34725" href="OCF.BTBO.html#34725" class="Bound">cf</a> <a id="34728" class="Symbol">:</a> <a id="34730" href="OCF.BTBO.html#34715" class="Bound">X</a> <a id="34732" class="Symbol">→</a> <a id="34734" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="34737" class="Symbol">)</a> <a id="34739" class="Keyword">where</a>
    <a id="34749" class="Comment">-- 定义 Ordₙ₊₁, 将其共尾度划分为5类: 0, 1, ω, (ω, Ω), Ω</a>
    <a id="34798" class="Keyword">data</a> <a id="34803" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a> <a id="34808" class="Symbol">:</a> <a id="34810" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="34814" class="Keyword">where</a>
      <a id="34826" href="OCF.BTBO.html#34826" class="InductiveConstructor">zero</a> <a id="34831" class="Symbol">:</a> <a id="34833" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a>
      <a id="34844" href="OCF.BTBO.html#34844" class="InductiveConstructor">suc</a> <a id="34848" class="Symbol">:</a> <a id="34850" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a> <a id="34855" class="Symbol">→</a> <a id="34857" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a>
      <a id="34868" href="OCF.BTBO.html#34868" class="InductiveConstructor">limω</a> <a id="34873" class="Symbol">:</a> <a id="34875" class="Symbol">(</a><a id="34876" href="OCF.BTBO.html#34876" class="Bound">f</a> <a id="34878" class="Symbol">:</a> <a id="34880" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="34882" class="Symbol">→</a> <a id="34884" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a><a id="34888" class="Symbol">)</a> <a id="34890" class="Symbol">→</a> <a id="34892" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a>
      <a id="34903" class="Comment">-- 代表所有 `k≤n` 的 `Ordₖ` 的 `limΩ`.</a>
      <a id="34942" href="OCF.BTBO.html#34942" class="InductiveConstructor">limX</a> <a id="34947" class="Symbol">:</a> <a id="34949" class="Symbol">(</a><a id="34950" href="OCF.BTBO.html#34950" class="Bound">x</a> <a id="34952" class="Symbol">:</a> <a id="34954" href="OCF.BTBO.html#34715" class="Bound">X</a><a id="34955" class="Symbol">)</a> <a id="34957" class="Symbol">(</a><a id="34958" href="OCF.BTBO.html#34958" class="Bound">f</a> <a id="34960" class="Symbol">:</a> <a id="34962" href="OCF.BTBO.html#34725" class="Bound">cf</a> <a id="34965" href="OCF.BTBO.html#34950" class="Bound">x</a> <a id="34967" class="Symbol">→</a> <a id="34969" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a><a id="34973" class="Symbol">)</a> <a id="34975" class="Symbol">→</a> <a id="34977" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a>
      <a id="34988" href="OCF.BTBO.html#34988" class="InductiveConstructor">limΩ</a> <a id="34993" class="Symbol">:</a> <a id="34995" class="Symbol">(</a><a id="34996" href="OCF.BTBO.html#34996" class="Bound">f</a> <a id="34998" class="Symbol">:</a> <a id="35000" href="OCF.BTBO.html#34715" class="Bound">X</a> <a id="35002" class="Symbol">→</a> <a id="35004" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a><a id="35008" class="Symbol">)</a> <a id="35010" class="Symbol">→</a> <a id="35012" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a>

    <a id="35022" class="Comment">-- 定义 `α : Ordₙ₊₁` 的共尾度</a>
    <a id="35050" href="OCF.BTBO.html#35050" class="Function">cf₊</a> <a id="35054" class="Symbol">:</a> <a id="35056" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a> <a id="35061" class="Symbol">→</a> <a id="35063" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="35071" href="OCF.BTBO.html#35050" class="Function">cf₊</a> <a id="35075" class="Symbol">(</a><a id="35076" href="OCF.BTBO.html#34988" class="InductiveConstructor">limΩ</a> <a id="35081" class="Symbol">_)</a> <a id="35084" class="Symbol">=</a> <a id="35086" href="OCF.BTBO.html#34715" class="Bound">X</a>
    <a id="35092" href="OCF.BTBO.html#35050" class="Function">cf₊</a> <a id="35096" class="Symbol">(</a><a id="35097" href="OCF.BTBO.html#34942" class="InductiveConstructor">limX</a> <a id="35102" href="OCF.BTBO.html#35102" class="Bound">x</a> <a id="35104" class="Symbol">_)</a> <a id="35107" class="Symbol">=</a> <a id="35109" href="OCF.BTBO.html#34725" class="Bound">cf</a> <a id="35112" href="OCF.BTBO.html#35102" class="Bound">x</a>
    <a id="35118" class="Comment">-- 我们只关心 &gt;ω 的情况</a>
    <a id="35138" href="OCF.BTBO.html#35050" class="CatchallClause Function">cf₊</a><a id="35141" class="CatchallClause"> </a><a id="35142" class="CatchallClause Symbol">_</a> <a id="35144" class="Symbol">=</a> <a id="35146" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

  <a id="35151" class="Comment">-- 互递归完成下标为自然数的整个 `Ordₙ` 层级以及每层的共尾度</a>
  <a id="35189" class="Keyword">mutual</a>
    <a id="Ord_nat_ccz181078.Ord"></a><a id="35200" href="OCF.BTBO.html#35200" class="Function">Ord</a> <a id="35204" class="Symbol">:</a> <a id="35206" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="35208" class="Symbol">→</a> <a id="35210" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="35218" href="OCF.BTBO.html#35200" class="Function">Ord</a> <a id="35222" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="35227" class="Symbol">=</a> <a id="35229" href="OCF.BTBO.html#2334" class="Datatype">Ord₀</a>
    <a id="35238" href="OCF.BTBO.html#35200" class="Function">Ord</a> <a id="35242" class="Symbol">(</a><a id="35243" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="35247" href="OCF.BTBO.html#35247" class="Bound">n</a><a id="35248" class="Symbol">)</a> <a id="35250" class="Symbol">=</a> <a id="35252" href="OCF.BTBO.html#34803" class="Datatype">Ord₊</a> <a id="35257" class="Symbol">(</a><a id="35258" href="OCF.BTBO.html#35269" class="Function">cf</a> <a id="35261" href="OCF.BTBO.html#35247" class="Bound">n</a><a id="35262" class="Symbol">)</a>

    <a id="Ord_nat_ccz181078.cf"></a><a id="35269" href="OCF.BTBO.html#35269" class="Function">cf</a> <a id="35272" class="Symbol">:</a> <a id="35274" class="Symbol">(</a><a id="35275" href="OCF.BTBO.html#35275" class="Bound">n</a> <a id="35277" class="Symbol">:</a> <a id="35279" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="35280" class="Symbol">)</a> <a id="35282" class="Symbol">→</a> <a id="35284" href="OCF.BTBO.html#35200" class="Function">Ord</a> <a id="35288" href="OCF.BTBO.html#35275" class="Bound">n</a> <a id="35290" class="Symbol">→</a> <a id="35292" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="35300" href="OCF.BTBO.html#35269" class="Function">cf</a> <a id="35303" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="35308" class="Symbol">_</a> <a id="35310" class="Symbol">=</a> <a id="35312" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="35318" href="OCF.BTBO.html#35269" class="Function">cf</a> <a id="35321" class="Symbol">(</a><a id="35322" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="35326" href="OCF.BTBO.html#35326" class="Bound">n</a><a id="35327" class="Symbol">)</a> <a id="35329" class="Symbol">=</a> <a id="35331" href="OCF.BTBO.html#35050" class="Function">cf₊</a> <a id="35335" class="Symbol">(</a><a id="35336" href="OCF.BTBO.html#35269" class="Function">cf</a> <a id="35339" href="OCF.BTBO.html#35326" class="Bound">n</a><a id="35340" class="Symbol">)</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
