<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.1 - 序数, FGH, 不动点)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.1---序数-fgh-不动点" id="toc-形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#目标人群" id="toc-目标人群">目标人群</a></li>
  <li><a href="#补充材料" id="toc-补充材料">补充材料</a></li>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a></li>
  <li><a href="#快速增长层级" id="toc-快速增长层级">快速增长层级</a></li>
  <li><a href="#序数的递归原理" id="toc-序数的递归原理">序数的递归原理</a></li>
  <li><a href="#无穷迭代" id="toc-无穷迭代">无穷迭代</a></li>
  <li><a href="#序数算术" id="toc-序数算术">序数算术</a></li>
  <li><a href="#跳出运算" id="toc-跳出运算">跳出运算</a></li>
  <li><a href="#不动点的枚举" id="toc-不动点的枚举">不动点的枚举</a></li>
  <li><a href="#ε-ζ-η-层级" id="toc-ε-ζ-η-层级">ε， ζ， η 层级</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Veblen/Basic.lagda.md">Basic.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Veblen.Basic.html">Basic.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是可运行且保证停机的<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0_(%E6%95%B0%E5%AD%A6)">大数</a>计算程序的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文学编程 (literate programming)</a> 实现.</p>
<ul>
<li><strong>可运行</strong>是相对于自然语言的数学描述而言, 本文贴出的代码可以在电脑上运行.</li>
<li><strong>保证停机</strong>是相对于<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备 (Turing-complete)</a> 语言 (如C语言) 而言, 本文使用的 <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a> 语言并非图灵完备, 其自带<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/termination-checking.html">停机检查 (termination checking)</a>, 写出的程序保证停机.</li>
<li><strong>文学编程</strong>是指本文既是程序代码, 也是程序文档, 代码和文档交织在一起, 以增强可读性.
<ul>
<li>Agda 程序会自动抽取本文所有代码块中的代码, 并执行类型检查, 而忽略代码块以外的内容.</li>
<li>※ 冷知识: 文学编程的发明者<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳 (Donald Knuth)</a>, 也是大数数学入门级内容<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%B4%8D%E7%AE%AD%E8%99%9F%E8%A1%A8%E7%A4%BA%E6%B3%95">高德纳箭号</a>的发明者, 也是排版软件 <a href="https://zh.wikipedia.org/wiki/TeX">TeX</a> 的发明者.</li>
</ul></li>
</ul>
<p>也就是说, 提供足够的时间, 能量和内存, 本文介绍的大数计算程序可以真正算出一个大数. 如果真的想运行: - 关于 Agda 的安装请参考 <a href="https://agda.readthedocs.io/en/latest/getting-started/installation.html">Installation</a>. - 本文所在Github仓库: <a href="https://github.com/choukh/agda-googology">agda-googology</a>.</p>
<h3 id="目标人群">目标人群</h3>
<ul>
<li>大数数学已入门 (如, 看完<a href="https://www.zhihu.com/column/c_1307845959598960640">大数数学入门</a>), 对严格性有进一步要求的读者.</li>
<li>Agda 已入门 (如, 看完 <a href="https://agda-zh.github.io/PLFA-zh/">PLFA</a>), 对大数计算程序的编程实现感兴趣的读者.</li>
</ul>
<p>只对前者感兴趣的读者, 可以忽略代码部分, 而只阅读文学部分, 它们可以看作是基于朴素类型论的数学描述, 并使用了 <span class="math inline">\LaTeX</span> 公式, 以对齐通常的数学习惯.</p>
<h3 id="补充材料">补充材料</h3>
<ul>
<li><a href="https://www.zhihu.com/column/c_1307845959598960640">core.exe - 大数数学入门</a></li>
<li><a href="https://www.zhihu.com/column/c_1697290814588301312">core.exe - 大数数学入门 - 重置版</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">oCaU - Agda大序数</a>
<ul>
<li>详细讨论了上至二元Veblen层级的序性质.</li>
<li>※ 本文不会讨论这些性质.</li>
</ul></li>
</ul>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="2078" class="Keyword">module</a> <a id="2085" href="Veblen.Basic.html" class="Module">Veblen.Basic</a> <a id="2098" class="Keyword">where</a>

<a id="2105" class="Keyword">open</a> <a id="2110" class="Keyword">import</a> <a id="2117" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2126" class="Keyword">public</a> <a id="2133" class="Keyword">using</a> <a id="2139" class="Symbol">(</a><a id="2140" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2141" class="Symbol">;</a> <a id="2143" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2147" class="Symbol">;</a> <a id="2149" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2152" class="Symbol">;</a> <a id="2154" href="Data.Nat.Base.html#1095" class="InductiveConstructor">2+</a><a id="2156" class="Symbol">)</a>
<a id="2158" class="Keyword">open</a> <a id="2163" class="Keyword">import</a> <a id="2170" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="2180" class="Keyword">public</a> <a id="2187" class="Keyword">using</a> <a id="2193" class="Symbol">(</a><a id="2194" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2195" class="Symbol">)</a>
<a id="2197" class="Keyword">open</a> <a id="2202" class="Keyword">import</a> <a id="2209" href="Function.html" class="Module">Function</a> <a id="2218" class="Keyword">public</a> <a id="2225" class="Keyword">using</a> <a id="2231" class="Symbol">(</a><a id="2232" href="Function.Base.html#704" class="Function">id</a><a id="2234" class="Symbol">;</a> <a id="2236" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="2239" class="Symbol">;</a> <a id="2241" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="2244" class="Symbol">;</a> <a id="2246" href="Function.Base.html#4486" class="Function Operator">_∋_</a><a id="2249" class="Symbol">)</a>
<a id="2251" class="Keyword">open</a> <a id="2256" class="Keyword">import</a> <a id="2263" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2301" class="Symbol">as</a> <a id="2304" class="Module">Eq</a> <a id="2307" class="Keyword">public</a> <a id="2314" class="Keyword">using</a> <a id="2320" class="Symbol">(</a><a id="2321" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2324" class="Symbol">;</a> <a id="2326" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2330" class="Symbol">;</a> <a id="2332" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a><a id="2336" class="Symbol">)</a>
<a id="2338" class="Keyword">open</a> <a id="2343" href="Relation.Binary.PropositionalEquality.Properties.html#6744" class="Module">Eq.≡-Reasoning</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<p>我们知道自然数类型 <span class="math inline">ℕ</span> 由如下两条规则定义.</p>
<p><span class="math display">
\frac{}{~\text{zero} : ℕ~}
\qquad
\frac{\alpha:ℕ}{~\text{suc}~\alpha:ℕ~}
</span></p>
<p><strong>定义</strong> 我们的序数类型 <span class="math inline">\text{Ord}</span> 则在 <span class="math inline">ℕ</span> 的基础上增加了第三条规则 <span class="math inline">\text{lim}</span>, 即如果 <span class="math inline">f</span> 是 <span class="math inline">ℕ</span> 到序数的函数, 那么 <span class="math inline">\text{lim}~f</span> 也是序数.</p>
<p><span class="math display">
\frac{}{~\text{zero} : \text{Ord}~}
\qquad
\frac{\alpha:\text{Ord}}{~\text{suc}~\alpha:\text{Ord}~}
\qquad
\frac{~f : ℕ\rightarrow\text{Ord}~}{\text{lim}~f:\text{Ord}}
</span></p>
<pre class="Agda"><a id="2771" class="Keyword">data</a> <a id="Ord"></a><a id="2776" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="2780" class="Symbol">:</a> <a id="2782" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="2786" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="2794" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a> <a id="2799" class="Symbol">:</a> <a id="2801" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="2807" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a>  <a id="2812" class="Symbol">:</a> <a id="2814" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="2818" class="Symbol">→</a> <a id="2820" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="2826" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a>  <a id="2831" class="Symbol">:</a> <a id="2833" class="Symbol">(</a><a id="2834" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2836" class="Symbol">→</a> <a id="2838" href="Veblen.Basic.html#2776" class="Datatype">Ord</a><a id="2841" class="Symbol">)</a> <a id="2843" class="Symbol">→</a> <a id="2845" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
</pre>
<p>这样的 <span class="math inline">f : ℕ\rightarrow\text{Ord}</span> 又叫做 <span class="math inline">\text{lim}~f</span> 的基本序列 (fundamental sequence), 而 <span class="math inline">\text{lim}~f</span> 则叫做基本序列 <span class="math inline">f</span> 的极限. 这样的定义允许我们很方便地讨论零, 后继序数和极限序数三种情况. 为了方便阅读, 我们会把 <span class="math inline">\text{zero}</span> 写作 <span class="math inline">0</span>, 把 <span class="math inline">\text{suc}~x</span> 写作 <span class="math inline">x^+</span>.</p>
<p><strong>注意</strong> 我们的序数类型, 学名叫布劳威尔树序数 (Brouwer tree ordinals), 比真正的序数宽泛很多, 体现在以下两点: - 树序数不要求基本序列是严格递增的. - 严格递增的约束对于大数的计算本身而言无关紧要. - 我们构造的序数的基本序列都是严格递增的, 如果想要, 可以额外补上证明. - <a href="https://zhuanlan.zhihu.com/p/572691308">Agda大序数</a>一文中证明了其中构造的上至 <span class="math inline">\Gamma_0</span> 的所有树序数的基本序列都是严格递增的. - 树序数是外延的 (extensional), 即真正的序数与树上的节点并不是唯一对应的. - 这意味着我们可以用不同的基本序列构造出相同的序数. - 但同一性证明依赖于函数外延性 (function extensionality), 或某种商 (quotient) 机制, 如 setoid 或 cubical. - 但这并不会影响大数的计算, 因为只要给出基本序列就能算, 况且大数的表示确实是依赖于特定的基本序列的.</p>
<p><strong>约定</strong> 我们用 <span class="math inline">α,β,γ,δ</span> 表示序数, 用 <span class="math inline">m,n</span> 表示自然数.</p>
<pre class="Agda"><a id="3599" class="Keyword">variable</a>
  <a id="3610" href="Veblen.Basic.html#3610" class="Generalizable">α</a> <a id="3612" href="Veblen.Basic.html#3612" class="Generalizable">β</a> <a id="3614" href="Veblen.Basic.html#3614" class="Generalizable">γ</a> <a id="3616" href="Veblen.Basic.html#3616" class="Generalizable">δ</a> <a id="3618" class="Symbol">:</a> <a id="3620" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
  <a id="3626" href="Veblen.Basic.html#3626" class="Generalizable">m</a> <a id="3628" href="Veblen.Basic.html#3628" class="Generalizable">n</a> <a id="3630" class="Symbol">:</a> <a id="3632" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<p><strong>约定</strong> 我们遵循类型论的习惯, 今后都会在无歧义的情况下省略函数应用的括号.</p>
<p><strong>定义</strong> 自然数到序数的嵌入函数 <span class="math inline">\text{finord} : ℕ → \text{Ord}</span></p>
<p><span class="math display">
\begin{aligned}
\text{finord}~0 &amp;= 0 \\
\text{finord}~n^+ &amp;= (\text{finord}~n)^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="finord"></a><a id="3845" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="3852" class="Symbol">:</a> <a id="3854" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3856" class="Symbol">→</a> <a id="3858" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="3862" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="3869" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="3874" class="Symbol">=</a> <a id="3876" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a>
<a id="3881" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="3888" class="Symbol">(</a><a id="3889" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3893" href="Veblen.Basic.html#3893" class="Bound">n</a><a id="3894" class="Symbol">)</a> <a id="3896" class="Symbol">=</a> <a id="3898" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="3902" class="Symbol">(</a><a id="3903" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="3910" href="Veblen.Basic.html#3893" class="Bound">n</a><a id="3911" class="Symbol">)</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\text{finord}</span> 构成了基本序列 <span class="math inline">(0, 1, 2, \ldots)</span>, 其极限定义为 <span class="math inline">ω</span></p>
<p><span class="math display">
ω := \text{lim}~\text{finord}
</span></p>
<pre class="Agda"><a id="ω"></a><a id="4027" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="4029" class="Symbol">=</a> <a id="4031" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="4035" href="Veblen.Basic.html#3845" class="Function">finord</a>
</pre>
<p><strong>非文学</strong> 以下代码调用了<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能, 允许数字字面量依据上下文自动具有自然数或序数类型.</p>
<pre class="Agda"><a id="4186" class="Keyword">open</a> <a id="4191" class="Keyword">import</a> <a id="4198" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a>

<a id="4220" class="Keyword">instance</a>
  <a id="4231" href="Veblen.Basic.html#4231" class="Function">_</a> <a id="4233" class="Symbol">=</a> <a id="4235" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4242" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="4246" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4248" class="Keyword">record</a> <a id="4255" class="Symbol">{</a> <a id="4257" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4268" class="Symbol">=</a> <a id="4270" class="Symbol">λ</a> <a id="4272" href="Veblen.Basic.html#4272" class="Bound">_</a> <a id="4274" class="Symbol">→</a> <a id="4276" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4278" class="Symbol">;</a> <a id="4280" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4288" class="Symbol">=</a> <a id="4290" class="Symbol">λ</a> <a id="4292" href="Veblen.Basic.html#4292" class="Bound">n</a> <a id="4294" class="Symbol">→</a> <a id="4296" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="4303" href="Veblen.Basic.html#4292" class="Bound">n</a> <a id="4305" class="Symbol">}</a>
  <a id="4309" href="Veblen.Basic.html#4309" class="Function">_</a> <a id="4311" class="Symbol">=</a> <a id="4313" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4320" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="4324" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4326" class="Keyword">record</a> <a id="4333" class="Symbol">{</a> <a id="4335" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4346" class="Symbol">=</a> <a id="4348" class="Symbol">λ</a> <a id="4350" href="Veblen.Basic.html#4350" class="Bound">_</a> <a id="4352" class="Symbol">→</a> <a id="4354" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4356" class="Symbol">;</a> <a id="4358" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4366" class="Symbol">=</a> <a id="4368" class="Symbol">λ</a> <a id="4370" href="Veblen.Basic.html#4370" class="Bound">n</a> <a id="4372" class="Symbol">→</a> <a id="4374" href="Veblen.Basic.html#4370" class="Bound">n</a> <a id="4376" class="Symbol">}</a>
</pre>
<p>以下为测试用例.</p>
<pre class="Agda"><a id="4401" href="Veblen.Basic.html#4401" class="Function">_</a> <a id="4403" class="Symbol">=</a> <a id="4405" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="4409" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4411" class="Number">233</a>
<a id="4415" href="Veblen.Basic.html#4415" class="Function">_</a> <a id="4417" class="Symbol">=</a> <a id="4419" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="4423" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4425" class="Number">233</a>
</pre>
<h2 id="快速增长层级">快速增长层级</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">A</span> 表示类型.</p>
<pre class="Agda"><a id="4475" class="Keyword">variable</a> <a id="4484" href="Veblen.Basic.html#4484" class="Generalizable">A</a> <a id="4486" class="Symbol">:</a> <a id="4488" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义</strong> 函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span></p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{n^+} &amp;= F \circ F^n
\end{aligned}
</span></p>
<p>其中 <span class="math inline">\text{id}</span> 是恒等函数.</p>
<pre class="Agda"><a id="_∘ⁿ_"></a><a id="4647" href="Veblen.Basic.html#4647" class="Function Operator">_∘ⁿ_</a> <a id="4652" class="Symbol">:</a> <a id="4654" class="Symbol">(</a><a id="4655" href="Veblen.Basic.html#4484" class="Generalizable">A</a> <a id="4657" class="Symbol">→</a> <a id="4659" href="Veblen.Basic.html#4484" class="Generalizable">A</a><a id="4660" class="Symbol">)</a> <a id="4662" class="Symbol">→</a> <a id="4664" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4666" class="Symbol">→</a> <a id="4668" class="Symbol">(</a><a id="4669" href="Veblen.Basic.html#4484" class="Generalizable">A</a> <a id="4671" class="Symbol">→</a> <a id="4673" href="Veblen.Basic.html#4484" class="Generalizable">A</a><a id="4674" class="Symbol">)</a>
<a id="4676" class="Symbol">(</a><a id="4677" href="Veblen.Basic.html#4677" class="Bound">F</a> <a id="4679" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="4682" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="4686" class="Symbol">)</a>  <a id="4689" class="Symbol">=</a> <a id="4691" href="Function.Base.html#704" class="Function">id</a>
<a id="4694" class="Symbol">(</a><a id="4695" href="Veblen.Basic.html#4695" class="Bound">F</a> <a id="4697" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="4700" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4704" href="Veblen.Basic.html#4704" class="Bound">n</a><a id="4705" class="Symbol">)</a> <a id="4707" class="Symbol">=</a> <a id="4709" class="Symbol">(</a><a id="4710" href="Veblen.Basic.html#4695" class="Bound">F</a> <a id="4712" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4714" class="Symbol">(</a><a id="4715" href="Veblen.Basic.html#4695" class="Bound">F</a> <a id="4717" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="4720" href="Veblen.Basic.html#4704" class="Bound">n</a><a id="4721" class="Symbol">))</a>
</pre>
<p><strong>定义</strong> 快速增长层级 (Fast Growing Hierarchy, FGH) 是一个函数族 <span class="math inline">f : \text{Ord} → ℕ → ℕ</span>, 对于每个序数 <span class="math inline">α</span>, <span class="math inline">f_α</span> 是一个从自然数到自然数的函数, 定义如下.</p>
<p><span class="math display">
\begin{aligned}
f_0~n &amp;= n^+ \\
f_{α^+}~n &amp;= f_α^n~n \\
f_{\text{lim}~g}~n &amp;= f_{g~n}~n
\end{aligned}
</span></p>
<pre class="Agda"><a id="4964" class="Keyword">module</a> <a id="FGH"></a><a id="4971" href="Veblen.Basic.html#4971" class="Module">FGH</a> <a id="4975" class="Keyword">where</a>
  <a id="FGH.f"></a><a id="4983" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="4985" class="Symbol">:</a> <a id="4987" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="4991" class="Symbol">→</a> <a id="4993" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4995" class="Symbol">→</a> <a id="4997" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="5001" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5003" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a> <a id="5008" href="Veblen.Basic.html#5008" class="Bound">n</a> <a id="5010" class="Symbol">=</a> <a id="5012" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5016" href="Veblen.Basic.html#5008" class="Bound">n</a>
  <a id="5020" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5022" class="Symbol">(</a><a id="5023" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="5027" href="Veblen.Basic.html#5027" class="Bound">α</a><a id="5028" class="Symbol">)</a> <a id="5030" href="Veblen.Basic.html#5030" class="Bound">n</a> <a id="5032" class="Symbol">=</a> <a id="5034" class="Symbol">(</a><a id="5035" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5037" href="Veblen.Basic.html#5027" class="Bound">α</a> <a id="5039" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="5042" href="Veblen.Basic.html#5030" class="Bound">n</a><a id="5043" class="Symbol">)</a> <a id="5045" href="Veblen.Basic.html#5030" class="Bound">n</a>
  <a id="5049" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5051" class="Symbol">(</a><a id="5052" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="5056" href="Veblen.Basic.html#5056" class="Bound">g</a><a id="5057" class="Symbol">)</a> <a id="5059" href="Veblen.Basic.html#5059" class="Bound">n</a> <a id="5061" class="Symbol">=</a> <a id="5063" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5065" class="Symbol">(</a><a id="5066" href="Veblen.Basic.html#5056" class="Bound">g</a> <a id="5068" href="Veblen.Basic.html#5059" class="Bound">n</a><a id="5069" class="Symbol">)</a> <a id="5071" href="Veblen.Basic.html#5059" class="Bound">n</a>
</pre>
<p><strong>例</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_0~n &amp;= n^+ \\
f_1~n &amp;= 2n \\
f_2~n &amp;= 2^n~n
\end{aligned}
</span></p>
<p>这些等式的证明只需对 <span class="math inline">n</span> 进行归纳, 是显然的. 代码方面我们只写一些实例作为测试.</p>
<pre class="Agda">  <a id="FGH.f-0-2"></a><a id="5228" href="Veblen.Basic.html#5228" class="Function">f-0-2</a> <a id="5234" class="Symbol">:</a> <a id="5236" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5238" class="Number">0</a> <a id="5240" class="Number">2</a> <a id="5242" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5244" class="Number">3</a>
  <a id="5248" href="Veblen.Basic.html#5228" class="Function">f-0-2</a> <a id="5254" class="Symbol">=</a> <a id="5256" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-1-2"></a><a id="5264" href="Veblen.Basic.html#5264" class="Function">f-1-2</a> <a id="5270" class="Symbol">:</a> <a id="5272" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5274" class="Number">1</a> <a id="5276" class="Number">2</a> <a id="5278" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5280" class="Number">4</a>
  <a id="5284" href="Veblen.Basic.html#5264" class="Function">f-1-2</a> <a id="5290" class="Symbol">=</a> <a id="5292" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-2-2"></a><a id="5300" href="Veblen.Basic.html#5300" class="Function">f-2-2</a> <a id="5306" class="Symbol">:</a> <a id="5308" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5310" class="Number">2</a> <a id="5312" class="Number">2</a> <a id="5314" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5316" class="Number">8</a>
  <a id="5320" href="Veblen.Basic.html#5300" class="Function">f-2-2</a> <a id="5326" class="Symbol">=</a> <a id="5328" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math inline">f_3</span> 以上的表达式越来越复杂, 但不难计算实例如 <span class="math inline">f_{3}~2=2048</span>.</p>
<pre class="Agda">  <a id="FGH.f-3-2"></a><a id="5393" href="Veblen.Basic.html#5393" class="Function">f-3-2</a> <a id="5399" class="Symbol">:</a> <a id="5401" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5403" class="Number">3</a> <a id="5405" class="Number">2</a> <a id="5407" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5409" class="Number">2048</a>
  <a id="5416" href="Veblen.Basic.html#5393" class="Function">f-3-2</a> <a id="5422" class="Symbol">=</a> <a id="5424" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>引理</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_{\alpha^+}~n &amp;= f_\alpha^n~n \\
f_{ω}~n &amp;= f_{n}~n
\end{aligned}
</span></p>
<pre class="Agda">  <a id="FGH.f-suc"></a><a id="5546" href="Veblen.Basic.html#5546" class="Function">f-suc</a> <a id="5552" class="Symbol">:</a> <a id="5554" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5556" class="Symbol">(</a><a id="5557" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="5561" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="5562" class="Symbol">)</a> <a id="5564" href="Veblen.Basic.html#3628" class="Generalizable">n</a> <a id="5566" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5568" class="Symbol">(</a><a id="5569" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5571" href="Veblen.Basic.html#3610" class="Generalizable">α</a> <a id="5573" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="5576" href="Veblen.Basic.html#3628" class="Generalizable">n</a><a id="5577" class="Symbol">)</a> <a id="5579" href="Veblen.Basic.html#3628" class="Generalizable">n</a>
  <a id="5583" href="Veblen.Basic.html#5546" class="Function">f-suc</a> <a id="5589" class="Symbol">=</a> <a id="5591" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-ω"></a><a id="5599" href="Veblen.Basic.html#5599" class="Function">f-ω</a> <a id="5603" class="Symbol">:</a> <a id="5605" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5607" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="5609" href="Veblen.Basic.html#3628" class="Generalizable">n</a> <a id="5611" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5613" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5615" class="Symbol">(</a><a id="5616" href="Veblen.Basic.html#3845" class="Function">finord</a> <a id="5623" href="Veblen.Basic.html#3628" class="Generalizable">n</a><a id="5624" class="Symbol">)</a> <a id="5626" href="Veblen.Basic.html#3628" class="Generalizable">n</a>
  <a id="5630" href="Veblen.Basic.html#5599" class="Function">f-ω</a> <a id="5634" class="Symbol">=</a> <a id="5636" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 本文出现的大部分命题的证明都是「依定义即得」的, 体现为代码中的 <code>refl</code>. 也就是说, 证明都是直接展开定义, 不需要额外的推理. 但这并不意味着所有证明是显然的, 有时候递归定义的展开会非常复杂, 这时候我们会分布展开, 逐步化简, 但每一步都是 <code>refl</code> 可证.</p>
<p><strong>定理</strong> 由以上两式不难看出</p>
<p><span class="math display">
f_{ω^+}~n = f_ω^n~n
</span></p>
<pre class="Agda">  <a id="FGH.f-ω⁺"></a><a id="5848" href="Veblen.Basic.html#5848" class="Function">f-ω⁺</a> <a id="5853" class="Symbol">:</a> <a id="5855" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5857" class="Symbol">(</a><a id="5858" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="5862" href="Veblen.Basic.html#4027" class="Function">ω</a><a id="5863" class="Symbol">)</a> <a id="5865" href="Veblen.Basic.html#3628" class="Generalizable">n</a> <a id="5867" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5869" class="Symbol">(</a><a id="5870" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="5872" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="5874" href="Veblen.Basic.html#4647" class="Function Operator">∘ⁿ</a> <a id="5877" href="Veblen.Basic.html#3628" class="Generalizable">n</a><a id="5878" class="Symbol">)</a> <a id="5880" href="Veblen.Basic.html#3628" class="Generalizable">n</a>
  <a id="5884" href="Veblen.Basic.html#5848" class="Function">f-ω⁺</a> <a id="5889" class="Symbol">=</a> <a id="5891" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>推论</strong> 特别地, 有</p>
<p><span class="math display">
f_{ω^+}~2 = f_ω~(f_ω~2)
</span></p>
<p>但此式无法在 Agda 中直接证明, 因为 Agda 想先把两边都算出, 而这是不现实的. 如果有读者知道如何证明, 请打在评论区. 作为替代, 我们可以证明如下式子.</p>
<p><span class="math display">
f_{\alpha^+}~2 = f_\alpha~(f_\alpha~2)
</span></p>
<pre class="Agda">  <a id="FGH.f-suc-2"></a><a id="6089" href="Veblen.Basic.html#6089" class="Function">f-suc-2</a> <a id="6097" class="Symbol">:</a> <a id="6099" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="6101" class="Symbol">(</a><a id="6102" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="6106" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="6107" class="Symbol">)</a> <a id="6109" class="Number">2</a> <a id="6111" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6113" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="6115" href="Veblen.Basic.html#3610" class="Generalizable">α</a> <a id="6117" class="Symbol">(</a><a id="6118" href="Veblen.Basic.html#4983" class="Function">f</a> <a id="6120" href="Veblen.Basic.html#3610" class="Generalizable">α</a> <a id="6122" class="Number">2</a><a id="6123" class="Symbol">)</a>
  <a id="6127" href="Veblen.Basic.html#6089" class="Function">f-suc-2</a> <a id="6135" class="Symbol">=</a> <a id="6137" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实</strong> <span class="math inline">f_{ω^+} 64</span> 已经大于葛立恒数.</p>
<blockquote>
<p>从这里开始, 研究大数的数学就转变成了研究快速增长函数的数学, 进而转变成研究大的序数的数学.</p>
</blockquote>
<h2 id="序数的递归原理">序数的递归原理</h2>
<p>为了系统性的构造大序数, 我们先证明序数归纳法, 并由此得到序数的递归原理.</p>
<p><strong>定理 序数归纳法 (transfinite induction)</strong> 对于任意性质 <span class="math inline">P : \text{Ord} → \text{Set}</span>, 如果 1. <span class="math inline">P~0</span> 成立, 2. 对于任意序数 <span class="math inline">α</span>, 如果 <span class="math inline">P~α</span> 成立, 则 <span class="math inline">P~α^+</span> 成立, 3. 对于任意基本序列 <span class="math inline">f</span>, 如果对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P~(f~n)</span> 成立, 则 <span class="math inline">P~(\text{lim}~f)</span> 成立,</p>
<p>则对于任意序数 <span class="math inline">α</span>, <span class="math inline">P~α</span> 成立.</p>
<pre class="Agda"><a id="ind"></a><a id="6518" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6522" class="Symbol">:</a> <a id="6524" class="Symbol">{</a><a id="6525" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6527" class="Symbol">:</a> <a id="6529" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="6533" class="Symbol">→</a> <a id="6535" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="6538" class="Symbol">}</a>
  <a id="6542" class="Symbol">→</a> <a id="6544" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6546" class="InductiveConstructor">zero</a>
  <a id="6553" class="Symbol">→</a> <a id="6555" class="Symbol">(∀</a> <a id="6558" href="Veblen.Basic.html#6558" class="Bound">α</a> <a id="6560" class="Symbol">→</a> <a id="6562" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6564" href="Veblen.Basic.html#6558" class="Bound">α</a> <a id="6566" class="Symbol">→</a> <a id="6568" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6570" class="Symbol">(</a><a id="6571" class="InductiveConstructor">suc</a> <a id="6575" href="Veblen.Basic.html#6558" class="Bound">α</a><a id="6576" class="Symbol">))</a>
  <a id="6581" class="Symbol">→</a> <a id="6583" class="Symbol">(∀</a> <a id="6586" href="Veblen.Basic.html#6586" class="Bound">f</a> <a id="6588" class="Symbol">→</a> <a id="6590" class="Symbol">(∀</a> <a id="6593" href="Veblen.Basic.html#6593" class="Bound">n</a> <a id="6595" class="Symbol">→</a> <a id="6597" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6599" class="Symbol">(</a><a id="6600" href="Veblen.Basic.html#6586" class="Bound">f</a> <a id="6602" href="Veblen.Basic.html#6593" class="Bound">n</a><a id="6603" class="Symbol">))</a> <a id="6606" class="Symbol">→</a> <a id="6608" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6610" class="Symbol">(</a><a id="6611" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="6615" href="Veblen.Basic.html#6586" class="Bound">f</a><a id="6616" class="Symbol">))</a>
  <a id="6621" class="Symbol">→</a> <a id="6623" class="Symbol">∀</a> <a id="6625" href="Veblen.Basic.html#6625" class="Bound">α</a> <a id="6627" class="Symbol">→</a> <a id="6629" href="Veblen.Basic.html#6525" class="Bound">P</a> <a id="6631" href="Veblen.Basic.html#6625" class="Bound">α</a>
</pre>
<p><strong>(证明)</strong> 要证对于任意序数 <span class="math inline">α</span>, <span class="math inline">P~α</span> 成立. 归纳 <span class="math inline">α</span> 的三种情况.</p>
<ul>
<li>当 <span class="math inline">α=0</span> 时, 由条件1, <span class="math inline">P~0</span> 成立.</li>
<li>当 <span class="math inline">α=α^+</span> 时, 要证 <span class="math inline">P\,α^+</span> 成立. 由归纳假设, <span class="math inline">P~α</span> 成立. 由条件2, <span class="math inline">P~α^+</span> 成立.</li>
<li>当 <span class="math inline">α=\text{lim}~f</span> 时, 要证 <span class="math inline">P~(\text{lim}~f)</span> 成立. 由归纳假设, 对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P~(f~n)</span> 成立. 由条件3, <span class="math inline">P~(\text{lim}~f)</span> 成立. ∎</li>
</ul>
<pre class="Agda"><a id="6905" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6909" href="Veblen.Basic.html#6909" class="Bound">z</a> <a id="6911" href="Veblen.Basic.html#6911" class="Bound">s</a> <a id="6913" href="Veblen.Basic.html#6913" class="Bound">l</a> <a id="6915" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a> <a id="6920" class="Symbol">=</a> <a id="6922" href="Veblen.Basic.html#6909" class="Bound">z</a>
<a id="6924" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6928" href="Veblen.Basic.html#6928" class="Bound">z</a> <a id="6930" href="Veblen.Basic.html#6930" class="Bound">s</a> <a id="6932" href="Veblen.Basic.html#6932" class="Bound">l</a> <a id="6934" class="Symbol">(</a><a id="6935" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="6939" href="Veblen.Basic.html#6939" class="Bound">α</a><a id="6940" class="Symbol">)</a> <a id="6942" class="Symbol">=</a> <a id="6944" href="Veblen.Basic.html#6930" class="Bound">s</a> <a id="6946" href="Veblen.Basic.html#6939" class="Bound">α</a> <a id="6948" class="Symbol">(</a><a id="6949" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6953" href="Veblen.Basic.html#6928" class="Bound">z</a> <a id="6955" href="Veblen.Basic.html#6930" class="Bound">s</a> <a id="6957" href="Veblen.Basic.html#6932" class="Bound">l</a> <a id="6959" href="Veblen.Basic.html#6939" class="Bound">α</a><a id="6960" class="Symbol">)</a>
<a id="6962" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6966" href="Veblen.Basic.html#6966" class="Bound">z</a> <a id="6968" href="Veblen.Basic.html#6968" class="Bound">s</a> <a id="6970" href="Veblen.Basic.html#6970" class="Bound">l</a> <a id="6972" class="Symbol">(</a><a id="6973" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="6977" href="Veblen.Basic.html#6977" class="Bound">f</a><a id="6978" class="Symbol">)</a> <a id="6980" class="Symbol">=</a> <a id="6982" href="Veblen.Basic.html#6970" class="Bound">l</a> <a id="6984" href="Veblen.Basic.html#6977" class="Bound">f</a> <a id="6986" class="Symbol">λ</a> <a id="6988" href="Veblen.Basic.html#6988" class="Bound">n</a> <a id="6990" class="Symbol">→</a> <a id="6992" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="6996" href="Veblen.Basic.html#6966" class="Bound">z</a> <a id="6998" href="Veblen.Basic.html#6968" class="Bound">s</a> <a id="7000" href="Veblen.Basic.html#6970" class="Bound">l</a> <a id="7002" class="Symbol">(</a><a id="7003" href="Veblen.Basic.html#6977" class="Bound">f</a> <a id="7005" href="Veblen.Basic.html#6988" class="Bound">n</a><a id="7006" class="Symbol">)</a>
</pre>
<p><strong>定理 序数的递归原理 (transfinite recursion)</strong> 对于任意类型 <span class="math inline">A</span>, 函数 <span class="math inline">z : A</span>, <span class="math inline">s : A → A</span>, <span class="math inline">l : (ℕ → A) → A</span>, 和任意序数 <span class="math inline">α</span>, 存在唯一的 <span class="math inline">\text{rec}~z~s~l~α : A</span>, 满足</p>
<p><span class="math display">
\begin{aligned}
\text{rec}~z~s~l~0 &amp;= z \\
\text{rec}~z~s~l~α^+ &amp;= s~(\text{rec}~z~s~l~α) \\
\text{rec}~z~s~l~(\text{lim}~f) &amp;= l~(λ~n,\text{rec}~z~s~l~(f~n))
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 令 <span class="math inline">P = λ~\_,A</span> 并应用序数归纳法即可. ∎</p>
<pre class="Agda"><a id="rec"></a><a id="7382" href="Veblen.Basic.html#7382" class="Function">rec</a> <a id="7386" class="Symbol">:</a> <a id="7388" href="Veblen.Basic.html#4484" class="Generalizable">A</a> <a id="7390" class="Symbol">→</a> <a id="7392" class="Symbol">(</a><a id="7393" href="Veblen.Basic.html#4484" class="Generalizable">A</a> <a id="7395" class="Symbol">→</a> <a id="7397" href="Veblen.Basic.html#4484" class="Generalizable">A</a><a id="7398" class="Symbol">)</a> <a id="7400" class="Symbol">→</a> <a id="7402" class="Symbol">((</a><a id="7404" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7406" class="Symbol">→</a> <a id="7408" href="Veblen.Basic.html#4484" class="Generalizable">A</a><a id="7409" class="Symbol">)</a> <a id="7411" class="Symbol">→</a> <a id="7413" href="Veblen.Basic.html#4484" class="Generalizable">A</a><a id="7414" class="Symbol">)</a> <a id="7416" class="Symbol">→</a> <a id="7418" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="7422" class="Symbol">→</a> <a id="7424" href="Veblen.Basic.html#4484" class="Generalizable">A</a>
<a id="7426" href="Veblen.Basic.html#7382" class="Function">rec</a> <a id="7430" href="Veblen.Basic.html#7430" class="Bound">z</a> <a id="7432" href="Veblen.Basic.html#7432" class="Bound">s</a> <a id="7434" href="Veblen.Basic.html#7434" class="Bound">l</a> <a id="7436" class="Symbol">=</a> <a id="7438" href="Veblen.Basic.html#6518" class="Function">ind</a> <a id="7442" href="Veblen.Basic.html#7430" class="Bound">z</a> <a id="7444" class="Symbol">(λ</a> <a id="7447" href="Veblen.Basic.html#7447" class="Bound">_</a> <a id="7449" class="Symbol">→</a> <a id="7451" href="Veblen.Basic.html#7432" class="Bound">s</a><a id="7452" class="Symbol">)</a> <a id="7454" class="Symbol">(λ</a> <a id="7457" href="Veblen.Basic.html#7457" class="Bound">_</a> <a id="7459" class="Symbol">→</a> <a id="7461" href="Veblen.Basic.html#7434" class="Bound">l</a><a id="7462" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 序数的递归原理是序数归纳法的特例, 也就是说, 序数的递归原理是序数归纳法的一个直接应用.</p>
<p><strong>注意</strong> 序数的递归原理相当强大, 因为 <span class="math inline">A</span> 可以是任意类型, 包括函数类型 <span class="math inline">\text{Ord}\rightarrow\text{Ord}</span> 与 <span class="math inline">(\text{Ord}\rightarrow\text{Ord})\rightarrow(\text{Ord}\rightarrow\text{Ord})</span> 等, 也就是说它允许定义高阶函数的递归. 本文出现的所有大序数都由它定义.</p>
<h2 id="无穷迭代">无穷迭代</h2>
<pre class="Agda"><a id="_∘^_"></a><a id="7738" href="Veblen.Basic.html#7738" class="Function Operator">_∘^_</a> <a id="7743" class="Symbol">:</a> <a id="7745" class="Symbol">(</a><a id="7746" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="7750" class="Symbol">→</a> <a id="7752" href="Veblen.Basic.html#2776" class="Datatype">Ord</a><a id="7755" class="Symbol">)</a> <a id="7757" class="Symbol">→</a> <a id="7759" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="7763" class="Symbol">→</a> <a id="7765" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="7769" class="Symbol">→</a> <a id="7771" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="7775" class="Symbol">(</a><a id="7776" href="Veblen.Basic.html#7776" class="Bound">F</a> <a id="7778" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="7781" href="Veblen.Basic.html#7781" class="Bound">α</a><a id="7782" class="Symbol">)</a> <a id="7784" href="Veblen.Basic.html#7784" class="Bound">β</a> <a id="7786" class="Symbol">=</a> <a id="7788" href="Veblen.Basic.html#7382" class="Function">rec</a> <a id="7792" href="Veblen.Basic.html#7784" class="Bound">β</a> <a id="7794" href="Veblen.Basic.html#7776" class="Bound">F</a> <a id="7796" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="7800" href="Veblen.Basic.html#7781" class="Bound">α</a>
</pre>
<pre class="Agda"><a id="7815" class="Keyword">variable</a>
  <a id="7826" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7828" class="Symbol">:</a> <a id="7830" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="7834" class="Symbol">→</a> <a id="7836" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
  <a id="7842" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="7844" href="Veblen.Basic.html#7844" class="Generalizable">g</a> <a id="7846" href="Veblen.Basic.html#7846" class="Generalizable">h</a> <a id="7848" class="Symbol">:</a> <a id="7850" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7852" class="Symbol">→</a> <a id="7854" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
</pre>
<pre class="Agda"><a id="∘^-zero"></a><a id="7871" href="Veblen.Basic.html#7871" class="Function">∘^-zero</a> <a id="7879" class="Symbol">:</a> <a id="7881" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7883" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="7886" class="InductiveConstructor">zero</a> <a id="7891" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7893" href="Function.Base.html#704" class="Function">id</a>
<a id="7896" href="Veblen.Basic.html#7871" class="Function">∘^-zero</a> <a id="7904" class="Symbol">=</a> <a id="7906" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="∘^-suc"></a><a id="7924" href="Veblen.Basic.html#7924" class="Function">∘^-suc</a> <a id="7931" class="Symbol">:</a> <a id="7933" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7935" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="7938" class="InductiveConstructor">suc</a> <a id="7942" href="Veblen.Basic.html#3610" class="Generalizable">α</a> <a id="7944" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7946" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7948" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="7950" class="Symbol">(</a><a id="7951" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7953" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="7956" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="7957" class="Symbol">)</a>
<a id="7959" href="Veblen.Basic.html#7924" class="Function">∘^-suc</a> <a id="7966" class="Symbol">=</a> <a id="7968" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="∘^-lim"></a><a id="7986" href="Veblen.Basic.html#7986" class="Function">∘^-lim</a> <a id="7993" class="Symbol">:</a> <a id="7995" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="7997" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8000" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8004" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="8006" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8008" class="Symbol">λ</a> <a id="8010" href="Veblen.Basic.html#8010" class="Bound">β</a> <a id="8012" class="Symbol">→</a> <a id="8014" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8018" class="Symbol">λ</a> <a id="8020" href="Veblen.Basic.html#8020" class="Bound">n</a> <a id="8022" class="Symbol">→</a> <a id="8024" class="Symbol">(</a><a id="8025" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8027" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8030" class="Symbol">(</a><a id="8031" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="8033" href="Veblen.Basic.html#8020" class="Bound">n</a><a id="8034" class="Symbol">))</a> <a id="8037" href="Veblen.Basic.html#8010" class="Bound">β</a>
<a id="8039" href="Veblen.Basic.html#7986" class="Function">∘^-lim</a> <a id="8046" class="Symbol">=</a> <a id="8048" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="iterω"></a><a id="8066" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="8072" class="Symbol">:</a> <a id="8074" class="Symbol">(</a><a id="8075" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8079" class="Symbol">→</a> <a id="8081" href="Veblen.Basic.html#2776" class="Datatype">Ord</a><a id="8084" class="Symbol">)</a> <a id="8086" class="Symbol">→</a> <a id="8088" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8092" class="Symbol">→</a> <a id="8094" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8098" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="8104" href="Veblen.Basic.html#8104" class="Bound">F</a> <a id="8106" href="Veblen.Basic.html#8106" class="Bound">α</a> <a id="8108" class="Symbol">=</a> <a id="8110" class="Symbol">(</a><a id="8111" href="Veblen.Basic.html#8104" class="Bound">F</a> <a id="8113" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8116" href="Veblen.Basic.html#4027" class="Function">ω</a><a id="8117" class="Symbol">)</a> <a id="8119" href="Veblen.Basic.html#8106" class="Bound">α</a>
</pre>
<h2 id="序数算术">序数算术</h2>
<pre class="Agda"><a id="8143" class="Keyword">infixl</a> <a id="8150" class="Number">6</a> <a id="8152" href="Veblen.Basic.html#8156" class="Function Operator">_+_</a>
<a id="_+_"></a><a id="8156" href="Veblen.Basic.html#8156" class="Function Operator">_+_</a> <a id="8160" class="Symbol">:</a> <a id="8162" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8166" class="Symbol">→</a> <a id="8168" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8172" class="Symbol">→</a> <a id="8174" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8178" href="Veblen.Basic.html#8178" class="Bound">α</a> <a id="8180" href="Veblen.Basic.html#8156" class="Function Operator">+</a> <a id="8182" href="Veblen.Basic.html#8182" class="Bound">β</a> <a id="8184" class="Symbol">=</a> <a id="8186" class="Symbol">(</a><a id="8187" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8191" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8194" href="Veblen.Basic.html#8182" class="Bound">β</a><a id="8195" class="Symbol">)</a> <a id="8197" href="Veblen.Basic.html#8178" class="Bound">α</a>
</pre>
<pre class="Agda"><a id="8212" class="Keyword">infixl</a> <a id="8219" class="Number">7</a> <a id="8221" href="Veblen.Basic.html#8225" class="Function Operator">_*_</a>
<a id="_*_"></a><a id="8225" href="Veblen.Basic.html#8225" class="Function Operator">_*_</a> <a id="8229" class="Symbol">:</a> <a id="8231" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8235" class="Symbol">→</a> <a id="8237" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8241" class="Symbol">→</a> <a id="8243" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8247" href="Veblen.Basic.html#8247" class="Bound">α</a> <a id="8249" href="Veblen.Basic.html#8225" class="Function Operator">*</a> <a id="8251" href="Veblen.Basic.html#8251" class="Bound">β</a> <a id="8253" class="Symbol">=</a> <a id="8255" class="Symbol">((</a><a id="8257" href="Veblen.Basic.html#8156" class="Function Operator">_+</a> <a id="8260" href="Veblen.Basic.html#8247" class="Bound">α</a><a id="8261" class="Symbol">)</a> <a id="8263" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8266" href="Veblen.Basic.html#8251" class="Bound">β</a><a id="8267" class="Symbol">)</a> <a id="8269" class="Number">0</a>
</pre>
<pre class="Agda"><a id="8284" class="Keyword">infix</a> <a id="8290" class="Number">8</a> <a id="8292" href="Veblen.Basic.html#8296" class="Function Operator">_^_</a>
<a id="_^_"></a><a id="8296" href="Veblen.Basic.html#8296" class="Function Operator">_^_</a> <a id="8300" class="Symbol">:</a> <a id="8302" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8306" class="Symbol">→</a> <a id="8308" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8312" class="Symbol">→</a> <a id="8314" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8318" href="Veblen.Basic.html#8318" class="Bound">α</a> <a id="8320" href="Veblen.Basic.html#8296" class="Function Operator">^</a> <a id="8322" href="Veblen.Basic.html#8322" class="Bound">β</a> <a id="8324" class="Symbol">=</a> <a id="8326" class="Symbol">((</a><a id="8328" href="Veblen.Basic.html#8225" class="Function Operator">_*</a> <a id="8331" href="Veblen.Basic.html#8318" class="Bound">α</a><a id="8332" class="Symbol">)</a> <a id="8334" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8337" href="Veblen.Basic.html#8322" class="Bound">β</a><a id="8338" class="Symbol">)</a> <a id="8340" class="Number">1</a>
</pre>
<pre class="Agda"><a id="_+ω^_"></a><a id="8355" href="Veblen.Basic.html#8355" class="Function Operator">_+ω^_</a> <a id="8361" class="Symbol">:</a> <a id="8363" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8367" class="Symbol">→</a> <a id="8369" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8373" class="Symbol">→</a> <a id="8375" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8379" href="Veblen.Basic.html#8379" class="Bound">α</a> <a id="8381" href="Veblen.Basic.html#8355" class="Function Operator">+ω^</a> <a id="8385" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a> <a id="8390" class="Symbol">=</a> <a id="8392" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8396" href="Veblen.Basic.html#8379" class="Bound">α</a>
<a id="8398" href="Veblen.Basic.html#8398" class="Bound">α</a> <a id="8400" href="Veblen.Basic.html#8355" class="Function Operator">+ω^</a> <a id="8404" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8408" href="Veblen.Basic.html#8408" class="Bound">β</a> <a id="8410" class="Symbol">=</a> <a id="8412" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="8418" class="Symbol">(</a><a id="8419" href="Veblen.Basic.html#8355" class="Function Operator">_+ω^</a> <a id="8424" href="Veblen.Basic.html#8408" class="Bound">β</a><a id="8425" class="Symbol">)</a> <a id="8427" href="Veblen.Basic.html#8398" class="Bound">α</a>
<a id="8429" href="Veblen.Basic.html#8429" class="Bound">α</a> <a id="8431" href="Veblen.Basic.html#8355" class="Function Operator">+ω^</a> <a id="8435" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8439" href="Veblen.Basic.html#8439" class="Bound">f</a> <a id="8441" class="Symbol">=</a> <a id="8443" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8447" class="Symbol">λ</a> <a id="8449" href="Veblen.Basic.html#8449" class="Bound">n</a> <a id="8451" class="Symbol">→</a> <a id="8453" href="Veblen.Basic.html#8429" class="Bound">α</a> <a id="8455" href="Veblen.Basic.html#8355" class="Function Operator">+ω^</a> <a id="8459" href="Veblen.Basic.html#8439" class="Bound">f</a> <a id="8461" href="Veblen.Basic.html#8449" class="Bound">n</a>
</pre>
<h2 id="跳出运算">跳出运算</h2>
<p>复合了后继的迭代.</p>
<pre class="Agda"><a id="jump"></a><a id="8496" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8501" class="Symbol">:</a> <a id="8503" class="Symbol">(</a><a id="8504" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8508" class="Symbol">→</a> <a id="8510" href="Veblen.Basic.html#2776" class="Datatype">Ord</a><a id="8513" class="Symbol">)</a> <a id="8515" class="Symbol">→</a> <a id="8517" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8521" class="Symbol">→</a> <a id="8523" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="8527" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8532" href="Veblen.Basic.html#8532" class="Bound">F</a> <a id="8534" href="Veblen.Basic.html#8534" class="Bound">α</a> <a id="8536" class="Symbol">=</a> <a id="8538" class="Symbol">((</a><a id="8540" href="Veblen.Basic.html#8532" class="Bound">F</a> <a id="8542" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="8544" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a><a id="8547" class="Symbol">)</a> <a id="8549" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8552" href="Veblen.Basic.html#8534" class="Bound">α</a><a id="8553" class="Symbol">)</a> <a id="8555" class="Symbol">(</a><a id="8556" href="Veblen.Basic.html#8532" class="Bound">F</a> <a id="8558" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a><a id="8562" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="jump-0"></a><a id="8577" href="Veblen.Basic.html#8577" class="Function">jump-0</a> <a id="8584" class="Symbol">:</a> <a id="8586" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8591" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8593" class="Number">0</a> <a id="8595" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8597" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8599" class="Number">0</a>
<a id="8601" href="Veblen.Basic.html#8577" class="Function">jump-0</a> <a id="8608" class="Symbol">=</a> <a id="8610" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="jump-suc"></a><a id="8628" href="Veblen.Basic.html#8628" class="Function">jump-suc</a> <a id="8637" class="Symbol">:</a> <a id="8639" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8644" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8646" class="Symbol">(</a><a id="8647" class="InductiveConstructor">suc</a> <a id="8651" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="8652" class="Symbol">)</a> <a id="8654" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8656" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8658" class="Symbol">(</a><a id="8659" class="InductiveConstructor">suc</a> <a id="8663" class="Symbol">(</a><a id="8664" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8669" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8671" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="8672" class="Symbol">))</a>
<a id="8675" href="Veblen.Basic.html#8628" class="Function">jump-suc</a> <a id="8684" class="Symbol">{</a><a id="8685" href="Veblen.Basic.html#8685" class="Bound">F</a><a id="8686" class="Symbol">}</a> <a id="8688" class="Symbol">{</a><a id="8689" href="Veblen.Basic.html#8689" class="Bound">α</a><a id="8690" class="Symbol">}</a> <a id="8692" class="Symbol">=</a> <a id="8694" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="8702" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8707" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8709" class="Symbol">(</a><a id="8710" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8714" href="Veblen.Basic.html#8689" class="Bound">α</a><a id="8715" class="Symbol">)</a>                        <a id="8740" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="8746" class="Symbol">((</a><a id="8748" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8750" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="8752" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a><a id="8755" class="Symbol">)</a> <a id="8757" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8760" class="Symbol">(</a><a id="8761" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8765" href="Veblen.Basic.html#8689" class="Bound">α</a><a id="8766" class="Symbol">))</a> <a id="8769" class="Symbol">(</a><a id="8770" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8772" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a><a id="8776" class="Symbol">)</a>       <a id="8784" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="8790" class="Symbol">(</a><a id="8791" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8793" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="8795" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a><a id="8798" class="Symbol">)</a> <a id="8800" class="Symbol">(((</a><a id="8803" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8805" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="8807" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a><a id="8810" class="Symbol">)</a> <a id="8812" href="Veblen.Basic.html#7738" class="Function Operator">∘^</a> <a id="8815" href="Veblen.Basic.html#8689" class="Bound">α</a><a id="8816" class="Symbol">)</a> <a id="8818" class="Symbol">(</a><a id="8819" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8821" href="Veblen.Basic.html#2794" class="InductiveConstructor">zero</a><a id="8825" class="Symbol">))</a> <a id="8828" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="8834" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8836" class="Symbol">(</a><a id="8837" href="Veblen.Basic.html#2807" class="InductiveConstructor">suc</a> <a id="8841" class="Symbol">(</a><a id="8842" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8847" href="Veblen.Basic.html#8685" class="Bound">F</a> <a id="8849" href="Veblen.Basic.html#8689" class="Bound">α</a><a id="8850" class="Symbol">))</a>                    <a id="8872" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>
</pre>
<pre class="Agda"><a id="jump-lim"></a><a id="8887" href="Veblen.Basic.html#8887" class="Function">jump-lim</a> <a id="8896" class="Symbol">:</a> <a id="8898" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8903" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8905" class="Symbol">(</a><a id="8906" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8910" href="Veblen.Basic.html#7842" class="Generalizable">f</a><a id="8911" class="Symbol">)</a> <a id="8913" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8915" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="8919" class="Symbol">λ</a> <a id="8921" href="Veblen.Basic.html#8921" class="Bound">n</a> <a id="8923" class="Symbol">→</a> <a id="8925" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="8930" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="8932" class="Symbol">(</a><a id="8933" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="8935" href="Veblen.Basic.html#8921" class="Bound">n</a><a id="8936" class="Symbol">)</a>
<a id="8938" href="Veblen.Basic.html#8887" class="Function">jump-lim</a> <a id="8947" class="Symbol">=</a> <a id="8949" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="不动点的枚举">不动点的枚举</h2>
<pre class="Agda"><a id="fixpt"></a><a id="8978" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="8984" class="Symbol">:</a> <a id="8986" class="Symbol">(</a><a id="8987" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="8991" class="Symbol">→</a> <a id="8993" href="Veblen.Basic.html#2776" class="Datatype">Ord</a><a id="8996" class="Symbol">)</a> <a id="8998" class="Symbol">→</a> <a id="9000" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="9004" class="Symbol">→</a> <a id="9006" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="9010" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9016" href="Veblen.Basic.html#9016" class="Bound">F</a> <a id="9018" class="Symbol">=</a> <a id="9020" href="Veblen.Basic.html#8496" class="Function">jump</a> <a id="9025" class="Symbol">(</a><a id="9026" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="9032" href="Veblen.Basic.html#9016" class="Bound">F</a><a id="9033" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="fixpt-0"></a><a id="9048" href="Veblen.Basic.html#9048" class="Function">fixpt-0</a> <a id="9056" class="Symbol">:</a> <a id="9058" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9064" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9066" class="Number">0</a> <a id="9068" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9070" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="9076" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9078" class="Number">0</a>
<a id="9080" href="Veblen.Basic.html#9048" class="Function">fixpt-0</a> <a id="9088" class="Symbol">=</a> <a id="9090" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="fixpt-suc"></a><a id="9108" href="Veblen.Basic.html#9108" class="Function">fixpt-suc</a> <a id="9118" class="Symbol">:</a> <a id="9120" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9126" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9128" class="Symbol">(</a><a id="9129" class="InductiveConstructor">suc</a> <a id="9133" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="9134" class="Symbol">)</a> <a id="9136" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9138" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="9144" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9146" class="Symbol">(</a><a id="9147" class="InductiveConstructor">suc</a> <a id="9151" class="Symbol">(</a><a id="9152" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9158" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9160" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="9161" class="Symbol">))</a>
<a id="9164" href="Veblen.Basic.html#9108" class="Function">fixpt-suc</a> <a id="9174" class="Symbol">{</a><a id="9175" href="Veblen.Basic.html#9175" class="Bound">F</a><a id="9176" class="Symbol">}</a> <a id="9178" class="Symbol">{</a><a id="9179" href="Veblen.Basic.html#9179" class="Bound">α</a><a id="9180" class="Symbol">}</a> <a id="9182" class="Symbol">=</a> <a id="9184" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="fixpt-lim"></a><a id="9202" href="Veblen.Basic.html#9202" class="Function">fixpt-lim</a> <a id="9212" class="Symbol">:</a> <a id="9214" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9220" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9222" class="Symbol">(</a><a id="9223" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="9227" href="Veblen.Basic.html#7842" class="Generalizable">f</a><a id="9228" class="Symbol">)</a> <a id="9230" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9232" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="9236" class="Symbol">λ</a> <a id="9238" href="Veblen.Basic.html#9238" class="Bound">n</a> <a id="9240" class="Symbol">→</a> <a id="9242" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9248" href="Veblen.Basic.html#7826" class="Generalizable">F</a> <a id="9250" class="Symbol">(</a><a id="9251" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="9253" href="Veblen.Basic.html#9238" class="Bound">n</a><a id="9254" class="Symbol">)</a>
<a id="9256" href="Veblen.Basic.html#9202" class="Function">fixpt-lim</a> <a id="9266" class="Symbol">=</a> <a id="9268" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="ε-ζ-η-层级">ε， ζ， η 层级</h2>
<pre class="Agda"><a id="ε"></a><a id="9301" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9303" class="Symbol">:</a> <a id="9305" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="9309" class="Symbol">→</a> <a id="9311" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="9315" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9317" class="Symbol">=</a> <a id="9319" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9325" class="Symbol">(</a><a id="9326" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="9328" href="Veblen.Basic.html#8296" class="Function Operator">^_</a><a id="9330" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="ε-0"></a><a id="9345" href="Veblen.Basic.html#9345" class="Function">ε-0</a> <a id="9349" class="Symbol">:</a> <a id="9351" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9353" class="Number">0</a> <a id="9355" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9357" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="9363" class="Symbol">(</a><a id="9364" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="9366" href="Veblen.Basic.html#8296" class="Function Operator">^_</a><a id="9368" class="Symbol">)</a> <a id="9370" class="Number">0</a>
<a id="9372" href="Veblen.Basic.html#9345" class="Function">ε-0</a> <a id="9376" class="Symbol">=</a> <a id="9378" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="ε-suc"></a><a id="9396" href="Veblen.Basic.html#9396" class="Function">ε-suc</a> <a id="9402" class="Symbol">:</a> <a id="9404" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9406" class="Symbol">(</a><a id="9407" class="InductiveConstructor">suc</a> <a id="9411" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="9412" class="Symbol">)</a> <a id="9414" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9416" href="Veblen.Basic.html#8066" class="Function">iterω</a> <a id="9422" class="Symbol">(</a><a id="9423" href="Veblen.Basic.html#4027" class="Function">ω</a> <a id="9425" href="Veblen.Basic.html#8296" class="Function Operator">^_</a><a id="9427" class="Symbol">)</a> <a id="9429" class="Symbol">(</a><a id="9430" class="InductiveConstructor">suc</a> <a id="9434" class="Symbol">(</a><a id="9435" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9437" href="Veblen.Basic.html#3610" class="Generalizable">α</a><a id="9438" class="Symbol">))</a>
<a id="9441" href="Veblen.Basic.html#9396" class="Function">ε-suc</a> <a id="9447" class="Symbol">=</a> <a id="9449" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="ε-lim"></a><a id="9467" href="Veblen.Basic.html#9467" class="Function">ε-lim</a> <a id="9473" class="Symbol">:</a> <a id="9475" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9477" class="Symbol">(</a><a id="9478" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="9482" href="Veblen.Basic.html#7842" class="Generalizable">f</a><a id="9483" class="Symbol">)</a> <a id="9485" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9487" href="Veblen.Basic.html#2826" class="InductiveConstructor">lim</a> <a id="9491" class="Symbol">λ</a> <a id="9493" href="Veblen.Basic.html#9493" class="Bound">n</a> <a id="9495" class="Symbol">→</a> <a id="9497" href="Veblen.Basic.html#9301" class="Function">ε</a> <a id="9499" class="Symbol">(</a><a id="9500" href="Veblen.Basic.html#7842" class="Generalizable">f</a> <a id="9502" href="Veblen.Basic.html#9493" class="Bound">n</a><a id="9503" class="Symbol">)</a>
<a id="9505" href="Veblen.Basic.html#9467" class="Function">ε-lim</a> <a id="9511" class="Symbol">=</a> <a id="9513" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="ζ"></a><a id="9531" href="Veblen.Basic.html#9531" class="Function">ζ</a> <a id="9533" class="Symbol">:</a> <a id="9535" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="9539" class="Symbol">→</a> <a id="9541" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="9545" href="Veblen.Basic.html#9531" class="Function">ζ</a> <a id="9547" class="Symbol">=</a> <a id="9549" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9555" href="Veblen.Basic.html#9301" class="Function">ε</a>
</pre>
<pre class="Agda"><a id="η"></a><a id="9570" href="Veblen.Basic.html#9570" class="Function">η</a> <a id="9572" class="Symbol">:</a> <a id="9574" href="Veblen.Basic.html#2776" class="Datatype">Ord</a> <a id="9578" class="Symbol">→</a> <a id="9580" href="Veblen.Basic.html#2776" class="Datatype">Ord</a>
<a id="9584" href="Veblen.Basic.html#9570" class="Function">η</a> <a id="9586" class="Symbol">=</a> <a id="9588" href="Veblen.Basic.html#8978" class="Function">fixpt</a> <a id="9594" href="Veblen.Basic.html#9531" class="Function">ζ</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
