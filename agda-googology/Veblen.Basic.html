<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.1 - 序数, FGH, 不动点)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.1---序数-fgh-不动点" id="toc-形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#目标人群" id="toc-目标人群">目标人群</a></li>
  <li><a href="#补充材料" id="toc-补充材料">补充材料</a></li>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a></li>
  <li><a href="#快速增长层级" id="toc-快速增长层级">快速增长层级</a></li>
  <li><a href="#序数的递归原理" id="toc-序数的递归原理">序数的递归原理</a></li>
  <li><a href="#超限复合" id="toc-超限复合">超限复合</a></li>
  <li><a href="#序数算术" id="toc-序数算术">序数算术</a></li>
  <li><a href="#三大高阶函数" id="toc-三大高阶函数">三大高阶函数</a>
  <ul>
  <li><a href="#无穷迭代" id="toc-无穷迭代">无穷迭代</a></li>
  <li><a href="#跳出运算" id="toc-跳出运算">跳出运算</a></li>
  <li><a href="#不动点的枚举" id="toc-不动点的枚举">不动点的枚举</a></li>
  </ul></li>
  <li><a href="#ε-ζ-η-层级" id="toc-ε-ζ-η-层级">ε， ζ， η 层级</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Veblen/Basic.lagda.md">Basic.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Veblen.Basic.html">Basic.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是可运行且保证停机的<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0_(%E6%95%B0%E5%AD%A6)">大数</a>计算程序的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文学编程 (literate programming)</a> 实现.</p>
<ul>
<li><strong>可运行</strong>是相对于自然语言的数学描述而言, 本文贴出的代码可以在电脑上运行.</li>
<li><strong>保证停机</strong>是相对于<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备 (Turing-complete)</a> 语言 (如C语言) 而言, 本文使用的 <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a> 语言并非图灵完备, 其自带<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/termination-checking.html">停机检查 (termination checking)</a>, 写出的程序保证停机.</li>
<li><strong>文学编程</strong>是指本文既是程序代码, 也是程序文档, 代码和文档交织在一起, 以增强可读性.
<ul>
<li>Agda 程序会自动抽取本文所有代码块中的代码, 并执行类型检查, 而忽略代码块以外的内容.</li>
<li>※ 冷知识: 文学编程的发明者<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳 (Donald Knuth)</a>, 也是大数数学入门级内容<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%B4%8D%E7%AE%AD%E8%99%9F%E8%A1%A8%E7%A4%BA%E6%B3%95">高德纳箭号</a>的发明者, 也是排版软件 <a href="https://zh.wikipedia.org/wiki/TeX">TeX</a> 的发明者.</li>
</ul></li>
</ul>
<p>也就是说, 提供足够的时间, 能量和内存, 本文介绍的大数计算程序可以真正算出一个大数. 如果真的想运行: 1. 参考 <a href="https://agda.readthedocs.io/en/latest/getting-started/installation.html">Installation</a> 安装 Agda. 2. 进本文所在Github仓库 (<a href="https://github.com/choukh/agda-googology">agda-googology</a>) 下载本文 markdown 源码. 3. 用编辑器打开源码, 确认进入了 <a href="https://agda.readthedocs.io/en/latest/tools/emacs-mode.html">agda-mode</a>, <code>C-c C-n</code> 对 <code>oom</code> 执行正规化.</p>
<h3 id="目标人群">目标人群</h3>
<ul>
<li>大数数学已入门 (如, 看完<a href="https://www.zhihu.com/column/c_1307845959598960640">大数数学入门</a>), 对严格性有进一步要求的读者.</li>
<li>Agda 已入门 (如, 看完 <a href="https://agda-zh.github.io/PLFA-zh/">PLFA</a>), 对大数计算程序的编程实现感兴趣的读者.</li>
</ul>
<p>只对前者感兴趣的读者, 可以忽略代码部分, 而只阅读文学部分, 它们可以看作是基于朴素类型论的数学描述, 并使用了 <span class="math inline">\LaTeX</span> 公式, 以对齐通常的数学习惯.</p>
<h3 id="补充材料">补充材料</h3>
<ul>
<li><a href="https://www.zhihu.com/column/c_1307845959598960640">core.exe - 大数数学入门</a></li>
<li><a href="https://www.zhihu.com/column/c_1697290814588301312">core.exe - 大数数学入门 - 重置版</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">oCaU - Agda大序数</a>
<ul>
<li>该文详细讨论了上至二元Veblen层级的序性质, 而本文不会讨论这些性质.</li>
</ul></li>
<li><a href="https://github.com/choukh/Googology">oCaU - LVO 的 Coq 实现</a>
<ul>
<li>纯代码, 无文学</li>
</ul></li>
</ul>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="2284" class="Keyword">module</a> <a id="2291" href="Veblen.Basic.html" class="Module">Veblen.Basic</a> <a id="2304" class="Keyword">where</a>

<a id="2311" class="Keyword">open</a> <a id="2316" class="Keyword">import</a> <a id="2323" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2332" class="Keyword">public</a> <a id="2339" class="Keyword">using</a> <a id="2345" class="Symbol">(</a><a id="2346" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2347" class="Symbol">;</a> <a id="2349" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2353" class="Symbol">;</a> <a id="2355" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2358" class="Symbol">;</a> <a id="2360" href="Data.Nat.Base.html#1095" class="InductiveConstructor">2+</a><a id="2362" class="Symbol">)</a>
<a id="2364" class="Keyword">open</a> <a id="2369" class="Keyword">import</a> <a id="2376" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="2386" class="Keyword">public</a> <a id="2393" class="Keyword">using</a> <a id="2399" class="Symbol">(</a><a id="2400" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2401" class="Symbol">)</a>
<a id="2403" class="Keyword">open</a> <a id="2408" class="Keyword">import</a> <a id="2415" href="Function.html" class="Module">Function</a> <a id="2424" class="Keyword">public</a> <a id="2431" class="Keyword">using</a> <a id="2437" class="Symbol">(</a><a id="2438" href="Function.Base.html#704" class="Function">id</a><a id="2440" class="Symbol">;</a> <a id="2442" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="2445" class="Symbol">;</a> <a id="2447" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="2450" class="Symbol">;</a> <a id="2452" href="Function.Base.html#4486" class="Function Operator">_∋_</a><a id="2455" class="Symbol">)</a>
<a id="2457" class="Keyword">open</a> <a id="2462" class="Keyword">import</a> <a id="2469" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2507" class="Symbol">as</a> <a id="2510" class="Module">Eq</a> <a id="2513" class="Keyword">public</a> <a id="2520" class="Keyword">using</a> <a id="2526" class="Symbol">(</a><a id="2527" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2530" class="Symbol">;</a> <a id="2532" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2536" class="Symbol">;</a> <a id="2538" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a><a id="2542" class="Symbol">)</a>
<a id="2544" class="Keyword">open</a> <a id="2549" href="Relation.Binary.PropositionalEquality.Properties.html#6744" class="Module">Eq.≡-Reasoning</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<p>我们知道自然数类型 <span class="math inline">ℕ</span> 由如下两条规则定义.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : ℕ\kern{0.17em}}
\qquad
\frac{\alpha:ℕ}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:ℕ\kern{0.17em}}
</span></p>
<p><strong>定义</strong> 我们的序数类型 <span class="math inline">\text{Ord}</span> 在 <span class="math inline">ℕ</span> 的基础上增加了第三条规则 <span class="math inline">\text{lim}</span>, 即如果 <span class="math inline">f</span> 是 <span class="math inline">ℕ</span> 到序数的函数, 那么 <span class="math inline">\text{lim}\kern{0.17em}f</span> 也是序数.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : \text{Ord}\kern{0.17em}}
\qquad
\frac{\alpha:\text{Ord}}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:\text{Ord}\kern{0.17em}}
\qquad
\frac{\kern{0.17em}f : ℕ\rightarrow\text{Ord}\kern{0.17em}}{\text{lim}\kern{0.17em}f:\text{Ord}}
</span></p>
<pre class="Agda"><a id="3144" class="Keyword">data</a> <a id="Ord"></a><a id="3149" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="3153" class="Symbol">:</a> <a id="3155" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3159" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="3167" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a> <a id="3172" class="Symbol">:</a> <a id="3174" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="3180" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a>  <a id="3185" class="Symbol">:</a> <a id="3187" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="3191" class="Symbol">→</a> <a id="3193" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="3199" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a>  <a id="3204" class="Symbol">:</a> <a id="3206" class="Symbol">(</a><a id="3207" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3209" class="Symbol">→</a> <a id="3211" href="Veblen.Basic.html#3149" class="Datatype">Ord</a><a id="3214" class="Symbol">)</a> <a id="3216" class="Symbol">→</a> <a id="3218" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
</pre>
<p>这样的 <span class="math inline">f : ℕ\rightarrow\text{Ord}</span> 又叫做 <span class="math inline">\text{lim}\kern{0.17em}f</span> 的基本序列 (fundamental sequence), 而 <span class="math inline">\text{lim}\kern{0.17em}f</span> 则叫做基本序列 <span class="math inline">f</span> 的极限. 这样的定义允许我们很方便地讨论零, 后继序数和极限序数三种情况. 为了方便阅读, 我们会把 <span class="math inline">\text{zero}</span> 写作 <span class="math inline">0</span>, 把 <span class="math inline">\text{suc}\kern{0.17em}x</span> 写作 <span class="math inline">x^+</span>.</p>
<p><strong>注意</strong> 我们的序数类型, 学名叫布劳威尔树序数 (Brouwer tree ordinals), 比真正的序数宽泛很多, 体现在以下两点: - 树序数不要求基本序列是严格递增的. - 严格递增的约束对于计算本身而言无关紧要. - 当然, 如果要保证算出的大数足够大, 那么基本序列的递增性是必要的. - 我们构造的序数的基本序列都是严格递增的, 如果想要, 可以额外补上证明. - <a href="https://zhuanlan.zhihu.com/p/572691308">Agda大序数</a>一文中证明了其中构造的上至 <span class="math inline">\Gamma_0</span> 的所有树序数的基本序列都是严格递增的. - 树序数是极其外延的 (extensional), 即真正的序数与树上的节点并不是唯一对应的. - 这意味着我们可以用大量不同的基本序列构造出相同的序数. - 但同一性证明依赖于函数外延性 (function extensionality), 或某种商 (quotient) 机制, 如 setoid 或 cubical. - 但这并不会影响大数的计算, 因为只要给出基本序列就能算, 况且 FGH 大数的表示确实是依赖于特定基本序列的.</p>
<p><strong>约定</strong> 我们用 <span class="math inline">α,β,γ,δ</span> 表示序数, 用 <span class="math inline">m,n</span> 表示自然数.</p>
<pre class="Agda"><a id="4052" class="Keyword">variable</a>
  <a id="4063" href="Veblen.Basic.html#4063" class="Generalizable">α</a> <a id="4065" href="Veblen.Basic.html#4065" class="Generalizable">β</a> <a id="4067" href="Veblen.Basic.html#4067" class="Generalizable">γ</a> <a id="4069" href="Veblen.Basic.html#4069" class="Generalizable">δ</a> <a id="4071" class="Symbol">:</a> <a id="4073" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
  <a id="4079" href="Veblen.Basic.html#4079" class="Generalizable">m</a> <a id="4081" href="Veblen.Basic.html#4081" class="Generalizable">n</a> <a id="4083" class="Symbol">:</a> <a id="4085" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<p><strong>约定</strong> 我们遵循类型论的习惯, 今后都会在无歧义的情况下省略函数应用的括号.</p>
<p><strong>定义</strong> 自然数到序数的嵌入函数 <span class="math inline">\text{finord} : ℕ → \text{Ord}</span> 如下</p>
<p><span class="math display">
\begin{aligned}
\text{finord}\kern{0.17em}0 &amp;= 0 \\
\text{finord}\kern{0.17em}n^+ &amp;= (\text{finord}\kern{0.17em}n)^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="finord"></a><a id="4337" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="4344" class="Symbol">:</a> <a id="4346" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4348" class="Symbol">→</a> <a id="4350" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="4354" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="4361" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="4366" class="Symbol">=</a> <a id="4368" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a>
<a id="4373" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="4380" class="Symbol">(</a><a id="4381" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4385" href="Veblen.Basic.html#4385" class="Bound">n</a><a id="4386" class="Symbol">)</a> <a id="4388" class="Symbol">=</a> <a id="4390" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="4394" class="Symbol">(</a><a id="4395" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="4402" href="Veblen.Basic.html#4385" class="Bound">n</a><a id="4403" class="Symbol">)</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\text{finord}</span> 构成了基本序列 <span class="math inline">(0, 1, 2, \ldots)</span>, 其极限定义为 <span class="math inline">ω</span></p>
<p><span class="math display">
ω := \text{lim}\kern{0.17em}\text{finord}
</span></p>
<pre class="Agda"><a id="ω"></a><a id="4531" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="4533" class="Symbol">=</a> <a id="4535" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="4539" href="Veblen.Basic.html#4337" class="Function">finord</a>
</pre>
<p><strong>非文学</strong> 以下代码调用了<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能, 允许数字字面量依据上下文自动具有自然数或序数类型.</p>
<pre class="Agda"><a id="4690" class="Keyword">open</a> <a id="4695" class="Keyword">import</a> <a id="4702" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a>

<a id="4724" class="Keyword">instance</a>
  <a id="4735" href="Veblen.Basic.html#4735" class="Function">_</a> <a id="4737" class="Symbol">=</a> <a id="4739" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4746" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="4750" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4752" class="Keyword">record</a> <a id="4759" class="Symbol">{</a> <a id="4761" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4772" class="Symbol">=</a> <a id="4774" class="Symbol">λ</a> <a id="4776" href="Veblen.Basic.html#4776" class="Bound">_</a> <a id="4778" class="Symbol">→</a> <a id="4780" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4782" class="Symbol">;</a> <a id="4784" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4792" class="Symbol">=</a> <a id="4794" class="Symbol">λ</a> <a id="4796" href="Veblen.Basic.html#4796" class="Bound">n</a> <a id="4798" class="Symbol">→</a> <a id="4800" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="4807" href="Veblen.Basic.html#4796" class="Bound">n</a> <a id="4809" class="Symbol">}</a>
  <a id="4813" href="Veblen.Basic.html#4813" class="Function">_</a> <a id="4815" class="Symbol">=</a> <a id="4817" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4824" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="4828" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4830" class="Keyword">record</a> <a id="4837" class="Symbol">{</a> <a id="4839" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4850" class="Symbol">=</a> <a id="4852" class="Symbol">λ</a> <a id="4854" href="Veblen.Basic.html#4854" class="Bound">_</a> <a id="4856" class="Symbol">→</a> <a id="4858" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4860" class="Symbol">;</a> <a id="4862" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4870" class="Symbol">=</a> <a id="4872" class="Symbol">λ</a> <a id="4874" href="Veblen.Basic.html#4874" class="Bound">n</a> <a id="4876" class="Symbol">→</a> <a id="4878" href="Veblen.Basic.html#4874" class="Bound">n</a> <a id="4880" class="Symbol">}</a>
</pre>
<p>以下为测试用例.</p>
<pre class="Agda"><a id="4905" href="Veblen.Basic.html#4905" class="Function">_</a> <a id="4907" class="Symbol">=</a> <a id="4909" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="4913" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4915" class="Number">233</a>
<a id="4919" href="Veblen.Basic.html#4919" class="Function">_</a> <a id="4921" class="Symbol">=</a> <a id="4923" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="4927" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4929" class="Number">233</a>
</pre>
<h2 id="快速增长层级">快速增长层级</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">A</span> 表示类型.</p>
<pre class="Agda"><a id="4979" class="Keyword">variable</a> <a id="4988" href="Veblen.Basic.html#4988" class="Generalizable">A</a> <a id="4990" class="Symbol">:</a> <a id="4992" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义</strong> 函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span></p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{n^+} &amp;= F \circ F^n
\end{aligned}
</span></p>
<p>其中 <span class="math inline">\text{id}</span> 是恒等函数.</p>
<pre class="Agda"><a id="_∘ⁿ_"></a><a id="5151" href="Veblen.Basic.html#5151" class="Function Operator">_∘ⁿ_</a> <a id="5156" class="Symbol">:</a> <a id="5158" class="Symbol">(</a><a id="5159" href="Veblen.Basic.html#4988" class="Generalizable">A</a> <a id="5161" class="Symbol">→</a> <a id="5163" href="Veblen.Basic.html#4988" class="Generalizable">A</a><a id="5164" class="Symbol">)</a> <a id="5166" class="Symbol">→</a> <a id="5168" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5170" class="Symbol">→</a> <a id="5172" class="Symbol">(</a><a id="5173" href="Veblen.Basic.html#4988" class="Generalizable">A</a> <a id="5175" class="Symbol">→</a> <a id="5177" href="Veblen.Basic.html#4988" class="Generalizable">A</a><a id="5178" class="Symbol">)</a>
<a id="5180" class="Symbol">(</a><a id="5181" href="Veblen.Basic.html#5181" class="Bound">F</a> <a id="5183" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="5186" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="5190" class="Symbol">)</a>  <a id="5193" class="Symbol">=</a> <a id="5195" href="Function.Base.html#704" class="Function">id</a>
<a id="5198" class="Symbol">(</a><a id="5199" href="Veblen.Basic.html#5199" class="Bound">F</a> <a id="5201" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="5204" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5208" href="Veblen.Basic.html#5208" class="Bound">n</a><a id="5209" class="Symbol">)</a> <a id="5211" class="Symbol">=</a> <a id="5213" class="Symbol">(</a><a id="5214" href="Veblen.Basic.html#5199" class="Bound">F</a> <a id="5216" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5218" class="Symbol">(</a><a id="5219" href="Veblen.Basic.html#5199" class="Bound">F</a> <a id="5221" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="5224" href="Veblen.Basic.html#5208" class="Bound">n</a><a id="5225" class="Symbol">))</a>
</pre>
<p><strong>定义</strong> 快速增长层级 (Fast Growing Hierarchy, FGH) 是一个函数族 <span class="math inline">f : \text{Ord} → ℕ → ℕ</span>, 对于每个序数 <span class="math inline">α</span>, <span class="math inline">f_α</span> 是一个从自然数到自然数的函数, 定义如下.</p>
<p><span class="math display">
\begin{aligned}
f_0\kern{0.17em}n &amp;= n^+ \\
f_{α^+}\kern{0.17em}n &amp;= f_α^n\kern{0.17em}n \\
f_{\text{lim}\kern{0.17em}g}\kern{0.17em}n &amp;= f_{g\kern{0.17em}n}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda"><a id="5552" class="Keyword">module</a> <a id="FGH"></a><a id="5559" href="Veblen.Basic.html#5559" class="Module">FGH</a> <a id="5563" class="Keyword">where</a>
  <a id="FGH.f"></a><a id="5571" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5573" class="Symbol">:</a> <a id="5575" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="5579" class="Symbol">→</a> <a id="5581" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5583" class="Symbol">→</a> <a id="5585" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="5589" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5591" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a> <a id="5596" href="Veblen.Basic.html#5596" class="Bound">n</a> <a id="5598" class="Symbol">=</a> <a id="5600" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5604" href="Veblen.Basic.html#5596" class="Bound">n</a>
  <a id="5608" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5610" class="Symbol">(</a><a id="5611" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="5615" href="Veblen.Basic.html#5615" class="Bound">α</a><a id="5616" class="Symbol">)</a> <a id="5618" href="Veblen.Basic.html#5618" class="Bound">n</a> <a id="5620" class="Symbol">=</a> <a id="5622" class="Symbol">(</a><a id="5623" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5625" href="Veblen.Basic.html#5615" class="Bound">α</a> <a id="5627" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="5630" href="Veblen.Basic.html#5618" class="Bound">n</a><a id="5631" class="Symbol">)</a> <a id="5633" href="Veblen.Basic.html#5618" class="Bound">n</a>
  <a id="5637" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5639" class="Symbol">(</a><a id="5640" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="5644" href="Veblen.Basic.html#5644" class="Bound">g</a><a id="5645" class="Symbol">)</a> <a id="5647" href="Veblen.Basic.html#5647" class="Bound">n</a> <a id="5649" class="Symbol">=</a> <a id="5651" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5653" class="Symbol">(</a><a id="5654" href="Veblen.Basic.html#5644" class="Bound">g</a> <a id="5656" href="Veblen.Basic.html#5647" class="Bound">n</a><a id="5657" class="Symbol">)</a> <a id="5659" href="Veblen.Basic.html#5647" class="Bound">n</a>
</pre>
<p><strong>例</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_0\kern{0.17em}n &amp;= n^+ \\
f_1\kern{0.17em}n &amp;= 2n \\
f_2\kern{0.17em}n &amp;= 2^n\kern{0.17em}n
\end{aligned}
</span></p>
<p>这些等式的证明只需对 <span class="math inline">n</span> 进行归纳, 是显然的. 代码方面我们只写一些实例作为测试.</p>
<pre class="Agda">  <a id="FGH.f-0-2"></a><a id="5864" href="Veblen.Basic.html#5864" class="Function">f-0-2</a> <a id="5870" class="Symbol">:</a> <a id="5872" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5874" class="Number">0</a> <a id="5876" class="Number">2</a> <a id="5878" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5880" class="Number">3</a>
  <a id="5884" href="Veblen.Basic.html#5864" class="Function">f-0-2</a> <a id="5890" class="Symbol">=</a> <a id="5892" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-1-2"></a><a id="5900" href="Veblen.Basic.html#5900" class="Function">f-1-2</a> <a id="5906" class="Symbol">:</a> <a id="5908" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5910" class="Number">1</a> <a id="5912" class="Number">2</a> <a id="5914" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5916" class="Number">4</a>
  <a id="5920" href="Veblen.Basic.html#5900" class="Function">f-1-2</a> <a id="5926" class="Symbol">=</a> <a id="5928" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-2-2"></a><a id="5936" href="Veblen.Basic.html#5936" class="Function">f-2-2</a> <a id="5942" class="Symbol">:</a> <a id="5944" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="5946" class="Number">2</a> <a id="5948" class="Number">2</a> <a id="5950" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5952" class="Number">8</a>
  <a id="5956" href="Veblen.Basic.html#5936" class="Function">f-2-2</a> <a id="5962" class="Symbol">=</a> <a id="5964" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math inline">f_3</span> 以上的表达式越来越复杂, 但不难计算实例如 <span class="math inline">f_{3}\kern{0.17em}2=2048</span>.</p>
<pre class="Agda">  <a id="FGH.f-3-2"></a><a id="6041" href="Veblen.Basic.html#6041" class="Function">f-3-2</a> <a id="6047" class="Symbol">:</a> <a id="6049" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6051" class="Number">3</a> <a id="6053" class="Number">2</a> <a id="6055" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6057" class="Number">2048</a>
  <a id="6064" href="Veblen.Basic.html#6041" class="Function">f-3-2</a> <a id="6070" class="Symbol">=</a> <a id="6072" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>引理</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_{\alpha^+}\kern{0.17em}n &amp;= f_\alpha^n\kern{0.17em}n \\
f_{ω}\kern{0.17em}n &amp;= f_{n}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda">  <a id="FGH.f-suc"></a><a id="6242" href="Veblen.Basic.html#6242" class="Function">f-suc</a> <a id="6248" class="Symbol">:</a> <a id="6250" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6252" class="Symbol">(</a><a id="6253" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="6257" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="6258" class="Symbol">)</a> <a id="6260" href="Veblen.Basic.html#4081" class="Generalizable">n</a> <a id="6262" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6264" class="Symbol">(</a><a id="6265" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6267" href="Veblen.Basic.html#4063" class="Generalizable">α</a> <a id="6269" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="6272" href="Veblen.Basic.html#4081" class="Generalizable">n</a><a id="6273" class="Symbol">)</a> <a id="6275" href="Veblen.Basic.html#4081" class="Generalizable">n</a>
  <a id="6279" href="Veblen.Basic.html#6242" class="Function">f-suc</a> <a id="6285" class="Symbol">=</a> <a id="6287" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-ω"></a><a id="6295" href="Veblen.Basic.html#6295" class="Function">f-ω</a> <a id="6299" class="Symbol">:</a> <a id="6301" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6303" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="6305" href="Veblen.Basic.html#4081" class="Generalizable">n</a> <a id="6307" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6309" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6311" class="Symbol">(</a><a id="6312" href="Veblen.Basic.html#4337" class="Function">finord</a> <a id="6319" href="Veblen.Basic.html#4081" class="Generalizable">n</a><a id="6320" class="Symbol">)</a> <a id="6322" href="Veblen.Basic.html#4081" class="Generalizable">n</a>
  <a id="6326" href="Veblen.Basic.html#6295" class="Function">f-ω</a> <a id="6330" class="Symbol">=</a> <a id="6332" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 本文出现的大部分命题的证明都是「依定义即得」的, 体现为代码中的 <code>refl</code>. 也就是说, 证明都是直接展开定义, 不需要额外的推理. 但这并不意味着所有证明是显然的, 有时候递归定义的展开会非常复杂, 这时候我们会分布展开, 逐步化简, 但每一步都是 <code>refl</code> 可证.</p>
<p><strong>定理</strong> 由以上两式不难看出</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}n = f_ω^n\kern{0.17em}n
</span></p>
<pre class="Agda">  <a id="FGH.f-ω⁺"></a><a id="6568" href="Veblen.Basic.html#6568" class="Function">f-ω⁺</a> <a id="6573" class="Symbol">:</a> <a id="6575" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6577" class="Symbol">(</a><a id="6578" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="6582" href="Veblen.Basic.html#4531" class="Function">ω</a><a id="6583" class="Symbol">)</a> <a id="6585" href="Veblen.Basic.html#4081" class="Generalizable">n</a> <a id="6587" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6589" class="Symbol">(</a><a id="6590" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6592" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="6594" href="Veblen.Basic.html#5151" class="Function Operator">∘ⁿ</a> <a id="6597" href="Veblen.Basic.html#4081" class="Generalizable">n</a><a id="6598" class="Symbol">)</a> <a id="6600" href="Veblen.Basic.html#4081" class="Generalizable">n</a>
  <a id="6604" href="Veblen.Basic.html#6568" class="Function">f-ω⁺</a> <a id="6609" class="Symbol">=</a> <a id="6611" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>推论</strong> 特别地, 有</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}2 = f_ω\kern{0.17em}(f_ω\kern{0.17em}2)
</span></p>
<p>但此式无法在 Agda 中直接证明, 因为 Agda 想先把两边都算出, 而这是不现实的. 如果有读者知道如何证明, 请打在评论区. 作为替代, 我们可以证明如下式子.</p>
<p><span class="math display">
f_{\alpha^+}\kern{0.17em}2 = f_\alpha\kern{0.17em}(f_\alpha\kern{0.17em}2)
</span></p>
<pre class="Agda">  <a id="FGH.f-suc-2"></a><a id="6881" href="Veblen.Basic.html#6881" class="Function">f-suc-2</a> <a id="6889" class="Symbol">:</a> <a id="6891" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6893" class="Symbol">(</a><a id="6894" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="6898" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="6899" class="Symbol">)</a> <a id="6901" class="Number">2</a> <a id="6903" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6905" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6907" href="Veblen.Basic.html#4063" class="Generalizable">α</a> <a id="6909" class="Symbol">(</a><a id="6910" href="Veblen.Basic.html#5571" class="Function">f</a> <a id="6912" href="Veblen.Basic.html#4063" class="Generalizable">α</a> <a id="6914" class="Number">2</a><a id="6915" class="Symbol">)</a>
  <a id="6919" href="Veblen.Basic.html#6881" class="Function">f-suc-2</a> <a id="6927" class="Symbol">=</a> <a id="6929" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实</strong> <span class="math inline">f_{ω^+} 64</span> 已经大于葛立恒数.</p>
<blockquote>
<p>从这里开始, 研究大数的数学就转变成了研究快速增长函数的数学, 进而转变成研究大的序数的数学.</p>
</blockquote>
<h2 id="序数的递归原理">序数的递归原理</h2>
<p>为了系统性的构造大序数, 我们先证明序数归纳法, 并由此得到序数的递归原理.</p>
<p><strong>定理 序数归纳法 (transfinite induction)</strong> 对于任意性质 <span class="math inline">P : \text{Ord} → \text{Set}</span>, 如果 1. <span class="math inline">P\kern{0.17em}0</span> 成立, 2. 对于任意序数 <span class="math inline">α</span>, 如果 <span class="math inline">P\kern{0.17em}α</span> 成立, 则 <span class="math inline">P\kern{0.17em}α^+</span> 成立, 3. 对于任意基本序列 <span class="math inline">f</span>, 如果对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立, 则 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立,</p>
<p>则对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立.</p>
<pre class="Agda"><a id="ind"></a><a id="7406" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="7410" class="Symbol">:</a> <a id="7412" class="Symbol">{</a><a id="7413" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7415" class="Symbol">:</a> <a id="7417" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="7421" class="Symbol">→</a> <a id="7423" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="7426" class="Symbol">}</a>
  <a id="7430" class="Symbol">→</a> <a id="7432" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7434" class="InductiveConstructor">zero</a>
  <a id="7441" class="Symbol">→</a> <a id="7443" class="Symbol">(∀</a> <a id="7446" href="Veblen.Basic.html#7446" class="Bound">α</a> <a id="7448" class="Symbol">→</a> <a id="7450" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7452" href="Veblen.Basic.html#7446" class="Bound">α</a> <a id="7454" class="Symbol">→</a> <a id="7456" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7458" class="Symbol">(</a><a id="7459" class="InductiveConstructor">suc</a> <a id="7463" href="Veblen.Basic.html#7446" class="Bound">α</a><a id="7464" class="Symbol">))</a>
  <a id="7469" class="Symbol">→</a> <a id="7471" class="Symbol">(∀</a> <a id="7474" href="Veblen.Basic.html#7474" class="Bound">f</a> <a id="7476" class="Symbol">→</a> <a id="7478" class="Symbol">(∀</a> <a id="7481" href="Veblen.Basic.html#7481" class="Bound">n</a> <a id="7483" class="Symbol">→</a> <a id="7485" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7487" class="Symbol">(</a><a id="7488" href="Veblen.Basic.html#7474" class="Bound">f</a> <a id="7490" href="Veblen.Basic.html#7481" class="Bound">n</a><a id="7491" class="Symbol">))</a> <a id="7494" class="Symbol">→</a> <a id="7496" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7498" class="Symbol">(</a><a id="7499" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="7503" href="Veblen.Basic.html#7474" class="Bound">f</a><a id="7504" class="Symbol">))</a>
  <a id="7509" class="Symbol">→</a> <a id="7511" class="Symbol">∀</a> <a id="7513" href="Veblen.Basic.html#7513" class="Bound">α</a> <a id="7515" class="Symbol">→</a> <a id="7517" href="Veblen.Basic.html#7413" class="Bound">P</a> <a id="7519" href="Veblen.Basic.html#7513" class="Bound">α</a>
</pre>
<p><strong>(证明)</strong> 要证对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立. 归纳 <span class="math inline">α</span> 的三种情况.</p>
<ul>
<li>当 <span class="math inline">α=0</span> 时, 由条件1, <span class="math inline">P\kern{0.17em}0</span> 成立.</li>
<li>当 <span class="math inline">α=α^+</span> 时, 要证 <span class="math inline">P\,α^+</span> 成立. 由归纳假设, <span class="math inline">P\kern{0.17em}α</span> 成立. 由条件2, <span class="math inline">P\kern{0.17em}α^+</span> 成立.</li>
<li>当 <span class="math inline">α=\text{lim}\kern{0.17em}f</span> 时, 要证 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. 由归纳假设, 对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立. 由条件3, <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. ∎</li>
</ul>
<pre class="Agda"><a id="7925" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="7929" href="Veblen.Basic.html#7929" class="Bound">z</a> <a id="7931" href="Veblen.Basic.html#7931" class="Bound">s</a> <a id="7933" href="Veblen.Basic.html#7933" class="Bound">l</a> <a id="7935" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a> <a id="7940" class="Symbol">=</a> <a id="7942" href="Veblen.Basic.html#7929" class="Bound">z</a>
<a id="7944" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="7948" href="Veblen.Basic.html#7948" class="Bound">z</a> <a id="7950" href="Veblen.Basic.html#7950" class="Bound">s</a> <a id="7952" href="Veblen.Basic.html#7952" class="Bound">l</a> <a id="7954" class="Symbol">(</a><a id="7955" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="7959" href="Veblen.Basic.html#7959" class="Bound">α</a><a id="7960" class="Symbol">)</a> <a id="7962" class="Symbol">=</a> <a id="7964" href="Veblen.Basic.html#7950" class="Bound">s</a> <a id="7966" href="Veblen.Basic.html#7959" class="Bound">α</a> <a id="7968" class="Symbol">(</a><a id="7969" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="7973" href="Veblen.Basic.html#7948" class="Bound">z</a> <a id="7975" href="Veblen.Basic.html#7950" class="Bound">s</a> <a id="7977" href="Veblen.Basic.html#7952" class="Bound">l</a> <a id="7979" href="Veblen.Basic.html#7959" class="Bound">α</a><a id="7980" class="Symbol">)</a>
<a id="7982" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="7986" href="Veblen.Basic.html#7986" class="Bound">z</a> <a id="7988" href="Veblen.Basic.html#7988" class="Bound">s</a> <a id="7990" href="Veblen.Basic.html#7990" class="Bound">l</a> <a id="7992" class="Symbol">(</a><a id="7993" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="7997" href="Veblen.Basic.html#7997" class="Bound">f</a><a id="7998" class="Symbol">)</a> <a id="8000" class="Symbol">=</a> <a id="8002" href="Veblen.Basic.html#7990" class="Bound">l</a> <a id="8004" href="Veblen.Basic.html#7997" class="Bound">f</a> <a id="8006" class="Symbol">λ</a> <a id="8008" href="Veblen.Basic.html#8008" class="Bound">n</a> <a id="8010" class="Symbol">→</a> <a id="8012" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="8016" href="Veblen.Basic.html#7986" class="Bound">z</a> <a id="8018" href="Veblen.Basic.html#7988" class="Bound">s</a> <a id="8020" href="Veblen.Basic.html#7990" class="Bound">l</a> <a id="8022" class="Symbol">(</a><a id="8023" href="Veblen.Basic.html#7997" class="Bound">f</a> <a id="8025" href="Veblen.Basic.html#8008" class="Bound">n</a><a id="8026" class="Symbol">)</a>
</pre>
<p><strong>定理 序数的递归原理 (transfinite recursion)</strong> 对于任意类型 <span class="math inline">A</span>, 函数 <span class="math inline">z : A</span>, <span class="math inline">s : A → A</span>, <span class="math inline">l : (ℕ → A) → A</span>, 和任意序数 <span class="math inline">α</span>, 存在唯一的 <span class="math inline">\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α : A</span>, 满足</p>
<p><span class="math display">
\begin{aligned}
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}0 &amp;= z \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α^+ &amp;= s\kern{0.17em}(\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α) \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= l\kern{0.17em}(λ\kern{0.17em}n,\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(f\kern{0.17em}n))
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 令 <span class="math inline">P = λ\kern{0.17em}\_,A</span> 并应用序数归纳法即可. ∎</p>
<pre class="Agda"><a id="rec"></a><a id="8762" href="Veblen.Basic.html#8762" class="Function">rec</a> <a id="8766" class="Symbol">:</a> <a id="8768" href="Veblen.Basic.html#4988" class="Generalizable">A</a> <a id="8770" class="Symbol">→</a> <a id="8772" class="Symbol">(</a><a id="8773" href="Veblen.Basic.html#4988" class="Generalizable">A</a> <a id="8775" class="Symbol">→</a> <a id="8777" href="Veblen.Basic.html#4988" class="Generalizable">A</a><a id="8778" class="Symbol">)</a> <a id="8780" class="Symbol">→</a> <a id="8782" class="Symbol">((</a><a id="8784" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8786" class="Symbol">→</a> <a id="8788" href="Veblen.Basic.html#4988" class="Generalizable">A</a><a id="8789" class="Symbol">)</a> <a id="8791" class="Symbol">→</a> <a id="8793" href="Veblen.Basic.html#4988" class="Generalizable">A</a><a id="8794" class="Symbol">)</a> <a id="8796" class="Symbol">→</a> <a id="8798" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="8802" class="Symbol">→</a> <a id="8804" href="Veblen.Basic.html#4988" class="Generalizable">A</a>
<a id="8806" href="Veblen.Basic.html#8762" class="Function">rec</a> <a id="8810" href="Veblen.Basic.html#8810" class="Bound">z</a> <a id="8812" href="Veblen.Basic.html#8812" class="Bound">s</a> <a id="8814" href="Veblen.Basic.html#8814" class="Bound">l</a> <a id="8816" class="Symbol">=</a> <a id="8818" href="Veblen.Basic.html#7406" class="Function">ind</a> <a id="8822" href="Veblen.Basic.html#8810" class="Bound">z</a> <a id="8824" class="Symbol">(λ</a> <a id="8827" href="Veblen.Basic.html#8827" class="Bound">_</a> <a id="8829" class="Symbol">→</a> <a id="8831" href="Veblen.Basic.html#8812" class="Bound">s</a><a id="8832" class="Symbol">)</a> <a id="8834" class="Symbol">(λ</a> <a id="8837" href="Veblen.Basic.html#8837" class="Bound">_</a> <a id="8839" class="Symbol">→</a> <a id="8841" href="Veblen.Basic.html#8814" class="Bound">l</a><a id="8842" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 序数的递归原理是序数归纳法的特例, 也就是说, 序数的递归原理是序数归纳法的一个直接应用.</p>
<p><strong>注意</strong> 序数的递归原理相当强大, 因为 <span class="math inline">A</span> 可以是任意类型, 包括函数类型 <span class="math inline">\text{Ord}\rightarrow\text{Ord}</span> 与 <span class="math inline">(\text{Ord}\rightarrow\text{Ord})\rightarrow(\text{Ord}\rightarrow\text{Ord})</span> 等, 也就是说它允许定义高阶函数的递归. 本文出现的所有大序数都由 <span class="math inline">\text{rec}</span> 定义.</p>
<h2 id="超限复合">超限复合</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">F</span> 表示序数函数 <span class="math inline">\text{Ord} → \text{Ord}</span>, 用 <span class="math inline">f,g,h</span> 表示基本序列 <span class="math inline">ℕ → \text{Ord}</span>.</p>
<pre class="Agda"><a id="9216" class="Keyword">variable</a>
  <a id="9227" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="9229" class="Symbol">:</a> <a id="9231" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="9235" class="Symbol">→</a> <a id="9237" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
  <a id="9243" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="9245" href="Veblen.Basic.html#9245" class="Generalizable">g</a> <a id="9247" href="Veblen.Basic.html#9247" class="Generalizable">h</a> <a id="9249" class="Symbol">:</a> <a id="9251" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9253" class="Symbol">→</a> <a id="9255" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
</pre>
<p><strong>定义</strong> 仿照函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span>, 我们定义序数函数 <span class="math inline">F : \text{Ord} → \text{Ord}</span> 的 <span class="math inline">α</span> 次复合 <span class="math inline">F^α</span>, 但使用序数的递归原理 <span class="math inline">\text{rec}</span> 来定义.</p>
<p><span class="math display">
F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}\text{lim}\kern{0.17em}\alpha
</span></p>
<pre class="Agda"><a id="_∘^_"></a><a id="9518" href="Veblen.Basic.html#9518" class="Function Operator">_∘^_</a> <a id="9523" class="Symbol">:</a> <a id="9525" class="Symbol">(</a><a id="9526" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="9530" class="Symbol">→</a> <a id="9532" href="Veblen.Basic.html#3149" class="Datatype">Ord</a><a id="9535" class="Symbol">)</a> <a id="9537" class="Symbol">→</a> <a id="9539" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="9543" class="Symbol">→</a> <a id="9545" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="9549" class="Symbol">→</a> <a id="9551" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="9555" class="Symbol">(</a><a id="9556" href="Veblen.Basic.html#9556" class="Bound">F</a> <a id="9558" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="9561" href="Veblen.Basic.html#9561" class="Bound">α</a><a id="9562" class="Symbol">)</a> <a id="9564" href="Veblen.Basic.html#9564" class="Bound">β</a> <a id="9566" class="Symbol">=</a> <a id="9568" href="Veblen.Basic.html#8762" class="Function">rec</a> <a id="9572" href="Veblen.Basic.html#9564" class="Bound">β</a> <a id="9574" href="Veblen.Basic.html#9556" class="Bound">F</a> <a id="9576" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="9580" href="Veblen.Basic.html#9561" class="Bound">α</a>
</pre>
<p><strong>注意</strong> 该定义不是 <span class="math inline">F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}\alpha)</span>, 此式有类型错误.</p>
<p>对于 <span class="math inline">\text{rec}</span> 的四个参数, 直观上 - 第一个参数是初始值, 这里是 <span class="math inline">F^\alpha</span> 的输入 <span class="math inline">\beta</span>, - 第二个参数是后继步骤, 需要指定递归迭代的函数, 这里递归迭代的就是 <span class="math inline">F</span>, - 第三个参数是极限步骤, 需要指定将极限步对应的步骤基本序列 <span class="math inline">λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta</span> 映射的序数的函数, 这里就是单纯地取其极限, 所以指定为 <span class="math inline">\text{lim}</span>, - 第四个参数是递归的次数, 这里是 <span class="math inline">\alpha</span>.</p>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{α^+} &amp;= F \circ F^α \\
F^{\text{lim}\kern{0.17em}f} &amp;= λ\kern{0.17em}\beta,\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta
\end{aligned}
</span></p>
<pre class="Agda"><a id="∘^-zero"></a><a id="10283" href="Veblen.Basic.html#10283" class="Function">∘^-zero</a> <a id="10291" class="Symbol">:</a> <a id="10293" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10295" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10298" class="InductiveConstructor">zero</a> <a id="10303" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10305" href="Function.Base.html#704" class="Function">id</a>
<a id="10308" href="Veblen.Basic.html#10283" class="Function">∘^-zero</a> <a id="10316" class="Symbol">=</a> <a id="10318" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-suc"></a><a id="10324" href="Veblen.Basic.html#10324" class="Function">∘^-suc</a> <a id="10331" class="Symbol">:</a> <a id="10333" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10335" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10338" class="InductiveConstructor">suc</a> <a id="10342" href="Veblen.Basic.html#4063" class="Generalizable">α</a> <a id="10344" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10346" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10348" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="10350" class="Symbol">(</a><a id="10351" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10353" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10356" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="10357" class="Symbol">)</a>
<a id="10359" href="Veblen.Basic.html#10324" class="Function">∘^-suc</a> <a id="10366" class="Symbol">=</a> <a id="10368" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-lim"></a><a id="10374" href="Veblen.Basic.html#10374" class="Function">∘^-lim</a> <a id="10381" class="Symbol">:</a> <a id="10383" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10385" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10388" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="10392" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="10394" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10396" class="Symbol">λ</a> <a id="10398" href="Veblen.Basic.html#10398" class="Bound">β</a> <a id="10400" class="Symbol">→</a> <a id="10402" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="10406" class="Symbol">λ</a> <a id="10408" href="Veblen.Basic.html#10408" class="Bound">n</a> <a id="10410" class="Symbol">→</a> <a id="10412" class="Symbol">(</a><a id="10413" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="10415" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10418" class="Symbol">(</a><a id="10419" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="10421" href="Veblen.Basic.html#10408" class="Bound">n</a><a id="10422" class="Symbol">))</a> <a id="10425" href="Veblen.Basic.html#10398" class="Bound">β</a>
<a id="10427" href="Veblen.Basic.html#10374" class="Function">∘^-lim</a> <a id="10434" class="Symbol">=</a> <a id="10436" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="序数算术">序数算术</h2>
<p><strong>定义</strong> 从 <span class="math inline">α</span> 开始做 <span class="math inline">β</span> 次后继叫做序数加法, 记作 <span class="math inline">α+β</span>.</p>
<pre class="Agda"><a id="10506" class="Keyword">infixl</a> <a id="10513" class="Number">6</a> <a id="10515" href="Veblen.Basic.html#10519" class="Function Operator">_+_</a>
<a id="_+_"></a><a id="10519" href="Veblen.Basic.html#10519" class="Function Operator">_+_</a> <a id="10523" class="Symbol">:</a> <a id="10525" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10529" class="Symbol">→</a> <a id="10531" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10535" class="Symbol">→</a> <a id="10537" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="10541" href="Veblen.Basic.html#10541" class="Bound">α</a> <a id="10543" href="Veblen.Basic.html#10519" class="Function Operator">+</a> <a id="10545" href="Veblen.Basic.html#10545" class="Bound">β</a> <a id="10547" class="Symbol">=</a> <a id="10549" class="Symbol">(</a><a id="10550" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="10554" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10557" href="Veblen.Basic.html#10545" class="Bound">β</a><a id="10558" class="Symbol">)</a> <a id="10560" href="Veblen.Basic.html#10541" class="Bound">α</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">0</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">+ α</span> 叫做序数乘法, 记作 <span class="math inline">α*β</span>.</p>
<pre class="Agda"><a id="10623" class="Keyword">infixl</a> <a id="10630" class="Number">7</a> <a id="10632" href="Veblen.Basic.html#10636" class="Function Operator">_*_</a>
<a id="_*_"></a><a id="10636" href="Veblen.Basic.html#10636" class="Function Operator">_*_</a> <a id="10640" class="Symbol">:</a> <a id="10642" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10646" class="Symbol">→</a> <a id="10648" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10652" class="Symbol">→</a> <a id="10654" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="10658" href="Veblen.Basic.html#10658" class="Bound">α</a> <a id="10660" href="Veblen.Basic.html#10636" class="Function Operator">*</a> <a id="10662" href="Veblen.Basic.html#10662" class="Bound">β</a> <a id="10664" class="Symbol">=</a> <a id="10666" class="Symbol">((</a><a id="10668" href="Veblen.Basic.html#10519" class="Function Operator">_+</a> <a id="10671" href="Veblen.Basic.html#10658" class="Bound">α</a><a id="10672" class="Symbol">)</a> <a id="10674" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10677" href="Veblen.Basic.html#10662" class="Bound">β</a><a id="10678" class="Symbol">)</a> <a id="10680" class="Number">0</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">1</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">* α</span> 叫做序数幂, 记作 <span class="math inline">α^β</span>.</p>
<pre class="Agda"><a id="10742" class="Keyword">infix</a> <a id="10748" class="Number">8</a> <a id="10750" href="Veblen.Basic.html#10754" class="Function Operator">_^_</a>
<a id="_^_"></a><a id="10754" href="Veblen.Basic.html#10754" class="Function Operator">_^_</a> <a id="10758" class="Symbol">:</a> <a id="10760" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10764" class="Symbol">→</a> <a id="10766" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="10770" class="Symbol">→</a> <a id="10772" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="10776" href="Veblen.Basic.html#10776" class="Bound">α</a> <a id="10778" href="Veblen.Basic.html#10754" class="Function Operator">^</a> <a id="10780" href="Veblen.Basic.html#10780" class="Bound">β</a> <a id="10782" class="Symbol">=</a> <a id="10784" class="Symbol">((</a><a id="10786" href="Veblen.Basic.html#10636" class="Function Operator">_*</a> <a id="10789" href="Veblen.Basic.html#10776" class="Bound">α</a><a id="10790" class="Symbol">)</a> <a id="10792" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="10795" href="Veblen.Basic.html#10780" class="Bound">β</a><a id="10796" class="Symbol">)</a> <a id="10798" class="Number">1</a>
</pre>
<h2 id="三大高阶函数">三大高阶函数</h2>
<p>Veblen层级的构造需要三个重要的高阶函数</p>
<ol type="1">
<li>无穷迭代 <span class="math inline">λF,F^\omega</span></li>
<li>跳出运算 <span class="math inline">\text{jump}</span></li>
<li>不动点的枚举 <span class="math inline">\text{fixpt}</span></li>
</ol>
<p>它们都具有类型 <span class="math inline">(\text{Ord}→\text{Ord})→(\text{Ord}→\text{Ord})</span>.</p>
<h3 id="无穷迭代">无穷迭代</h3>
<p><strong>定义</strong> 我们称 <span class="math inline">F</span> 的 <span class="math inline">\omega</span> 次复合 <span class="math inline">F^\omega</span> 为 <span class="math inline">F</span> 的无穷迭代.</p>
<pre class="Agda"><a id="iterω"></a><a id="11043" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="11049" class="Symbol">:</a> <a id="11051" class="Symbol">(</a><a id="11052" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="11056" class="Symbol">→</a> <a id="11058" href="Veblen.Basic.html#3149" class="Datatype">Ord</a><a id="11061" class="Symbol">)</a> <a id="11063" class="Symbol">→</a> <a id="11065" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="11069" class="Symbol">→</a> <a id="11071" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="11075" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="11081" href="Veblen.Basic.html#11081" class="Bound">F</a> <a id="11083" class="Symbol">=</a> <a id="11085" href="Veblen.Basic.html#11081" class="Bound">F</a> <a id="11087" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="11090" href="Veblen.Basic.html#4531" class="Function">ω</a>
</pre>
<h3 id="跳出运算">跳出运算</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span> 和迭代次数 <span class="math inline">α</span>, 从 <span class="math inline">F\kern{0.17em}0</span> 开始, 每次迭代时先做一次后继再迭代 <span class="math inline">F</span>, 总共迭代 <span class="math inline">α</span> 次的运算叫做 <span class="math inline">F</span> 的 <span class="math inline">α</span> 次跳出, 记作 <span class="math inline">\text{jump}\kern{0.17em}F\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{jump}\kern{0.17em}F\kern{0.17em}α := (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}0)
</span></p>
<pre class="Agda"><a id="jump"></a><a id="11406" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="11411" class="Symbol">:</a> <a id="11413" class="Symbol">(</a><a id="11414" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="11418" class="Symbol">→</a> <a id="11420" href="Veblen.Basic.html#3149" class="Datatype">Ord</a><a id="11423" class="Symbol">)</a> <a id="11425" class="Symbol">→</a> <a id="11427" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="11431" class="Symbol">→</a> <a id="11433" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="11437" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="11442" href="Veblen.Basic.html#11442" class="Bound">F</a> <a id="11444" href="Veblen.Basic.html#11444" class="Bound">α</a> <a id="11446" class="Symbol">=</a> <a id="11448" class="Symbol">((</a><a id="11450" href="Veblen.Basic.html#11442" class="Bound">F</a> <a id="11452" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="11454" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a><a id="11457" class="Symbol">)</a> <a id="11459" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="11462" href="Veblen.Basic.html#11444" class="Bound">α</a><a id="11463" class="Symbol">)</a> <a id="11465" class="Symbol">(</a><a id="11466" href="Veblen.Basic.html#11442" class="Bound">F</a> <a id="11468" class="Number">0</a><a id="11469" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}0 &amp;= F\kern{0.17em}0 \\
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{jump}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{jump}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 零和极限的情况是显然的. 对于后继的情况, 有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^{α^+}\kern{0.17em}(F\kern{0.17em}0) \\
&amp;= F\kern{0.17em}((F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}0)) \\
&amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+
\end{aligned}
</span> ∎</p>
<pre class="Agda"><a id="jump-0"></a><a id="12283" href="Veblen.Basic.html#12283" class="Function">jump-0</a> <a id="12290" class="Symbol">:</a> <a id="12292" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12297" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12299" class="Number">0</a> <a id="12301" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12303" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12305" class="Number">0</a>
<a id="12307" href="Veblen.Basic.html#12283" class="Function">jump-0</a> <a id="12314" class="Symbol">=</a> <a id="12316" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="jump-suc"></a><a id="12322" href="Veblen.Basic.html#12322" class="Function">jump-suc</a> <a id="12331" class="Symbol">:</a> <a id="12333" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12338" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12340" class="Symbol">(</a><a id="12341" class="InductiveConstructor">suc</a> <a id="12345" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="12346" class="Symbol">)</a> <a id="12348" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12350" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12352" class="Symbol">(</a><a id="12353" class="InductiveConstructor">suc</a> <a id="12357" class="Symbol">(</a><a id="12358" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12363" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12365" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="12366" class="Symbol">))</a>
<a id="12369" href="Veblen.Basic.html#12322" class="Function">jump-suc</a> <a id="12378" class="Symbol">{</a><a id="12379" href="Veblen.Basic.html#12379" class="Bound">F</a><a id="12380" class="Symbol">}</a> <a id="12382" class="Symbol">{</a><a id="12383" href="Veblen.Basic.html#12383" class="Bound">α</a><a id="12384" class="Symbol">}</a> <a id="12386" class="Symbol">=</a> <a id="12388" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="12396" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12401" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12403" class="Symbol">(</a><a id="12404" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="12408" href="Veblen.Basic.html#12383" class="Bound">α</a><a id="12409" class="Symbol">)</a>                        <a id="12434" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="12440" class="Symbol">((</a><a id="12442" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12444" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="12446" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a><a id="12449" class="Symbol">)</a> <a id="12451" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="12454" class="Symbol">(</a><a id="12455" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="12459" href="Veblen.Basic.html#12383" class="Bound">α</a><a id="12460" class="Symbol">))</a> <a id="12463" class="Symbol">(</a><a id="12464" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12466" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a><a id="12470" class="Symbol">)</a>       <a id="12478" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="12484" class="Symbol">(</a><a id="12485" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12487" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="12489" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a><a id="12492" class="Symbol">)</a> <a id="12494" class="Symbol">(((</a><a id="12497" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12499" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="12501" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a><a id="12504" class="Symbol">)</a> <a id="12506" href="Veblen.Basic.html#9518" class="Function Operator">∘^</a> <a id="12509" href="Veblen.Basic.html#12383" class="Bound">α</a><a id="12510" class="Symbol">)</a> <a id="12512" class="Symbol">(</a><a id="12513" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12515" href="Veblen.Basic.html#3167" class="InductiveConstructor">zero</a><a id="12519" class="Symbol">))</a> <a id="12522" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="12528" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12530" class="Symbol">(</a><a id="12531" href="Veblen.Basic.html#3180" class="InductiveConstructor">suc</a> <a id="12535" class="Symbol">(</a><a id="12536" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12541" href="Veblen.Basic.html#12379" class="Bound">F</a> <a id="12543" href="Veblen.Basic.html#12383" class="Bound">α</a><a id="12544" class="Symbol">))</a>                    <a id="12566" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>

<a id="jump-lim"></a><a id="12569" href="Veblen.Basic.html#12569" class="Function">jump-lim</a> <a id="12578" class="Symbol">:</a> <a id="12580" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12585" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12587" class="Symbol">(</a><a id="12588" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="12592" href="Veblen.Basic.html#9243" class="Generalizable">f</a><a id="12593" class="Symbol">)</a> <a id="12595" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12597" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="12601" class="Symbol">λ</a> <a id="12603" href="Veblen.Basic.html#12603" class="Bound">n</a> <a id="12605" class="Symbol">→</a> <a id="12607" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12612" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="12614" class="Symbol">(</a><a id="12615" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="12617" href="Veblen.Basic.html#12603" class="Bound">n</a><a id="12618" class="Symbol">)</a>
<a id="12620" href="Veblen.Basic.html#12569" class="Function">jump-lim</a> <a id="12629" class="Symbol">=</a> <a id="12631" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="不动点的枚举">不动点的枚举</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span>, 我们定义 <span class="math inline">F</span> 的第 <span class="math inline">α</span> 个不动点 <span class="math inline">\text{fixpt}\kern{0.17em}F\kern{0.17em}α</span> 为 <span class="math inline">F^\omega</span> 的第 <span class="math inline">α</span> 个跳出 <span class="math inline">\text{jump}\kern{0.17em}(F^\omega)\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{fixpt}\kern{0.17em}F := \text{jump}\kern{0.17em}(F^\omega)
</span></p>
<pre class="Agda"><a id="fixpt"></a><a id="12893" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="12899" class="Symbol">:</a> <a id="12901" class="Symbol">(</a><a id="12902" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="12906" class="Symbol">→</a> <a id="12908" href="Veblen.Basic.html#3149" class="Datatype">Ord</a><a id="12911" class="Symbol">)</a> <a id="12913" class="Symbol">→</a> <a id="12915" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="12919" class="Symbol">→</a> <a id="12921" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="12925" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="12931" href="Veblen.Basic.html#12931" class="Bound">F</a> <a id="12933" class="Symbol">=</a> <a id="12935" href="Veblen.Basic.html#11406" class="Function">jump</a> <a id="12940" class="Symbol">(</a><a id="12941" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="12947" href="Veblen.Basic.html#12931" class="Bound">F</a><a id="12948" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{fixpt}\kern{0.17em}F\kern{0.17em}0 &amp;= F^\omega\kern{0.17em}0 \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F^\omega\kern{0.17em}(\text{fixpt}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{fixpt}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<pre class="Agda"><a id="fixpt-0"></a><a id="13391" href="Veblen.Basic.html#13391" class="Function">fixpt-0</a> <a id="13399" class="Symbol">:</a> <a id="13401" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13407" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13409" class="Number">0</a> <a id="13411" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13413" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="13419" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13421" class="Number">0</a>
<a id="13423" href="Veblen.Basic.html#13391" class="Function">fixpt-0</a> <a id="13431" class="Symbol">=</a> <a id="13433" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-suc"></a><a id="13439" href="Veblen.Basic.html#13439" class="Function">fixpt-suc</a> <a id="13449" class="Symbol">:</a> <a id="13451" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13457" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13459" class="Symbol">(</a><a id="13460" class="InductiveConstructor">suc</a> <a id="13464" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="13465" class="Symbol">)</a> <a id="13467" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13469" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="13475" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13477" class="Symbol">(</a><a id="13478" class="InductiveConstructor">suc</a> <a id="13482" class="Symbol">(</a><a id="13483" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13489" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13491" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="13492" class="Symbol">))</a>
<a id="13495" href="Veblen.Basic.html#13439" class="Function">fixpt-suc</a> <a id="13505" class="Symbol">{</a><a id="13506" href="Veblen.Basic.html#13506" class="Bound">F</a><a id="13507" class="Symbol">}</a> <a id="13509" class="Symbol">{</a><a id="13510" href="Veblen.Basic.html#13510" class="Bound">α</a><a id="13511" class="Symbol">}</a> <a id="13513" class="Symbol">=</a> <a id="13515" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-lim"></a><a id="13521" href="Veblen.Basic.html#13521" class="Function">fixpt-lim</a> <a id="13531" class="Symbol">:</a> <a id="13533" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13539" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13541" class="Symbol">(</a><a id="13542" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="13546" href="Veblen.Basic.html#9243" class="Generalizable">f</a><a id="13547" class="Symbol">)</a> <a id="13549" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13551" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="13555" class="Symbol">λ</a> <a id="13557" href="Veblen.Basic.html#13557" class="Bound">n</a> <a id="13559" class="Symbol">→</a> <a id="13561" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13567" href="Veblen.Basic.html#9227" class="Generalizable">F</a> <a id="13569" class="Symbol">(</a><a id="13570" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="13572" href="Veblen.Basic.html#13557" class="Bound">n</a><a id="13573" class="Symbol">)</a>
<a id="13575" href="Veblen.Basic.html#13521" class="Function">fixpt-lim</a> <a id="13585" class="Symbol">=</a> <a id="13587" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 跳出运算不一定跟无穷迭代配合使用, 后面会出现多种情况需要跳出, 以提高增长率.</p>
<h2 id="ε-ζ-η-层级">ε， ζ， η 层级</h2>
<p>我们定义三个序数函数 <span class="math inline">\varepsilon, \zeta, \eta</span> 如下.</p>
<p><strong>定义</strong> <span class="math inline">\varepsilon</span> 是函数 <span class="math inline">λα,ω^α</span> 的不动点枚举.</p>
<pre class="Agda"><a id="ε"></a><a id="13755" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="13757" class="Symbol">:</a> <a id="13759" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="13763" class="Symbol">→</a> <a id="13765" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="13769" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="13771" class="Symbol">=</a> <a id="13773" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="13779" class="Symbol">(</a><a id="13780" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="13782" href="Veblen.Basic.html#10754" class="Function Operator">^_</a><a id="13784" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\varepsilon_0 &amp;= (λα,ω^α)^ω\kern{0.17em}0 =
\begin{rcases}
ω^{ω^{⋰^{ω^0}}}
\end{rcases}ω
\\
\varepsilon_{α^+} &amp;= (λα,ω^α)^ω\kern{0.17em}({ε_α}^+) =
\begin{rcases}
ω^{ω^{⋰^{ω^{({ε_α}^+)}}}}
\end{rcases}ω
\\
\varepsilon_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\varepsilon_{f\kern{0.17em}n} = \text{lim}(ε_{f\kern{0.17em}0},ε_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<pre class="Agda"><a id="ε-0"></a><a id="14252" href="Veblen.Basic.html#14252" class="Function">ε-0</a> <a id="14256" class="Symbol">:</a> <a id="14258" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="14260" class="Number">0</a> <a id="14262" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14264" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="14270" class="Symbol">(</a><a id="14271" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="14273" href="Veblen.Basic.html#10754" class="Function Operator">^_</a><a id="14275" class="Symbol">)</a> <a id="14277" class="Number">0</a>
<a id="14279" href="Veblen.Basic.html#14252" class="Function">ε-0</a> <a id="14283" class="Symbol">=</a> <a id="14285" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-suc"></a><a id="14291" href="Veblen.Basic.html#14291" class="Function">ε-suc</a> <a id="14297" class="Symbol">:</a> <a id="14299" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="14301" class="Symbol">(</a><a id="14302" class="InductiveConstructor">suc</a> <a id="14306" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="14307" class="Symbol">)</a> <a id="14309" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14311" href="Veblen.Basic.html#11043" class="Function">iterω</a> <a id="14317" class="Symbol">(</a><a id="14318" href="Veblen.Basic.html#4531" class="Function">ω</a> <a id="14320" href="Veblen.Basic.html#10754" class="Function Operator">^_</a><a id="14322" class="Symbol">)</a> <a id="14324" class="Symbol">(</a><a id="14325" class="InductiveConstructor">suc</a> <a id="14329" class="Symbol">(</a><a id="14330" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="14332" href="Veblen.Basic.html#4063" class="Generalizable">α</a><a id="14333" class="Symbol">))</a>
<a id="14336" href="Veblen.Basic.html#14291" class="Function">ε-suc</a> <a id="14342" class="Symbol">=</a> <a id="14344" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-lim"></a><a id="14350" href="Veblen.Basic.html#14350" class="Function">ε-lim</a> <a id="14356" class="Symbol">:</a> <a id="14358" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="14360" class="Symbol">(</a><a id="14361" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="14365" href="Veblen.Basic.html#9243" class="Generalizable">f</a><a id="14366" class="Symbol">)</a> <a id="14368" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14370" href="Veblen.Basic.html#3199" class="InductiveConstructor">lim</a> <a id="14374" class="Symbol">λ</a> <a id="14376" href="Veblen.Basic.html#14376" class="Bound">n</a> <a id="14378" class="Symbol">→</a> <a id="14380" href="Veblen.Basic.html#13755" class="Function">ε</a> <a id="14382" class="Symbol">(</a><a id="14383" href="Veblen.Basic.html#9243" class="Generalizable">f</a> <a id="14385" href="Veblen.Basic.html#14376" class="Bound">n</a><a id="14386" class="Symbol">)</a>
<a id="14388" href="Veblen.Basic.html#14350" class="Function">ε-lim</a> <a id="14394" class="Symbol">=</a> <a id="14396" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\zeta</span> 是 <span class="math inline">ε</span> 的不动点枚举.</p>
<pre class="Agda"><a id="ζ"></a><a id="14444" href="Veblen.Basic.html#14444" class="Function">ζ</a> <a id="14446" class="Symbol">:</a> <a id="14448" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="14452" class="Symbol">→</a> <a id="14454" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="14458" href="Veblen.Basic.html#14444" class="Function">ζ</a> <a id="14460" class="Symbol">=</a> <a id="14462" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="14468" href="Veblen.Basic.html#13755" class="Function">ε</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\zeta_0 &amp;= ε^ω\kern{0.17em}0 =
\begin{rcases}
ε_{ε_{⋱_{ε_0}}}
\end{rcases}ω \\
\zeta_{α^+} &amp;= ε^ω\kern{0.17em}({\zeta_α}^+) =
\begin{rcases}
ε_{ε_{⋱_{({\zeta_α}^+)}}}
\end{rcases}ω
\\
\zeta_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\zeta_{f\kern{0.17em}n} = \text{lim}(ζ_{f\kern{0.17em}0},ζ_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<p><strong>定义</strong> <span class="math inline">\eta</span> 是 <span class="math inline">\zeta</span> 的不动点枚举.</p>
<pre class="Agda"><a id="η"></a><a id="14933" href="Veblen.Basic.html#14933" class="Function">η</a> <a id="14935" class="Symbol">:</a> <a id="14937" href="Veblen.Basic.html#3149" class="Datatype">Ord</a> <a id="14941" class="Symbol">→</a> <a id="14943" href="Veblen.Basic.html#3149" class="Datatype">Ord</a>
<a id="14947" href="Veblen.Basic.html#14933" class="Function">η</a> <a id="14949" class="Symbol">=</a> <a id="14951" href="Veblen.Basic.html#12893" class="Function">fixpt</a> <a id="14957" href="Veblen.Basic.html#14444" class="Function">ζ</a>
</pre>
<p>一个很大的大数:</p>
<p><span class="math display">
f_{η_0} 99 = f_{
  \begin{rcases}
  ζ_{ζ_{⋱_{ζ_0}}}
  \end{rcases}99
}99
</span></p>
<pre class="Agda"><a id="oom"></a><a id="15062" href="Veblen.Basic.html#15062" class="Function">oom</a> <a id="15066" class="Symbol">=</a> <a id="15068" href="Veblen.Basic.html#5571" class="Function">FGH.f</a> <a id="15074" class="Symbol">(</a><a id="15075" href="Veblen.Basic.html#14933" class="Function">η</a> <a id="15077" class="Number">0</a><a id="15078" class="Symbol">)</a> <a id="15080" class="Number">99</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
