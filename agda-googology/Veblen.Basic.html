<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>形式化大数数学 (1.1 - 序数, FGH, 不动点)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#形式化大数数学-1.1---序数-fgh-不动点" id="toc-形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#目标人群" id="toc-目标人群">目标人群</a></li>
  <li><a href="#补充材料" id="toc-补充材料">补充材料</a></li>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  </ul></li>
  <li><a href="#序数的定义" id="toc-序数的定义">序数的定义</a></li>
  <li><a href="#快速增长层级" id="toc-快速增长层级">快速增长层级</a></li>
  <li><a href="#序数的递归原理" id="toc-序数的递归原理">序数的递归原理</a></li>
  <li><a href="#超限复合" id="toc-超限复合">超限复合</a></li>
  <li><a href="#序数算术" id="toc-序数算术">序数算术</a></li>
  <li><a href="#三大高阶函数" id="toc-三大高阶函数">三大高阶函数</a>
  <ul>
  <li><a href="#无穷迭代" id="toc-无穷迭代">无穷迭代</a></li>
  <li><a href="#跳出运算" id="toc-跳出运算">跳出运算</a></li>
  <li><a href="#不动点的枚举" id="toc-不动点的枚举">不动点的枚举</a></li>
  </ul></li>
  <li><a href="#ε-ζ-η-层级" id="toc-ε-ζ-η-层级">ε， ζ， η 层级</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="形式化大数数学-1.1---序数-fgh-不动点">形式化大数数学 (1.1 - 序数, FGH, 不动点)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-googology/blob/main/src/Veblen/Basic.lagda.md">Basic.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-googology/Veblen.Basic.html">Basic.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是可运行且保证停机的<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0_(%E6%95%B0%E5%AD%A6)">大数</a>计算程序的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文学编程 (literate programming)</a> 实现.</p>
<ul>
<li><strong>可运行</strong>是相对于自然语言的数学描述而言, 本文贴出的代码可以在电脑上运行.</li>
<li><strong>保证停机</strong>是相对于<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备 (Turing-complete)</a> 语言 (如C语言) 而言, 本文使用的 <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a> 语言并非图灵完备, 其自带<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/termination-checking.html">停机检查 (termination checking)</a>, 写出的程序保证停机.</li>
<li><strong>文学编程</strong>是指本文既是程序代码, 也是程序文档, 代码和文档交织在一起, 以增强可读性.
<ul>
<li>Agda 程序会自动抽取本文所有代码块中的代码, 并执行类型检查, 而忽略代码块以外的内容.</li>
<li>※ 冷知识: 文学编程的发明者<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳 (Donald Knuth)</a>, 也是大数数学入门级内容<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%B4%8D%E7%AE%AD%E8%99%9F%E8%A1%A8%E7%A4%BA%E6%B3%95">高德纳箭号</a>的发明者, 也是排版软件 <a href="https://zh.wikipedia.org/wiki/TeX">TeX</a> 的发明者.</li>
</ul></li>
</ul>
<p>也就是说, 提供足够的时间, 能量和内存, 本文介绍的大数计算程序可以真正算出一个大数. 如果真的想运行: 1. 参考 <a href="https://agda.readthedocs.io/en/latest/getting-started/installation.html">Installation</a> 安装 Agda. 2. 进本文所在Github仓库 (<a href="https://github.com/choukh/agda-googology">agda-googology</a>) 下载本文 markdown 源码. 3. 用编辑器打开源码, 确认进入了 <a href="https://agda.readthedocs.io/en/latest/tools/emacs-mode.html">agda-mode</a>, 键入 <code>C-c C-n</code> 对本文定义的任意大数 (如文末的 <code>oom</code>) 执行正规化 (normalization).</p>
<h3 id="目标人群">目标人群</h3>
<ul>
<li>大数数学已入门 (如, 看完<a href="https://www.zhihu.com/column/c_1307845959598960640">大数数学入门</a>), 对严格性和精确定义有进一步要求的读者.</li>
<li>Agda 已入门 (如, 看完 <a href="https://agda-zh.github.io/PLFA-zh/">PLFA</a>), 对大数计算程序的编程实现感兴趣的读者.</li>
</ul>
<p>只对前者感兴趣的读者, 可以忽略代码部分, 而只阅读文学部分, 它们可以看作是基于朴素类型论的数学描述, 并使用了 <span class="math inline">\LaTeX</span> 公式, 以对齐通常的数学习惯.</p>
<h3 id="补充材料">补充材料</h3>
<ul>
<li><a href="https://www.zhihu.com/column/c_1307845959598960640">core.exe - 大数数学入门</a></li>
<li><a href="https://www.zhihu.com/column/c_1697290814588301312">core.exe - 大数数学入门 - 重置版</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">oCaU - Agda大序数</a>
<ul>
<li>该文详细讨论了上至二元Veblen层级的序性质, 而本文不会讨论这些性质.</li>
</ul></li>
<li><a href="https://github.com/choukh/Googology">oCaU - LVO 的 Coq 实现</a>
<ul>
<li>纯代码, 无文学</li>
</ul></li>
</ul>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="2374" class="Keyword">module</a> <a id="2381" href="Veblen.Basic.html" class="Module">Veblen.Basic</a> <a id="2394" class="Keyword">where</a>

<a id="2401" class="Keyword">open</a> <a id="2406" class="Keyword">import</a> <a id="2413" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2422" class="Keyword">public</a> <a id="2429" class="Keyword">using</a> <a id="2435" class="Symbol">(</a><a id="2436" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2437" class="Symbol">;</a> <a id="2439" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2443" class="Symbol">;</a> <a id="2445" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2448" class="Symbol">;</a> <a id="2450" href="Data.Nat.Base.html#1095" class="InductiveConstructor">2+</a><a id="2452" class="Symbol">)</a>
<a id="2454" class="Keyword">open</a> <a id="2459" class="Keyword">import</a> <a id="2466" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="2476" class="Keyword">public</a> <a id="2483" class="Keyword">using</a> <a id="2489" class="Symbol">(</a><a id="2490" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2491" class="Symbol">;</a> <a id="2493" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="2495" class="Symbol">)</a>
<a id="2497" class="Keyword">open</a> <a id="2502" class="Keyword">import</a> <a id="2509" href="Function.html" class="Module">Function</a> <a id="2518" class="Keyword">public</a> <a id="2525" class="Keyword">using</a> <a id="2531" class="Symbol">(</a><a id="2532" href="Function.Base.html#704" class="Function">id</a><a id="2534" class="Symbol">;</a> <a id="2536" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="2539" class="Symbol">;</a> <a id="2541" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="2544" class="Symbol">;</a> <a id="2546" href="Function.Base.html#4486" class="Function Operator">_∋_</a><a id="2549" class="Symbol">)</a>
<a id="2551" class="Keyword">open</a> <a id="2556" class="Keyword">import</a> <a id="2563" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2601" class="Symbol">as</a> <a id="2604" class="Module">Eq</a> <a id="2607" class="Keyword">public</a>
  <a id="2616" class="Keyword">using</a> <a id="2622" class="Symbol">(</a><a id="2623" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2626" class="Symbol">;</a> <a id="2628" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2632" class="Symbol">;</a> <a id="2634" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a><a id="2638" class="Symbol">;</a> <a id="2640" href="Relation.Binary.PropositionalEquality.Core.html#1489" class="Function">cong-app</a><a id="2648" class="Symbol">)</a>
<a id="2650" class="Keyword">open</a> <a id="2655" href="Relation.Binary.PropositionalEquality.Properties.html#6744" class="Module">Eq.≡-Reasoning</a> <a id="2670" class="Keyword">public</a>
</pre>
<h2 id="序数的定义">序数的定义</h2>
<p>我们知道自然数类型 <span class="math inline">ℕ</span> 由如下两条规则定义.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : ℕ\kern{0.17em}}
\qquad
\frac{\alpha:ℕ}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:ℕ\kern{0.17em}}
</span></p>
<p><strong>定义</strong> 我们的序数类型 <span class="math inline">\text{Ord}</span> 在 <span class="math inline">ℕ</span> 的基础上增加了第三条规则 <span class="math inline">\text{lim}</span>, 即如果 <span class="math inline">f</span> 是 <span class="math inline">ℕ</span> 到序数的函数, 那么 <span class="math inline">\text{lim}\kern{0.17em}f</span> 也是序数.</p>
<p><span class="math display">
\frac{}{\kern{0.17em}\text{zero} : \text{Ord}\kern{0.17em}}
\qquad
\frac{\alpha:\text{Ord}}{\kern{0.17em}\text{suc}\kern{0.17em}\alpha:\text{Ord}\kern{0.17em}}
\qquad
\frac{\kern{0.17em}f : ℕ\rightarrow\text{Ord}\kern{0.17em}}{\text{lim}\kern{0.17em}f:\text{Ord}}
</span></p>
<pre class="Agda"><a id="3257" class="Keyword">data</a> <a id="Ord"></a><a id="3262" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="3266" class="Symbol">:</a> <a id="3268" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3272" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="3280" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a> <a id="3285" class="Symbol">:</a> <a id="3287" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="3293" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a>  <a id="3298" class="Symbol">:</a> <a id="3300" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="3304" class="Symbol">→</a> <a id="3306" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="3312" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a>  <a id="3317" class="Symbol">:</a> <a id="3319" class="Symbol">(</a><a id="3320" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3322" class="Symbol">→</a> <a id="3324" href="Veblen.Basic.html#3262" class="Datatype">Ord</a><a id="3327" class="Symbol">)</a> <a id="3329" class="Symbol">→</a> <a id="3331" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
</pre>
<p>这样的 <span class="math inline">f : ℕ\rightarrow\text{Ord}</span> 又叫做 <span class="math inline">\text{lim}\kern{0.17em}f</span> 的基本列 (fundamental sequence), 而 <span class="math inline">\text{lim}\kern{0.17em}f</span> 则叫做基本列 <span class="math inline">f</span> 的极限. 仅就我们将要做的事情而言, <span class="math inline">\lim</span> 可视为等同于集合论的 <span class="math inline">\sup</span>. 这样的定义允许我们很方便地讨论零, 后继序数和极限序数三种情况. 为了方便阅读, 我们会把 <span class="math inline">\text{zero}</span> 写作 <span class="math inline">0</span>, 把 <span class="math inline">\text{suc}\kern{0.17em}x</span> 写作 <span class="math inline">x^+</span>.</p>
<p><strong>注意</strong> 我们的序数类型, 学名叫布劳威尔树序数 (Brouwer tree ordinals), 比真正的递归序数宽泛很多, 体现在以下两点:</p>
<ul>
<li>树序数不要求基本列是严格递增的.
<ul>
<li>严格递增的约束对于计算本身而言无关紧要.</li>
<li>当然, 如果要保证算出的大数足够大, 那么基本列的递增性是必要的.</li>
<li>我们构造的序数的基本列都是严格递增的, 如果想要, 可以额外补上证明.</li>
<li><a href="https://zhuanlan.zhihu.com/p/572691308">Agda大序数</a>一文中证明了其中构造的上至 <span class="math inline">\Gamma_0</span> 的所有树序数的基本列都是严格递增的.</li>
</ul></li>
<li>树序数是高度外延的 (extensional), 即一个真正的递归序数可能对应树上大量的节点.
<ul>
<li>也就是说我们可以用大量不同的基本列构造出相同的序数.
<ul>
<li>但同一性证明依赖于函数外延性 (function extensionality), 或某种商 (quotient) 机制, 如 setoid 或 cubical.</li>
</ul></li>
<li>但这并不影响大数的计算, 因为只要给出基本列就能算, 况且 FGH 大数的具体数值确实可能是依赖于特定基本列的——同一序数的不同定义方式会使基本列在起始处稍有不同.</li>
</ul></li>
</ul>
<p><strong>约定</strong> 我们用 <span class="math inline">α,β,γ,δ</span> 表示序数, 用 <span class="math inline">m,n</span> 表示自然数.</p>
<pre class="Agda"><a id="4229" class="Keyword">variable</a>
  <a id="4240" href="Veblen.Basic.html#4240" class="Generalizable">α</a> <a id="4242" href="Veblen.Basic.html#4242" class="Generalizable">β</a> <a id="4244" href="Veblen.Basic.html#4244" class="Generalizable">γ</a> <a id="4246" href="Veblen.Basic.html#4246" class="Generalizable">δ</a> <a id="4248" class="Symbol">:</a> <a id="4250" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
  <a id="4256" href="Veblen.Basic.html#4256" class="Generalizable">m</a> <a id="4258" href="Veblen.Basic.html#4258" class="Generalizable">n</a> <a id="4260" class="Symbol">:</a> <a id="4262" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<p><strong>约定</strong> 我们遵循类型论的习惯, 今后都会在无歧义的情况下省略函数应用的括号.</p>
<p><strong>定义</strong> 自然数到序数的嵌入函数 <span class="math inline">\text{finord} : ℕ → \text{Ord}</span> 如下</p>
<p><span class="math display">
\begin{aligned}
\text{finord}\kern{0.17em}0 &amp;= 0 \\
\text{finord}\kern{0.17em}n^+ &amp;= (\text{finord}\kern{0.17em}n)^+
\end{aligned}
</span></p>
<pre class="Agda"><a id="finord"></a><a id="4514" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="4521" class="Symbol">:</a> <a id="4523" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4525" class="Symbol">→</a> <a id="4527" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="4531" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="4538" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="4543" class="Symbol">=</a> <a id="4545" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a>
<a id="4550" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="4557" class="Symbol">(</a><a id="4558" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4562" href="Veblen.Basic.html#4562" class="Bound">n</a><a id="4563" class="Symbol">)</a> <a id="4565" class="Symbol">=</a> <a id="4567" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="4571" class="Symbol">(</a><a id="4572" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="4579" href="Veblen.Basic.html#4562" class="Bound">n</a><a id="4580" class="Symbol">)</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\text{finord}</span> 构成了基本列 <span class="math inline">(0, 1, 2, \ldots)</span>, 其极限定义为 <span class="math inline">ω</span></p>
<p><span class="math display">
ω := \text{lim}\kern{0.17em}\text{finord}
</span></p>
<pre class="Agda"><a id="ω"></a><a id="4707" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="4709" class="Symbol">=</a> <a id="4711" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="4715" href="Veblen.Basic.html#4514" class="Function">finord</a>
</pre>
<p><strong>非文学</strong> 以下代码调用了<a href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/literal-overloading.html">字面量重载</a>功能, 允许数字字面量依据上下文自动具有自然数或序数类型.</p>
<pre class="Agda"><a id="4866" class="Keyword">open</a> <a id="4871" class="Keyword">import</a> <a id="4878" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a> <a id="4899" class="Keyword">public</a>
<a id="4906" class="Keyword">instance</a>
  <a id="nOrd"></a><a id="4917" href="Veblen.Basic.html#4917" class="Function">nOrd</a> <a id="4922" class="Symbol">=</a> <a id="4924" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="4931" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="4935" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="4937" class="Keyword">record</a> <a id="4944" class="Symbol">{</a> <a id="4946" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="4957" class="Symbol">=</a> <a id="4959" class="Symbol">λ</a> <a id="4961" href="Veblen.Basic.html#4961" class="Bound">_</a> <a id="4963" class="Symbol">→</a> <a id="4965" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="4967" class="Symbol">;</a> <a id="4969" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="4977" class="Symbol">=</a> <a id="4979" class="Symbol">λ</a> <a id="4981" href="Veblen.Basic.html#4981" class="Bound">n</a> <a id="4983" class="Symbol">→</a> <a id="4985" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="4992" href="Veblen.Basic.html#4981" class="Bound">n</a> <a id="4994" class="Symbol">}</a>
  <a id="nNat"></a><a id="4998" href="Veblen.Basic.html#4998" class="Function">nNat</a> <a id="5003" class="Symbol">=</a> <a id="5005" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a> <a id="5012" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="5016" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5018" class="Keyword">record</a> <a id="5025" class="Symbol">{</a> <a id="5027" href="Agda.Builtin.FromNat.html#252" class="Field">Constraint</a> <a id="5038" class="Symbol">=</a> <a id="5040" class="Symbol">λ</a> <a id="5042" href="Veblen.Basic.html#5042" class="Bound">_</a> <a id="5044" class="Symbol">→</a> <a id="5046" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="5048" class="Symbol">;</a> <a id="5050" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a> <a id="5058" class="Symbol">=</a> <a id="5060" class="Symbol">λ</a> <a id="5062" href="Veblen.Basic.html#5062" class="Bound">n</a> <a id="5064" class="Symbol">→</a> <a id="5066" href="Veblen.Basic.html#5062" class="Bound">n</a> <a id="5068" class="Symbol">}</a>
</pre>
<p>以下为测试用例.</p>
<pre class="Agda"><a id="5093" href="Veblen.Basic.html#5093" class="Function">_</a> <a id="5095" class="Symbol">=</a> <a id="5097" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="5101" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5103" class="Number">233</a>
<a id="5107" href="Veblen.Basic.html#5107" class="Function">_</a> <a id="5109" class="Symbol">=</a> <a id="5111" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>   <a id="5115" href="Function.Base.html#4486" class="Function Operator">∋</a> <a id="5117" class="Number">233</a>
</pre>
<h2 id="快速增长层级">快速增长层级</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">A</span> 表示类型.</p>
<pre class="Agda"><a id="5167" class="Keyword">variable</a> <a id="5176" href="Veblen.Basic.html#5176" class="Generalizable">A</a> <a id="5178" class="Symbol">:</a> <a id="5180" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义</strong> 函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span></p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{n^+} &amp;= F \circ F^n
\end{aligned}
</span></p>
<p>其中 <span class="math inline">\text{id}</span> 是恒等函数.</p>
<pre class="Agda"><a id="_∘ⁿ_"></a><a id="5339" href="Veblen.Basic.html#5339" class="Function Operator">_∘ⁿ_</a> <a id="5344" class="Symbol">:</a> <a id="5346" class="Symbol">(</a><a id="5347" href="Veblen.Basic.html#5176" class="Generalizable">A</a> <a id="5349" class="Symbol">→</a> <a id="5351" href="Veblen.Basic.html#5176" class="Generalizable">A</a><a id="5352" class="Symbol">)</a> <a id="5354" class="Symbol">→</a> <a id="5356" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5358" class="Symbol">→</a> <a id="5360" class="Symbol">(</a><a id="5361" href="Veblen.Basic.html#5176" class="Generalizable">A</a> <a id="5363" class="Symbol">→</a> <a id="5365" href="Veblen.Basic.html#5176" class="Generalizable">A</a><a id="5366" class="Symbol">)</a>
<a id="5368" href="Veblen.Basic.html#5368" class="Bound">F</a> <a id="5370" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="5373" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="5379" class="Symbol">=</a> <a id="5381" href="Function.Base.html#704" class="Function">id</a>
<a id="5384" href="Veblen.Basic.html#5384" class="Bound">F</a> <a id="5386" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="5389" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5393" href="Veblen.Basic.html#5393" class="Bound">n</a> <a id="5395" class="Symbol">=</a> <a id="5397" class="Symbol">(</a><a id="5398" href="Veblen.Basic.html#5384" class="Bound">F</a> <a id="5400" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5402" class="Symbol">(</a><a id="5403" href="Veblen.Basic.html#5384" class="Bound">F</a> <a id="5405" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="5408" href="Veblen.Basic.html#5393" class="Bound">n</a><a id="5409" class="Symbol">))</a>
</pre>
<p><strong>定义</strong> 快速增长层级 (Fast Growing Hierarchy, FGH) 是一个函数族 <span class="math inline">f : \text{Ord} → ℕ → ℕ</span>, 对于每个序数 <span class="math inline">α</span>, <span class="math inline">f_α</span> 是一个从自然数到自然数的函数, 定义如下.</p>
<p><span class="math display">
\begin{aligned}
f_0\kern{0.17em}n &amp;= n^+ \\
f_{α^+}\kern{0.17em}n &amp;= f_α^n\kern{0.17em}n \\
f_{\text{lim}\kern{0.17em}g}\kern{0.17em}n &amp;= f_{g\kern{0.17em}n}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda"><a id="5736" class="Keyword">module</a> <a id="FGH"></a><a id="5743" href="Veblen.Basic.html#5743" class="Module">FGH</a> <a id="5747" class="Keyword">where</a>
  <a id="FGH.f"></a><a id="5755" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5757" class="Symbol">:</a> <a id="5759" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="5763" class="Symbol">→</a> <a id="5765" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5767" class="Symbol">→</a> <a id="5769" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="5773" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5775" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a> <a id="5780" href="Veblen.Basic.html#5780" class="Bound">n</a> <a id="5782" class="Symbol">=</a> <a id="5784" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5788" href="Veblen.Basic.html#5780" class="Bound">n</a>
  <a id="5792" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5794" class="Symbol">(</a><a id="5795" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="5799" href="Veblen.Basic.html#5799" class="Bound">α</a><a id="5800" class="Symbol">)</a> <a id="5802" href="Veblen.Basic.html#5802" class="Bound">n</a> <a id="5804" class="Symbol">=</a> <a id="5806" class="Symbol">(</a><a id="5807" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5809" href="Veblen.Basic.html#5799" class="Bound">α</a> <a id="5811" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="5814" href="Veblen.Basic.html#5802" class="Bound">n</a><a id="5815" class="Symbol">)</a> <a id="5817" href="Veblen.Basic.html#5802" class="Bound">n</a>
  <a id="5821" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5823" class="Symbol">(</a><a id="5824" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="5828" href="Veblen.Basic.html#5828" class="Bound">g</a><a id="5829" class="Symbol">)</a> <a id="5831" href="Veblen.Basic.html#5831" class="Bound">n</a> <a id="5833" class="Symbol">=</a> <a id="5835" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="5837" class="Symbol">(</a><a id="5838" href="Veblen.Basic.html#5828" class="Bound">g</a> <a id="5840" href="Veblen.Basic.html#5831" class="Bound">n</a><a id="5841" class="Symbol">)</a> <a id="5843" href="Veblen.Basic.html#5831" class="Bound">n</a>
</pre>
<p><strong>例</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_0\kern{0.17em}n &amp;= n^+ \\
f_1\kern{0.17em}n &amp;= 2n \\
f_2\kern{0.17em}n &amp;= 2^n\kern{0.17em}n
\end{aligned}
</span></p>
<p>这些等式的证明只需对 <span class="math inline">n</span> 进行归纳, 是显然的. 代码方面我们只写一些实例作为测试.</p>
<pre class="Agda">  <a id="FGH.f-0-2"></a><a id="6048" href="Veblen.Basic.html#6048" class="Function">f-0-2</a> <a id="6054" class="Symbol">:</a> <a id="6056" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6058" class="Number">0</a> <a id="6060" class="Number">2</a> <a id="6062" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6064" class="Number">3</a>
  <a id="6068" href="Veblen.Basic.html#6048" class="Function">f-0-2</a> <a id="6074" class="Symbol">=</a> <a id="6076" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-1-2"></a><a id="6084" href="Veblen.Basic.html#6084" class="Function">f-1-2</a> <a id="6090" class="Symbol">:</a> <a id="6092" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6094" class="Number">1</a> <a id="6096" class="Number">2</a> <a id="6098" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6100" class="Number">4</a>
  <a id="6104" href="Veblen.Basic.html#6084" class="Function">f-1-2</a> <a id="6110" class="Symbol">=</a> <a id="6112" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-2-2"></a><a id="6120" href="Veblen.Basic.html#6120" class="Function">f-2-2</a> <a id="6126" class="Symbol">:</a> <a id="6128" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6130" class="Number">2</a> <a id="6132" class="Number">2</a> <a id="6134" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6136" class="Number">8</a>
  <a id="6140" href="Veblen.Basic.html#6120" class="Function">f-2-2</a> <a id="6146" class="Symbol">=</a> <a id="6148" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math inline">f_3</span> 以上的表达式越来越复杂, 但不难计算实例如 <span class="math inline">f_{3}\kern{0.17em}2=2048</span>.</p>
<pre class="Agda">  <a id="FGH.f-3-2"></a><a id="6225" href="Veblen.Basic.html#6225" class="Function">f-3-2</a> <a id="6231" class="Symbol">:</a> <a id="6233" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6235" class="Number">3</a> <a id="6237" class="Number">2</a> <a id="6239" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6241" class="Number">2048</a>
  <a id="6248" href="Veblen.Basic.html#6225" class="Function">f-3-2</a> <a id="6254" class="Symbol">=</a> <a id="6256" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>引理</strong> 我们有</p>
<p><span class="math display">
\begin{aligned}
f_{\alpha^+}\kern{0.17em}n &amp;= f_\alpha^n\kern{0.17em}n \\
f_{ω}\kern{0.17em}n &amp;= f_{n}\kern{0.17em}n
\end{aligned}
</span></p>
<pre class="Agda">  <a id="FGH.f-suc"></a><a id="6426" href="Veblen.Basic.html#6426" class="Function">f-suc</a> <a id="6432" class="Symbol">:</a> <a id="6434" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6436" class="Symbol">(</a><a id="6437" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="6441" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="6442" class="Symbol">)</a> <a id="6444" href="Veblen.Basic.html#4258" class="Generalizable">n</a> <a id="6446" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6448" class="Symbol">(</a><a id="6449" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6451" href="Veblen.Basic.html#4240" class="Generalizable">α</a> <a id="6453" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="6456" href="Veblen.Basic.html#4258" class="Generalizable">n</a><a id="6457" class="Symbol">)</a> <a id="6459" href="Veblen.Basic.html#4258" class="Generalizable">n</a>
  <a id="6463" href="Veblen.Basic.html#6426" class="Function">f-suc</a> <a id="6469" class="Symbol">=</a> <a id="6471" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="FGH.f-ω"></a><a id="6479" href="Veblen.Basic.html#6479" class="Function">f-ω</a> <a id="6483" class="Symbol">:</a> <a id="6485" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6487" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="6489" href="Veblen.Basic.html#4258" class="Generalizable">n</a> <a id="6491" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6493" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6495" class="Symbol">(</a><a id="6496" href="Veblen.Basic.html#4514" class="Function">finord</a> <a id="6503" href="Veblen.Basic.html#4258" class="Generalizable">n</a><a id="6504" class="Symbol">)</a> <a id="6506" href="Veblen.Basic.html#4258" class="Generalizable">n</a>
  <a id="6510" href="Veblen.Basic.html#6479" class="Function">f-ω</a> <a id="6514" class="Symbol">=</a> <a id="6516" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 本文出现的大部分命题的证明都是「依定义即得」的, 体现为代码中的 <code>refl</code>. 也就是说, 证明都是直接展开定义, 不需要额外的推理. 但这并不意味着所有证明是显然的, 有时候递归定义的展开会非常复杂, 这时候我们会分步展开, 逐步化简, 但每一步都 <code>refl</code> 可证.</p>
<p><strong>定理</strong> 由以上两式不难看出</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}n = f_ω^n\kern{0.17em}n
</span></p>
<pre class="Agda">  <a id="FGH.f-ω⁺"></a><a id="6751" href="Veblen.Basic.html#6751" class="Function">f-ω⁺</a> <a id="6756" class="Symbol">:</a> <a id="6758" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6760" class="Symbol">(</a><a id="6761" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="6765" href="Veblen.Basic.html#4707" class="Function">ω</a><a id="6766" class="Symbol">)</a> <a id="6768" href="Veblen.Basic.html#4258" class="Generalizable">n</a> <a id="6770" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6772" class="Symbol">(</a><a id="6773" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="6775" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="6777" href="Veblen.Basic.html#5339" class="Function Operator">∘ⁿ</a> <a id="6780" href="Veblen.Basic.html#4258" class="Generalizable">n</a><a id="6781" class="Symbol">)</a> <a id="6783" href="Veblen.Basic.html#4258" class="Generalizable">n</a>
  <a id="6787" href="Veblen.Basic.html#6751" class="Function">f-ω⁺</a> <a id="6792" class="Symbol">=</a> <a id="6794" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>推论</strong> 特别地, 有</p>
<p><span class="math display">
f_{ω^+}\kern{0.17em}2 = f_ω\kern{0.17em}(f_ω\kern{0.17em}2)
</span></p>
<p>但此式无法在 Agda 中直接证明, 因为 Agda 想先把两边都算出再比较相等, 而这是不现实的. 如果有读者知道如何证明, 请打在评论区. 作为替代, 我们可以证明如下式子.</p>
<p><span class="math display">
f_{\alpha^+}\kern{0.17em}2 = f_\alpha\kern{0.17em}(f_\alpha\kern{0.17em}2)
</span></p>
<pre class="Agda">  <a id="FGH.f-suc-2"></a><a id="7069" href="Veblen.Basic.html#7069" class="Function">f-suc-2</a> <a id="7077" class="Symbol">:</a> <a id="7079" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="7081" class="Symbol">(</a><a id="7082" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="7086" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="7087" class="Symbol">)</a> <a id="7089" class="Number">2</a> <a id="7091" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7093" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="7095" href="Veblen.Basic.html#4240" class="Generalizable">α</a> <a id="7097" class="Symbol">(</a><a id="7098" href="Veblen.Basic.html#5755" class="Function">f</a> <a id="7100" href="Veblen.Basic.html#4240" class="Generalizable">α</a> <a id="7102" class="Number">2</a><a id="7103" class="Symbol">)</a>
  <a id="7107" href="Veblen.Basic.html#7069" class="Function">f-suc-2</a> <a id="7115" class="Symbol">=</a> <a id="7117" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>事实</strong> <span class="math inline">f_{ω^+} 64</span> 已经大于葛立恒数.</p>
<blockquote>
<p>从这里开始, 研究大数的数学就转变成了研究快速增长函数的数学, 进而转变成研究大的序数的数学.</p>
</blockquote>
<h2 id="序数的递归原理">序数的递归原理</h2>
<p>为了系统性的构造大序数, 我们先证明序数归纳法, 并由此得到序数的递归原理.</p>
<p><strong>定理 序数归纳法 (transfinite induction)</strong> 对于任意性质 <span class="math inline">P : \text{Ord} → \text{Set}</span>, 如果</p>
<ol type="1">
<li><span class="math inline">P\kern{0.17em}0</span> 成立,</li>
<li>对于任意序数 <span class="math inline">α</span>, 如果 <span class="math inline">P\kern{0.17em}α</span> 成立, 则 <span class="math inline">P\kern{0.17em}α^+</span> 成立,</li>
<li>对于任意基本列 <span class="math inline">f</span>, 如果对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立, 则 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立,</li>
</ol>
<p>则对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立.</p>
<pre class="Agda"><a id="ind"></a><a id="7594" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="7598" class="Symbol">:</a> <a id="7600" class="Symbol">{</a><a id="7601" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7603" class="Symbol">:</a> <a id="7605" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="7609" class="Symbol">→</a> <a id="7611" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="7614" class="Symbol">}</a>
  <a id="7618" class="Symbol">→</a> <a id="7620" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7622" class="InductiveConstructor">zero</a>
  <a id="7629" class="Symbol">→</a> <a id="7631" class="Symbol">(∀</a> <a id="7634" href="Veblen.Basic.html#7634" class="Bound">α</a> <a id="7636" class="Symbol">→</a> <a id="7638" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7640" href="Veblen.Basic.html#7634" class="Bound">α</a> <a id="7642" class="Symbol">→</a> <a id="7644" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7646" class="Symbol">(</a><a id="7647" class="InductiveConstructor">suc</a> <a id="7651" href="Veblen.Basic.html#7634" class="Bound">α</a><a id="7652" class="Symbol">))</a>
  <a id="7657" class="Symbol">→</a> <a id="7659" class="Symbol">(∀</a> <a id="7662" href="Veblen.Basic.html#7662" class="Bound">f</a> <a id="7664" class="Symbol">→</a> <a id="7666" class="Symbol">(∀</a> <a id="7669" href="Veblen.Basic.html#7669" class="Bound">n</a> <a id="7671" class="Symbol">→</a> <a id="7673" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7675" class="Symbol">(</a><a id="7676" href="Veblen.Basic.html#7662" class="Bound">f</a> <a id="7678" href="Veblen.Basic.html#7669" class="Bound">n</a><a id="7679" class="Symbol">))</a> <a id="7682" class="Symbol">→</a> <a id="7684" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7686" class="Symbol">(</a><a id="7687" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="7691" href="Veblen.Basic.html#7662" class="Bound">f</a><a id="7692" class="Symbol">))</a>
  <a id="7697" class="Symbol">→</a> <a id="7699" class="Symbol">∀</a> <a id="7701" href="Veblen.Basic.html#7701" class="Bound">α</a> <a id="7703" class="Symbol">→</a> <a id="7705" href="Veblen.Basic.html#7601" class="Bound">P</a> <a id="7707" href="Veblen.Basic.html#7701" class="Bound">α</a>
</pre>
<p><strong>(证明)</strong> 要证对于任意序数 <span class="math inline">α</span>, <span class="math inline">P\kern{0.17em}α</span> 成立. 归纳 <span class="math inline">α</span> 的三种情况.</p>
<ul>
<li>当 <span class="math inline">α=0</span> 时, 由条件1, <span class="math inline">P\kern{0.17em}0</span> 成立.</li>
<li>当 <span class="math inline">α=α^+</span> 时, 要证 <span class="math inline">P\,α^+</span> 成立. 由归纳假设, <span class="math inline">P\kern{0.17em}α</span> 成立. 由条件2, <span class="math inline">P\kern{0.17em}α^+</span> 成立.</li>
<li>当 <span class="math inline">α=\text{lim}\kern{0.17em}f</span> 时, 要证 <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. 由归纳假设, 对于任意自然数 <span class="math inline">n</span>, <span class="math inline">P\kern{0.17em}(f\kern{0.17em}n)</span> 成立. 由条件3, <span class="math inline">P\kern{0.17em}(\text{lim}\kern{0.17em}f)</span> 成立. ∎</li>
</ul>
<pre class="Agda"><a id="8113" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="8117" href="Veblen.Basic.html#8117" class="Bound">z</a> <a id="8119" href="Veblen.Basic.html#8119" class="Bound">s</a> <a id="8121" href="Veblen.Basic.html#8121" class="Bound">l</a> <a id="8123" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a> <a id="8128" class="Symbol">=</a> <a id="8130" href="Veblen.Basic.html#8117" class="Bound">z</a>
<a id="8132" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="8136" href="Veblen.Basic.html#8136" class="Bound">z</a> <a id="8138" href="Veblen.Basic.html#8138" class="Bound">s</a> <a id="8140" href="Veblen.Basic.html#8140" class="Bound">l</a> <a id="8142" class="Symbol">(</a><a id="8143" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="8147" href="Veblen.Basic.html#8147" class="Bound">α</a><a id="8148" class="Symbol">)</a> <a id="8150" class="Symbol">=</a> <a id="8152" href="Veblen.Basic.html#8138" class="Bound">s</a> <a id="8154" href="Veblen.Basic.html#8147" class="Bound">α</a> <a id="8156" class="Symbol">(</a><a id="8157" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="8161" href="Veblen.Basic.html#8136" class="Bound">z</a> <a id="8163" href="Veblen.Basic.html#8138" class="Bound">s</a> <a id="8165" href="Veblen.Basic.html#8140" class="Bound">l</a> <a id="8167" href="Veblen.Basic.html#8147" class="Bound">α</a><a id="8168" class="Symbol">)</a>
<a id="8170" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="8174" href="Veblen.Basic.html#8174" class="Bound">z</a> <a id="8176" href="Veblen.Basic.html#8176" class="Bound">s</a> <a id="8178" href="Veblen.Basic.html#8178" class="Bound">l</a> <a id="8180" class="Symbol">(</a><a id="8181" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="8185" href="Veblen.Basic.html#8185" class="Bound">f</a><a id="8186" class="Symbol">)</a> <a id="8188" class="Symbol">=</a> <a id="8190" href="Veblen.Basic.html#8178" class="Bound">l</a> <a id="8192" href="Veblen.Basic.html#8185" class="Bound">f</a> <a id="8194" class="Symbol">λ</a> <a id="8196" href="Veblen.Basic.html#8196" class="Bound">n</a> <a id="8198" class="Symbol">→</a> <a id="8200" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="8204" href="Veblen.Basic.html#8174" class="Bound">z</a> <a id="8206" href="Veblen.Basic.html#8176" class="Bound">s</a> <a id="8208" href="Veblen.Basic.html#8178" class="Bound">l</a> <a id="8210" class="Symbol">(</a><a id="8211" href="Veblen.Basic.html#8185" class="Bound">f</a> <a id="8213" href="Veblen.Basic.html#8196" class="Bound">n</a><a id="8214" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 这里看起来像是循环论证, 我们实际做的事情是从类型论承诺的规则中抽取出对 <span class="math inline">\text{Ord}</span> 单独适用的部分, 并固化为了一个高阶函数 <span class="math inline">\text{ind}</span>.</p>
<p><strong>定理 序数的递归原理 (transfinite recursion)</strong> 对于任意类型 <span class="math inline">A</span>, 函数 <span class="math inline">z : A</span>, <span class="math inline">s : A → A</span>, <span class="math inline">l : (ℕ → A) → A</span>, 和任意序数 <span class="math inline">α</span>, 存在唯一的 <span class="math inline">\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α : A</span>, 满足</p>
<p><span class="math display">
\begin{aligned}
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}0 &amp;= z \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α^+ &amp;= s\kern{0.17em}(\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}α) \\
\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= l\kern{0.17em}(λ\kern{0.17em}n,\text{rec}\kern{0.17em}z\kern{0.17em}s\kern{0.17em}l\kern{0.17em}(f\kern{0.17em}n))
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 令 <span class="math inline">P = λ\kern{0.17em}\_,A</span> 并应用序数归纳法即可. ∎</p>
<pre class="Agda"><a id="rec"></a><a id="9043" href="Veblen.Basic.html#9043" class="Function">rec</a> <a id="9047" class="Symbol">:</a> <a id="9049" href="Veblen.Basic.html#5176" class="Generalizable">A</a> <a id="9051" class="Symbol">→</a> <a id="9053" class="Symbol">(</a><a id="9054" href="Veblen.Basic.html#5176" class="Generalizable">A</a> <a id="9056" class="Symbol">→</a> <a id="9058" href="Veblen.Basic.html#5176" class="Generalizable">A</a><a id="9059" class="Symbol">)</a> <a id="9061" class="Symbol">→</a> <a id="9063" class="Symbol">((</a><a id="9065" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9067" class="Symbol">→</a> <a id="9069" href="Veblen.Basic.html#5176" class="Generalizable">A</a><a id="9070" class="Symbol">)</a> <a id="9072" class="Symbol">→</a> <a id="9074" href="Veblen.Basic.html#5176" class="Generalizable">A</a><a id="9075" class="Symbol">)</a> <a id="9077" class="Symbol">→</a> <a id="9079" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="9083" class="Symbol">→</a> <a id="9085" href="Veblen.Basic.html#5176" class="Generalizable">A</a>
<a id="9087" href="Veblen.Basic.html#9043" class="Function">rec</a> <a id="9091" href="Veblen.Basic.html#9091" class="Bound">z</a> <a id="9093" href="Veblen.Basic.html#9093" class="Bound">s</a> <a id="9095" href="Veblen.Basic.html#9095" class="Bound">l</a> <a id="9097" class="Symbol">=</a> <a id="9099" href="Veblen.Basic.html#7594" class="Function">ind</a> <a id="9103" href="Veblen.Basic.html#9091" class="Bound">z</a> <a id="9105" class="Symbol">(λ</a> <a id="9108" href="Veblen.Basic.html#9108" class="Bound">_</a> <a id="9110" class="Symbol">→</a> <a id="9112" href="Veblen.Basic.html#9093" class="Bound">s</a><a id="9113" class="Symbol">)</a> <a id="9115" class="Symbol">(λ</a> <a id="9118" href="Veblen.Basic.html#9118" class="Bound">_</a> <a id="9120" class="Symbol">→</a> <a id="9122" href="Veblen.Basic.html#9095" class="Bound">l</a><a id="9123" class="Symbol">)</a>
</pre>
<p><strong>注意</strong> 序数的递归原理和序数归纳法都可视作高阶函数, 递归原理是归纳法的特例.</p>
<p><strong>注意</strong> 序数的递归原理相当强大, 因为 <span class="math inline">A</span> 可以是任意类型, 包括函数类型 <span class="math inline">\text{Ord}\rightarrow\text{Ord}</span> 与 <span class="math inline">(\text{Ord}\rightarrow\text{Ord})\rightarrow(\text{Ord}\rightarrow\text{Ord})</span> 等, 也就是说它允许定义高阶函数的递归. 本文出现的所有大序数都由 <span class="math inline">\text{rec}</span> 定义.</p>
<h2 id="超限复合">超限复合</h2>
<p><strong>约定</strong> 我们用 <span class="math inline">F</span> 表示序数函数 <span class="math inline">\text{Ord} → \text{Ord}</span>, 用 <span class="math inline">f,g,h</span> 表示基本列 <span class="math inline">ℕ → \text{Ord}</span>.</p>
<pre class="Agda"><a id="9486" class="Keyword">variable</a>
  <a id="9497" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="9499" class="Symbol">:</a> <a id="9501" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="9505" class="Symbol">→</a> <a id="9507" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
  <a id="9513" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="9515" href="Veblen.Basic.html#9515" class="Generalizable">g</a> <a id="9517" href="Veblen.Basic.html#9517" class="Generalizable">h</a> <a id="9519" class="Symbol">:</a> <a id="9521" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9523" class="Symbol">→</a> <a id="9525" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
</pre>
<p><strong>定义</strong> 仿照函数 <span class="math inline">F : A → A</span> 的 <span class="math inline">n</span> 次复合 <span class="math inline">F^n</span>, 我们定义序数函数 <span class="math inline">F : \text{Ord} → \text{Ord}</span> 的 <span class="math inline">α</span> 次复合 <span class="math inline">F^α</span>, 但使用序数的递归原理 <span class="math inline">\text{rec}</span> 来定义.</p>
<p><span class="math display">
F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}\text{lim}\kern{0.17em}\alpha
</span></p>
<pre class="Agda"><a id="_∘^_"></a><a id="9788" href="Veblen.Basic.html#9788" class="Function Operator">_∘^_</a> <a id="9793" class="Symbol">:</a> <a id="9795" class="Symbol">(</a><a id="9796" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="9800" class="Symbol">→</a> <a id="9802" href="Veblen.Basic.html#3262" class="Datatype">Ord</a><a id="9805" class="Symbol">)</a> <a id="9807" class="Symbol">→</a> <a id="9809" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="9813" class="Symbol">→</a> <a id="9815" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="9819" class="Symbol">→</a> <a id="9821" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="9825" class="Symbol">(</a><a id="9826" href="Veblen.Basic.html#9826" class="Bound">F</a> <a id="9828" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="9831" href="Veblen.Basic.html#9831" class="Bound">α</a><a id="9832" class="Symbol">)</a> <a id="9834" href="Veblen.Basic.html#9834" class="Bound">β</a> <a id="9836" class="Symbol">=</a> <a id="9838" href="Veblen.Basic.html#9043" class="Function">rec</a> <a id="9842" href="Veblen.Basic.html#9834" class="Bound">β</a> <a id="9844" href="Veblen.Basic.html#9826" class="Bound">F</a> <a id="9846" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="9850" href="Veblen.Basic.html#9831" class="Bound">α</a>
</pre>
<p><strong>注意</strong> 该定义不是 <span class="math inline">F^\alpha\kern{0.17em}\beta=\text{rec}\kern{0.17em}\beta\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}\alpha)</span>, 此式有类型错误.</p>
<p>对于 <span class="math inline">\text{rec}</span> 的四个参数, 直观上</p>
<ul>
<li>第一个参数是初始值, 这里是 <span class="math inline">F^\alpha</span> 的输入 <span class="math inline">\beta</span>,</li>
<li>第二个参数是后继步骤, 需要指定递归迭代的函数, 这里递归迭代的就是 <span class="math inline">F</span>,</li>
<li>第三个参数是极限步骤, 需要指定将极限步对应的步骤基本列 <span class="math inline">λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta</span> 映射到序数的函数, 这里就是单纯地取其极限, 所以指定为 <span class="math inline">\text{lim}</span>,</li>
<li>第四个参数是递归的次数, 这里是 <span class="math inline">\alpha</span>.</li>
</ul>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
F^0 &amp;= \text{id} \\
F^{α^+} &amp;= F \circ F^α \\
F^{\text{lim}\kern{0.17em}f} &amp;= λ\kern{0.17em}\beta,\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta
\end{aligned}
</span></p>
<pre class="Agda"><a id="∘^-zero"></a><a id="10553" href="Veblen.Basic.html#10553" class="Function">∘^-zero</a> <a id="10561" class="Symbol">:</a> <a id="10563" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10565" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="10568" class="InductiveConstructor">zero</a> <a id="10573" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10575" href="Function.Base.html#704" class="Function">id</a>
<a id="10578" href="Veblen.Basic.html#10553" class="Function">∘^-zero</a> <a id="10586" class="Symbol">=</a> <a id="10588" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-suc"></a><a id="10594" href="Veblen.Basic.html#10594" class="Function">∘^-suc</a> <a id="10601" class="Symbol">:</a> <a id="10603" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10605" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="10608" class="InductiveConstructor">suc</a> <a id="10612" href="Veblen.Basic.html#4240" class="Generalizable">α</a> <a id="10614" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10616" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10618" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="10620" class="Symbol">(</a><a id="10621" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10623" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="10626" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="10627" class="Symbol">)</a>
<a id="10629" href="Veblen.Basic.html#10594" class="Function">∘^-suc</a> <a id="10636" class="Symbol">=</a> <a id="10638" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="∘^-lim"></a><a id="10644" href="Veblen.Basic.html#10644" class="Function">∘^-lim</a> <a id="10651" class="Symbol">:</a> <a id="10653" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10655" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="10658" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="10662" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="10664" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10666" class="Symbol">λ</a> <a id="10668" href="Veblen.Basic.html#10668" class="Bound">β</a> <a id="10670" class="Symbol">→</a> <a id="10672" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="10676" class="Symbol">λ</a> <a id="10678" href="Veblen.Basic.html#10678" class="Bound">n</a> <a id="10680" class="Symbol">→</a> <a id="10682" class="Symbol">(</a><a id="10683" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="10685" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="10688" class="Symbol">(</a><a id="10689" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="10691" href="Veblen.Basic.html#10678" class="Bound">n</a><a id="10692" class="Symbol">))</a> <a id="10695" href="Veblen.Basic.html#10668" class="Bound">β</a>
<a id="10697" href="Veblen.Basic.html#10644" class="Function">∘^-lim</a> <a id="10704" class="Symbol">=</a> <a id="10706" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> <span class="math inline">λ\kern{0.17em}\beta,\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}\kern{0.17em}\beta</span> 不能简化成 <span class="math inline">\text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}F^{f\kern{0.17em}n}</span>, 此式有类型错误.</p>
<h2 id="序数算术">序数算术</h2>
<p><strong>定义</strong> 从 <span class="math inline">α</span> 开始做 <span class="math inline">β</span> 次后继叫做序数加法, 记作 <span class="math inline">α+β</span>.</p>
<pre class="Agda"><a id="11012" class="Keyword">infixl</a> <a id="11019" class="Number">6</a> <a id="11021" href="Veblen.Basic.html#11025" class="Function Operator">_+_</a>
<a id="_+_"></a><a id="11025" href="Veblen.Basic.html#11025" class="Function Operator">_+_</a> <a id="11029" class="Symbol">:</a> <a id="11031" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11035" class="Symbol">→</a> <a id="11037" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11041" class="Symbol">→</a> <a id="11043" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="11047" href="Veblen.Basic.html#11047" class="Bound">α</a> <a id="11049" href="Veblen.Basic.html#11025" class="Function Operator">+</a> <a id="11051" href="Veblen.Basic.html#11051" class="Bound">β</a> <a id="11053" class="Symbol">=</a> <a id="11055" class="Symbol">(</a><a id="11056" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="11060" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="11063" href="Veblen.Basic.html#11051" class="Bound">β</a><a id="11064" class="Symbol">)</a> <a id="11066" href="Veblen.Basic.html#11047" class="Bound">α</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">0</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">+ α</span> 叫做序数乘法, 记作 <span class="math inline">α*β</span>.</p>
<pre class="Agda"><a id="11129" class="Keyword">infixl</a> <a id="11136" class="Number">7</a> <a id="11138" href="Veblen.Basic.html#11142" class="Function Operator">_*_</a>
<a id="_*_"></a><a id="11142" href="Veblen.Basic.html#11142" class="Function Operator">_*_</a> <a id="11146" class="Symbol">:</a> <a id="11148" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11152" class="Symbol">→</a> <a id="11154" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11158" class="Symbol">→</a> <a id="11160" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="11164" href="Veblen.Basic.html#11164" class="Bound">α</a> <a id="11166" href="Veblen.Basic.html#11142" class="Function Operator">*</a> <a id="11168" href="Veblen.Basic.html#11168" class="Bound">β</a> <a id="11170" class="Symbol">=</a> <a id="11172" class="Symbol">((</a><a id="11174" href="Veblen.Basic.html#11025" class="Function Operator">_+</a> <a id="11177" href="Veblen.Basic.html#11164" class="Bound">α</a><a id="11178" class="Symbol">)</a> <a id="11180" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="11183" href="Veblen.Basic.html#11168" class="Bound">β</a><a id="11184" class="Symbol">)</a> <a id="11186" class="Number">0</a>
</pre>
<p><strong>定义</strong> 从 <span class="math inline">1</span> 开始做 <span class="math inline">β</span> 次 <span class="math inline">* α</span> 叫做序数幂, 记作 <span class="math inline">α^β</span>.</p>
<pre class="Agda"><a id="11248" class="Keyword">infix</a> <a id="11254" class="Number">8</a> <a id="11256" href="Veblen.Basic.html#11260" class="Function Operator">_^_</a>
<a id="_^_"></a><a id="11260" href="Veblen.Basic.html#11260" class="Function Operator">_^_</a> <a id="11264" class="Symbol">:</a> <a id="11266" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11270" class="Symbol">→</a> <a id="11272" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11276" class="Symbol">→</a> <a id="11278" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="11282" href="Veblen.Basic.html#11282" class="Bound">α</a> <a id="11284" href="Veblen.Basic.html#11260" class="Function Operator">^</a> <a id="11286" href="Veblen.Basic.html#11286" class="Bound">β</a> <a id="11288" class="Symbol">=</a> <a id="11290" class="Symbol">((</a><a id="11292" href="Veblen.Basic.html#11142" class="Function Operator">_*</a> <a id="11295" href="Veblen.Basic.html#11282" class="Bound">α</a><a id="11296" class="Symbol">)</a> <a id="11298" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="11301" href="Veblen.Basic.html#11286" class="Bound">β</a><a id="11302" class="Symbol">)</a> <a id="11304" class="Number">1</a>
</pre>
<p>关于为什么不能定义序数的第四级运算的原因可以参看<a href="https://zhuanlan.zhihu.com/p/580526275">Agda大序数(6) 迭代幂次</a>.</p>
<h2 id="三大高阶函数">三大高阶函数</h2>
<p>Veblen层级的构造需要三个重要的高阶函数</p>
<ol type="1">
<li>无穷迭代 <span class="math inline">λF,F^\omega</span></li>
<li>跳出运算 <span class="math inline">\text{jump}</span></li>
<li>不动点的枚举 <span class="math inline">\text{fixpt}</span></li>
</ol>
<p>它们都具有类型 <span class="math inline">(\text{Ord}→\text{Ord})→(\text{Ord}→\text{Ord})</span>.</p>
<h3 id="无穷迭代">无穷迭代</h3>
<p><strong>定义</strong> 我们称 <span class="math inline">F</span> 的 <span class="math inline">\omega</span> 次复合 <span class="math inline">F^\omega</span> 为 <span class="math inline">F</span> 的无穷迭代.</p>
<pre class="Agda"><a id="iterω"></a><a id="11633" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="11639" class="Symbol">:</a> <a id="11641" class="Symbol">(</a><a id="11642" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11646" class="Symbol">→</a> <a id="11648" href="Veblen.Basic.html#3262" class="Datatype">Ord</a><a id="11651" class="Symbol">)</a> <a id="11653" class="Symbol">→</a> <a id="11655" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="11659" class="Symbol">→</a> <a id="11661" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="11665" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="11671" href="Veblen.Basic.html#11671" class="Bound">F</a> <a id="11673" class="Symbol">=</a> <a id="11675" href="Veblen.Basic.html#11671" class="Bound">F</a> <a id="11677" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="11680" href="Veblen.Basic.html#4707" class="Function">ω</a>
</pre>
<h3 id="跳出运算">跳出运算</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span> 和迭代次数 <span class="math inline">α</span>, 从 <span class="math inline">F\kern{0.17em}0</span> 开始, 每次迭代时先做一次后继再迭代 <span class="math inline">F</span>, 总共迭代 <span class="math inline">α</span> 次的运算叫做 <span class="math inline">F</span> 的 <span class="math inline">α</span> 次跳出, 记作 <span class="math inline">\text{jump}\kern{0.17em}F\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{jump}\kern{0.17em}F\kern{0.17em}α := (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}0)
</span></p>
<pre class="Agda"><a id="jump"></a><a id="11996" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="12001" class="Symbol">:</a> <a id="12003" class="Symbol">(</a><a id="12004" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="12008" class="Symbol">→</a> <a id="12010" href="Veblen.Basic.html#3262" class="Datatype">Ord</a><a id="12013" class="Symbol">)</a> <a id="12015" class="Symbol">→</a> <a id="12017" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="12021" class="Symbol">→</a> <a id="12023" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="12027" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="12032" href="Veblen.Basic.html#12032" class="Bound">F</a> <a id="12034" href="Veblen.Basic.html#12034" class="Bound">α</a> <a id="12036" class="Symbol">=</a> <a id="12038" class="Symbol">((</a><a id="12040" href="Veblen.Basic.html#12032" class="Bound">F</a> <a id="12042" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="12044" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a><a id="12047" class="Symbol">)</a> <a id="12049" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="12052" href="Veblen.Basic.html#12034" class="Bound">α</a><a id="12053" class="Symbol">)</a> <a id="12055" class="Symbol">(</a><a id="12056" href="Veblen.Basic.html#12032" class="Bound">F</a> <a id="12058" class="Number">0</a><a id="12059" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}0 &amp;= F\kern{0.17em}0 \\
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{jump}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{jump}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<p><strong>(证明)</strong> 零和极限的情况是显然的. 对于后继的情况, 有</p>
<p><span class="math display">
\begin{aligned}
\text{jump}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= (F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^{α^+}\kern{0.17em}(F\kern{0.17em}0) \\
&amp;= (F\kern{0.17em}\circ\kern{0.17em}\text{suc})((F\kern{0.17em}\circ\kern{0.17em}\text{suc})\kern{0.17em}^α\kern{0.17em}(F\kern{0.17em}0)) \\
&amp;= F\kern{0.17em}(\text{jump}\kern{0.17em}F\kern{0.17em}α)^+
\end{aligned}
</span></p>
<p>∎</p>
<pre class="Agda"><a id="jump-0"></a><a id="12904" href="Veblen.Basic.html#12904" class="Function">jump-0</a> <a id="12911" class="Symbol">:</a> <a id="12913" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="12918" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="12920" class="Number">0</a> <a id="12922" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12924" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="12926" class="Number">0</a>
<a id="12928" href="Veblen.Basic.html#12904" class="Function">jump-0</a> <a id="12935" class="Symbol">=</a> <a id="12937" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="jump-suc"></a><a id="12943" href="Veblen.Basic.html#12943" class="Function">jump-suc</a> <a id="12952" class="Symbol">:</a> <a id="12954" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="12959" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="12961" class="Symbol">(</a><a id="12962" class="InductiveConstructor">suc</a> <a id="12966" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="12967" class="Symbol">)</a> <a id="12969" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12971" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="12973" class="Symbol">(</a><a id="12974" class="InductiveConstructor">suc</a> <a id="12978" class="Symbol">(</a><a id="12979" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="12984" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="12986" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="12987" class="Symbol">))</a>
<a id="12990" href="Veblen.Basic.html#12943" class="Function">jump-suc</a> <a id="12999" class="Symbol">{</a><a id="13000" href="Veblen.Basic.html#13000" class="Bound">F</a><a id="13001" class="Symbol">}</a> <a id="13003" class="Symbol">{</a><a id="13004" href="Veblen.Basic.html#13004" class="Bound">α</a><a id="13005" class="Symbol">}</a> <a id="13007" class="Symbol">=</a> <a id="13009" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
  <a id="13017" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="13022" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13024" class="Symbol">(</a><a id="13025" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="13029" href="Veblen.Basic.html#13004" class="Bound">α</a><a id="13030" class="Symbol">)</a>                        <a id="13055" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="13061" class="Symbol">((</a><a id="13063" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13065" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="13067" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a><a id="13070" class="Symbol">)</a> <a id="13072" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="13075" class="Symbol">(</a><a id="13076" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="13080" href="Veblen.Basic.html#13004" class="Bound">α</a><a id="13081" class="Symbol">))</a> <a id="13084" class="Symbol">(</a><a id="13085" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13087" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a><a id="13091" class="Symbol">)</a>       <a id="13099" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="13105" class="Symbol">(</a><a id="13106" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13108" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="13110" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a><a id="13113" class="Symbol">)</a> <a id="13115" class="Symbol">(((</a><a id="13118" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13120" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="13122" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a><a id="13125" class="Symbol">)</a> <a id="13127" href="Veblen.Basic.html#9788" class="Function Operator">∘^</a> <a id="13130" href="Veblen.Basic.html#13004" class="Bound">α</a><a id="13131" class="Symbol">)</a> <a id="13133" class="Symbol">(</a><a id="13134" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13136" href="Veblen.Basic.html#3280" class="InductiveConstructor">zero</a><a id="13140" class="Symbol">))</a> <a id="13143" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
  <a id="13149" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13151" class="Symbol">(</a><a id="13152" href="Veblen.Basic.html#3293" class="InductiveConstructor">suc</a> <a id="13156" class="Symbol">(</a><a id="13157" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="13162" href="Veblen.Basic.html#13000" class="Bound">F</a> <a id="13164" href="Veblen.Basic.html#13004" class="Bound">α</a><a id="13165" class="Symbol">))</a>                    <a id="13187" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>

<a id="jump-lim"></a><a id="13190" href="Veblen.Basic.html#13190" class="Function">jump-lim</a> <a id="13199" class="Symbol">:</a> <a id="13201" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="13206" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="13208" class="Symbol">(</a><a id="13209" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="13213" href="Veblen.Basic.html#9513" class="Generalizable">f</a><a id="13214" class="Symbol">)</a> <a id="13216" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13218" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="13222" class="Symbol">λ</a> <a id="13224" href="Veblen.Basic.html#13224" class="Bound">n</a> <a id="13226" class="Symbol">→</a> <a id="13228" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="13233" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="13235" class="Symbol">(</a><a id="13236" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="13238" href="Veblen.Basic.html#13224" class="Bound">n</a><a id="13239" class="Symbol">)</a>
<a id="13241" href="Veblen.Basic.html#13190" class="Function">jump-lim</a> <a id="13250" class="Symbol">=</a> <a id="13252" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="不动点的枚举">不动点的枚举</h3>
<p><strong>定义</strong> 给定序数函数 <span class="math inline">F</span>, 我们定义 <span class="math inline">F</span> 的第 <span class="math inline">α</span> 个不动点 <span class="math inline">\text{fixpt}\kern{0.17em}F\kern{0.17em}α</span> 为 <span class="math inline">F^\omega</span> 的第 <span class="math inline">α</span> 个跳出 <span class="math inline">\text{jump}\kern{0.17em}(F^\omega)\kern{0.17em}α</span>.</p>
<p><span class="math display">
\text{fixpt}\kern{0.17em}F := \text{jump}\kern{0.17em}(F^\omega)
</span></p>
<pre class="Agda"><a id="fixpt"></a><a id="13514" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="13520" class="Symbol">:</a> <a id="13522" class="Symbol">(</a><a id="13523" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="13527" class="Symbol">→</a> <a id="13529" href="Veblen.Basic.html#3262" class="Datatype">Ord</a><a id="13532" class="Symbol">)</a> <a id="13534" class="Symbol">→</a> <a id="13536" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="13540" class="Symbol">→</a> <a id="13542" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="13546" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="13552" href="Veblen.Basic.html#13552" class="Bound">F</a> <a id="13554" class="Symbol">=</a> <a id="13556" href="Veblen.Basic.html#11996" class="Function">jump</a> <a id="13561" class="Symbol">(</a><a id="13562" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="13568" href="Veblen.Basic.html#13552" class="Bound">F</a><a id="13569" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\text{fixpt}\kern{0.17em}F\kern{0.17em}0 &amp;= F^\omega\kern{0.17em}0 \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(α^+) &amp;= F^\omega\kern{0.17em}(\text{fixpt}\kern{0.17em}F\kern{0.17em}α)^+ \\
\text{fixpt}\kern{0.17em}F\kern{0.17em}(\text{lim}\kern{0.17em}f) &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\text{fixpt}\kern{0.17em}F\kern{0.17em}(f\kern{0.17em}n)
\end{aligned}
</span></p>
<pre class="Agda"><a id="fixpt-0"></a><a id="14012" href="Veblen.Basic.html#14012" class="Function">fixpt-0</a> <a id="14020" class="Symbol">:</a> <a id="14022" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14028" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14030" class="Number">0</a> <a id="14032" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14034" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="14040" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14042" class="Number">0</a>
<a id="14044" href="Veblen.Basic.html#14012" class="Function">fixpt-0</a> <a id="14052" class="Symbol">=</a> <a id="14054" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-suc"></a><a id="14060" href="Veblen.Basic.html#14060" class="Function">fixpt-suc</a> <a id="14070" class="Symbol">:</a> <a id="14072" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14078" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14080" class="Symbol">(</a><a id="14081" class="InductiveConstructor">suc</a> <a id="14085" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="14086" class="Symbol">)</a> <a id="14088" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14090" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="14096" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14098" class="Symbol">(</a><a id="14099" class="InductiveConstructor">suc</a> <a id="14103" class="Symbol">(</a><a id="14104" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14110" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14112" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="14113" class="Symbol">))</a>
<a id="14116" href="Veblen.Basic.html#14060" class="Function">fixpt-suc</a> <a id="14126" class="Symbol">{</a><a id="14127" href="Veblen.Basic.html#14127" class="Bound">F</a><a id="14128" class="Symbol">}</a> <a id="14130" class="Symbol">{</a><a id="14131" href="Veblen.Basic.html#14131" class="Bound">α</a><a id="14132" class="Symbol">}</a> <a id="14134" class="Symbol">=</a> <a id="14136" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="fixpt-lim"></a><a id="14142" href="Veblen.Basic.html#14142" class="Function">fixpt-lim</a> <a id="14152" class="Symbol">:</a> <a id="14154" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14160" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14162" class="Symbol">(</a><a id="14163" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="14167" href="Veblen.Basic.html#9513" class="Generalizable">f</a><a id="14168" class="Symbol">)</a> <a id="14170" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14172" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="14176" class="Symbol">λ</a> <a id="14178" href="Veblen.Basic.html#14178" class="Bound">n</a> <a id="14180" class="Symbol">→</a> <a id="14182" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14188" href="Veblen.Basic.html#9497" class="Generalizable">F</a> <a id="14190" class="Symbol">(</a><a id="14191" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="14193" href="Veblen.Basic.html#14178" class="Bound">n</a><a id="14194" class="Symbol">)</a>
<a id="14196" href="Veblen.Basic.html#14142" class="Function">fixpt-lim</a> <a id="14206" class="Symbol">=</a> <a id="14208" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>注意</strong> 跳出运算并非一定搭配无穷迭代使用, 但一定会搭配极限使用. 后面我们会看到多种 <span class="math inline">\text{lim}</span> 的情况需要跳出, 以提高增长率.</p>
<h2 id="ε-ζ-η-层级">ε， ζ， η 层级</h2>
<p>我们定义三个序数函数 <span class="math inline">\varepsilon, \zeta, \eta</span> 如下.</p>
<p><strong>定义</strong> <span class="math inline">\varepsilon</span> 是函数 <span class="math inline">λα,ω^α</span> 的不动点枚举</p>
<p><span class="math display">
ε := \text{fixpt}\kern{0.17em}λα,ω\kern{0.17em}^α
</span></p>
<pre class="Agda"><a id="ε"></a><a id="14461" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="14463" class="Symbol">:</a> <a id="14465" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="14469" class="Symbol">→</a> <a id="14471" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="14475" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="14477" class="Symbol">=</a> <a id="14479" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="14485" class="Symbol">(</a><a id="14486" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="14488" href="Veblen.Basic.html#11260" class="Function Operator">^_</a><a id="14490" class="Symbol">)</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\varepsilon_0 &amp;= (λα,ω^α)^ω\kern{0.17em}0 =
ω^{ω^{⋰^{ω^0}}}
\\
\varepsilon_{α^+} &amp;= (λα,ω^α)^ω\kern{0.17em}({ε_α}^+) =
ω^{ω^{⋰^{ω^{({ε_α}^+)}}}}
\\
\varepsilon_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\varepsilon_{f\kern{0.17em}n} = \text{lim}(ε_{f\kern{0.17em}0},ε_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<pre class="Agda"><a id="ε-0"></a><a id="14900" href="Veblen.Basic.html#14900" class="Function">ε-0</a> <a id="14904" class="Symbol">:</a> <a id="14906" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="14908" class="Number">0</a> <a id="14910" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14912" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="14918" class="Symbol">(</a><a id="14919" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="14921" href="Veblen.Basic.html#11260" class="Function Operator">^_</a><a id="14923" class="Symbol">)</a> <a id="14925" class="Number">0</a>
<a id="14927" href="Veblen.Basic.html#14900" class="Function">ε-0</a> <a id="14931" class="Symbol">=</a> <a id="14933" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-suc"></a><a id="14939" href="Veblen.Basic.html#14939" class="Function">ε-suc</a> <a id="14945" class="Symbol">:</a> <a id="14947" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="14949" class="Symbol">(</a><a id="14950" class="InductiveConstructor">suc</a> <a id="14954" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="14955" class="Symbol">)</a> <a id="14957" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="14959" href="Veblen.Basic.html#11633" class="Function">iterω</a> <a id="14965" class="Symbol">(</a><a id="14966" href="Veblen.Basic.html#4707" class="Function">ω</a> <a id="14968" href="Veblen.Basic.html#11260" class="Function Operator">^_</a><a id="14970" class="Symbol">)</a> <a id="14972" class="Symbol">(</a><a id="14973" class="InductiveConstructor">suc</a> <a id="14977" class="Symbol">(</a><a id="14978" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="14980" href="Veblen.Basic.html#4240" class="Generalizable">α</a><a id="14981" class="Symbol">))</a>
<a id="14984" href="Veblen.Basic.html#14939" class="Function">ε-suc</a> <a id="14990" class="Symbol">=</a> <a id="14992" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ε-lim"></a><a id="14998" href="Veblen.Basic.html#14998" class="Function">ε-lim</a> <a id="15004" class="Symbol">:</a> <a id="15006" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="15008" class="Symbol">(</a><a id="15009" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="15013" href="Veblen.Basic.html#9513" class="Generalizable">f</a><a id="15014" class="Symbol">)</a> <a id="15016" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15018" href="Veblen.Basic.html#3312" class="InductiveConstructor">lim</a> <a id="15022" class="Symbol">λ</a> <a id="15024" href="Veblen.Basic.html#15024" class="Bound">n</a> <a id="15026" class="Symbol">→</a> <a id="15028" href="Veblen.Basic.html#14461" class="Function">ε</a> <a id="15030" class="Symbol">(</a><a id="15031" href="Veblen.Basic.html#9513" class="Generalizable">f</a> <a id="15033" href="Veblen.Basic.html#15024" class="Bound">n</a><a id="15034" class="Symbol">)</a>
<a id="15036" href="Veblen.Basic.html#14998" class="Function">ε-lim</a> <a id="15042" class="Symbol">=</a> <a id="15044" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong>定义</strong> <span class="math inline">\zeta</span> 是 <span class="math inline">ε</span> 的不动点枚举</p>
<p><span class="math display">
ζ := \text{fixpt}\kern{0.17em}ε
</span></p>
<pre class="Agda"><a id="ζ"></a><a id="15130" href="Veblen.Basic.html#15130" class="Function">ζ</a> <a id="15132" class="Symbol">:</a> <a id="15134" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="15138" class="Symbol">→</a> <a id="15140" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="15144" href="Veblen.Basic.html#15130" class="Function">ζ</a> <a id="15146" class="Symbol">=</a> <a id="15148" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="15154" href="Veblen.Basic.html#14461" class="Function">ε</a>
</pre>
<p><strong>定理</strong> 依定义有</p>
<p><span class="math display">
\begin{aligned}
\zeta_0 &amp;= ε^ω\kern{0.17em}0 =
ε_{ε_{⋱_{ε_0}}}
\\
\zeta_{α^+} &amp;= ε^ω\kern{0.17em}({\zeta_α}^+) =
ε_{ε_{⋱_{({\zeta_α}^+)}}}
\\
\zeta_{\text{lim}\kern{0.17em}f} &amp;= \text{lim}\kern{0.17em}λ\kern{0.17em}n\kern{0.17em},\kern{0.17em}\zeta_{f\kern{0.17em}n} = \text{lim}(ζ_{f\kern{0.17em}0},ζ_{f\kern{0.17em}1},...)
\end{aligned}
</span></p>
<p><strong>定义</strong> <span class="math inline">\eta</span> 是 <span class="math inline">\zeta</span> 的不动点枚举</p>
<p><span class="math display">
η := \text{fixpt}\kern{0.17em}ζ
</span></p>
<pre class="Agda"><a id="η"></a><a id="15599" href="Veblen.Basic.html#15599" class="Function">η</a> <a id="15601" class="Symbol">:</a> <a id="15603" href="Veblen.Basic.html#3262" class="Datatype">Ord</a> <a id="15607" class="Symbol">→</a> <a id="15609" href="Veblen.Basic.html#3262" class="Datatype">Ord</a>
<a id="15613" href="Veblen.Basic.html#15599" class="Function">η</a> <a id="15615" class="Symbol">=</a> <a id="15617" href="Veblen.Basic.html#13514" class="Function">fixpt</a> <a id="15623" href="Veblen.Basic.html#15130" class="Function">ζ</a>
</pre>
<p><strong>例</strong> 一个很大的大数:</p>
<p><span class="math display">
\text{oom} := f_{η_0} 99 = f_{
  ζ_{ζ_{⋱_{ζ_0}}}
}99
</span></p>
<p>其中 <span class="math inline">ζ_{ζ_{⋱_{ζ_0}}}</span> 是从 <span class="math inline">ζ_0</span> 开始迭代了 99 次 <span class="math inline">ζ</span>.</p>
<pre class="Agda"><a id="oom"></a><a id="15761" href="Veblen.Basic.html#15761" class="Function">oom</a> <a id="15765" class="Symbol">=</a> <a id="15767" href="Veblen.Basic.html#5755" class="Function">FGH.f</a> <a id="15773" class="Symbol">(</a><a id="15774" href="Veblen.Basic.html#15599" class="Function">η</a> <a id="15776" class="Number">0</a><a id="15777" class="Symbol">)</a> <a id="15779" class="Number">99</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
