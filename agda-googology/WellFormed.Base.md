---
title: 形式化大数数学 (2.0 - 良构树序数)
zhihu-tags: Agda, 大数数学, 序数
zhihu-url: https://zhuanlan.zhihu.com/p/711649863
---

# 形式化大数数学 (2.0 - 良构树序数)

> 交流Q群: 893531731  
> 本文源码: [Base.lagda.md](https://github.com/choukh/agda-googology/blob/main/src/WellFormed/Base.lagda.md)  
> 高亮渲染: [Base.html](https://choukh.github.io/agda-googology/WellFormed.Base.html)  

本系列文章致力于可运行且保证停机的大数计算程序的文学编程. 我们在[第一章](https://zhuanlan.zhihu.com/p/707713300)定义出了 [LVO](https://googology.fandom.com/wiki/Large_Veblen_ordinal), 接下来计划介绍[序数崩塌函数 (OCF)](https://googology.fandom.com/wiki/Ordinal_collapsing_function).
如果希望用这套方法走得比较远的话 (比如达到 [EBO](https://googology.fandom.com/wiki/Extended_Buchholz's_function)), 那么对基础理论有较高的要求. 我们需要从底层定义开始, 把严格性再提高一个档次, 因此会先花费相当大的篇幅构建良构树序数相关的理论.

## 基础的选取

我们发现对于 EBO 的定义, [函数外延性](https://ncatlab.org/nlab/show/function+extensionality), [证明无关性](https://ncatlab.org/nlab/show/proof+relevance)以及特定命题到集合的[大消去](https://cstheory.stackexchange.com/questions/40339/what-exactly-is-large-elimination)似乎是不可或缺的. 同伦类型论 (HoTT) 可以优雅地满足这三个需求, 因此我们采用它的一个Agda版本——立方类型论 (Cubical Agda) 作为数学基础. 采用 HoTT 作为基础的另一个好处是, [泛等原理](https://ncatlab.org/nlab/show/univalent+foundations+for+mathematics)将帮助我们省去一部分重复代码, 这在后篇可以看到.

<pre class="Agda"><a id="1208" class="Symbol">{-#</a> <a id="1212" class="Keyword">OPTIONS</a> <a id="1220" class="Pragma">--safe</a> <a id="1227" class="Pragma">--cubical</a> <a id="1237" class="Symbol">#-}</a>
<a id="1241" class="Keyword">module</a> <a id="1248" href="WellFormed.Base.html" class="Module">WellFormed.Base</a> <a id="1264" class="Keyword">where</a>
</pre>
### 库依赖

我们采用[命题相等](https://ncatlab.org/nlab/show/propositional+equality)作为主要使用的[同一性概念](https://ncatlab.org/nlab/show/equality), 而[道路类型 (path type)](https://ncatlab.org/nlab/show/path+type) 只作为一个辅助. 在 HoTT 中这两者是等价的, 但分情况使用可以简化证明. 命题相等的相关引理的道路版本会带上命名空间 `🧊` ([冰立方](https://emojipedia.org/zh/%E5%86%B0%E5%9D%97)) 以示区别. 它来源于立方类型论不像 HoTT 那么热 (hot), 而是冷的, 所以是冰立方. 知乎正文无法显示颜文字, 所以只会留下一个空格, 不过没关系, 只需视作函数重载.

**Cubical库**

<pre class="Agda"><a id="1698" class="Keyword">open</a> <a id="1703" class="Keyword">import</a> <a id="1710" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="1738" class="Symbol">as</a> <a id="1741" class="Module">🧊</a> <a id="1743" class="Keyword">public</a>
  <a id="1752" class="Keyword">hiding</a> <a id="1759" class="Symbol">(</a><a id="1760" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">_≡_</a><a id="1763" class="Symbol">;</a> <a id="1765" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a><a id="1769" class="Symbol">;</a> <a id="1771" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a><a id="1774" class="Symbol">;</a> <a id="1776" href="Cubical.Foundations.Prelude.html#1430" class="Function">cong</a><a id="1780" class="Symbol">;</a> <a id="1782" href="Cubical.Foundations.Prelude.html#2025" class="Function">cong₂</a><a id="1787" class="Symbol">;</a> <a id="1789" href="Cubical.Foundations.Prelude.html#9486" class="Function">subst</a><a id="1794" class="Symbol">;</a> <a id="1796" href="Cubical.Foundations.Prelude.html#8857" class="Function Operator">_∎</a><a id="1798" class="Symbol">)</a>
<a id="1800" class="Keyword">open</a> <a id="1805" class="Keyword">import</a> <a id="1812" href="Cubical.Data.Equality.html" class="Module">Cubical.Data.Equality</a> <a id="1834" class="Keyword">public</a>
  <a id="1843" class="Keyword">using</a> <a id="1849" class="Symbol">(</a><a id="1850" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a><a id="1858" class="Symbol">;</a> <a id="1860" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a><a id="1868" class="Symbol">;</a> <a id="1870" href="Cubical.Data.Equality.Conversion.html#2530" class="Function">PathPathEq</a><a id="1880" class="Symbol">)</a>
<a id="1882" class="Keyword">open</a> <a id="1887" class="Keyword">import</a> <a id="1894" href="Cubical.Data.Sigma.html" class="Module">Cubical.Data.Sigma</a> <a id="1913" class="Keyword">public</a>
  <a id="1922" class="Keyword">using</a> <a id="1928" class="Symbol">(</a><a id="1929" href="Cubical.Core.Primitives.html#6268" class="Function">Σ-syntax</a><a id="1937" class="Symbol">;</a> <a id="1939" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">_×_</a><a id="1942" class="Symbol">;</a> <a id="1944" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="1947" class="Symbol">;</a> <a id="1949" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="1952" class="Symbol">;</a> <a id="1954" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="1957" class="Symbol">;</a> <a id="1959" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a><a id="1965" class="Symbol">)</a>
<a id="1967" class="Keyword">open</a> <a id="1972" class="Keyword">import</a> <a id="1979" href="Cubical.HITs.PropositionalTruncation.html" class="Module">Cubical.HITs.PropositionalTruncation</a> <a id="2016" class="Keyword">public</a>
  <a id="2025" class="Keyword">using</a> <a id="2031" class="Symbol">(</a><a id="2032" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥_∥₁</a><a id="2036" class="Symbol">;</a> <a id="2038" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="2042" class="Symbol">;</a> <a id="2044" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a><a id="2051" class="Symbol">;</a> <a id="2053" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a><a id="2056" class="Symbol">;</a> <a id="2058" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a><a id="2062" class="Symbol">;</a> <a id="2064" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a><a id="2067" class="Symbol">;</a> <a id="2069" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">map2</a><a id="2073" class="Symbol">;</a> <a id="2075" href="Cubical.HITs.PropositionalTruncation.Properties.html#7028" class="Function">rec→Set</a><a id="2082" class="Symbol">)</a>
</pre>
**标准库**

<pre class="Agda"><a id="2106" class="Keyword">open</a> <a id="2111" class="Keyword">import</a> <a id="2118" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2127" class="Symbol">as</a> <a id="2130" class="Module">ℕ</a> <a id="2132" class="Keyword">public</a> <a id="2139" class="Keyword">using</a> <a id="2145" class="Symbol">(</a><a id="2146" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2147" class="Symbol">;</a> <a id="2149" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2153" class="Symbol">;</a> <a id="2155" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="2158" class="Symbol">)</a>
<a id="2160" class="Keyword">open</a> <a id="2165" class="Keyword">import</a> <a id="2172" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="2192" class="Symbol">as</a> <a id="2195" class="Module">ℕ</a> <a id="2197" class="Keyword">public</a> <a id="2204" class="Keyword">using</a> <a id="2210" class="Symbol">(</a><a id="2211" href="Data.Nat.Properties.html#10543" class="Function">&lt;-cmp</a><a id="2216" class="Symbol">)</a>
<a id="2218" class="Keyword">open</a> <a id="2223" class="Keyword">import</a> <a id="2230" href="Function.html" class="Module">Function</a> <a id="2239" class="Keyword">public</a> <a id="2246" class="Keyword">using</a> <a id="2252" class="Symbol">(</a><a id="2253" href="Function.Base.html#704" class="Function">id</a><a id="2255" class="Symbol">;</a> <a id="2257" href="Function.Base.html#1638" class="Function">flip</a><a id="2261" class="Symbol">;</a> <a id="2263" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="2266" class="Symbol">;</a> <a id="2268" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="2271" class="Symbol">;</a> <a id="2273" href="Function.Base.html#4486" class="Function Operator">_∋_</a><a id="2276" class="Symbol">;</a> <a id="2278" href="Function.Base.html#4736" class="Function">it</a><a id="2280" class="Symbol">;</a> <a id="2282" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="2290" class="Symbol">)</a>
<a id="2292" class="Keyword">open</a> <a id="2297" class="Keyword">import</a> <a id="2304" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2342" class="Keyword">public</a>
  <a id="2351" class="Keyword">using</a> <a id="2357" class="Symbol">(</a><a id="2358" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2361" class="Symbol">;</a> <a id="2363" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2367" class="Symbol">;</a> <a id="2369" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a><a id="2372" class="Symbol">;</a> <a id="2374" href="Relation.Binary.PropositionalEquality.Core.html#1757" class="Function">trans</a><a id="2379" class="Symbol">;</a> <a id="2381" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a><a id="2385" class="Symbol">;</a> <a id="2387" href="Relation.Binary.PropositionalEquality.Core.html#1808" class="Function">subst</a><a id="2392" class="Symbol">)</a>
</pre>
**桥接库**

用于处理Cubical库与标准库混用时的一些问题.

<pre class="Agda"><a id="2443" class="Keyword">open</a> <a id="2448" class="Keyword">import</a> <a id="2455" href="Bridged.Data.Empty.html" class="Module">Bridged.Data.Empty</a> <a id="2474" class="Keyword">public</a> <a id="2481" class="Keyword">using</a> <a id="2487" class="Symbol">(</a><a id="2488" href="Data.Empty.html#895" class="Function">⊥</a><a id="2489" class="Symbol">;</a> <a id="2491" href="Data.Empty.html#1050" class="Function">⊥-elim</a><a id="2497" class="Symbol">;</a> <a id="2499" href="Bridged.Data.Empty.html#238" class="Function">isProp⊥</a><a id="2506" class="Symbol">)</a>
<a id="2508" class="Keyword">open</a> <a id="2513" class="Keyword">import</a> <a id="2520" href="Bridged.Data.Unit.html" class="Module">Bridged.Data.Unit</a> <a id="2538" class="Keyword">public</a> <a id="2545" class="Keyword">using</a> <a id="2551" class="Symbol">(</a><a id="2552" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="2553" class="Symbol">;</a> <a id="2555" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="2557" class="Symbol">;</a> <a id="2559" href="Bridged.Data.Unit.html#150" class="Function">isProp⊤</a><a id="2566" class="Symbol">)</a>
<a id="2568" class="Keyword">open</a> <a id="2573" class="Keyword">import</a> <a id="2580" href="Bridged.Data.Sum.html" class="Module">Bridged.Data.Sum</a> <a id="2597" class="Keyword">public</a> <a id="2604" class="Keyword">using</a> <a id="2610" class="Symbol">(</a><a id="2611" href="Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="2614" class="Symbol">;</a> <a id="2616" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a><a id="2619" class="Symbol">;</a> <a id="2621" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a><a id="2624" class="Symbol">;</a> <a id="2626" href="Bridged.Data.Sum.html#744" class="Function">isProp⊎</a><a id="2633" class="Symbol">)</a>
</pre>
## 良构树序数

我们互归纳定义序数及其上的序关系, 因为我们的序数定义中就要用到由该序关系表达的一个条件作为约束. 这种约束后的序数我们称为良构树序数 $\text{Ord}$, 约束所用的序关系称为路径关系 $\text{Rd}(a, b)$, 其中 $a,b : \text{Ord}$. 这里所说的路径其实就是树 (tree) 中的路径 (path), 为了避免与 HoTT 中的道路 (path) 混淆, 我们称之为路径 (road). 后面会证明, $\text{Rd}(a, b)$ 是同伦层级意义下的集合, 也就是说 $\text{Rd}(a, b)$ 表示从序数 $a$ 到序数 $b$ 的所有路径所组成的集合.

<pre class="Agda"><a id="2966" class="Keyword">data</a> <a id="Ord"></a><a id="2971" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="2982" class="Keyword">data</a> <a id="Road"></a><a id="2987" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="2992" class="Symbol">:</a> <a id="2994" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="2998" class="Symbol">→</a> <a id="3000" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3004" class="Symbol">→</a> <a id="3006" href="Agda.Primitive.html#388" class="Primitive">Type</a>
</pre>
以上只是声明我们将要定义的东西, 它们的具体定义将在后面给出. 但在给出之前, 我们要假装它们已经完成了, 来表达定义中要用的一些辅助概念.

**定义 2-0-0** 我们说 $a$ 是 $b$ 的子树, 记作 $a \lt b$, 当且仅当存在一条从 $a$ 到 $b$ 的路径.

<pre class="Agda"><a id="_&lt;_"></a><a id="3168" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="_≮_"></a><a id="3172" href="WellFormed.Base.html#3172" class="Function Operator">_≮_</a> <a id="3176" class="Symbol">:</a> <a id="3178" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3182" class="Symbol">→</a> <a id="3184" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="3188" class="Symbol">→</a> <a id="3190" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3194" class="Symbol">;</a> <a id="3196" class="Keyword">infix</a> <a id="3202" class="Number">6</a> <a id="3204" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="3208" href="WellFormed.Base.html#3172" class="Function Operator">_≮_</a>
<a id="3212" href="WellFormed.Base.html#3212" class="Bound">a</a> <a id="3214" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3216" href="WellFormed.Base.html#3216" class="Bound">b</a> <a id="3218" class="Symbol">=</a> <a id="3220" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="3222" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3227" href="WellFormed.Base.html#3212" class="Bound">a</a> <a id="3229" href="WellFormed.Base.html#3216" class="Bound">b</a> <a id="3231" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
<a id="3234" href="WellFormed.Base.html#3234" class="Bound">a</a> <a id="3236" href="WellFormed.Base.html#3172" class="Function Operator">≮</a> <a id="3238" href="WellFormed.Base.html#3238" class="Bound">b</a> <a id="3240" class="Symbol">=</a> <a id="3242" href="WellFormed.Base.html#3234" class="Bound">a</a> <a id="3244" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3246" href="WellFormed.Base.html#3238" class="Bound">b</a> <a id="3248" class="Symbol">→</a> <a id="3250" href="Data.Empty.html#895" class="Function">⊥</a>
</pre>
注意此处说的「存在」形式表达为路径关系的命题截断, 满足

- 任给一条路径 $r:\text{Rd}(a,b)$, 都可以证明 $|r|:a\lt b$
- 任意两个证明 $p,q:a\lt b$ 都有 $p = q$

**定义 2-0-1** 我们将自然数到序数的函数简称**序列**, 其类型 $ℕ→\text{Ord}$ 简记为 $\text{Seq}$.

<pre class="Agda"><a id="Seq"></a><a id="3450" href="WellFormed.Base.html#3450" class="Function">Seq</a> <a id="3454" class="Symbol">:</a> <a id="3456" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="3461" href="WellFormed.Base.html#3450" class="Function">Seq</a> <a id="3465" class="Symbol">=</a> <a id="3467" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3469" class="Symbol">→</a> <a id="3471" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
</pre>
**定义 2-0-2** 我们说一个序列 $f:\text{Seq}$ 是**良构**的 (well-formed), 记作 $\text{wf}(f)$, 当且仅当它严格单调递增, 即对任意 $n$ 都有 $f(n) < f(n^+)$. 良构序列又叫序数的基本列.

<pre class="Agda"><a id="wf"></a><a id="3624" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3627" class="Symbol">:</a> <a id="3629" href="WellFormed.Base.html#3450" class="Function">Seq</a> <a id="3633" class="Symbol">→</a> <a id="3635" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="3640" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="3643" href="WellFormed.Base.html#3643" class="Bound">f</a> <a id="3645" class="Symbol">=</a> <a id="3647" class="Symbol">∀</a> <a id="3649" class="Symbol">{</a><a id="3650" href="WellFormed.Base.html#3650" class="Bound">n</a><a id="3651" class="Symbol">}</a> <a id="3653" class="Symbol">→</a> <a id="3655" href="WellFormed.Base.html#3643" class="Bound">f</a> <a id="3657" href="WellFormed.Base.html#3650" class="Bound">n</a> <a id="3659" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="3661" href="WellFormed.Base.html#3643" class="Bound">f</a> <a id="3663" class="Symbol">(</a><a id="3664" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3668" href="WellFormed.Base.html#3650" class="Bound">n</a><a id="3669" class="Symbol">)</a>
</pre>
**约定 2-0-3** 我们使用 $m,n$ 表示自然数, $a,b,c,d$ 表示序数, $f,g$ 表示基本列, $r,s$ 表示路径.

<pre class="Agda"><a id="3757" class="Keyword">variable</a>
  <a id="3768" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="3770" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="3772" class="Symbol">:</a> <a id="3774" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="3778" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3780" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="3782" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="3784" href="WellFormed.Base.html#3784" class="Generalizable">d</a> <a id="3786" class="Symbol">:</a> <a id="3788" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
  <a id="3794" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="3796" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="3798" class="Symbol">:</a> <a id="3800" href="WellFormed.Base.html#3450" class="Function">Seq</a>
  <a id="3806" href="WellFormed.Base.html#3806" class="Generalizable">r</a> <a id="3808" href="WellFormed.Base.html#3808" class="Generalizable">s</a> <a id="3810" class="Symbol">:</a> <a id="3812" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="3817" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="3819" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
</pre>
现在给出良构树序数和路径关系的具体定义.

**定义 2-0-4** 良构树序数

$$
\frac{}{\quad\text{zero} : \text{Ord}\quad}
\qquad
\frac{a:\text{Ord}}{\quad\text{suc}(a):\text{Ord}\quad}
\qquad
\frac{f:\text{Seq}\quad w : \text{wf}(f)}{\quad\lim(f,w):\text{Ord}\quad}
$$

后文在没有歧义的情况下采用如下简写:
- $\text{zero}$ 记作 $0$
- $\text{suc}(a)$ 记作 $a^+$
- $\lim(f,w)$ 记作 $\lim(f)$

<pre class="Agda"><a id="4168" class="Keyword">data</a> <a id="4173" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="4177" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="4185" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="4190" class="Symbol">:</a> <a id="4192" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="4198" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a>  <a id="4203" class="Symbol">:</a> <a id="4205" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="4209" class="Symbol">→</a> <a id="4211" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="4217" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a>  <a id="4222" class="Symbol">:</a> <a id="4224" class="Symbol">(</a><a id="4225" href="WellFormed.Base.html#4225" class="Bound">f</a> <a id="4227" class="Symbol">:</a> <a id="4229" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="4232" class="Symbol">)</a> <a id="4234" class="Symbol">→</a> <a id="4236" class="Symbol">⦃</a> <a id="4238" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4241" href="WellFormed.Base.html#4225" class="Bound">f</a> <a id="4243" class="Symbol">⦄</a> <a id="4245" class="Symbol">→</a> <a id="4247" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
</pre>
**定义 2-0-5** 路径关系

$$
\frac{}
{\quad\text{zero} : \text{Rd}(a, a^+)\quad}
\qquad
\frac{r:\text{Rd}(a,b)}
{\quad\text{suc}(r):\text{Rd}(a,b^+)\quad}
\qquad
\frac{\quad f:\text{Seq}\quad n:ℕ\quad w:\text{wf}(f)\quad r:\text{Rd}(a,f(n))\quad}
{\lim(f,n,w,r):\text{Rd}(a,\lim(f))}
$$

后文在没有歧义的情况下采用如下简写:
- $\text{zero}$ 记作 $0$
- $\text{suc}(r)$ 记作 $r^+$
- $\lim(f,n,w,r)$ 记作 $\lim(r)$

<pre class="Agda"><a id="4646" class="Keyword">data</a> <a id="4651" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4656" class="Keyword">where</a>
  <a id="Road.zero"></a><a id="4664" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="4669" class="Symbol">:</a> <a id="4671" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4676" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="4678" class="Symbol">(</a><a id="4679" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="4683" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="4684" class="Symbol">)</a>
  <a id="Road.suc"></a><a id="4688" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a>  <a id="4693" class="Symbol">:</a> <a id="4695" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4700" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="4702" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="4704" class="Symbol">→</a> <a id="4706" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4711" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="4713" class="Symbol">(</a><a id="4714" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="4718" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="4719" class="Symbol">)</a>
  <a id="Road.lim"></a><a id="4723" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a>  <a id="4728" class="Symbol">:</a> <a id="4730" class="Symbol">⦃</a> <a id="4732" href="WellFormed.Base.html#4732" class="Bound">_</a> <a id="4734" class="Symbol">:</a> <a id="4736" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="4739" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="4741" class="Symbol">⦄</a> <a id="4743" class="Symbol">→</a> <a id="4745" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4750" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="4752" class="Symbol">(</a><a id="4753" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="4755" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="4756" class="Symbol">)</a> <a id="4758" class="Symbol">→</a> <a id="4760" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="4765" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="4767" class="Symbol">(</a><a id="4768" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="4772" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="4773" class="Symbol">)</a>
</pre>
注意此处序数与路径的记法是重载的 (overloaded), 从上下文可以推断它们指的是序数的概念还是路径的概念.

**约定 2-0-6** 对于路径关系的截断——子树关系, 我们还将采用如下简写:

- $|0|$ 记作 $0_1$
- $|r^+|$ 记作 $r^{+_1}$
- $|\lim(r)|$ 记作 $\lim_1(r)$

<pre class="Agda"><a id="4960" class="Keyword">pattern</a> <a id="zero₁"></a><a id="4968" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>  <a id="4975" class="Symbol">=</a> <a id="4977" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="4979" class="InductiveConstructor">zero</a> <a id="4984" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="4987" class="Keyword">pattern</a> <a id="suc₁"></a><a id="4995" href="WellFormed.Base.html#4995" class="InductiveConstructor">suc₁</a> <a id="5000" href="WellFormed.Base.html#5010" class="Bound">r</a> <a id="5002" class="Symbol">=</a> <a id="5004" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="5006" class="InductiveConstructor">suc</a> <a id="5010" href="WellFormed.Base.html#5010" class="Bound">r</a> <a id="5012" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="5015" class="Keyword">pattern</a> <a id="lim₁"></a><a id="5023" href="WellFormed.Base.html#5023" class="InductiveConstructor">lim₁</a> <a id="5028" href="WellFormed.Base.html#5038" class="Bound">r</a> <a id="5030" class="Symbol">=</a> <a id="5032" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="5034" class="InductiveConstructor">lim</a> <a id="5038" href="WellFormed.Base.html#5038" class="Bound">r</a> <a id="5040" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
### 基本性质

**事实 2-0-7** 良构条件是命题.  
**证明** 由定义2-0-2 即得. ∎

<pre class="Agda"><a id="isPropWf"></a><a id="5113" href="WellFormed.Base.html#5113" class="Function">isPropWf</a> <a id="5122" class="Symbol">:</a> <a id="5124" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="5131" class="Symbol">(</a><a id="5132" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5135" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="5136" class="Symbol">)</a>
<a id="5138" href="WellFormed.Base.html#5113" class="Function">isPropWf</a> <a id="5147" class="Symbol">=</a> <a id="5149" href="Cubical.Foundations.HLevels.html#17512" class="Function">isPropImplicitΠ</a> <a id="5165" class="Symbol">λ</a> <a id="5167" href="WellFormed.Base.html#5167" class="Bound">_</a> <a id="5169" class="Symbol">→</a> <a id="5171" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
  <a id="5181" class="Keyword">where</a> <a id="5187" class="Keyword">open</a> <a id="5192" class="Keyword">import</a> <a id="5199" href="Cubical.Foundations.HLevels.html" class="Module">Cubical.Foundations.HLevels</a>
</pre>
**事实 2-0-8** 两个良构序列的极限相等, 只要它们逐项相等.  
**证明** 事实 2-0-7 说明良构性证明对极限序数的同一性没有影响. 结合 HoTT 承诺的函数外延性即证. ∎

<pre class="Agda"><a id="limExtPath"></a><a id="5339" href="WellFormed.Base.html#5339" class="Function">limExtPath</a> <a id="5350" class="Symbol">:</a> <a id="5352" class="Symbol">{</a><a id="5353" href="WellFormed.Base.html#5353" class="Bound">wff</a> <a id="5357" class="Symbol">:</a> <a id="5359" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5362" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="5363" class="Symbol">}</a> <a id="5365" class="Symbol">{</a><a id="5366" href="WellFormed.Base.html#5366" class="Bound">wfg</a> <a id="5370" class="Symbol">:</a> <a id="5372" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5375" href="WellFormed.Base.html#3796" class="Generalizable">g</a><a id="5376" class="Symbol">}</a> <a id="5378" class="Symbol">→</a> <a id="5380" class="Symbol">(∀</a> <a id="5383" href="WellFormed.Base.html#5383" class="Bound">n</a> <a id="5385" class="Symbol">→</a> <a id="5387" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="5392" class="Symbol">_</a> <a id="5394" class="Symbol">(</a><a id="5395" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="5397" href="WellFormed.Base.html#5383" class="Bound">n</a><a id="5398" class="Symbol">)</a> <a id="5400" class="Symbol">(</a><a id="5401" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="5403" href="WellFormed.Base.html#5383" class="Bound">n</a><a id="5404" class="Symbol">))</a> <a id="5407" class="Symbol">→</a> <a id="5409" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="5414" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="5418" class="Symbol">(</a><a id="5419" class="InductiveConstructor">lim</a> <a id="5423" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="5425" class="Symbol">⦃</a> <a id="5427" href="WellFormed.Base.html#5353" class="Bound">wff</a> <a id="5431" class="Symbol">⦄)</a> <a id="5434" class="Symbol">(</a><a id="5435" class="InductiveConstructor">lim</a> <a id="5439" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="5441" class="Symbol">⦃</a> <a id="5443" href="WellFormed.Base.html#5366" class="Bound">wfg</a> <a id="5447" class="Symbol">⦄)</a>
<a id="5450" href="WellFormed.Base.html#5339" class="Function">limExtPath</a> <a id="5461" href="WellFormed.Base.html#5461" class="Bound">p</a> <a id="5463" class="Symbol">=</a> <a id="5465" href="Cubical.Foundations.Prelude.html#2025" class="Function">🧊.cong₂</a> <a id="5473" class="Symbol">(λ</a> <a id="5476" href="WellFormed.Base.html#5476" class="Bound">f</a> <a id="5478" class="Symbol">(</a><a id="5479" href="WellFormed.Base.html#5479" class="Bound">wff</a> <a id="5483" class="Symbol">:</a> <a id="5485" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5488" href="WellFormed.Base.html#5476" class="Bound">f</a><a id="5489" class="Symbol">)</a> <a id="5491" class="Symbol">→</a> <a id="5493" href="WellFormed.Base.html#4217" class="InductiveConstructor">Ord.lim</a> <a id="5501" href="WellFormed.Base.html#5476" class="Bound">f</a> <a id="5503" class="Symbol">⦃</a> <a id="5505" href="WellFormed.Base.html#5479" class="Bound">wff</a> <a id="5509" class="Symbol">⦄)</a> <a id="5512" class="Symbol">(</a><a id="5513" href="Cubical.Foundations.Prelude.html#10257" class="Function">funExt</a> <a id="5520" href="WellFormed.Base.html#5461" class="Bound">p</a><a id="5521" class="Symbol">)</a> <a id="5523" class="Symbol">(</a><a id="5524" href="Cubical.Foundations.Prelude.html#13282" class="Function">toPathP</a> <a id="5532" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5534" href="WellFormed.Base.html#5113" class="Function">isPropWf</a> <a id="5543" class="Symbol">_</a> <a id="5545" class="Symbol">_)</a>

<a id="limExt"></a><a id="5549" href="WellFormed.Base.html#5549" class="Function">limExt</a> <a id="5556" class="Symbol">:</a> <a id="5558" class="Symbol">{</a><a id="5559" href="WellFormed.Base.html#5559" class="Bound">wff</a> <a id="5563" class="Symbol">:</a> <a id="5565" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5568" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="5569" class="Symbol">}</a> <a id="5571" class="Symbol">{</a><a id="5572" href="WellFormed.Base.html#5572" class="Bound">wfg</a> <a id="5576" class="Symbol">:</a> <a id="5578" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="5581" href="WellFormed.Base.html#3796" class="Generalizable">g</a><a id="5582" class="Symbol">}</a> <a id="5584" class="Symbol">→</a> <a id="5586" class="Symbol">(∀</a> <a id="5589" href="WellFormed.Base.html#5589" class="Bound">n</a> <a id="5591" class="Symbol">→</a> <a id="5593" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="5595" href="WellFormed.Base.html#5589" class="Bound">n</a> <a id="5597" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5599" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="5601" href="WellFormed.Base.html#5589" class="Bound">n</a><a id="5602" class="Symbol">)</a> <a id="5604" class="Symbol">→</a> <a id="5606" class="InductiveConstructor">lim</a> <a id="5610" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="5612" class="Symbol">⦃</a> <a id="5614" href="WellFormed.Base.html#5559" class="Bound">wff</a> <a id="5618" class="Symbol">⦄</a> <a id="5620" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5622" class="InductiveConstructor">lim</a> <a id="5626" href="WellFormed.Base.html#3796" class="Generalizable">g</a> <a id="5628" class="Symbol">⦃</a> <a id="5630" href="WellFormed.Base.html#5572" class="Bound">wfg</a> <a id="5634" class="Symbol">⦄</a>
<a id="5636" href="WellFormed.Base.html#5549" class="Function">limExt</a> <a id="5643" href="WellFormed.Base.html#5643" class="Bound">p</a> <a id="5645" class="Symbol">=</a> <a id="5647" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="5656" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5658" href="WellFormed.Base.html#5339" class="Function">limExtPath</a> <a id="5669" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="5671" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="5680" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="5682" href="WellFormed.Base.html#5643" class="Bound">p</a>
</pre>
## 序数集合

<pre class="Agda"><a id="5706" class="Keyword">module</a> <a id="OrdSet"></a><a id="5713" href="WellFormed.Base.html#5713" class="Module">OrdSet</a> <a id="5720" class="Keyword">where</a>
  <a id="5728" class="Keyword">open</a> <a id="5733" class="Keyword">import</a> <a id="5740" href="Cubical.Foundations.HLevels.html" class="Module">Cubical.Foundations.HLevels</a>
</pre>
我们使用 [encode-decode 方法](https://ncatlab.org/nlab/show/encode-decode+method) 证明 $\text{Ord}$ 是同伦层级意义下的集合. 具体细节这里不展开, 大致分为以下四步:

**2-0-9-1** 定义 `a b : Ord` 的覆叠空间 `Cover a b`, 容易证明它是一个命题.

<pre class="Agda">  <a id="OrdSet.Cover"></a><a id="5969" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="5975" class="Symbol">:</a> <a id="5977" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="5981" class="Symbol">→</a> <a id="5983" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="5987" class="Symbol">→</a> <a id="5989" href="Agda.Primitive.html#388" class="Primitive">Type</a>
  <a id="5996" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6002" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a>    <a id="6010" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a>    <a id="6018" class="Symbol">=</a> <a id="6020" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6024" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6030" class="Symbol">(</a><a id="6031" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6035" href="WellFormed.Base.html#6035" class="Bound">a</a><a id="6036" class="Symbol">)</a> <a id="6038" class="Symbol">(</a><a id="6039" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6043" href="WellFormed.Base.html#6043" class="Bound">b</a><a id="6044" class="Symbol">)</a> <a id="6046" class="Symbol">=</a> <a id="6048" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6054" href="WellFormed.Base.html#6035" class="Bound">a</a> <a id="6056" href="WellFormed.Base.html#6043" class="Bound">b</a>
  <a id="6060" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6066" class="Symbol">(</a><a id="6067" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6071" href="WellFormed.Base.html#6071" class="Bound">f</a><a id="6072" class="Symbol">)</a> <a id="6074" class="Symbol">(</a><a id="6075" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6079" href="WellFormed.Base.html#6079" class="Bound">g</a><a id="6080" class="Symbol">)</a> <a id="6082" class="Symbol">=</a> <a id="6084" class="Symbol">∀</a> <a id="6086" href="WellFormed.Base.html#6086" class="Bound">n</a> <a id="6088" class="Symbol">→</a> <a id="6090" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6096" class="Symbol">(</a><a id="6097" href="WellFormed.Base.html#6071" class="Bound">f</a> <a id="6099" href="WellFormed.Base.html#6086" class="Bound">n</a><a id="6100" class="Symbol">)</a> <a id="6102" class="Symbol">(</a><a id="6103" href="WellFormed.Base.html#6079" class="Bound">g</a> <a id="6105" href="WellFormed.Base.html#6086" class="Bound">n</a><a id="6106" class="Symbol">)</a>
  <a id="6110" href="WellFormed.Base.html#5969" class="CatchallClause Function">Cover</a><a id="6115" class="CatchallClause"> </a><a id="6116" class="CatchallClause Symbol">_</a><a id="6117" class="CatchallClause">       </a><a id="6124" class="CatchallClause Symbol">_</a>       <a id="6132" class="Symbol">=</a> <a id="6134" href="Data.Empty.html#895" class="Function">⊥</a>

  <a id="OrdSet.reflCode"></a><a id="6139" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6148" class="Symbol">:</a> <a id="6150" class="Symbol">(</a><a id="6151" href="WellFormed.Base.html#6151" class="Bound">a</a> <a id="6153" class="Symbol">:</a> <a id="6155" href="WellFormed.Base.html#2971" class="Datatype">Ord</a><a id="6158" class="Symbol">)</a> <a id="6160" class="Symbol">→</a> <a id="6162" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6168" href="WellFormed.Base.html#6151" class="Bound">a</a> <a id="6170" href="WellFormed.Base.html#6151" class="Bound">a</a>
  <a id="6174" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6183" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="6188" class="Symbol">=</a> <a id="6190" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
  <a id="6195" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6204" class="Symbol">(</a><a id="6205" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6209" href="WellFormed.Base.html#6209" class="Bound">a</a><a id="6210" class="Symbol">)</a> <a id="6212" class="Symbol">=</a> <a id="6214" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6223" href="WellFormed.Base.html#6209" class="Bound">a</a>
  <a id="6227" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6236" class="Symbol">(</a><a id="6237" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6241" href="WellFormed.Base.html#6241" class="Bound">f</a><a id="6242" class="Symbol">)</a> <a id="6244" href="WellFormed.Base.html#6244" class="Bound">n</a> <a id="6246" class="Symbol">=</a> <a id="6248" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6257" class="Symbol">(</a><a id="6258" href="WellFormed.Base.html#6241" class="Bound">f</a> <a id="6260" href="WellFormed.Base.html#6244" class="Bound">n</a><a id="6261" class="Symbol">)</a>

  <a id="OrdSet.isPropCover"></a><a id="6266" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6278" class="Symbol">:</a> <a id="6280" class="Symbol">∀</a> <a id="6282" href="WellFormed.Base.html#6282" class="Bound">a</a> <a id="6284" href="WellFormed.Base.html#6284" class="Bound">b</a> <a id="6286" class="Symbol">→</a> <a id="6288" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="6295" class="Symbol">(</a><a id="6296" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6302" href="WellFormed.Base.html#6282" class="Bound">a</a> <a id="6304" href="WellFormed.Base.html#6284" class="Bound">b</a><a id="6305" class="Symbol">)</a>
  <a id="6309" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6321" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="6326" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="6331" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="6334" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="6337" class="Symbol">=</a> <a id="6339" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
  <a id="6348" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6360" class="Symbol">(</a><a id="6361" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6365" href="WellFormed.Base.html#6365" class="Bound">a</a><a id="6366" class="Symbol">)</a> <a id="6368" class="Symbol">(</a><a id="6369" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6373" href="WellFormed.Base.html#6373" class="Bound">b</a><a id="6374" class="Symbol">)</a> <a id="6376" class="Symbol">=</a> <a id="6378" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6390" href="WellFormed.Base.html#6365" class="Bound">a</a> <a id="6392" href="WellFormed.Base.html#6373" class="Bound">b</a>
  <a id="6396" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6408" class="Symbol">(</a><a id="6409" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6413" href="WellFormed.Base.html#6413" class="Bound">f</a><a id="6414" class="Symbol">)</a> <a id="6416" class="Symbol">(</a><a id="6417" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6421" href="WellFormed.Base.html#6421" class="Bound">g</a><a id="6422" class="Symbol">)</a> <a id="6424" class="Symbol">=</a> <a id="6426" href="Cubical.Foundations.HLevels.html#16363" class="Function">isPropΠ</a> <a id="6434" class="Symbol">(λ</a> <a id="6437" href="WellFormed.Base.html#6437" class="Bound">n</a> <a id="6439" class="Symbol">→</a> <a id="6441" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="6453" class="Symbol">(</a><a id="6454" href="WellFormed.Base.html#6413" class="Bound">f</a> <a id="6456" href="WellFormed.Base.html#6437" class="Bound">n</a><a id="6457" class="Symbol">)</a> <a id="6459" class="Symbol">(</a><a id="6460" href="WellFormed.Base.html#6421" class="Bound">g</a> <a id="6462" href="WellFormed.Base.html#6437" class="Bound">n</a><a id="6463" class="Symbol">))</a>
</pre>
**2-0-9-2** 将 `a b : Ord` 的道路空间 `Path a b` 编码为覆叠空间.

<pre class="Agda">  <a id="OrdSet.encode"></a><a id="6534" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="6541" class="Symbol">:</a> <a id="6543" class="Symbol">∀</a> <a id="6545" href="WellFormed.Base.html#6545" class="Bound">a</a> <a id="6547" href="WellFormed.Base.html#6547" class="Bound">b</a> <a id="6549" class="Symbol">→</a> <a id="6551" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="6556" class="Symbol">_</a> <a id="6558" href="WellFormed.Base.html#6545" class="Bound">a</a> <a id="6560" href="WellFormed.Base.html#6547" class="Bound">b</a> <a id="6562" class="Symbol">→</a> <a id="6564" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6570" href="WellFormed.Base.html#6545" class="Bound">a</a> <a id="6572" href="WellFormed.Base.html#6547" class="Bound">b</a>
  <a id="6576" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="6583" href="WellFormed.Base.html#6583" class="Bound">a</a> <a id="6585" href="WellFormed.Base.html#6585" class="Bound">b</a> <a id="6587" class="Symbol">=</a> <a id="6589" href="Cubical.Foundations.Prelude.html#11720" class="Function">J</a> <a id="6591" class="Symbol">(λ</a> <a id="6594" href="WellFormed.Base.html#6594" class="Bound">b</a> <a id="6596" href="WellFormed.Base.html#6596" class="Bound">_</a> <a id="6598" class="Symbol">→</a> <a id="6600" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6606" href="WellFormed.Base.html#6583" class="Bound">a</a> <a id="6608" href="WellFormed.Base.html#6594" class="Bound">b</a><a id="6609" class="Symbol">)</a> <a id="6611" class="Symbol">(</a><a id="6612" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6621" href="WellFormed.Base.html#6583" class="Bound">a</a><a id="6622" class="Symbol">)</a>

  <a id="OrdSet.encodeRefl"></a><a id="6627" href="WellFormed.Base.html#6627" class="Function">encodeRefl</a> <a id="6638" class="Symbol">:</a> <a id="6640" class="Symbol">∀</a> <a id="6642" href="WellFormed.Base.html#6642" class="Bound">a</a> <a id="6644" class="Symbol">→</a> <a id="6646" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="6651" class="Symbol">_</a> <a id="6653" class="Symbol">(</a><a id="6654" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="6661" href="WellFormed.Base.html#6642" class="Bound">a</a> <a id="6663" href="WellFormed.Base.html#6642" class="Bound">a</a> <a id="6665" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a><a id="6671" class="Symbol">)</a> <a id="6673" class="Symbol">(</a><a id="6674" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6683" href="WellFormed.Base.html#6642" class="Bound">a</a><a id="6684" class="Symbol">)</a>
  <a id="6688" href="WellFormed.Base.html#6627" class="Function">encodeRefl</a> <a id="6699" href="WellFormed.Base.html#6699" class="Bound">a</a> <a id="6701" class="Symbol">=</a> <a id="6703" href="Cubical.Foundations.Prelude.html#11801" class="Function">JRefl</a> <a id="6709" class="Symbol">(λ</a> <a id="6712" href="WellFormed.Base.html#6712" class="Bound">b</a> <a id="6714" href="WellFormed.Base.html#6714" class="Bound">_</a> <a id="6716" class="Symbol">→</a> <a id="6718" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6724" href="WellFormed.Base.html#6699" class="Bound">a</a> <a id="6726" href="WellFormed.Base.html#6712" class="Bound">b</a><a id="6727" class="Symbol">)</a> <a id="6729" class="Symbol">(</a><a id="6730" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="6739" href="WellFormed.Base.html#6699" class="Bound">a</a><a id="6740" class="Symbol">)</a>
</pre>
**2-0-9-3** 将覆叠空间解码为道路空间.

<pre class="Agda">  <a id="OrdSet.decode"></a><a id="6784" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6791" class="Symbol">:</a> <a id="6793" class="Symbol">∀</a> <a id="6795" href="WellFormed.Base.html#6795" class="Bound">a</a> <a id="6797" href="WellFormed.Base.html#6797" class="Bound">b</a> <a id="6799" class="Symbol">→</a> <a id="6801" href="WellFormed.Base.html#5969" class="Function">Cover</a> <a id="6807" href="WellFormed.Base.html#6795" class="Bound">a</a> <a id="6809" href="WellFormed.Base.html#6797" class="Bound">b</a> <a id="6811" class="Symbol">→</a> <a id="6813" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="6818" class="Symbol">_</a> <a id="6820" href="WellFormed.Base.html#6795" class="Bound">a</a> <a id="6822" href="WellFormed.Base.html#6797" class="Bound">b</a>
  <a id="6826" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6833" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="6838" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="6843" class="Symbol">_</a> <a id="6845" class="Symbol">=</a> <a id="6847" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
  <a id="6856" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6863" class="Symbol">(</a><a id="6864" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6868" href="WellFormed.Base.html#6868" class="Bound">a</a><a id="6869" class="Symbol">)</a> <a id="6871" class="Symbol">(</a><a id="6872" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6876" href="WellFormed.Base.html#6876" class="Bound">b</a><a id="6877" class="Symbol">)</a> <a id="6879" href="WellFormed.Base.html#6879" class="Bound">p</a> <a id="6881" class="Symbol">=</a> <a id="6883" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="6890" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="6894" class="Symbol">(</a><a id="6895" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6902" href="WellFormed.Base.html#6868" class="Bound">a</a> <a id="6904" href="WellFormed.Base.html#6876" class="Bound">b</a> <a id="6906" href="WellFormed.Base.html#6879" class="Bound">p</a><a id="6907" class="Symbol">)</a>
  <a id="6911" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6918" class="Symbol">(</a><a id="6919" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6923" href="WellFormed.Base.html#6923" class="Bound">f</a><a id="6924" class="Symbol">)</a> <a id="6926" class="Symbol">(</a><a id="6927" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="6931" href="WellFormed.Base.html#6931" class="Bound">g</a><a id="6932" class="Symbol">)</a> <a id="6934" href="WellFormed.Base.html#6934" class="Bound">p</a> <a id="6936" class="Symbol">=</a> <a id="6938" href="WellFormed.Base.html#5339" class="Function">limExtPath</a> <a id="6949" class="Symbol">λ</a> <a id="6951" href="WellFormed.Base.html#6951" class="Bound">n</a> <a id="6953" class="Symbol">→</a> <a id="6955" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="6962" class="Symbol">(</a><a id="6963" href="WellFormed.Base.html#6923" class="Bound">f</a> <a id="6965" href="WellFormed.Base.html#6951" class="Bound">n</a><a id="6966" class="Symbol">)</a> <a id="6968" class="Symbol">(</a><a id="6969" href="WellFormed.Base.html#6931" class="Bound">g</a> <a id="6971" href="WellFormed.Base.html#6951" class="Bound">n</a><a id="6972" class="Symbol">)</a> <a id="6974" class="Symbol">(</a><a id="6975" href="WellFormed.Base.html#6934" class="Bound">p</a> <a id="6977" href="WellFormed.Base.html#6951" class="Bound">n</a><a id="6978" class="Symbol">)</a>

  <a id="OrdSet.decodeRefl"></a><a id="6983" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="6994" class="Symbol">:</a> <a id="6996" class="Symbol">∀</a> <a id="6998" href="WellFormed.Base.html#6998" class="Bound">a</a> <a id="7000" class="Symbol">→</a> <a id="7002" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="7007" class="Symbol">_</a> <a id="7009" class="Symbol">(</a><a id="7010" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="7017" href="WellFormed.Base.html#6998" class="Bound">a</a> <a id="7019" href="WellFormed.Base.html#6998" class="Bound">a</a> <a id="7021" class="Symbol">(</a><a id="7022" href="WellFormed.Base.html#6139" class="Function">reflCode</a> <a id="7031" href="WellFormed.Base.html#6998" class="Bound">a</a><a id="7032" class="Symbol">))</a> <a id="7035" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
  <a id="7044" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7055" href="WellFormed.Base.html#4185" class="InductiveConstructor">zero</a> <a id="7060" class="Symbol">=</a> <a id="7062" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
  <a id="7071" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7082" class="Symbol">(</a><a id="7083" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7087" href="WellFormed.Base.html#7087" class="Bound">a</a><a id="7088" class="Symbol">)</a> <a id="7090" href="WellFormed.Base.html#7090" class="Bound">i</a> <a id="7092" class="Symbol">=</a> <a id="7094" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="7101" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="7105" class="Symbol">(</a><a id="7106" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7117" href="WellFormed.Base.html#7087" class="Bound">a</a> <a id="7119" href="WellFormed.Base.html#7090" class="Bound">i</a><a id="7120" class="Symbol">)</a>
  <a id="7124" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7135" class="Symbol">(</a><a id="7136" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="7140" href="WellFormed.Base.html#7140" class="Bound">f</a><a id="7141" class="Symbol">)</a> <a id="7143" href="WellFormed.Base.html#7143" class="Bound">i</a> <a id="7145" class="Symbol">=</a> <a id="7147" href="Cubical.Foundations.Prelude.html#2025" class="Function">🧊.cong₂</a>
    <a id="7159" class="Symbol">(λ</a> <a id="7162" href="WellFormed.Base.html#7162" class="Bound">f</a> <a id="7164" class="Symbol">(</a><a id="7165" href="WellFormed.Base.html#7165" class="Bound">wff</a> <a id="7169" class="Symbol">:</a> <a id="7171" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="7174" href="WellFormed.Base.html#7162" class="Bound">f</a><a id="7175" class="Symbol">)</a> <a id="7177" class="Symbol">→</a> <a id="7179" href="WellFormed.Base.html#4217" class="InductiveConstructor">Ord.lim</a> <a id="7187" href="WellFormed.Base.html#7162" class="Bound">f</a> <a id="7189" class="Symbol">⦃</a> <a id="7191" href="WellFormed.Base.html#7165" class="Bound">wff</a> <a id="7195" class="Symbol">⦄)</a>
    <a id="7202" class="Symbol">(λ</a> <a id="7205" href="WellFormed.Base.html#7205" class="Bound">j</a> <a id="7207" href="WellFormed.Base.html#7207" class="Bound">n</a> <a id="7209" class="Symbol">→</a> <a id="7211" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7222" class="Symbol">(</a><a id="7223" href="WellFormed.Base.html#7140" class="Bound">f</a> <a id="7225" href="WellFormed.Base.html#7207" class="Bound">n</a><a id="7226" class="Symbol">)</a> <a id="7228" href="WellFormed.Base.html#7143" class="Bound">i</a> <a id="7230" href="WellFormed.Base.html#7205" class="Bound">j</a><a id="7231" class="Symbol">)</a>
    <a id="7237" class="Symbol">(</a><a id="7238" href="Cubical.Foundations.HLevels.html#10125" class="Function">isSet→SquareP</a> <a id="7252" class="Symbol">{</a><a id="7253" class="Argument">A</a> <a id="7255" class="Symbol">=</a> <a id="7257" class="Symbol">λ</a> <a id="7259" href="WellFormed.Base.html#7259" class="Bound">i</a> <a id="7261" href="WellFormed.Base.html#7261" class="Bound">j</a> <a id="7263" class="Symbol">→</a> <a id="7265" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="7268" class="Symbol">(λ</a> <a id="7271" href="WellFormed.Base.html#7271" class="Bound">n</a> <a id="7273" class="Symbol">→</a> <a id="7275" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7286" class="Symbol">(</a><a id="7287" href="WellFormed.Base.html#7140" class="Bound">f</a> <a id="7289" href="WellFormed.Base.html#7271" class="Bound">n</a><a id="7290" class="Symbol">)</a> <a id="7292" href="WellFormed.Base.html#7259" class="Bound">i</a> <a id="7294" href="WellFormed.Base.html#7261" class="Bound">j</a><a id="7295" class="Symbol">)}</a>
      <a id="7304" class="Symbol">(λ</a> <a id="7307" href="WellFormed.Base.html#7307" class="Bound">_</a> <a id="7309" href="WellFormed.Base.html#7309" class="Bound">_</a> <a id="7311" class="Symbol">→</a> <a id="7313" href="Cubical.Foundations.Prelude.html#18852" class="Function">isProp→isSet</a> <a id="7326" href="WellFormed.Base.html#5113" class="Function">isPropWf</a><a id="7334" class="Symbol">)</a> <a id="7336" class="Symbol">(</a><a id="7337" href="Cubical.Foundations.Prelude.html#13282" class="Function">toPathP</a> <a id="7345" class="Symbol">(</a><a id="7346" href="WellFormed.Base.html#5113" class="Function">isPropWf</a> <a id="7355" class="Symbol">_</a> <a id="7357" class="Symbol">_))</a> <a id="7361" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="7368" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="7375" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="7382" href="WellFormed.Base.html#7143" class="Bound">i</a><a id="7383" class="Symbol">)</a>
</pre>
**2-0-9-4** 证明编码与解码互逆, 结合 `Cover a b` 是命题, 说明 `Path a b` 是命题, 也即 `Ord` 是集合.

<pre class="Agda">  <a id="OrdSet.decodeEncode"></a><a id="7477" href="WellFormed.Base.html#7477" class="Function">decodeEncode</a> <a id="7490" class="Symbol">:</a> <a id="7492" class="Symbol">∀</a> <a id="7494" href="WellFormed.Base.html#7494" class="Bound">a</a> <a id="7496" href="WellFormed.Base.html#7496" class="Bound">b</a> <a id="7498" href="WellFormed.Base.html#7498" class="Bound">p</a> <a id="7500" class="Symbol">→</a> <a id="7502" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="7507" class="Symbol">_</a> <a id="7509" class="Symbol">(</a><a id="7510" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="7517" href="WellFormed.Base.html#7494" class="Bound">a</a> <a id="7519" href="WellFormed.Base.html#7496" class="Bound">b</a> <a id="7521" class="Symbol">(</a><a id="7522" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="7529" href="WellFormed.Base.html#7494" class="Bound">a</a> <a id="7531" href="WellFormed.Base.html#7496" class="Bound">b</a> <a id="7533" href="WellFormed.Base.html#7498" class="Bound">p</a><a id="7534" class="Symbol">))</a> <a id="7537" href="WellFormed.Base.html#7498" class="Bound">p</a>
  <a id="7541" href="WellFormed.Base.html#7477" class="Function">decodeEncode</a> <a id="7554" href="WellFormed.Base.html#7554" class="Bound">a</a> <a id="7556" class="Symbol">_</a> <a id="7558" class="Symbol">=</a> <a id="7560" href="Cubical.Foundations.Prelude.html#11720" class="Function">J</a> <a id="7562" class="Symbol">(λ</a> <a id="7565" href="WellFormed.Base.html#7565" class="Bound">b</a> <a id="7567" href="WellFormed.Base.html#7567" class="Bound">p</a> <a id="7569" class="Symbol">→</a> <a id="7571" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="7576" class="Symbol">_</a> <a id="7578" class="Symbol">(</a><a id="7579" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="7586" href="WellFormed.Base.html#7554" class="Bound">a</a> <a id="7588" href="WellFormed.Base.html#7565" class="Bound">b</a> <a id="7590" class="Symbol">(</a><a id="7591" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="7598" href="WellFormed.Base.html#7554" class="Bound">a</a> <a id="7600" href="WellFormed.Base.html#7565" class="Bound">b</a> <a id="7602" href="WellFormed.Base.html#7567" class="Bound">p</a><a id="7603" class="Symbol">))</a> <a id="7606" href="WellFormed.Base.html#7567" class="Bound">p</a><a id="7607" class="Symbol">)</a>
    <a id="7613" class="Symbol">(</a><a id="7614" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="7621" class="Symbol">(</a><a id="7622" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="7629" href="WellFormed.Base.html#7554" class="Bound">a</a> <a id="7631" href="WellFormed.Base.html#7554" class="Bound">a</a><a id="7632" class="Symbol">)</a> <a id="7634" class="Symbol">(</a><a id="7635" href="WellFormed.Base.html#6627" class="Function">encodeRefl</a> <a id="7646" href="WellFormed.Base.html#7554" class="Bound">a</a><a id="7647" class="Symbol">)</a> <a id="7649" href="Cubical.Foundations.Prelude.html#4776" class="Function Operator">∙</a> <a id="7651" href="WellFormed.Base.html#6983" class="Function">decodeRefl</a> <a id="7662" href="WellFormed.Base.html#7554" class="Bound">a</a><a id="7663" class="Symbol">)</a>
    <a id="7669" class="Keyword">where</a> <a id="7675" class="Keyword">open</a> <a id="7680" class="Keyword">import</a> <a id="7687" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>

  <a id="OrdSet.isSetOrd"></a><a id="7722" href="WellFormed.Base.html#7722" class="Function">isSetOrd</a> <a id="7731" class="Symbol">:</a> <a id="7733" href="Cubical.Foundations.Prelude.html#14630" class="Function">isSet</a> <a id="7739" href="WellFormed.Base.html#2971" class="Datatype">Ord</a>
  <a id="7745" href="WellFormed.Base.html#7722" class="Function">isSetOrd</a> <a id="7754" href="WellFormed.Base.html#7754" class="Bound">a</a> <a id="7756" href="WellFormed.Base.html#7756" class="Bound">b</a> <a id="7758" class="Symbol">=</a> <a id="7760" href="Cubical.Foundations.HLevels.html#6927" class="Function">isOfHLevelRetract</a> <a id="7778" class="Number">1</a> <a id="7780" class="Symbol">(</a><a id="7781" href="WellFormed.Base.html#6534" class="Function">encode</a> <a id="7788" href="WellFormed.Base.html#7754" class="Bound">a</a> <a id="7790" href="WellFormed.Base.html#7756" class="Bound">b</a><a id="7791" class="Symbol">)</a> <a id="7793" class="Symbol">(</a><a id="7794" href="WellFormed.Base.html#6784" class="Function">decode</a> <a id="7801" href="WellFormed.Base.html#7754" class="Bound">a</a> <a id="7803" href="WellFormed.Base.html#7756" class="Bound">b</a><a id="7804" class="Symbol">)</a>
    <a id="7810" class="Symbol">(</a><a id="7811" href="WellFormed.Base.html#7477" class="Function">decodeEncode</a> <a id="7824" href="WellFormed.Base.html#7754" class="Bound">a</a> <a id="7826" href="WellFormed.Base.html#7756" class="Bound">b</a><a id="7827" class="Symbol">)</a> <a id="7829" class="Symbol">(</a><a id="7830" href="WellFormed.Base.html#6266" class="Function">isPropCover</a> <a id="7842" href="WellFormed.Base.html#7754" class="Bound">a</a> <a id="7844" href="WellFormed.Base.html#7756" class="Bound">b</a><a id="7845" class="Symbol">)</a>

  <a id="OrdSet.isProp≡"></a><a id="7850" href="WellFormed.Base.html#7850" class="Function">isProp≡</a> <a id="7858" class="Symbol">:</a> <a id="7860" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="7867" class="Symbol">(</a><a id="7868" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="7870" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7872" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="7873" class="Symbol">)</a>
  <a id="7877" href="WellFormed.Base.html#7850" class="Function">isProp≡</a> <a id="7885" class="Symbol">=</a> <a id="7887" href="Cubical.Foundations.Prelude.html#9486" class="Function">🧊.subst</a> <a id="7895" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="7902" href="Cubical.Data.Equality.Conversion.html#2530" class="Function">PathPathEq</a> <a id="7913" class="Symbol">(</a><a id="7914" href="WellFormed.Base.html#7722" class="Function">isSetOrd</a> <a id="7923" class="Symbol">_</a> <a id="7925" class="Symbol">_)</a>
</pre>
**事实 2-0-9** 序数类型是集合, 也即序数的同一性是命题.

<pre class="Agda"><a id="7977" class="Keyword">open</a> <a id="7982" href="WellFormed.Base.html#5713" class="Module">OrdSet</a> <a id="7989" class="Keyword">public</a> <a id="7996" class="Keyword">using</a> <a id="8002" class="Symbol">(</a><a id="8003" href="WellFormed.Base.html#7722" class="Function">isSetOrd</a><a id="8011" class="Symbol">;</a> <a id="8013" href="WellFormed.Base.html#7850" class="Function">isProp≡</a><a id="8020" class="Symbol">)</a>
</pre>
## 路径与子树关系

接下来我们考察路径关系及其截断——子树关系. 我们追加导入标准库中关于自然数的引理, 以及序关系的相关概念, 如什么是严格偏序, 什么是非严格偏序等.

<pre class="Agda"><a id="8124" class="Keyword">open</a> <a id="8129" class="Keyword">import</a> <a id="8136" href="Relation.Binary.Definitions.html" class="Module">Relation.Binary.Definitions</a>
<a id="8164" class="Keyword">open</a> <a id="8169" class="Keyword">import</a> <a id="8176" href="Relation.Binary.Definitions.html" class="Module">Relation.Binary.Definitions</a> <a id="8204" class="Keyword">public</a> <a id="8211" class="Keyword">using</a> <a id="8217" class="Symbol">(</a><a id="8218" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a><a id="8222" class="Symbol">;</a> <a id="8224" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a><a id="8228" class="Symbol">;</a> <a id="8230" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a><a id="8234" class="Symbol">)</a>
<a id="8236" class="Keyword">open</a> <a id="8241" class="Keyword">import</a> <a id="8248" href="Relation.Binary.Structures.html" class="Module">Relation.Binary.Structures</a> <a id="8275" class="Symbol">{</a><a id="8276" class="Argument">A</a> <a id="8278" class="Symbol">=</a> <a id="8280" href="WellFormed.Base.html#2971" class="Datatype">Ord</a><a id="8283" class="Symbol">}</a> <a id="8285" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a>
<a id="8289" class="Keyword">open</a> <a id="8294" class="Keyword">import</a> <a id="8301" href="Relation.Binary.PropositionalEquality.Properties.html" class="Module">Relation.Binary.PropositionalEquality.Properties</a> <a id="8350" class="Keyword">using</a> <a id="8356" class="Symbol">(</a><a id="8357" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a><a id="8370" class="Symbol">)</a>
<a id="8372" class="Keyword">open</a> <a id="8377" class="Keyword">import</a> <a id="8384" href="Induction.WellFounded.html" class="Module">Induction.WellFounded</a>
</pre>
### 严格序

**事实 2-0-10** 路径关系与子树关系尊重命题相等, 即

- 如果 $\text{Rd}(a,b)$ 且 $a=c$ 那么 $\text{Rd}(c,b)$
- 如果 $\text{Rd}(a,b)$ 且 $b=c$ 那么 $\text{Rd}(a,c)$
- 如果 $a \lt b$ 且 $a=c$ 那么 $c \lt b$
- 如果 $a \lt b$ 且 $b=c$ 那么 $a \lt c$


<pre class="Agda"><a id="rd-resp-≡"></a><a id="8636" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="8646" class="Symbol">:</a> <a id="8648" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="8653" href="Relation.Binary.Definitions.html#5663" class="Function Operator">Respects₂</a> <a id="8663" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a>
<a id="8667" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="8677" class="Symbol">=</a> <a id="8679" class="Symbol">(λ</a> <a id="8682" class="Symbol">{</a> <a id="8684" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8689" class="Symbol">→</a> <a id="8691" href="Function.Base.html#704" class="Function">id</a> <a id="8694" class="Symbol">})</a> <a id="8697" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8699" class="Symbol">(λ</a> <a id="8702" class="Symbol">{</a> <a id="8704" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8709" class="Symbol">→</a> <a id="8711" href="Function.Base.html#704" class="Function">id</a> <a id="8714" class="Symbol">})</a>

<a id="&lt;-resp-≡"></a><a id="8718" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="8727" class="Symbol">:</a> <a id="8729" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="8733" href="Relation.Binary.Definitions.html#5663" class="Function Operator">Respects₂</a> <a id="8743" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a>
<a id="8747" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="8756" class="Symbol">=</a> <a id="8758" class="Symbol">(λ</a> <a id="8761" class="Symbol">{</a> <a id="8763" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8768" class="Symbol">→</a> <a id="8770" href="Function.Base.html#704" class="Function">id</a> <a id="8773" class="Symbol">})</a> <a id="8776" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8778" class="Symbol">(λ</a> <a id="8781" class="Symbol">{</a> <a id="8783" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8788" class="Symbol">→</a> <a id="8790" href="Function.Base.html#704" class="Function">id</a> <a id="8793" class="Symbol">})</a>
</pre>
**定义 2-0-11** 任给 $r:\text{Rd}(a, b)$ 以及 $s:\text{Rd}(b, c)$, 递归定义**路径的结合** $r⋅s : \text{Rd}(a, c)$ 如下

- 若 $s=0$, 必然有 $c=b^+$, 于是 $r⋅s := r^+:\text{Rd}(a,b^+)$.
- 若存在 $s'$ 使得 $s=s'^+$, 必然存在 $c'$ 使得 $c=c'^+$ 且 $s':\text{Rd}(b,c')$, 于是 $r⋅s := (r⋅s')^+:\text{Rd}(a,c'^+)$.
- 若存在 $s'$ 使得 $s=\lim(s')$, 必然存在 $f$ 使得 $c=\lim(f)$ 且 $s':\text{Rd}(a,f(n))$, 于是 $r⋅s := \lim(r⋅s'):\text{Rd}(a,\lim(f))$. ∎

<pre class="Agda"><a id="rd-trans"></a><a id="9206" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9215" class="Symbol">:</a> <a id="9217" href="Relation.Binary.Definitions.html#2103" class="Function">Transitive</a> <a id="9228" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="9233" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9242" href="WellFormed.Base.html#9242" class="Bound">r</a> <a id="9244" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="9252" class="Symbol">=</a> <a id="9254" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="9258" href="WellFormed.Base.html#9242" class="Bound">r</a>
<a id="9260" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9269" href="WellFormed.Base.html#9269" class="Bound">r</a> <a id="9271" class="Symbol">(</a><a id="9272" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="9276" href="WellFormed.Base.html#9276" class="Bound">s</a><a id="9277" class="Symbol">)</a> <a id="9279" class="Symbol">=</a> <a id="9281" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="9285" class="Symbol">(</a><a id="9286" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9295" href="WellFormed.Base.html#9269" class="Bound">r</a> <a id="9297" href="WellFormed.Base.html#9276" class="Bound">s</a><a id="9298" class="Symbol">)</a>
<a id="9300" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9309" href="WellFormed.Base.html#9309" class="Bound">r</a> <a id="9311" class="Symbol">(</a><a id="9312" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="9316" href="WellFormed.Base.html#9316" class="Bound">s</a><a id="9317" class="Symbol">)</a> <a id="9319" class="Symbol">=</a> <a id="9321" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="9325" class="Symbol">(</a><a id="9326" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="9335" href="WellFormed.Base.html#9309" class="Bound">r</a> <a id="9337" href="WellFormed.Base.html#9316" class="Bound">s</a><a id="9338" class="Symbol">)</a>
</pre>
**事实 2-0-12** 由路径的结合立即可得子树关系的传递性.

<pre class="Agda"><a id="&lt;-trans"></a><a id="9388" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="9396" class="Symbol">:</a> <a id="9398" href="Relation.Binary.Definitions.html#2103" class="Function">Transitive</a> <a id="9409" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="9413" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="9421" class="Symbol">=</a> <a id="9423" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">map2</a> <a id="9428" href="WellFormed.Base.html#9206" class="Function">rd-trans</a>
</pre>
**定理 2-0-13** 路径关系是良基关系, 即任意序数 $a$ 在路径关系下可及.  
**证明** 在我们这套定义下, 该定理有一个技巧性的简短证明. 我们先假设存在 $a$ 到某 $b$ 的路径 $r:\text{Rd}(a,b)$, 以此证明 $a$ 可及之后, 提供路径 $0:\text{Rd}(a,a^+)$ 以消掉此前提. 现在, 假设有这样的 $r$, 对 $r$ 归纳.

- 若 $r=0$, 要证 $a$ 在路径关系下可及, 即证任意满足 $s:\text{Rd}(c,a)$ 的 $c$ 可及, 此即归纳假设.
- 若存在 $r'$ 使得 $r=r'^+$, 必然存在 $b'$ 使得 $b=b'^+$ 且 $r':\text{Rd}(a,b')$. 现在要证 $a$, 即证任意满足 $s:\text{Rd}(c,a)$ 的 $c$ 可及. 由归纳假设, 只需找到某 $x$ 满足 $\text{Rd}(c,x)$. 令 $x=b'$, 我们有 $s⋅r':\text{Rd}(c,b')$.
- 同理可证 $r=\lim(r')$ 的情况. ∎

<pre class="Agda"><a id="rd-acc"></a><a id="9941" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="9948" class="Symbol">:</a> <a id="9950" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="9955" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="9957" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="9959" class="Symbol">→</a> <a id="9961" href="Induction.WellFounded.html#1356" class="Datatype">Acc</a> <a id="9965" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="9970" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="9972" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="9979" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="9987" class="Symbol">=</a> <a id="9989" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="9993" class="Symbol">λ</a> <a id="9995" href="WellFormed.Base.html#9995" class="Bound">s</a> <a id="9997" class="Symbol">→</a> <a id="9999" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10006" href="WellFormed.Base.html#9995" class="Bound">s</a>
<a id="10008" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10015" class="Symbol">(</a><a id="10016" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="10020" href="WellFormed.Base.html#10020" class="Bound">r</a><a id="10021" class="Symbol">)</a> <a id="10023" class="Symbol">=</a> <a id="10025" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10029" class="Symbol">λ</a> <a id="10031" href="WellFormed.Base.html#10031" class="Bound">s</a> <a id="10033" class="Symbol">→</a> <a id="10035" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10042" class="Symbol">(</a><a id="10043" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="10052" href="WellFormed.Base.html#10031" class="Bound">s</a> <a id="10054" href="WellFormed.Base.html#10020" class="Bound">r</a><a id="10055" class="Symbol">)</a>
<a id="10057" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10064" class="Symbol">(</a><a id="10065" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="10069" href="WellFormed.Base.html#10069" class="Bound">r</a><a id="10070" class="Symbol">)</a> <a id="10072" class="Symbol">=</a> <a id="10074" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10078" class="Symbol">λ</a> <a id="10080" href="WellFormed.Base.html#10080" class="Bound">s</a> <a id="10082" class="Symbol">→</a> <a id="10084" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10091" class="Symbol">(</a><a id="10092" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="10101" href="WellFormed.Base.html#10080" class="Bound">s</a> <a id="10103" href="WellFormed.Base.html#10069" class="Bound">r</a><a id="10104" class="Symbol">)</a>

<a id="rd-wfnd"></a><a id="10107" href="WellFormed.Base.html#10107" class="Function">rd-wfnd</a> <a id="10115" class="Symbol">:</a> <a id="10117" href="Induction.WellFounded.html#1604" class="Function">WellFounded</a> <a id="10129" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="10134" href="WellFormed.Base.html#10107" class="Function">rd-wfnd</a> <a id="10142" class="Symbol">_</a> <a id="10144" class="Symbol">=</a> <a id="10146" href="WellFormed.Base.html#9941" class="Function">rd-acc</a> <a id="10153" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
</pre>
**定理 2-0-14** 子树关系是良基关系.  
**证明** 与路径关系的证明类似, 但需要先证明命题关系的可及性是命题, 暴露出立方类型论的区间原语 `i` 后递归即得. ∎

<pre class="Agda"><a id="isPropAcc"></a><a id="10264" href="WellFormed.Base.html#10264" class="Function">isPropAcc</a> <a id="10274" class="Symbol">:</a> <a id="10276" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="10283" class="Symbol">(</a><a id="10284" href="Induction.WellFounded.html#1356" class="Datatype">Acc</a> <a id="10288" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="10292" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="10293" class="Symbol">)</a>
<a id="10295" href="WellFormed.Base.html#10264" class="Function">isPropAcc</a> <a id="10305" class="Symbol">(</a><a id="10306" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10310" href="WellFormed.Base.html#10310" class="Bound">p</a><a id="10311" class="Symbol">)</a> <a id="10313" class="Symbol">(</a><a id="10314" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10318" href="WellFormed.Base.html#10318" class="Bound">q</a><a id="10319" class="Symbol">)</a> <a id="10321" href="WellFormed.Base.html#10321" class="Bound">i</a> <a id="10323" class="Symbol">=</a> <a id="10325" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10329" class="Symbol">(λ</a> <a id="10332" href="WellFormed.Base.html#10332" class="Bound">x&lt;a</a> <a id="10336" class="Symbol">→</a> <a id="10338" href="WellFormed.Base.html#10264" class="Function">isPropAcc</a> <a id="10348" class="Symbol">(</a><a id="10349" href="WellFormed.Base.html#10310" class="Bound">p</a> <a id="10351" href="WellFormed.Base.html#10332" class="Bound">x&lt;a</a><a id="10354" class="Symbol">)</a> <a id="10356" class="Symbol">(</a><a id="10357" href="WellFormed.Base.html#10318" class="Bound">q</a> <a id="10359" href="WellFormed.Base.html#10332" class="Bound">x&lt;a</a><a id="10362" class="Symbol">)</a> <a id="10364" href="WellFormed.Base.html#10321" class="Bound">i</a><a id="10365" class="Symbol">)</a>

<a id="&lt;-acc"></a><a id="10368" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10374" class="Symbol">:</a> <a id="10376" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="10378" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="10380" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="10382" class="Symbol">→</a> <a id="10384" href="Induction.WellFounded.html#1356" class="Datatype">Acc</a> <a id="10388" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="10392" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="10394" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10400" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>    <a id="10409" class="Symbol">=</a> <a id="10411" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10415" class="Symbol">λ</a> <a id="10417" href="WellFormed.Base.html#10417" class="Bound">r</a> <a id="10419" class="Symbol">→</a> <a id="10421" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10427" href="WellFormed.Base.html#10417" class="Bound">r</a>
<a id="10429" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10435" class="Symbol">(</a><a id="10436" href="WellFormed.Base.html#4995" class="InductiveConstructor">suc₁</a> <a id="10441" href="WellFormed.Base.html#10441" class="Bound">r</a><a id="10442" class="Symbol">)</a> <a id="10444" class="Symbol">=</a> <a id="10446" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10450" class="Symbol">λ</a> <a id="10452" href="WellFormed.Base.html#10452" class="Bound">s</a> <a id="10454" class="Symbol">→</a> <a id="10456" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10462" class="Symbol">(</a><a id="10463" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="10471" href="WellFormed.Base.html#10452" class="Bound">s</a> <a id="10473" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="10475" href="WellFormed.Base.html#10441" class="Bound">r</a> <a id="10477" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="10479" class="Symbol">)</a>
<a id="10481" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10487" class="Symbol">(</a><a id="10488" href="WellFormed.Base.html#5023" class="InductiveConstructor">lim₁</a> <a id="10493" href="WellFormed.Base.html#10493" class="Bound">r</a><a id="10494" class="Symbol">)</a> <a id="10496" class="Symbol">=</a> <a id="10498" href="Induction.WellFounded.html#1418" class="InductiveConstructor">acc</a> <a id="10502" class="Symbol">λ</a> <a id="10504" href="WellFormed.Base.html#10504" class="Bound">s</a> <a id="10506" class="Symbol">→</a> <a id="10508" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10514" class="Symbol">(</a><a id="10515" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="10523" href="WellFormed.Base.html#10504" class="Bound">s</a> <a id="10525" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="10527" href="WellFormed.Base.html#10493" class="Bound">r</a> <a id="10529" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="10531" class="Symbol">)</a>
<a id="10533" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10539" class="Symbol">(</a><a id="10540" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="10548" href="WellFormed.Base.html#10548" class="Bound">p</a> <a id="10550" href="WellFormed.Base.html#10550" class="Bound">q</a> <a id="10552" href="WellFormed.Base.html#10552" class="Bound">i</a><a id="10553" class="Symbol">)</a> <a id="10555" class="Symbol">=</a> <a id="10557" href="WellFormed.Base.html#10264" class="Function">isPropAcc</a> <a id="10567" class="Symbol">(</a><a id="10568" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10574" href="WellFormed.Base.html#10548" class="Bound">p</a><a id="10575" class="Symbol">)</a> <a id="10577" class="Symbol">(</a><a id="10578" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10584" href="WellFormed.Base.html#10550" class="Bound">q</a><a id="10585" class="Symbol">)</a> <a id="10587" href="WellFormed.Base.html#10552" class="Bound">i</a>

<a id="&lt;-wfnd"></a><a id="10590" href="WellFormed.Base.html#10590" class="Function">&lt;-wfnd</a> <a id="10597" class="Symbol">:</a> <a id="10599" href="Induction.WellFounded.html#1604" class="Function">WellFounded</a> <a id="10611" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="10615" href="WellFormed.Base.html#10590" class="Function">&lt;-wfnd</a> <a id="10622" class="Symbol">_</a> <a id="10624" class="Symbol">=</a> <a id="10626" href="WellFormed.Base.html#10368" class="Function">&lt;-acc</a> <a id="10632" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>
</pre>
**推论 2-0-15** 路径关系和子树关系都是非对称且反自反的.  
**证明** 良基关系都是非对称且反自反的. ∎

<pre class="Agda"><a id="rd-asym"></a><a id="10714" href="WellFormed.Base.html#10714" class="Function">rd-asym</a> <a id="10722" class="Symbol">:</a> <a id="10724" href="Relation.Binary.Definitions.html#2590" class="Function">Asymmetric</a> <a id="10735" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="10740" href="WellFormed.Base.html#10714" class="Function">rd-asym</a> <a id="10748" class="Symbol">=</a> <a id="10750" href="Induction.WellFounded.html#4411" class="Function">wf⇒asym</a> <a id="10758" href="WellFormed.Base.html#10107" class="Function">rd-wfnd</a>

<a id="rd-irrefl"></a><a id="10767" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a> <a id="10777" class="Symbol">:</a> <a id="10779" href="Relation.Binary.Definitions.html#2478" class="Function">Irreflexive</a> <a id="10791" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="10795" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="10800" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a> <a id="10810" class="Symbol">=</a> <a id="10812" href="Induction.WellFounded.html#4488" class="Function">wf⇒irrefl</a> <a id="10822" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="10832" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="10836" href="WellFormed.Base.html#10107" class="Function">rd-wfnd</a>

<a id="&lt;-asym"></a><a id="10845" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="10852" class="Symbol">:</a> <a id="10854" href="Relation.Binary.Definitions.html#2590" class="Function">Asymmetric</a> <a id="10865" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="10869" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="10876" class="Symbol">=</a> <a id="10878" href="Induction.WellFounded.html#4411" class="Function">wf⇒asym</a> <a id="10886" href="WellFormed.Base.html#10590" class="Function">&lt;-wfnd</a>

<a id="&lt;-irrefl"></a><a id="10894" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="10903" class="Symbol">:</a> <a id="10905" href="Relation.Binary.Definitions.html#2478" class="Function">Irreflexive</a> <a id="10917" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="10921" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="10925" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="10934" class="Symbol">=</a> <a id="10936" href="Induction.WellFounded.html#4488" class="Function">wf⇒irrefl</a> <a id="10946" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="10955" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="10959" href="WellFormed.Base.html#10590" class="Function">&lt;-wfnd</a>
</pre>
**定理 2-0-16** 路径关系与子树关系分别构成严格偏序.  
**证明** 由以上讨论可知. ∎

<pre class="Agda"><a id="rd-isStrictPartialOrder"></a><a id="11033" href="WellFormed.Base.html#11033" class="Function">rd-isStrictPartialOrder</a> <a id="11057" class="Symbol">:</a> <a id="11059" href="Relation.Binary.Structures.html#4298" class="Record">IsStrictPartialOrder</a> <a id="11080" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="11085" href="WellFormed.Base.html#11033" class="Function">rd-isStrictPartialOrder</a> <a id="11109" class="Symbol">=</a> <a id="11111" class="Keyword">record</a>
  <a id="11120" class="Symbol">{</a> <a id="11122" href="Relation.Binary.Structures.html#4373" class="Field">isEquivalence</a> <a id="11136" class="Symbol">=</a> <a id="11138" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a>
  <a id="11154" class="Symbol">;</a> <a id="11156" href="Relation.Binary.Structures.html#4407" class="Field">irrefl</a> <a id="11163" class="Symbol">=</a> <a id="11165" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a>
  <a id="11177" class="Symbol">;</a> <a id="11179" href="Relation.Binary.Structures.html#4447" class="Field">trans</a> <a id="11185" class="Symbol">=</a> <a id="11187" href="WellFormed.Base.html#9206" class="Function">rd-trans</a>
  <a id="11198" class="Symbol">;</a> <a id="11200" href="Relation.Binary.Structures.html#4482" class="Field">&lt;-resp-≈</a> <a id="11209" class="Symbol">=</a> <a id="11211" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="11221" class="Symbol">}</a>

<a id="&lt;-isStrictPartialOrder"></a><a id="11224" href="WellFormed.Base.html#11224" class="Function">&lt;-isStrictPartialOrder</a> <a id="11247" class="Symbol">:</a> <a id="11249" href="Relation.Binary.Structures.html#4298" class="Record">IsStrictPartialOrder</a> <a id="11270" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="11274" href="WellFormed.Base.html#11224" class="Function">&lt;-isStrictPartialOrder</a> <a id="11297" class="Symbol">=</a> <a id="11299" class="Keyword">record</a>
  <a id="11308" class="Symbol">{</a> <a id="11310" href="Relation.Binary.Structures.html#4373" class="Field">isEquivalence</a> <a id="11324" class="Symbol">=</a> <a id="11326" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a>
  <a id="11342" class="Symbol">;</a> <a id="11344" href="Relation.Binary.Structures.html#4407" class="Field">irrefl</a> <a id="11351" class="Symbol">=</a> <a id="11353" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a>
  <a id="11364" class="Symbol">;</a> <a id="11366" href="Relation.Binary.Structures.html#4447" class="Field">trans</a> <a id="11372" class="Symbol">=</a> <a id="11374" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a>
  <a id="11384" class="Symbol">;</a> <a id="11386" href="Relation.Binary.Structures.html#4482" class="Field">&lt;-resp-≈</a> <a id="11395" class="Symbol">=</a> <a id="11397" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="11406" class="Symbol">}</a>
</pre>
### 非严格序

**定义 2-0-17** 非严格序

- 序数 $a$ 到 $b$ 的非严格路径, 记作 $\widetilde{\text{Rd}}(a,b)$, 定义为和类型 $\text{Rd}(a,b)+(a=b)$.
- 非严格子树关系, 记作 $a \le b$, 定义为和类型 $(a < b) + (a = b)$.

<pre class="Agda"><a id="11592" class="Keyword">open</a> <a id="11597" class="Keyword">import</a> <a id="11604" href="Relation.Binary.Construct.StrictToNonStrict.html" class="Module">Relation.Binary.Construct.StrictToNonStrict</a> <a id="11648" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="11652" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
  <a id="11659" class="Symbol">as</a> <a id="NonStrictRoad"></a><a id="11662" href="WellFormed.Base.html#11662" class="Module">NonStrictRoad</a> <a id="11676" class="Keyword">public</a> <a id="11683" class="Keyword">using</a> <a id="11689" class="Symbol">()</a> <a id="11692" class="Keyword">renaming</a> <a id="11701" class="Symbol">(</a><a id="11702" href="Relation.Binary.Construct.StrictToNonStrict.html#1310" class="Function Operator">_≤_</a> <a id="11706" class="Symbol">to</a> <a id="11709" class="Keyword">infix</a> <a id="11715" class="Number">6</a> <a id="11717" class="Function Operator">NSRoad</a><a id="11723" class="Symbol">;</a> <a id="11725" href="Relation.Binary.Construct.StrictToNonStrict.html#1537" class="Function">&lt;⇒≤</a> <a id="11729" class="Symbol">to</a> <a id="11732" class="Function">rd→ns</a><a id="11737" class="Symbol">)</a>

<a id="11740" class="Keyword">open</a> <a id="11745" class="Keyword">import</a> <a id="11752" href="Relation.Binary.Construct.StrictToNonStrict.html" class="Module">Relation.Binary.Construct.StrictToNonStrict</a> <a id="11796" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="11800" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
  <a id="11806" class="Symbol">as</a> <a id="NonStrictSubTree"></a><a id="11809" href="WellFormed.Base.html#11809" class="Module">NonStrictSubTree</a> <a id="11826" class="Keyword">public</a> <a id="11833" class="Keyword">using</a> <a id="11839" class="Symbol">()</a> <a id="11842" class="Keyword">renaming</a> <a id="11851" class="Symbol">(</a><a id="11852" href="Relation.Binary.Construct.StrictToNonStrict.html#1310" class="Function Operator">_≤_</a> <a id="11856" class="Symbol">to</a> <a id="11859" class="Keyword">infix</a> <a id="11865" class="Number">6</a> <a id="11867" class="Function Operator">_≤_</a><a id="11870" class="Symbol">;</a> <a id="11872" href="Relation.Binary.Construct.StrictToNonStrict.html#1537" class="Function">&lt;⇒≤</a> <a id="11876" class="Symbol">to</a> <a id="11879" class="Function">&lt;→≤</a><a id="11882" class="Symbol">)</a>
</pre>
**事实 2-0-18** 给定非严格路径, 可以证明非严格子树关系.

<pre class="Agda"><a id="ns→≤"></a><a id="11934" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="11939" class="Symbol">:</a> <a id="11941" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="11948" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="11950" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="11952" class="Symbol">→</a> <a id="11954" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="11956" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="11958" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="11960" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="11965" class="Symbol">(</a><a id="11966" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="11970" href="WellFormed.Base.html#11970" class="Bound">r</a><a id="11971" class="Symbol">)</a> <a id="11973" class="Symbol">=</a> <a id="11975" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="11979" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="11981" href="WellFormed.Base.html#11970" class="Bound">r</a> <a id="11983" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="11986" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="11991" class="Symbol">(</a><a id="11992" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="11996" href="WellFormed.Base.html#11996" class="Bound">p</a><a id="11997" class="Symbol">)</a> <a id="11999" class="Symbol">=</a> <a id="12001" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="12005" href="WellFormed.Base.html#11996" class="Bound">p</a>
</pre>
**引理 2-0-19** 非严格子树关系也是命题.  
**引理** 如果和类型两边的命题互斥, 那么和类型也是一个命题. 由定义 2-0-0, $\lt$ 是命题. 由事实 2-0-9, 序数的相等也是命题. 由推论 2-0-15 ($\lt$ 的反自反性), 显然 $a \lt b$ 与 $a = b$ 互斥. ∎

<pre class="Agda"><a id="isProp≤"></a><a id="12183" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="12191" class="Symbol">:</a> <a id="12193" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="12200" class="Symbol">(</a><a id="12201" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12203" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="12205" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="12206" class="Symbol">)</a>
<a id="12208" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="12216" class="Symbol">=</a> <a id="12218" href="Bridged.Data.Sum.html#744" class="Function">isProp⊎</a> <a id="12226" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="12234" href="WellFormed.Base.html#7850" class="Function">isProp≡</a> <a id="12242" class="Symbol">(</a><a id="12243" href="Function.Base.html#1638" class="Function">flip</a> <a id="12248" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a><a id="12256" class="Symbol">)</a>
</pre>
**定理 2-0-20** $a$ 到 $b^+$ 的严格路径可以转换为 $a$ 到 $b$ 的非严格路径.  
**证明** 讨论 $r:\text{Rd}(a,b^+)$.
- 若 $r=0$, 则必然有 $a=b$.
- 若存在 $r'$ 使得 $r=r'^+$, 则必然有 $r':\text{Rd}(a,b)$. ∎

<pre class="Agda"><a id="&lt;s→≤-rd"></a><a id="12436" href="WellFormed.Base.html#12436" class="Function">&lt;s→≤-rd</a> <a id="12444" class="Symbol">:</a> <a id="12446" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="12451" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12453" class="Symbol">(</a><a id="12454" class="InductiveConstructor">suc</a> <a id="12458" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="12459" class="Symbol">)</a> <a id="12461" class="Symbol">→</a> <a id="12463" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="12470" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12472" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="12474" href="WellFormed.Base.html#12436" class="Function">&lt;s→≤-rd</a> <a id="12482" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="12490" class="Symbol">=</a> <a id="12492" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="12496" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12501" href="WellFormed.Base.html#12436" class="Function">&lt;s→≤-rd</a> <a id="12509" class="Symbol">(</a><a id="12510" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="12514" href="WellFormed.Base.html#12514" class="Bound">r</a><a id="12515" class="Symbol">)</a> <a id="12517" class="Symbol">=</a> <a id="12519" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="12523" href="WellFormed.Base.html#12514" class="Bound">r</a>
</pre>
**推论 2-0-21** 如果 $a \lt b^+$, 那么 $a \le b$.  
**证明** 由上述定理及引理 2-0-19 ($\le$ 的命题性) 即得. ∎

<pre class="Agda"><a id="&lt;s→≤"></a><a id="12627" href="WellFormed.Base.html#12627" class="Function">&lt;s→≤</a> <a id="12632" class="Symbol">:</a> <a id="12634" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12636" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="12638" class="InductiveConstructor">suc</a> <a id="12642" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="12644" class="Symbol">→</a> <a id="12646" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12648" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="12650" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="12652" href="WellFormed.Base.html#12627" class="Function">&lt;s→≤</a> <a id="12657" class="Symbol">=</a> <a id="12659" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="12663" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="12671" class="Symbol">(</a><a id="12672" href="WellFormed.Base.html#11934" class="Function">ns→≤</a> <a id="12677" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="12679" href="WellFormed.Base.html#12436" class="Function">&lt;s→≤-rd</a><a id="12686" class="Symbol">)</a>
</pre>
**事实 2-0-22** 定理 2-0-20 以及推论 2-0-21 的逆命题也成立.  
**证明** 讨论和类型的两边即可. ∎

<pre class="Agda"><a id="≤→&lt;s-rd"></a><a id="12770" href="WellFormed.Base.html#12770" class="Function">≤→&lt;s-rd</a> <a id="12778" class="Symbol">:</a> <a id="12780" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="12787" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12789" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="12791" class="Symbol">→</a> <a id="12793" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="12798" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12800" class="Symbol">(</a><a id="12801" class="InductiveConstructor">suc</a> <a id="12805" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="12806" class="Symbol">)</a>
<a id="12808" href="WellFormed.Base.html#12770" class="Function">≤→&lt;s-rd</a> <a id="12816" class="Symbol">(</a><a id="12817" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="12821" href="WellFormed.Base.html#12821" class="Bound">r</a><a id="12822" class="Symbol">)</a>    <a id="12827" class="Symbol">=</a> <a id="12829" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="12833" href="WellFormed.Base.html#12821" class="Bound">r</a>
<a id="12835" href="WellFormed.Base.html#12770" class="Function">≤→&lt;s-rd</a> <a id="12843" class="Symbol">(</a><a id="12844" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="12848" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="12852" class="Symbol">)</a> <a id="12854" class="Symbol">=</a> <a id="12856" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>

<a id="≤→&lt;s"></a><a id="12862" href="WellFormed.Base.html#12862" class="Function">≤→&lt;s</a> <a id="12867" class="Symbol">:</a> <a id="12869" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12871" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="12873" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="12875" class="Symbol">→</a> <a id="12877" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="12879" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="12881" class="InductiveConstructor">suc</a> <a id="12885" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
<a id="12887" href="WellFormed.Base.html#12862" class="Function">≤→&lt;s</a> <a id="12892" class="Symbol">(</a><a id="12893" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="12897" href="WellFormed.Base.html#12897" class="Bound">r</a><a id="12898" class="Symbol">)</a>    <a id="12903" class="Symbol">=</a> <a id="12905" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="12909" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="12913" href="WellFormed.Base.html#12897" class="Bound">r</a>
<a id="12915" href="WellFormed.Base.html#12862" class="Function">≤→&lt;s</a> <a id="12920" class="Symbol">(</a><a id="12921" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="12925" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="12929" class="Symbol">)</a> <a id="12931" class="Symbol">=</a> <a id="12933" href="WellFormed.Base.html#4968" class="InductiveConstructor">zero₁</a>
</pre>
**定理 2-0-23** 非严格路径关系和非严格子树关系分别满足自反性, 反对称性和传递性.  
**证明** 由定义 2-0-17 以及推论 2-0-15 ($\lt$ 的反自反性和非对称性) 显然成立. ∎

<pre class="Agda"><a id="ns-refl"></a><a id="13060" href="WellFormed.Base.html#13060" class="Function">ns-refl</a> <a id="13068" class="Symbol">:</a> <a id="13070" href="Relation.Binary.Definitions.html#1428" class="Function">Reflexive</a> <a id="13080" href="WellFormed.Base.html#11717" class="Function">NSRoad</a>
<a id="13087" href="WellFormed.Base.html#13060" class="Function">ns-refl</a> <a id="13095" class="Symbol">=</a> <a id="13097" href="Relation.Binary.Construct.StrictToNonStrict.html#1565" class="Function">NonStrictRoad.reflexive</a> <a id="13121" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ns-antisym"></a><a id="13127" href="WellFormed.Base.html#13127" class="Function">ns-antisym</a> <a id="13138" class="Symbol">:</a> <a id="13140" href="Relation.Binary.Definitions.html#2319" class="Function">Antisymmetric</a> <a id="13154" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="13158" href="WellFormed.Base.html#11717" class="Function">NSRoad</a>
<a id="13165" href="WellFormed.Base.html#13127" class="Function">ns-antisym</a> <a id="13176" class="Symbol">=</a> <a id="13178" href="Relation.Binary.Construct.StrictToNonStrict.html#1605" class="Function">NonStrictRoad.antisym</a> <a id="13200" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a> <a id="13214" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="13223" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a>

<a id="ns-trans"></a><a id="13234" href="WellFormed.Base.html#13234" class="Function">ns-trans</a> <a id="13243" class="Symbol">:</a> <a id="13245" href="Relation.Binary.Definitions.html#2103" class="Function">Transitive</a> <a id="13256" href="WellFormed.Base.html#11717" class="Function">NSRoad</a>
<a id="13263" href="WellFormed.Base.html#13234" class="Function">ns-trans</a> <a id="13272" class="Symbol">=</a> <a id="13274" href="Relation.Binary.Construct.StrictToNonStrict.html#1976" class="Function">NonStrictRoad.trans</a> <a id="13294" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a> <a id="13308" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="13318" href="WellFormed.Base.html#9206" class="Function">rd-trans</a>

<a id="rd-ns-trans"></a><a id="13328" href="WellFormed.Base.html#13328" class="Function">rd-ns-trans</a> <a id="13340" class="Symbol">:</a> <a id="13342" href="Relation.Binary.Definitions.html#1674" class="Function">Trans</a> <a id="13348" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="13353" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="13360" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="13365" href="WellFormed.Base.html#13328" class="Function">rd-ns-trans</a> <a id="13377" class="Symbol">=</a> <a id="13379" href="Relation.Binary.Construct.StrictToNonStrict.html#2379" class="Function">NonStrictRoad.&lt;-≤-trans</a> <a id="13403" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="13412" class="Symbol">(</a><a id="13413" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="13417" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a><a id="13426" class="Symbol">)</a>

<a id="ns-rd-trans"></a><a id="13429" href="WellFormed.Base.html#13429" class="Function">ns-rd-trans</a> <a id="13441" class="Symbol">:</a> <a id="13443" href="Relation.Binary.Definitions.html#1674" class="Function">Trans</a> <a id="13449" href="WellFormed.Base.html#11717" class="Function">NSRoad</a> <a id="13456" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="13461" href="WellFormed.Base.html#2987" class="Datatype">Road</a>
<a id="13466" href="WellFormed.Base.html#13429" class="Function">ns-rd-trans</a> <a id="13478" class="Symbol">=</a> <a id="13480" href="Relation.Binary.Construct.StrictToNonStrict.html#2553" class="Function">NonStrictRoad.≤-&lt;-trans</a> <a id="13504" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="13508" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="13517" class="Symbol">(</a><a id="13518" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13522" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a><a id="13531" class="Symbol">)</a>

<a id="≤-refl"></a><a id="13534" href="WellFormed.Base.html#13534" class="Function">≤-refl</a> <a id="13541" class="Symbol">:</a> <a id="13543" href="Relation.Binary.Definitions.html#1428" class="Function">Reflexive</a> <a id="13553" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="13557" href="WellFormed.Base.html#13534" class="Function">≤-refl</a> <a id="13564" class="Symbol">=</a> <a id="13566" href="Relation.Binary.Construct.StrictToNonStrict.html#1565" class="Function">NonStrictSubTree.reflexive</a> <a id="13593" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="≤-antisym"></a><a id="13599" href="WellFormed.Base.html#13599" class="Function">≤-antisym</a> <a id="13609" class="Symbol">:</a> <a id="13611" href="Relation.Binary.Definitions.html#2319" class="Function">Antisymmetric</a> <a id="13625" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="13629" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="13633" href="WellFormed.Base.html#13599" class="Function">≤-antisym</a> <a id="13643" class="Symbol">=</a> <a id="13645" href="Relation.Binary.Construct.StrictToNonStrict.html#1605" class="Function">NonStrictSubTree.antisym</a> <a id="13670" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a> <a id="13684" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="13692" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a>

<a id="≤-trans"></a><a id="13702" href="WellFormed.Base.html#13702" class="Function">≤-trans</a> <a id="13710" class="Symbol">:</a> <a id="13712" href="Relation.Binary.Definitions.html#2103" class="Function">Transitive</a> <a id="13723" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="13727" href="WellFormed.Base.html#13702" class="Function">≤-trans</a> <a id="13735" class="Symbol">=</a> <a id="13737" href="Relation.Binary.Construct.StrictToNonStrict.html#1976" class="Function">NonStrictSubTree.trans</a> <a id="13760" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a> <a id="13774" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="13783" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a>

<a id="&lt;-≤-trans"></a><a id="13792" href="WellFormed.Base.html#13792" class="Function">&lt;-≤-trans</a> <a id="13802" class="Symbol">:</a> <a id="13804" href="Relation.Binary.Definitions.html#1674" class="Function">Trans</a> <a id="13810" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="13814" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a> <a id="13818" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="13822" href="WellFormed.Base.html#13792" class="Function">&lt;-≤-trans</a> <a id="13832" class="Symbol">=</a> <a id="13834" href="Relation.Binary.Construct.StrictToNonStrict.html#2379" class="Function">NonStrictSubTree.&lt;-≤-trans</a> <a id="13861" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="13869" class="Symbol">(</a><a id="13870" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="13874" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a><a id="13882" class="Symbol">)</a>

<a id="≤-&lt;-trans"></a><a id="13885" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="13895" class="Symbol">:</a> <a id="13897" href="Relation.Binary.Definitions.html#1674" class="Function">Trans</a> <a id="13903" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a> <a id="13907" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a> <a id="13911" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a>
<a id="13915" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="13925" class="Symbol">=</a> <a id="13927" href="Relation.Binary.Construct.StrictToNonStrict.html#2553" class="Function">NonStrictSubTree.≤-&lt;-trans</a> <a id="13954" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="13958" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="13966" class="Symbol">(</a><a id="13967" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13971" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a><a id="13979" class="Symbol">)</a>
</pre>
**定理 2-0-24** 非严格路径关系与非严格子树关系分别构成非严格偏序.  
**证明** 由以上讨论可知. ∎

<pre class="Agda"><a id="ns-isPreorder"></a><a id="14055" href="WellFormed.Base.html#14055" class="Function">ns-isPreorder</a> <a id="14069" class="Symbol">:</a> <a id="14071" href="Relation.Binary.Structures.html#2191" class="Record">IsPreorder</a> <a id="14082" href="WellFormed.Base.html#11717" class="Function">NSRoad</a>
<a id="14089" href="WellFormed.Base.html#14055" class="Function">ns-isPreorder</a> <a id="14103" class="Symbol">=</a> <a id="14105" class="Keyword">record</a>
  <a id="14114" class="Symbol">{</a> <a id="14116" href="Relation.Binary.Structures.html#2256" class="Field">isEquivalence</a> <a id="14130" class="Symbol">=</a> <a id="14132" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a>
  <a id="14148" class="Symbol">;</a> <a id="14150" href="Relation.Binary.Structures.html#2359" class="Field">reflexive</a> <a id="14160" class="Symbol">=</a> <a id="14162" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a>
  <a id="14168" class="Symbol">;</a> <a id="14170" href="Relation.Binary.Structures.html#2389" class="Field">trans</a> <a id="14176" class="Symbol">=</a> <a id="14178" href="WellFormed.Base.html#13234" class="Function">ns-trans</a>
  <a id="14189" class="Symbol">}</a>

<a id="ns-isPartialOrder"></a><a id="14192" href="WellFormed.Base.html#14192" class="Function">ns-isPartialOrder</a> <a id="14210" class="Symbol">:</a> <a id="14212" href="Relation.Binary.Structures.html#3522" class="Record">IsPartialOrder</a> <a id="14227" href="WellFormed.Base.html#11717" class="Function">NSRoad</a>
<a id="14234" href="WellFormed.Base.html#14192" class="Function">ns-isPartialOrder</a> <a id="14252" class="Symbol">=</a> <a id="14254" class="Keyword">record</a> <a id="14261" class="Symbol">{</a> <a id="14263" href="Relation.Binary.Structures.html#3591" class="Field">isPreorder</a> <a id="14274" class="Symbol">=</a> <a id="14276" href="WellFormed.Base.html#14055" class="Function">ns-isPreorder</a> <a id="14290" class="Symbol">;</a> <a id="14292" href="Relation.Binary.Structures.html#3623" class="Field">antisym</a> <a id="14300" class="Symbol">=</a> <a id="14302" href="WellFormed.Base.html#13127" class="Function">ns-antisym</a> <a id="14313" class="Symbol">}</a>

<a id="≤-isPreorder"></a><a id="14316" href="WellFormed.Base.html#14316" class="Function">≤-isPreorder</a> <a id="14329" class="Symbol">:</a> <a id="14331" href="Relation.Binary.Structures.html#2191" class="Record">IsPreorder</a> <a id="14342" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="14346" href="WellFormed.Base.html#14316" class="Function">≤-isPreorder</a> <a id="14359" class="Symbol">=</a> <a id="14361" class="Keyword">record</a>
  <a id="14370" class="Symbol">{</a> <a id="14372" href="Relation.Binary.Structures.html#2256" class="Field">isEquivalence</a> <a id="14386" class="Symbol">=</a> <a id="14388" href="Relation.Binary.PropositionalEquality.Properties.html#5422" class="Function">isEquivalence</a>
  <a id="14404" class="Symbol">;</a> <a id="14406" href="Relation.Binary.Structures.html#2359" class="Field">reflexive</a> <a id="14416" class="Symbol">=</a> <a id="14418" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a>
  <a id="14424" class="Symbol">;</a> <a id="14426" href="Relation.Binary.Structures.html#2389" class="Field">trans</a> <a id="14432" class="Symbol">=</a> <a id="14434" href="WellFormed.Base.html#13702" class="Function">≤-trans</a>
  <a id="14444" class="Symbol">}</a>

<a id="≤-isPartialOrder"></a><a id="14447" href="WellFormed.Base.html#14447" class="Function">≤-isPartialOrder</a> <a id="14464" class="Symbol">:</a> <a id="14466" href="Relation.Binary.Structures.html#3522" class="Record">IsPartialOrder</a> <a id="14481" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a>
<a id="14485" href="WellFormed.Base.html#14447" class="Function">≤-isPartialOrder</a> <a id="14502" class="Symbol">=</a> <a id="14504" class="Keyword">record</a> <a id="14511" class="Symbol">{</a> <a id="14513" href="Relation.Binary.Structures.html#3591" class="Field">isPreorder</a> <a id="14524" class="Symbol">=</a> <a id="14526" href="WellFormed.Base.html#14316" class="Function">≤-isPreorder</a> <a id="14539" class="Symbol">;</a> <a id="14541" href="Relation.Binary.Structures.html#3623" class="Field">antisym</a> <a id="14549" class="Symbol">=</a> <a id="14551" href="WellFormed.Base.html#13599" class="Function">≤-antisym</a> <a id="14561" class="Symbol">}</a>
</pre>
证明以上性质后, 我们可以实例化以下记法模块以提高序关系证明代码的可读性, 会在后文中看到.

<pre class="Agda"><a id="14624" class="Keyword">module</a> <a id="RoadReasoning"></a><a id="14631" href="WellFormed.Base.html#14631" class="Module">RoadReasoning</a> <a id="14645" class="Keyword">where</a>
  <a id="14653" class="Keyword">open</a> <a id="14658" class="Keyword">import</a> <a id="14665" href="Relation.Binary.Reasoning.Base.Triple.html" class="Module">Relation.Binary.Reasoning.Base.Triple</a>
    <a id="14707" class="Symbol">{</a><a id="14708" class="Argument">_≈_</a> <a id="14712" class="Symbol">=</a> <a id="14714" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="14717" class="Symbol">}</a> <a id="14719" class="Symbol">{</a><a id="14720" class="Argument">_≤_</a> <a id="14724" class="Symbol">=</a> <a id="14726" href="WellFormed.Base.html#11717" class="Function">NSRoad</a><a id="14732" class="Symbol">}</a> <a id="14734" class="Symbol">{</a><a id="14735" class="Argument">_&lt;_</a> <a id="14739" class="Symbol">=</a> <a id="14741" href="WellFormed.Base.html#2987" class="Datatype">Road</a><a id="14745" class="Symbol">}</a>
    <a id="14751" href="WellFormed.Base.html#14055" class="Function">ns-isPreorder</a> <a id="14765" href="WellFormed.Base.html#10714" class="Function">rd-asym</a> <a id="14773" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="14782" href="WellFormed.Base.html#8636" class="Function">rd-resp-≡</a> <a id="14792" href="WellFormed.Base.html#11732" class="Function">rd→ns</a> <a id="14798" href="WellFormed.Base.html#13328" class="Function">rd-ns-trans</a> <a id="14810" href="WellFormed.Base.html#13429" class="Function">ns-rd-trans</a>
    <a id="14826" class="Keyword">public</a>

<a id="14834" class="Keyword">module</a> <a id="SubTreeReasoning"></a><a id="14841" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a> <a id="14858" class="Keyword">where</a>
  <a id="14866" class="Keyword">open</a> <a id="14871" class="Keyword">import</a> <a id="14878" href="Relation.Binary.Reasoning.Base.Triple.html" class="Module">Relation.Binary.Reasoning.Base.Triple</a>
    <a id="14920" class="Symbol">{</a><a id="14921" class="Argument">_≈_</a> <a id="14925" class="Symbol">=</a> <a id="14927" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="14930" class="Symbol">}</a> <a id="14932" class="Symbol">{</a><a id="14933" class="Argument">_≤_</a> <a id="14937" class="Symbol">=</a> <a id="14939" href="WellFormed.Base.html#11867" class="Function Operator">_≤_</a><a id="14942" class="Symbol">}</a> <a id="14944" class="Symbol">{</a><a id="14945" class="Argument">_&lt;_</a> <a id="14949" class="Symbol">=</a> <a id="14951" href="WellFormed.Base.html#3168" class="Function Operator">_&lt;_</a><a id="14954" class="Symbol">}</a>
    <a id="14960" href="WellFormed.Base.html#14316" class="Function">≤-isPreorder</a> <a id="14973" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="14980" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="14988" href="WellFormed.Base.html#8718" class="Function">&lt;-resp-≡</a> <a id="14997" href="WellFormed.Base.html#11879" class="Function">&lt;→≤</a> <a id="15001" href="WellFormed.Base.html#13792" class="Function">&lt;-≤-trans</a> <a id="15011" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a>
    <a id="15025" class="Keyword">public</a>
</pre>
## 良构序列的性质

**引理 2-0-25** 良构序列 $f$ 保持自然数的序, 即对任意 $m < n$ 都有 $f(m) < f(n)$.  
**证明** 对 $n$ 归纳.

- 若 $n=0$, 虚空真.
- 若 $n=n'^+$, 有 $m\lt n'^+$, 即 $m≤n'$
  - 若 $m\lt n'$, 由归纳假设有 $f(m)\lt f(n')$, 由 $f$ 的良构性质有 $f(n')\lt f(n'^+)$, 由 $\lt$ 的传递性有 $f(m)\lt f(n'^+)=f(n)$.
  - 若 $m=n'$, 由 $f$ 的良构性质有 $f(m)=f(n')\lt f(n'^+)=f(n)$. ∎

<pre class="Agda"><a id="seq-pres"></a><a id="15366" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="15375" class="Symbol">:</a> <a id="15377" class="Symbol">⦃</a> <a id="15379" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="15382" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="15384" class="Symbol">⦄</a> <a id="15386" class="Symbol">→</a> <a id="15388" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="15390" href="Data.Nat.Base.html#1801" class="Function Operator">ℕ.&lt;</a> <a id="15394" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="15396" class="Symbol">→</a> <a id="15398" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="15400" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="15402" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="15404" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="15406" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="15408" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="15417" class="Symbol">{</a><a id="15418" href="WellFormed.Base.html#15418" class="Bound">f</a><a id="15419" class="Symbol">}</a> <a id="15421" class="Symbol">{</a><a id="15422" href="WellFormed.Base.html#15422" class="Bound">m</a><a id="15423" class="Symbol">}</a> <a id="15425" class="Symbol">(</a><a id="15426" href="Data.Nat.Base.html#1756" class="InductiveConstructor">ℕ.s≤s</a> <a id="15432" class="Symbol">{</a><a id="15433" href="WellFormed.Base.html#15433" class="Bound">n</a><a id="15434" class="Symbol">}</a> <a id="15436" href="WellFormed.Base.html#15436" class="Bound">m≤n</a><a id="15439" class="Symbol">)</a> <a id="15441" class="Keyword">with</a> <a id="15446" href="Data.Nat.Properties.html#12931" class="Function">ℕ.m≤n⇒m&lt;n∨m≡n</a> <a id="15460" href="WellFormed.Base.html#15436" class="Bound">m≤n</a>
<a id="15464" class="Symbol">...</a> <a id="15468" class="Symbol">|</a> <a id="15470" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="15474" href="WellFormed.Base.html#15474" class="Bound">m&lt;n</a> <a id="15478" class="Symbol">=</a> <a id="15480" href="Relation.Binary.Reasoning.Syntax.html#2946" class="Function Operator">begin-strict</a>
  <a id="15495" class="Symbol">(</a><a id="15496" class="Bound">f</a> <a id="15498" class="Bound">m</a><a id="15499" class="Symbol">)</a>         <a id="15509" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="15512" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="15521" href="WellFormed.Base.html#15474" class="Bound">m&lt;n</a> <a id="15525" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="15529" class="Symbol">(</a><a id="15530" class="Bound">f</a> <a id="15532" class="Bound">n</a><a id="15533" class="Symbol">)</a>         <a id="15543" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">&lt;⟨</a> <a id="15546" href="Function.Base.html#4736" class="Function">it</a> <a id="15549" href="Relation.Binary.Reasoning.Syntax.html#5627" class="Function">⟩</a>
  <a id="15553" class="Bound">f</a> <a id="15555" class="Symbol">(</a><a id="15556" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15560" class="Bound">n</a><a id="15561" class="Symbol">)</a>     <a id="15567" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="15569" class="Keyword">where</a> <a id="15575" class="Keyword">open</a> <a id="15580" href="WellFormed.Base.html#14841" class="Module">SubTreeReasoning</a>
<a id="15597" class="Symbol">...</a> <a id="15601" class="Symbol">|</a> <a id="15603" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="15607" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="15612" class="Symbol">=</a> <a id="15614" href="Function.Base.html#4736" class="Function">it</a>
</pre>
注意上面的代码用到了我们刚才提到的高可读记法, 我们称为序关系推理链.

**引理 2-0-26** 良构序列对自然数的相等单射, 即如果序列的两个项相等, 那么它们的序号相等.  
**证明** 由良构序列的严格递增性显然成立. ∎

<pre class="Agda"><a id="seq-inj≡"></a><a id="15749" href="WellFormed.Base.html#15749" class="Function">seq-inj≡</a> <a id="15758" class="Symbol">:</a> <a id="15760" class="Symbol">∀</a> <a id="15762" href="WellFormed.Base.html#15762" class="Bound">f</a> <a id="15764" class="Symbol">→</a> <a id="15766" class="Symbol">⦃</a> <a id="15768" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="15771" href="WellFormed.Base.html#15762" class="Bound">f</a> <a id="15773" class="Symbol">⦄</a> <a id="15775" class="Symbol">→</a> <a id="15777" href="WellFormed.Base.html#15762" class="Bound">f</a> <a id="15779" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="15781" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15783" href="WellFormed.Base.html#15762" class="Bound">f</a> <a id="15785" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="15787" class="Symbol">→</a> <a id="15789" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="15791" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="15793" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="15795" href="WellFormed.Base.html#15749" class="Function">seq-inj≡</a> <a id="15804" class="Symbol">{</a><a id="15805" href="WellFormed.Base.html#15805" class="Bound">m</a><a id="15806" class="Symbol">}</a> <a id="15808" class="Symbol">{</a><a id="15809" href="WellFormed.Base.html#15809" class="Bound">n</a><a id="15810" class="Symbol">}</a> <a id="15812" class="Symbol">_</a> <a id="15814" href="WellFormed.Base.html#15814" class="Bound">eq</a> <a id="15817" class="Keyword">with</a> <a id="15822" href="Data.Nat.Properties.html#10543" class="Function">&lt;-cmp</a> <a id="15828" href="WellFormed.Base.html#15805" class="Bound">m</a> <a id="15830" href="WellFormed.Base.html#15809" class="Bound">n</a>
<a id="15832" class="Symbol">...</a> <a id="15836" class="Symbol">|</a> <a id="15838" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="15843" href="WellFormed.Base.html#15843" class="Bound">m&lt;n</a> <a id="15847" class="Symbol">_</a> <a id="15849" class="Symbol">_</a>  <a id="15852" class="Symbol">=</a> <a id="15854" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="15861" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="15863" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="15872" class="Bound">eq</a> <a id="15875" class="Symbol">(</a><a id="15876" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="15885" href="WellFormed.Base.html#15843" class="Bound">m&lt;n</a><a id="15888" class="Symbol">)</a>
<a id="15890" class="Symbol">...</a> <a id="15894" class="Symbol">|</a> <a id="15896" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="15901" class="Symbol">_</a> <a id="15903" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="15908" class="Symbol">_</a> <a id="15910" class="Symbol">=</a> <a id="15912" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="15917" class="Symbol">...</a> <a id="15921" class="Symbol">|</a> <a id="15923" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="15928" class="Symbol">_</a> <a id="15930" class="Symbol">_</a> <a id="15932" href="WellFormed.Base.html#15932" class="Bound">n&lt;m</a>  <a id="15937" class="Symbol">=</a> <a id="15939" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="15946" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="15948" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="15957" class="Symbol">(</a><a id="15958" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="15962" class="Bound">eq</a><a id="15964" class="Symbol">)</a> <a id="15966" class="Symbol">(</a><a id="15967" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="15976" href="WellFormed.Base.html#15932" class="Bound">n&lt;m</a><a id="15979" class="Symbol">)</a>
</pre>
**引理 2-0-27** 良构序列反映自然数的序, 即序列的两个项的大小关系反映序号的大小关系.  
**证明** 由良构序列的严格递增性显然成立. ∎

<pre class="Agda"><a id="seq-inj&lt;"></a><a id="16073" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="16082" class="Symbol">:</a> <a id="16084" class="Symbol">∀</a> <a id="16086" href="WellFormed.Base.html#16086" class="Bound">f</a> <a id="16088" class="Symbol">→</a> <a id="16090" class="Symbol">⦃</a> <a id="16092" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="16095" href="WellFormed.Base.html#16086" class="Bound">f</a> <a id="16097" class="Symbol">⦄</a> <a id="16099" class="Symbol">→</a> <a id="16101" href="WellFormed.Base.html#16086" class="Bound">f</a> <a id="16103" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="16105" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="16107" href="WellFormed.Base.html#16086" class="Bound">f</a> <a id="16109" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="16111" class="Symbol">→</a> <a id="16113" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="16115" href="Data.Nat.Base.html#1801" class="Function Operator">ℕ.&lt;</a> <a id="16119" href="WellFormed.Base.html#3770" class="Generalizable">n</a>
<a id="16121" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="16130" class="Symbol">{</a><a id="16131" href="WellFormed.Base.html#16131" class="Bound">m</a><a id="16132" class="Symbol">}</a> <a id="16134" class="Symbol">{</a><a id="16135" href="WellFormed.Base.html#16135" class="Bound">n</a><a id="16136" class="Symbol">}</a> <a id="16138" class="Symbol">_</a> <a id="16140" href="WellFormed.Base.html#16140" class="Bound">r</a> <a id="16142" class="Keyword">with</a> <a id="16147" href="Data.Nat.Properties.html#10543" class="Function">&lt;-cmp</a> <a id="16153" href="WellFormed.Base.html#16131" class="Bound">m</a> <a id="16155" href="WellFormed.Base.html#16135" class="Bound">n</a>
<a id="16157" class="Symbol">...</a> <a id="16161" class="Symbol">|</a> <a id="16163" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="16168" href="WellFormed.Base.html#16168" class="Bound">m&lt;n</a> <a id="16172" class="Symbol">_</a> <a id="16174" class="Symbol">_</a>  <a id="16177" class="Symbol">=</a> <a id="16179" href="WellFormed.Base.html#16168" class="Bound">m&lt;n</a>
<a id="16183" class="Symbol">...</a> <a id="16187" class="Symbol">|</a> <a id="16189" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="16194" class="Symbol">_</a> <a id="16196" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="16201" class="Symbol">_</a> <a id="16203" class="Symbol">=</a> <a id="16205" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="16212" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="16214" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="16223" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="16228" class="Bound">r</a>
<a id="16230" class="Symbol">...</a> <a id="16234" class="Symbol">|</a> <a id="16236" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="16241" class="Symbol">_</a> <a id="16243" class="Symbol">_</a> <a id="16245" href="WellFormed.Base.html#16245" class="Bound">n&lt;m</a>  <a id="16250" class="Symbol">=</a> <a id="16252" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="16259" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="16261" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="16268" class="Bound">r</a> <a id="16270" class="Symbol">(</a><a id="16271" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="16280" href="WellFormed.Base.html#16245" class="Bound">n&lt;m</a><a id="16283" class="Symbol">)</a>
</pre>
**事实 2-0-28** 对良构序列 $f$, 不存在 $m$ 使得 $f(m)$ 正好位于 $f(n)$ 与 $f(n^+)$ 之间.  
**证明** 由引理 2-0-25 以及自然数的相关性质可得. ∎

<pre class="Agda"><a id="seq-notDense"></a><a id="16405" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="16418" class="Symbol">:</a> <a id="16420" class="Symbol">∀</a> <a id="16422" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16424" class="Symbol">→</a> <a id="16426" class="Symbol">⦃</a> <a id="16428" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="16431" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16433" class="Symbol">⦄</a> <a id="16435" class="Symbol">→</a> <a id="16437" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16439" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="16441" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="16443" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16445" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="16447" class="Symbol">→</a> <a id="16449" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16451" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="16453" href="WellFormed.Base.html#3172" class="Function Operator">≮</a> <a id="16455" href="WellFormed.Base.html#16422" class="Bound">f</a> <a id="16457" class="Symbol">(</a><a id="16458" class="InductiveConstructor">suc</a> <a id="16462" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="16463" class="Symbol">)</a>
<a id="16465" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="16478" href="WellFormed.Base.html#16478" class="Bound">f</a> <a id="16480" href="WellFormed.Base.html#16480" class="Bound">r</a> <a id="16482" href="WellFormed.Base.html#16482" class="Bound">s</a> <a id="16484" class="Symbol">=</a> <a id="16486" href="Data.Nat.Properties.html#8631" class="Function">ℕ.&lt;⇒≱</a> <a id="16492" class="Symbol">(</a><a id="16493" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="16502" href="WellFormed.Base.html#16478" class="Bound">f</a> <a id="16504" href="WellFormed.Base.html#16480" class="Bound">r</a><a id="16505" class="Symbol">)</a> <a id="16507" class="Symbol">(</a><a id="16508" href="Data.Nat.Properties.html#13010" class="Function">ℕ.m&lt;1+n⇒m≤n</a> <a id="16520" class="Symbol">(</a><a id="16521" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="16530" href="WellFormed.Base.html#16478" class="Bound">f</a> <a id="16532" href="WellFormed.Base.html#16482" class="Bound">s</a><a id="16533" class="Symbol">))</a>
</pre>
## 同株关系

**定义 2-0-29** 序数 $a$ 与 $b$ 同株集, 记作 $\text{Homo}(a,b)$, 定义为从 $a$ 与 $b$ 通过路径关系共同延伸出去的那些序数. 如果该同株集非空, 我们就说 $a$ 与 $b$ 同株.

<pre class="Agda"><a id="Homo"></a><a id="16677" href="WellFormed.Base.html#16677" class="Function">Homo</a> <a id="16682" class="Symbol">:</a> <a id="16684" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="16688" class="Symbol">→</a> <a id="16690" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="16694" class="Symbol">→</a> <a id="16696" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="16701" href="WellFormed.Base.html#16677" class="Function">Homo</a> <a id="16706" href="WellFormed.Base.html#16706" class="Bound">a</a> <a id="16708" href="WellFormed.Base.html#16708" class="Bound">b</a> <a id="16710" class="Symbol">=</a> <a id="16712" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="16715" href="WellFormed.Base.html#16715" class="Bound">c</a> <a id="16717" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="16719" href="WellFormed.Base.html#2971" class="Datatype">Ord</a> <a id="16723" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="16725" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="16730" href="WellFormed.Base.html#16706" class="Bound">a</a> <a id="16732" href="WellFormed.Base.html#16715" class="Bound">c</a> <a id="16734" href="Cubical.Data.Sigma.Base.html#461" class="Function Operator">×</a> <a id="16736" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="16741" href="WellFormed.Base.html#16708" class="Bound">b</a> <a id="16743" href="WellFormed.Base.html#16715" class="Bound">c</a>
</pre>
**事实 2-0-30** 同株关系是自反且对称的.  
**证明** 由定义 2-0-29 显然成立. ∎

<pre class="Agda"><a id="Homo-refl"></a><a id="16814" href="WellFormed.Base.html#16814" class="Function">Homo-refl</a> <a id="16824" class="Symbol">:</a> <a id="16826" href="Relation.Binary.Definitions.html#1428" class="Function">Reflexive</a> <a id="16836" href="WellFormed.Base.html#16677" class="Function">Homo</a>
<a id="16841" href="WellFormed.Base.html#16814" class="Function">Homo-refl</a> <a id="16851" class="Symbol">{</a><a id="16852" href="WellFormed.Base.html#16852" class="Bound">x</a><a id="16853" class="Symbol">}</a> <a id="16855" class="Symbol">=</a> <a id="16857" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="16861" href="WellFormed.Base.html#16852" class="Bound">x</a> <a id="16863" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16865" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="16870" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16872" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>

<a id="Homo-sym"></a><a id="16878" href="WellFormed.Base.html#16878" class="Function">Homo-sym</a> <a id="16887" class="Symbol">:</a> <a id="16889" href="Relation.Binary.Definitions.html#1587" class="Function">Symmetric</a> <a id="16899" href="WellFormed.Base.html#16677" class="Function">Homo</a>
<a id="16904" href="WellFormed.Base.html#16878" class="Function">Homo-sym</a> <a id="16913" class="Symbol">(</a><a id="16914" href="WellFormed.Base.html#16914" class="Bound">c</a> <a id="16916" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16918" href="WellFormed.Base.html#16918" class="Bound">a&lt;c</a> <a id="16922" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16924" href="WellFormed.Base.html#16924" class="Bound">b&lt;c</a><a id="16927" class="Symbol">)</a> <a id="16929" class="Symbol">=</a> <a id="16931" href="WellFormed.Base.html#16914" class="Bound">c</a> <a id="16933" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16935" href="WellFormed.Base.html#16924" class="Bound">b&lt;c</a> <a id="16939" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="16941" href="WellFormed.Base.html#16918" class="Bound">a&lt;c</a>
</pre>
**注意 2-0-31** 同株关系不是传递关系. 比如 $0$ 与 $\lim(0,1,...)$ 同株, 也与 $\lim(1,2,...)$ 同株, 但后两者不同株. 「考虑同株」是在不商掉后两者的那种等价关系的情况下的代替处理方法, 出于形式上简洁的考虑.

## 子树的三歧性

**引理 2-0-32** 子树关系的连通性 $(a \lt b) + (b ≤ a)$ 是命题.  
**证明** 由推论 2-0-15 ($\lt$ 的反自反性), $a\lt b$ 与 $b≤a$ 互斥. ∎

<pre class="Agda"><a id="isPropConnex"></a><a id="17212" href="WellFormed.Base.html#17212" class="Function">isPropConnex</a> <a id="17225" class="Symbol">:</a> <a id="17227" href="Cubical.Foundations.Prelude.html#14575" class="Function">isProp</a> <a id="17234" class="Symbol">(</a><a id="17235" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="17237" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="17239" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="17241" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="17243" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="17245" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="17247" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="17248" class="Symbol">)</a>
<a id="17250" href="WellFormed.Base.html#17212" class="Function">isPropConnex</a> <a id="17263" class="Symbol">=</a> <a id="17265" href="Bridged.Data.Sum.html#744" class="Function">isProp⊎</a> <a id="17273" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="17281" href="WellFormed.Base.html#12183" class="Function">isProp≤</a> <a id="17289" class="Symbol">λ</a> <a id="17291" href="WellFormed.Base.html#17291" class="Bound">r</a> <a id="17293" href="WellFormed.Base.html#17293" class="Bound">s</a> <a id="17295" class="Symbol">→</a> <a id="17297" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="17306" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="17311" class="Symbol">(</a><a id="17312" href="WellFormed.Base.html#13792" class="Function">&lt;-≤-trans</a> <a id="17322" href="WellFormed.Base.html#17291" class="Bound">r</a> <a id="17324" href="WellFormed.Base.html#17293" class="Bound">s</a><a id="17325" class="Symbol">)</a>
</pre>
**定理 2-0-33** 忽略非同株序数 (up to homo), $\lt$ 与 $≤$ 连通.  
**证明** 即证在给定 $r:\text{Rd}(a,c)$ 与 $s:\text{Rd}(b,c)$ 的情况下, 有 $(a \lt b) + (b ≤ a)$ 成立. 对 $r$ 和 $s$ 归纳.

- 若 $r=0$ 且 $s=0$, 显然 $a=b$.
- 若 $r=0$ 且 $s=s'^+$, 必然有 $s':\text{Rd}(b,a)$, 于是 $|s'|:b \lt a$.
- 若 $r=r'^+$ 且 $s=0$, 必然有 $r':\text{Rd}(a,b)$, 于是 $|r'|:a \lt b$.
- 若 $r=r'^+$ 且 $s=s'^+$, 必然有 $r':\text{Rd}(a,c')$ 且 $s':\text{Rd}(b,c')$, 其中 $c'^+=c$. 对 $r',s'$ 使用归纳假设即可.
- 若 $r=\lim(f,n,w,r')$ 且 $s=\lim(f,m,w,s')$, 必然有 $r':\text{Rd}(a,f(n))$ 以及 $s':\text{Rd}(a,f(m))$. 讨论 $n,m$ 的大小关系.
  - 若 $n\lt m$, 由引理 2-0-25 (序列的保序性) 有 $t:f(n)\lt f(m)$. 由于当前的证明目标是命题, 由命题截断的基本性质, 在此局部可以把 $t$ 还原为未截断的 $t':\text{Rd}(f(n),f(m))$. 于是有 $r'⋅t':\text{Rd}(a,f(m))$. 再次对 $r'⋅t',s'$ 使用归纳假设即可.
  - 若 $n=m$, 直接对 $r',s'$ 使用归纳假设即可.
  - 若 $m\lt n$, 与 $n\lt m$ 的情况同理可证. ∎

<pre class="Agda"><a id="&lt;-connex-pre"></a><a id="18140" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18153" class="Symbol">:</a> <a id="18155" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="18160" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18162" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18164" class="Symbol">→</a> <a id="18166" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="18171" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18173" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18175" class="Symbol">→</a> <a id="18177" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18179" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18181" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18183" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="18185" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18187" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="18189" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="18191" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18204" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="18212" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="18220" class="Symbol">=</a> <a id="18222" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="18226" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="18228" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="18232" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="18237" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18250" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="18258" class="Symbol">(</a><a id="18259" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="18263" href="WellFormed.Base.html#18263" class="Bound">s</a><a id="18264" class="Symbol">)</a> <a id="18266" class="Symbol">=</a> <a id="18268" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="18272" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="18274" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="18278" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="18280" href="WellFormed.Base.html#18263" class="Bound">s</a> <a id="18282" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="18285" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18298" class="Symbol">(</a><a id="18299" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="18303" href="WellFormed.Base.html#18303" class="Bound">r</a><a id="18304" class="Symbol">)</a> <a id="18306" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="18314" class="Symbol">=</a> <a id="18316" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="18320" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="18322" href="WellFormed.Base.html#18303" class="Bound">r</a> <a id="18324" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="18327" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18340" class="Symbol">(</a><a id="18341" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="18345" href="WellFormed.Base.html#18345" class="Bound">r</a><a id="18346" class="Symbol">)</a> <a id="18348" class="Symbol">(</a><a id="18349" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="18353" href="WellFormed.Base.html#18353" class="Bound">s</a><a id="18354" class="Symbol">)</a> <a id="18356" class="Symbol">=</a> <a id="18358" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18371" href="WellFormed.Base.html#18345" class="Bound">r</a> <a id="18373" href="WellFormed.Base.html#18353" class="Bound">s</a>
<a id="18375" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18388" class="Symbol">(</a><a id="18389" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="18393" class="Symbol">{</a><a id="18394" href="WellFormed.Base.html#18394" class="Bound">n</a><a id="18395" class="Symbol">}</a> <a id="18397" href="WellFormed.Base.html#18397" class="Bound">r</a><a id="18398" class="Symbol">)</a> <a id="18400" class="Symbol">(</a><a id="18401" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="18405" class="Symbol">{</a><a id="18406" class="Argument">n</a> <a id="18408" class="Symbol">=</a> <a id="18410" href="WellFormed.Base.html#18410" class="Bound">m</a><a id="18411" class="Symbol">}</a> <a id="18413" href="WellFormed.Base.html#18413" class="Bound">s</a><a id="18414" class="Symbol">)</a> <a id="18416" class="Keyword">with</a> <a id="18421" href="Data.Nat.Properties.html#10543" class="Function">&lt;-cmp</a> <a id="18427" href="WellFormed.Base.html#18394" class="Bound">n</a> <a id="18429" href="WellFormed.Base.html#18410" class="Bound">m</a>
<a id="18431" class="Symbol">...</a> <a id="18435" class="Symbol">|</a> <a id="18437" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="18442" href="WellFormed.Base.html#18442" class="Bound">n&lt;m</a> <a id="18446" class="Symbol">_</a> <a id="18448" class="Symbol">_</a>  <a id="18451" class="Symbol">=</a> <a id="18453" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18457" href="WellFormed.Base.html#17212" class="Function">isPropConnex</a> <a id="18470" class="Symbol">(λ</a> <a id="18473" href="WellFormed.Base.html#18473" class="Bound">t</a> <a id="18475" class="Symbol">→</a> <a id="18477" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18490" class="Symbol">(</a><a id="18491" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="18500" class="Bound">r</a> <a id="18502" href="WellFormed.Base.html#18473" class="Bound">t</a><a id="18503" class="Symbol">)</a> <a id="18505" class="Bound">s</a><a id="18506" class="Symbol">)</a> <a id="18508" class="Symbol">(</a><a id="18509" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="18518" href="WellFormed.Base.html#18442" class="Bound">n&lt;m</a><a id="18521" class="Symbol">)</a>
<a id="18523" class="Symbol">...</a> <a id="18527" class="Symbol">|</a> <a id="18529" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="18534" class="Symbol">_</a> <a id="18536" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="18541" class="Symbol">_</a> <a id="18543" class="Symbol">=</a> <a id="18545" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18558" class="Bound">r</a> <a id="18560" class="Bound">s</a>
<a id="18562" class="Symbol">...</a> <a id="18566" class="Symbol">|</a> <a id="18568" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="18573" class="Symbol">_</a> <a id="18575" class="Symbol">_</a> <a id="18577" href="WellFormed.Base.html#18577" class="Bound">m&lt;n</a>  <a id="18582" class="Symbol">=</a> <a id="18584" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18588" href="WellFormed.Base.html#17212" class="Function">isPropConnex</a> <a id="18601" class="Symbol">(λ</a> <a id="18604" href="WellFormed.Base.html#18604" class="Bound">t</a> <a id="18606" class="Symbol">→</a> <a id="18608" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a> <a id="18621" class="Bound">r</a> <a id="18623" class="Symbol">(</a><a id="18624" href="WellFormed.Base.html#9206" class="Function">rd-trans</a> <a id="18633" class="Bound">s</a> <a id="18635" href="WellFormed.Base.html#18604" class="Bound">t</a><a id="18636" class="Symbol">))</a> <a id="18639" class="Symbol">(</a><a id="18640" href="WellFormed.Base.html#15366" class="Function">seq-pres</a> <a id="18649" href="WellFormed.Base.html#18577" class="Bound">m&lt;n</a><a id="18652" class="Symbol">)</a>
</pre>
**推论 2-0-34** 将同株关系弱化为命题, 一样有连通性成立.  
**证明** 由定理 2-0-33 和命题截断的基本性质即得. ∎

<pre class="Agda"><a id="&lt;-connex"></a><a id="18740" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="18749" class="Symbol">:</a> <a id="18751" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18753" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18755" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18757" class="Symbol">→</a> <a id="18759" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18761" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18763" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18765" class="Symbol">→</a> <a id="18767" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18769" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18771" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18773" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="18775" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18777" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="18779" href="WellFormed.Base.html#3778" class="Generalizable">a</a>
<a id="18781" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="18790" class="Symbol">=</a> <a id="18792" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="18797" href="WellFormed.Base.html#17212" class="Function">isPropConnex</a> <a id="18810" href="WellFormed.Base.html#18140" class="Function">&lt;-connex-pre</a>
</pre>
**推论 2-0-35** 忽略非同株序数 (up to homo), $\lt$ 满足三歧性.  
**证明** 由推论 2-0-34 和推论 2-0-15 ($\lt$ 的反自反性和非对称性) 即得. ∎

<pre class="Agda"><a id="&lt;-trich"></a><a id="18942" href="WellFormed.Base.html#18942" class="Function">&lt;-trich</a> <a id="18950" class="Symbol">:</a> <a id="18952" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18954" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18956" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18958" class="Symbol">→</a> <a id="18960" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18962" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18964" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="18966" class="Symbol">→</a> <a id="18968" href="Relation.Binary.Definitions.html#3038" class="Datatype">Tri</a> <a id="18972" class="Symbol">(</a><a id="18973" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18975" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18977" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="18978" class="Symbol">)</a> <a id="18980" class="Symbol">(</a><a id="18981" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="18983" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="18985" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="18986" class="Symbol">)</a> <a id="18988" class="Symbol">(</a><a id="18989" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="18991" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="18993" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="18994" class="Symbol">)</a>
<a id="18996" href="WellFormed.Base.html#18942" class="Function">&lt;-trich</a> <a id="19004" href="WellFormed.Base.html#19004" class="Bound">r</a> <a id="19006" href="WellFormed.Base.html#19006" class="Bound">s</a> <a id="19008" class="Keyword">with</a> <a id="19013" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="19022" href="WellFormed.Base.html#19004" class="Bound">r</a> <a id="19024" href="WellFormed.Base.html#19006" class="Bound">s</a>
<a id="19026" class="Symbol">...</a> <a id="19030" class="Symbol">|</a> <a id="19032" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="19036" href="WellFormed.Base.html#19036" class="Bound">t</a>       <a id="19044" class="Symbol">=</a> <a id="19046" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="19051" href="WellFormed.Base.html#19036" class="Bound">t</a> <a id="19053" class="Symbol">(λ</a> <a id="19056" href="WellFormed.Base.html#19056" class="Bound">p</a> <a id="19058" class="Symbol">→</a> <a id="19060" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="19069" href="WellFormed.Base.html#19056" class="Bound">p</a> <a id="19071" href="WellFormed.Base.html#19036" class="Bound">t</a><a id="19072" class="Symbol">)</a> <a id="19074" class="Symbol">(</a><a id="19075" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="19082" href="WellFormed.Base.html#19036" class="Bound">t</a><a id="19083" class="Symbol">)</a>
<a id="19085" class="Symbol">...</a> <a id="19089" class="Symbol">|</a> <a id="19091" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="19095" class="Symbol">(</a><a id="19096" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="19100" href="WellFormed.Base.html#19100" class="Bound">t</a><a id="19101" class="Symbol">)</a> <a id="19103" class="Symbol">=</a> <a id="19105" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="19110" class="Symbol">(</a><a id="19111" href="WellFormed.Base.html#10845" class="Function">&lt;-asym</a> <a id="19118" href="WellFormed.Base.html#19100" class="Bound">t</a><a id="19119" class="Symbol">)</a> <a id="19121" class="Symbol">(λ</a> <a id="19124" href="WellFormed.Base.html#19124" class="Bound">p</a> <a id="19126" class="Symbol">→</a> <a id="19128" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="19137" class="Symbol">(</a><a id="19138" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="19142" href="WellFormed.Base.html#19124" class="Bound">p</a><a id="19143" class="Symbol">)</a> <a id="19145" href="WellFormed.Base.html#19100" class="Bound">t</a><a id="19146" class="Symbol">)</a> <a id="19148" href="WellFormed.Base.html#19100" class="Bound">t</a>
<a id="19150" class="Symbol">...</a> <a id="19154" class="Symbol">|</a> <a id="19156" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="19160" class="Symbol">(</a><a id="19161" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="19165" href="WellFormed.Base.html#19165" class="Bound">p</a><a id="19166" class="Symbol">)</a> <a id="19168" class="Symbol">=</a> <a id="19170" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="19175" class="Symbol">(λ</a> <a id="19178" href="WellFormed.Base.html#19178" class="Bound">t</a> <a id="19180" class="Symbol">→</a> <a id="19182" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="19191" class="Symbol">(</a><a id="19192" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="19196" href="WellFormed.Base.html#19165" class="Bound">p</a><a id="19197" class="Symbol">)</a> <a id="19199" href="WellFormed.Base.html#19178" class="Bound">t</a><a id="19200" class="Symbol">)</a> <a id="19202" class="Symbol">(</a><a id="19203" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="19207" href="WellFormed.Base.html#19165" class="Bound">p</a><a id="19208" class="Symbol">)</a> <a id="19210" class="Symbol">(λ</a> <a id="19213" href="WellFormed.Base.html#19213" class="Bound">t</a> <a id="19215" class="Symbol">→</a> <a id="19217" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="19226" href="WellFormed.Base.html#19165" class="Bound">p</a> <a id="19228" href="WellFormed.Base.html#19213" class="Bound">t</a><a id="19229" class="Symbol">)</a>
</pre>
## 路径集合

我们通过证明路径的离散性来说明路径的集合性. 这里说的离散是指任意 $r,s:\text{Rd}(a,b)$ 的同一性可判定. 我们导入相关引理如自然数的K公理 (说是公理但在 HoTT 中其实是一个局域性质——集合满足K公理) 以及自然数的离散性等.

<pre class="Agda"><a id="19381" class="Keyword">module</a> <a id="RoadSet"></a><a id="19388" href="WellFormed.Base.html#19388" class="Module">RoadSet</a> <a id="19396" class="Keyword">where</a>
  <a id="19404" class="Keyword">open</a> <a id="19409" class="Keyword">import</a> <a id="19416" href="Cubical.Axiom.UniquenessOfIdentity.html" class="Module">Cubical.Axiom.UniquenessOfIdentity</a>
  <a id="19453" class="Keyword">open</a> <a id="19458" class="Keyword">import</a> <a id="19465" href="Cubical.Data.Nat.html" class="Module">Cubical.Data.Nat</a> <a id="19482" class="Keyword">using</a> <a id="19488" class="Symbol">(</a><a id="19489" href="Cubical.Data.Nat.Properties.html#3401" class="Function">discreteℕ</a><a id="19498" class="Symbol">;</a> <a id="19500" href="Cubical.Data.Nat.Properties.html#3705" class="Function">isSetℕ</a><a id="19506" class="Symbol">)</a>
  <a id="19510" class="Keyword">open</a> <a id="19515" class="Keyword">import</a> <a id="19522" href="Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a>
</pre>
**引理 2-0-36** 路径 $r:\text{Rd}(a,a^+)$ 唯一, 即对任意这样的 $r$ 都有 $r = 0$.  
**证明** 使用道路归纳法 (path induction), 转而证明对任意 $r:\text{Rd}(a,b^+)$ 和 $p:\text{Path}⟨\text{Ord}⟩(b,a)$ 有

$$\text{PathP}⟨λi,\text{Rd}(a,p(i)^+)⟩(r,0)$$

- 若 $r = 0$, 由序数的K公理即证.
- 若 $r = r'^+$, 有 $r':\text{Rd}(a,b)$, 结合 $p$, 违反路径的反自反性. ∎

<pre class="Agda">  <a id="RoadSet.zero-unique"></a><a id="19862" href="WellFormed.Base.html#19862" class="Function">zero-unique</a> <a id="19874" class="Symbol">:</a> <a id="19876" class="Symbol">(</a><a id="19877" href="WellFormed.Base.html#19877" class="Bound">r</a> <a id="19879" class="Symbol">:</a> <a id="19881" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="19886" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="19888" class="Symbol">(</a><a id="19889" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="19893" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="19894" class="Symbol">))</a> <a id="19897" class="Symbol">→</a> <a id="19899" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="19904" class="Symbol">_</a> <a id="19906" href="WellFormed.Base.html#19877" class="Bound">r</a> <a id="19908" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
  <a id="19915" href="WellFormed.Base.html#19862" class="Function">zero-unique</a> <a id="19927" href="WellFormed.Base.html#19927" class="Bound">r</a> <a id="19929" class="Symbol">=</a> <a id="19931" href="WellFormed.Base.html#19954" class="Function">aux</a> <a id="19935" href="WellFormed.Base.html#19927" class="Bound">r</a> <a id="19937" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="19944" class="Keyword">where</a>
    <a id="19954" href="WellFormed.Base.html#19954" class="Function">aux</a> <a id="19958" class="Symbol">:</a> <a id="19960" class="Symbol">(</a><a id="19961" href="WellFormed.Base.html#19961" class="Bound">r</a> <a id="19963" class="Symbol">:</a> <a id="19965" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="19970" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="19972" class="Symbol">(</a><a id="19973" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="19977" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="19978" class="Symbol">))</a> <a id="19981" class="Symbol">(</a><a id="19982" href="WellFormed.Base.html#19982" class="Bound">p</a> <a id="19984" class="Symbol">:</a> <a id="19986" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="19991" class="Symbol">_</a> <a id="19993" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="19995" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="19996" class="Symbol">)</a>
      <a id="20004" class="Symbol">→</a> <a id="20006" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="20012" class="Symbol">(λ</a> <a id="20015" href="WellFormed.Base.html#20015" class="Bound">i</a> <a id="20017" class="Symbol">→</a> <a id="20019" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20024" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20026" class="Symbol">(</a><a id="20027" href="WellFormed.Base.html#4198" class="InductiveConstructor">suc</a> <a id="20031" class="Symbol">(</a><a id="20032" href="WellFormed.Base.html#19982" class="Bound">p</a> <a id="20034" href="WellFormed.Base.html#20015" class="Bound">i</a><a id="20035" class="Symbol">)))</a> <a id="20039" href="WellFormed.Base.html#19961" class="Bound">r</a> <a id="20041" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
    <a id="20050" href="WellFormed.Base.html#19954" class="Function">aux</a> <a id="20054" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="20059" class="Symbol">=</a> <a id="20061" href="Cubical.Axiom.UniquenessOfIdentity.html#737" class="Function">UIP→AxiomK</a> <a id="20072" class="Symbol">(</a><a id="20073" href="Cubical.Axiom.UniquenessOfIdentity.html#976" class="Function">isSet→UIP</a> <a id="20083" href="WellFormed.Base.html#7722" class="Function">isSetOrd</a><a id="20091" class="Symbol">)</a> <a id="20093" class="Symbol">_</a> <a id="20095" class="Symbol">_</a> <a id="20097" class="Symbol">_</a> <a id="20099" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
    <a id="20110" href="WellFormed.Base.html#19954" class="Function">aux</a> <a id="20114" class="Symbol">(</a><a id="20115" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="20119" href="WellFormed.Base.html#20119" class="Bound">r</a><a id="20120" class="Symbol">)</a> <a id="20122" href="WellFormed.Base.html#20122" class="Bound">p</a> <a id="20124" class="Symbol">=</a> <a id="20126" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="20133" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="20135" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a> <a id="20145" class="Symbol">(</a><a id="20146" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="20150" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="20152" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="20161" href="WellFormed.Base.html#20122" class="Bound">p</a><a id="20162" class="Symbol">)</a> <a id="20164" href="WellFormed.Base.html#20119" class="Bound">r</a>
</pre>
**引理 2-0-37** 路径构造子 $\text{suc}:\text{Rd}(a,b)→\text{Rd}(a,b^+)$ 具有单射性, 即对任意 $r,s:\text{Rd}(a,b)$, 如果 $r^+=s^+$, 那么 $r=s$.  
**证明** 直接使用命题相等的构造子 $\text{refl}$ 反演即得. ∎

<pre class="Agda">  <a id="RoadSet.suc-inj"></a><a id="20349" href="WellFormed.Base.html#20349" class="Function">suc-inj</a> <a id="20357" class="Symbol">:</a> <a id="20359" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="20363" href="WellFormed.Base.html#3806" class="Generalizable">r</a> <a id="20365" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="20367" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="20371" href="WellFormed.Base.html#3808" class="Generalizable">s</a> <a id="20373" class="Symbol">→</a> <a id="20375" href="WellFormed.Base.html#3806" class="Generalizable">r</a> <a id="20377" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="20379" href="WellFormed.Base.html#3808" class="Generalizable">s</a>
  <a id="20383" href="WellFormed.Base.html#20349" class="Function">suc-inj</a> <a id="20391" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="20396" class="Symbol">=</a> <a id="20398" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="RoadSet.suc-injPath"></a><a id="20406" href="WellFormed.Base.html#20406" class="Function">suc-injPath</a> <a id="20418" class="Symbol">:</a> <a id="20420" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="20425" class="Symbol">_</a> <a id="20427" class="Symbol">(</a><a id="20428" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="20432" href="WellFormed.Base.html#3806" class="Generalizable">r</a><a id="20433" class="Symbol">)</a> <a id="20435" class="Symbol">(</a><a id="20436" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="20440" href="WellFormed.Base.html#3808" class="Generalizable">s</a><a id="20441" class="Symbol">)</a> <a id="20443" class="Symbol">→</a> <a id="20445" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="20450" class="Symbol">_</a> <a id="20452" href="WellFormed.Base.html#3806" class="Generalizable">r</a> <a id="20454" href="WellFormed.Base.html#3808" class="Generalizable">s</a>
  <a id="20458" href="WellFormed.Base.html#20406" class="Function">suc-injPath</a> <a id="20470" class="Symbol">=</a> <a id="20472" href="Cubical.Data.Equality.Conversion.html#1778" class="Function">eqToPath</a> <a id="20481" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="20483" href="WellFormed.Base.html#20349" class="Function">suc-inj</a> <a id="20491" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="20493" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a>
</pre>
**引理 2-0-38** 路径构造子 $\lim:\text{Rd}(a,f(n))→\text{Rd}(a,\lim(f))$ 具有单射性, 即对任意 $r,s:\text{Rd}(a,f(n))$, 如果 $\lim(r)=\lim(s)$, 那么 $r=s$.  
**证明** 与引理 2-0-36类似可证, 但需要用到自然数的K公理. ∎

<pre class="Agda">  <a id="RoadSet.lim-injPath"></a><a id="20694" href="WellFormed.Base.html#20694" class="Function">lim-injPath</a> <a id="20706" class="Symbol">:</a> <a id="20708" class="Symbol">⦃</a> <a id="20710" href="WellFormed.Base.html#20710" class="Symbol">_</a> <a id="20712" class="Symbol">:</a> <a id="20714" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="20717" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20719" class="Symbol">⦄</a> <a id="20721" class="Symbol">{</a><a id="20722" href="WellFormed.Base.html#20722" class="Bound">r</a> <a id="20724" href="WellFormed.Base.html#20724" class="Bound">s</a> <a id="20726" class="Symbol">:</a> <a id="20728" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20733" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20735" class="Symbol">(</a><a id="20736" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20738" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="20739" class="Symbol">)}</a> <a id="20742" class="Symbol">→</a> <a id="20744" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="20749" class="Symbol">(</a><a id="20750" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20755" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20757" class="Symbol">(</a><a id="20758" href="WellFormed.Base.html#4217" class="InductiveConstructor">lim</a> <a id="20762" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="20763" class="Symbol">))</a> <a id="20766" class="Symbol">(</a><a id="20767" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="20771" href="WellFormed.Base.html#20722" class="Bound">r</a><a id="20772" class="Symbol">)</a> <a id="20774" class="Symbol">(</a><a id="20775" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="20779" href="WellFormed.Base.html#20724" class="Bound">s</a><a id="20780" class="Symbol">)</a> <a id="20782" class="Symbol">→</a> <a id="20784" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="20789" class="Symbol">_</a> <a id="20791" href="WellFormed.Base.html#20722" class="Bound">r</a> <a id="20793" href="WellFormed.Base.html#20724" class="Bound">s</a>
  <a id="20797" href="WellFormed.Base.html#20694" class="Function">lim-injPath</a> <a id="20809" href="WellFormed.Base.html#20809" class="Bound">p</a> <a id="20811" class="Symbol">=</a> <a id="20813" href="WellFormed.Base.html#20847" class="Function">aux</a> <a id="20817" class="Symbol">(</a><a id="20818" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="20827" href="WellFormed.Base.html#20809" class="Bound">p</a><a id="20828" class="Symbol">)</a> <a id="20830" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="20837" class="Keyword">where</a>
    <a id="20847" href="WellFormed.Base.html#20847" class="Function">aux</a> <a id="20851" class="Symbol">:</a> <a id="20853" class="Symbol">⦃</a> <a id="20855" href="WellFormed.Base.html#20855" class="Bound">_</a> <a id="20857" class="Symbol">:</a> <a id="20859" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="20862" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20864" class="Symbol">⦄</a> <a id="20866" class="Symbol">{</a><a id="20867" href="WellFormed.Base.html#20867" class="Bound">r</a> <a id="20869" class="Symbol">:</a> <a id="20871" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20876" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20878" class="Symbol">(</a><a id="20879" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20881" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="20882" class="Symbol">)}</a> <a id="20885" class="Symbol">{</a><a id="20886" href="WellFormed.Base.html#20886" class="Bound">s</a> <a id="20888" class="Symbol">:</a> <a id="20890" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20895" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20897" class="Symbol">(</a><a id="20898" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20900" href="WellFormed.Base.html#3768" class="Generalizable">m</a><a id="20901" class="Symbol">)}</a> <a id="20904" class="Symbol">→</a> <a id="20906" href="WellFormed.Base.html#4723" class="InductiveConstructor">Road.lim</a> <a id="20915" class="Symbol">{</a><a id="20916" class="Argument">f</a> <a id="20918" class="Symbol">=</a> <a id="20920" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="20921" class="Symbol">}</a> <a id="20923" href="WellFormed.Base.html#20867" class="Bound">r</a> <a id="20925" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="20927" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="20931" href="WellFormed.Base.html#20886" class="Bound">s</a>
      <a id="20939" class="Symbol">→</a> <a id="20941" class="Symbol">(</a><a id="20942" href="WellFormed.Base.html#20942" class="Bound">p</a> <a id="20944" class="Symbol">:</a> <a id="20946" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="20951" class="Symbol">_</a> <a id="20953" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="20955" href="WellFormed.Base.html#3768" class="Generalizable">m</a><a id="20956" class="Symbol">)</a> <a id="20958" class="Symbol">→</a> <a id="20960" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="20966" class="Symbol">(λ</a> <a id="20969" href="WellFormed.Base.html#20969" class="Bound">i</a> <a id="20971" class="Symbol">→</a> <a id="20973" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="20978" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="20980" class="Symbol">(</a><a id="20981" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="20983" class="Symbol">(</a><a id="20984" href="WellFormed.Base.html#20942" class="Bound">p</a> <a id="20986" href="WellFormed.Base.html#20969" class="Bound">i</a><a id="20987" class="Symbol">)))</a> <a id="20991" href="WellFormed.Base.html#20867" class="Bound">r</a> <a id="20993" href="WellFormed.Base.html#20886" class="Bound">s</a>
    <a id="20999" href="WellFormed.Base.html#20847" class="Function">aux</a> <a id="21003" class="Symbol">{</a><a id="21004" href="WellFormed.Base.html#21004" class="Bound">f</a><a id="21005" class="Symbol">}</a> <a id="21007" class="Symbol">{</a><a id="21008" href="WellFormed.Base.html#21008" class="Bound">a</a><a id="21009" class="Symbol">}</a> <a id="21011" class="Symbol">{</a><a id="21012" href="WellFormed.Base.html#21012" class="Bound">r</a><a id="21013" class="Symbol">}</a> <a id="21015" class="Symbol">{</a><a id="21016" href="WellFormed.Base.html#21016" class="Bound">s</a><a id="21017" class="Symbol">}</a> <a id="21019" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="21024" class="Symbol">=</a> <a id="21026" href="Cubical.Axiom.UniquenessOfIdentity.html#737" class="Function">UIP→AxiomK</a> <a id="21037" class="Symbol">(</a><a id="21038" href="Cubical.Axiom.UniquenessOfIdentity.html#976" class="Function">isSet→UIP</a> <a id="21048" href="Cubical.Data.Nat.Properties.html#3705" class="Function">isSetℕ</a><a id="21054" class="Symbol">)</a> <a id="21056" class="Symbol">_</a> <a id="21058" class="Symbol">_</a>
      <a id="21066" class="Symbol">(λ</a> <a id="21069" href="WellFormed.Base.html#21069" class="Bound">p</a> <a id="21071" class="Symbol">→</a> <a id="21073" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="21079" class="Symbol">(λ</a> <a id="21082" href="WellFormed.Base.html#21082" class="Bound">i</a> <a id="21084" class="Symbol">→</a> <a id="21086" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="21091" href="WellFormed.Base.html#21008" class="Bound">a</a> <a id="21093" class="Symbol">(</a><a id="21094" href="WellFormed.Base.html#21004" class="Bound">f</a> <a id="21096" class="Symbol">(</a><a id="21097" href="WellFormed.Base.html#21069" class="Bound">p</a> <a id="21099" href="WellFormed.Base.html#21082" class="Bound">i</a><a id="21100" class="Symbol">)))</a> <a id="21104" href="WellFormed.Base.html#21012" class="Bound">r</a> <a id="21106" href="WellFormed.Base.html#21016" class="Bound">s</a><a id="21107" class="Symbol">)</a> <a id="21109" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a>
</pre>
**定理 2-0-39** 路径类型 $\text{Rd}(a,b)$ 离散.  
**证明** 给定 $r,s:\text{Rd}(a,b)$, 需要判定它们是否相等. 对 $r,s$ 归纳.

- 若 $s=0$, 不管 $r$ 是什么, 由引理 2-0-36 即可判定它们相等.
- 若 $r=0$ 且 $s=s'^+$, 必然有 $a=b$ 且 $s:\text{Rd}(a,a)$, 违反路径的反自反性.
- 若 $r=r'^+$ 且 $s=s'^+$, 递归判定 $r'$ 与 $s'$ 是否相等即可.
- 若 $r=\lim(f,n,w,r')$ 且 $s=\lim(f,m,w,s')$, 判定 $n$ 与 $m$ 是否相等, 若相等则递归判定 $r'$ 与 $s'$ 是否相等, 否则不等. ∎

<pre class="Agda">  <a id="RoadSet.discreteRoad"></a><a id="21489" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21502" class="Symbol">:</a> <a id="21504" href="Cubical.Relation.Nullary.Base.html#1538" class="Function">Discrete</a> <a id="21513" class="Symbol">(</a><a id="21514" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="21519" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="21521" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="21522" class="Symbol">)</a>
  <a id="21526" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21539" href="WellFormed.Base.html#21539" class="Bound">r</a> <a id="21541" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>           <a id="21556" class="Symbol">=</a> <a id="21558" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="21562" class="Symbol">(</a><a id="21563" href="WellFormed.Base.html#19862" class="Function">zero-unique</a> <a id="21575" href="WellFormed.Base.html#21539" class="Bound">r</a><a id="21576" class="Symbol">)</a>
  <a id="21580" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21593" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="21598" class="Symbol">(</a><a id="21599" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="21603" href="WellFormed.Base.html#21603" class="Bound">s</a><a id="21604" class="Symbol">)</a>     <a id="21610" class="Symbol">=</a> <a id="21612" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="21619" class="Symbol">(</a><a id="21620" href="WellFormed.Base.html#10767" class="Function">rd-irrefl</a> <a id="21630" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="21635" href="WellFormed.Base.html#21603" class="Bound">s</a><a id="21636" class="Symbol">)</a>
  <a id="21640" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21653" class="Symbol">(</a><a id="21654" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="21658" href="WellFormed.Base.html#21658" class="Bound">r</a><a id="21659" class="Symbol">)</a> <a id="21661" class="Symbol">(</a><a id="21662" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="21666" href="WellFormed.Base.html#21666" class="Bound">s</a><a id="21667" class="Symbol">)</a>  <a id="21670" class="Symbol">=</a> <a id="21672" href="Cubical.Relation.Nullary.Properties.html#2610" class="Function">mapDec</a> <a id="21679" class="Symbol">(</a><a id="21680" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="21687" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a><a id="21690" class="Symbol">)</a> <a id="21692" class="Symbol">(λ</a> <a id="21695" href="WellFormed.Base.html#21695" class="Bound">p</a> <a id="21697" href="WellFormed.Base.html#21697" class="Bound">q</a> <a id="21699" class="Symbol">→</a> <a id="21701" href="WellFormed.Base.html#21695" class="Bound">p</a> <a id="21703" class="Symbol">(</a><a id="21704" href="WellFormed.Base.html#20406" class="Function">suc-injPath</a> <a id="21716" href="WellFormed.Base.html#21697" class="Bound">q</a><a id="21717" class="Symbol">))</a> <a id="21720" class="Symbol">(</a><a id="21721" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21734" href="WellFormed.Base.html#21658" class="Bound">r</a> <a id="21736" href="WellFormed.Base.html#21666" class="Bound">s</a><a id="21737" class="Symbol">)</a>
  <a id="21741" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21754" class="Symbol">(</a><a id="21755" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="21759" class="Symbol">{</a><a id="21760" href="WellFormed.Base.html#21760" class="Bound">n</a><a id="21761" class="Symbol">}</a> <a id="21763" href="WellFormed.Base.html#21763" class="Bound">r</a><a id="21764" class="Symbol">)</a> <a id="21766" class="Symbol">(</a><a id="21767" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="21771" class="Symbol">{</a><a id="21772" class="Argument">n</a> <a id="21774" class="Symbol">=</a> <a id="21776" href="WellFormed.Base.html#21776" class="Bound">m</a><a id="21777" class="Symbol">}</a> <a id="21779" href="WellFormed.Base.html#21779" class="Bound">s</a><a id="21780" class="Symbol">)</a> <a id="21782" class="Keyword">with</a> <a id="21787" href="Cubical.Data.Nat.Properties.html#3401" class="Function">discreteℕ</a> <a id="21797" href="WellFormed.Base.html#21760" class="Bound">n</a> <a id="21799" href="WellFormed.Base.html#21776" class="Bound">m</a>
  <a id="21803" class="Symbol">...</a> <a id="21807" class="Symbol">|</a> <a id="21809" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="21813" href="WellFormed.Base.html#21813" class="Bound">p</a> <a id="21815" class="Symbol">=</a> <a id="21817" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="21822" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="21831" href="WellFormed.Base.html#21813" class="Bound">p</a> <a id="21833" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="21836" class="Symbol">λ</a> <a id="21838" class="Symbol">{</a> <a id="21840" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="21845" class="Symbol">→</a> <a id="21847" href="Cubical.Relation.Nullary.Properties.html#2610" class="Function">mapDec</a> <a id="21854" class="Symbol">(</a><a id="21855" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="21862" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a><a id="21865" class="Symbol">)</a> <a id="21867" class="Symbol">(λ</a> <a id="21870" href="WellFormed.Base.html#21870" class="Bound">p</a> <a id="21872" href="WellFormed.Base.html#21872" class="Bound">q</a> <a id="21874" class="Symbol">→</a> <a id="21876" href="WellFormed.Base.html#21870" class="Bound">p</a> <a id="21878" class="Symbol">(</a><a id="21879" href="WellFormed.Base.html#20694" class="Function">lim-injPath</a> <a id="21891" href="WellFormed.Base.html#21872" class="Bound">q</a><a id="21892" class="Symbol">))</a> <a id="21895" class="Symbol">(</a><a id="21896" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a> <a id="21909" class="Bound">r</a> <a id="21911" class="Bound">s</a><a id="21912" class="Symbol">)</a> <a id="21914" class="Symbol">}</a>
  <a id="21918" class="Symbol">...</a> <a id="21922" class="Symbol">|</a> <a id="21924" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a>  <a id="21928" href="WellFormed.Base.html#21928" class="Bound">p</a> <a id="21930" class="Symbol">=</a> <a id="21932" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a> <a id="21935" class="Symbol">λ</a> <a id="21937" href="WellFormed.Base.html#21937" class="Bound">q</a> <a id="21939" class="Symbol">→</a> <a id="21941" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="21946" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="21955" href="WellFormed.Base.html#21937" class="Bound">q</a> <a id="21957" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="21960" class="Symbol">λ</a> <a id="21962" class="Symbol">{</a> <a id="21964" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="21969" class="Symbol">→</a> <a id="21971" href="WellFormed.Base.html#21928" class="Bound">p</a> <a id="21973" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="21980" class="Symbol">}</a>
</pre>
**推论 2-0-40** 路径类型 $\text{Rd}(a,b)$ 是集合.  
**证明** 离散类型都是集合. ∎

<pre class="Agda">  <a id="RoadSet.isSetRoad"></a><a id="22060" href="WellFormed.Base.html#22060" class="Function">isSetRoad</a> <a id="22070" class="Symbol">:</a> <a id="22072" href="Cubical.Foundations.Prelude.html#14630" class="Function">isSet</a> <a id="22078" class="Symbol">(</a><a id="22079" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="22084" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="22086" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="22087" class="Symbol">)</a>
  <a id="22091" href="WellFormed.Base.html#22060" class="Function">isSetRoad</a> <a id="22101" class="Symbol">=</a> <a id="22103" href="Cubical.Relation.Nullary.Properties.html#6952" class="Function">Discrete→isSet</a> <a id="22118" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a>

<a id="22132" class="Keyword">open</a> <a id="22137" href="WellFormed.Base.html#19388" class="Module">RoadSet</a> <a id="22145" class="Keyword">public</a> <a id="22152" class="Keyword">using</a> <a id="22158" class="Symbol">(</a><a id="22159" href="WellFormed.Base.html#21489" class="Function">discreteRoad</a><a id="22171" class="Symbol">;</a> <a id="22173" href="WellFormed.Base.html#22060" class="Function">isSetRoad</a><a id="22182" class="Symbol">)</a>
</pre>
## 典范路径

最后, 我们来定义路径的典范映射. 典范映射具有以下性质.

**定义 2-0-41** 我们说函数 $f$ 是2-恒等的, 如果对任意 $x,y$ 都有 $f(x)=f(y)$.

<pre class="Agda"><a id="22298" class="Keyword">module</a> <a id="CanonicalRoad"></a><a id="22305" href="WellFormed.Base.html#22305" class="Module">CanonicalRoad</a> <a id="22319" class="Keyword">where</a>
  <a id="22327" class="Keyword">open</a> <a id="22332" class="Keyword">import</a> <a id="22339" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a> <a id="22368" class="Keyword">using</a> <a id="22374" class="Symbol">(</a><a id="22375" href="Cubical.Foundations.Function.html#2864" class="Function">2-Constant</a><a id="22385" class="Symbol">)</a>
</pre>
我们首先处理极限的情况. 给定任意 $r:a\lt f(n)$, 只要找到最小的 $m$ 满足 $s:a\lt f(m)$, $\lim(s)$ 就可以作为 $a\lt \lim(f)$ 的典范证明.

**定义 2-0-42** 我们说路径 $r:\text{Rd}(a,f(n))$ 的最小化, 记作 $\min(r)$, 是一个 $m:ℕ$ 满足 $s:a\lt f(m)$, 递归定义为

- 若 $n=0$, 取 $(m,s):=(0,r)$.
- 若 $n=n'^+$, 此时有 $a\lt f(n'^+)$, 且由 $f$ 的良构性有 $f(n')\lt f(n'^+)$, 因此 $a$ 与 $f(n')$ 同株, 判定它们的大小关系.
  - 若有 $r' : a\lt f(n')$, 取 $(m,s):=\min(r')$.
  - 若不然, 说明已经递归到最小了, 取 $(m,s):=(n,r)$. ∎

<pre class="Agda">  <a id="CanonicalRoad.min"></a><a id="22818" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="22822" class="Symbol">:</a> <a id="22824" class="Symbol">(</a><a id="22825" href="WellFormed.Base.html#22825" class="Bound">f</a> <a id="22827" class="Symbol">:</a> <a id="22829" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="22832" class="Symbol">)</a> <a id="22834" class="Symbol">⦃</a> <a id="22836" href="WellFormed.Base.html#22836" class="Bound">wff</a> <a id="22840" class="Symbol">:</a> <a id="22842" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="22845" href="WellFormed.Base.html#22825" class="Bound">f</a> <a id="22847" class="Symbol">⦄</a> <a id="22849" class="Symbol">→</a> <a id="22851" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="22853" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="22855" href="WellFormed.Base.html#22825" class="Bound">f</a> <a id="22857" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="22859" class="Symbol">→</a> <a id="22861" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="22864" href="WellFormed.Base.html#22864" class="Bound">m</a> <a id="22866" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="22868" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="22870" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="22872" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="22874" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="22876" href="WellFormed.Base.html#22825" class="Bound">f</a> <a id="22878" href="WellFormed.Base.html#22864" class="Bound">m</a>
  <a id="22882" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="22886" class="Symbol">{</a><a id="22887" class="Argument">n</a> <a id="22889" class="Symbol">=</a> <a id="22891" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="22895" class="Symbol">}</a> <a id="22897" href="WellFormed.Base.html#22897" class="Bound">f</a> <a id="22899" href="WellFormed.Base.html#22899" class="Bound">r</a> <a id="22901" class="Symbol">=</a> <a id="22903" class="Number">0</a> <a id="22905" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22907" href="WellFormed.Base.html#22899" class="Bound">r</a>
  <a id="22911" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="22915" class="Symbol">{</a><a id="22916" class="Argument">n</a> <a id="22918" class="Symbol">=</a> <a id="22920" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="22924" href="WellFormed.Base.html#22924" class="Bound">n</a><a id="22925" class="Symbol">}</a> <a id="22927" href="WellFormed.Base.html#22927" class="Bound">f</a> <a id="22929" href="WellFormed.Base.html#22929" class="Bound">r</a> <a id="22931" class="Keyword">with</a> <a id="22936" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="22945" href="WellFormed.Base.html#22929" class="Bound">r</a> <a id="22947" href="Function.Base.html#4736" class="Function">it</a>
  <a id="22952" class="Symbol">...</a> <a id="22956" class="Symbol">|</a> <a id="22958" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="22962" href="WellFormed.Base.html#22962" class="Bound">r</a> <a id="22964" class="Symbol">=</a> <a id="22966" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="22970" class="Bound">f</a> <a id="22972" href="WellFormed.Base.html#22962" class="Bound">r</a>
  <a id="22976" class="Symbol">...</a> <a id="22980" class="Symbol">|</a> <a id="22982" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="22986" class="Symbol">_</a> <a id="22988" class="Symbol">=</a> <a id="22990" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="22994" class="Bound">n</a> <a id="22996" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22998" class="Bound">r</a>
</pre>
**引理 2-0-43** 对任意 $r:\text{Rd}(a,f(n))$ 以及 $s:\text{Rd}(a,f(m))$ 有 $\min(r)=\min(s)$.  
**证明** 该引理直观上不难接受, 但完整写出将会是本文最冗长乏味的证明. 我们只说, 不断地分情况讨论, 并反复运用上文的各种引理后可证. ∎

<pre class="Agda">  <a id="CanonicalRoad.min-unique-pre"></a><a id="23178" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23193" class="Symbol">:</a> <a id="23195" class="Symbol">(</a><a id="23196" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23198" class="Symbol">:</a> <a id="23200" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="23203" class="Symbol">)</a> <a id="23205" class="Symbol">⦃</a> <a id="23207" href="WellFormed.Base.html#23207" class="Bound">wff</a> <a id="23211" class="Symbol">:</a> <a id="23213" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="23216" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23218" class="Symbol">⦄</a> <a id="23220" class="Symbol">(</a><a id="23221" href="WellFormed.Base.html#23221" class="Bound">r</a> <a id="23223" class="Symbol">:</a> <a id="23225" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="23227" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="23229" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23231" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="23232" class="Symbol">)</a> <a id="23234" class="Symbol">(</a><a id="23235" href="WellFormed.Base.html#23235" class="Bound">s</a> <a id="23237" class="Symbol">:</a> <a id="23239" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="23241" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="23243" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23245" class="Symbol">(</a><a id="23246" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="23250" href="WellFormed.Base.html#3768" class="Generalizable">m</a><a id="23251" class="Symbol">))</a>
    <a id="23258" class="Symbol">→</a> <a id="23260" class="Symbol">(</a><a id="23261" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23263" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="23265" href="WellFormed.Base.html#11867" class="Function Operator">≤</a> <a id="23267" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="23268" class="Symbol">)</a> <a id="23270" class="Symbol">→</a> <a id="23272" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="23277" class="Symbol">_</a> <a id="23279" class="Symbol">(</a><a id="23280" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="23284" href="WellFormed.Base.html#23196" class="Bound">f</a> <a id="23286" href="WellFormed.Base.html#23221" class="Bound">r</a><a id="23287" class="Symbol">)</a> <a id="23289" class="Symbol">(</a><a id="23290" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="23294" href="WellFormed.Base.html#3768" class="Generalizable">m</a> <a id="23296" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23298" href="WellFormed.Base.html#23235" class="Bound">s</a><a id="23299" class="Symbol">)</a>
  <a id="23303" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23318" class="Symbol">{</a><a id="23319" class="Argument">n</a> <a id="23321" class="Symbol">=</a> <a id="23323" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="23327" class="Symbol">}</a>  <a id="23330" href="WellFormed.Base.html#23330" class="Bound">f</a> <a id="23332" href="WellFormed.Base.html#23332" class="Bound">r</a> <a id="23334" href="WellFormed.Base.html#23334" class="Bound">s</a> <a id="23336" href="WellFormed.Base.html#23336" class="Bound">t</a> <a id="23338" class="Symbol">=</a> <a id="23340" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="23347" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23349" href="Data.Nat.Properties.html#12165" class="Function">ℕ.n≮0</a> <a id="23355" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23357" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="23366" href="WellFormed.Base.html#23330" class="Bound">f</a> <a id="23368" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23370" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="23380" href="WellFormed.Base.html#23336" class="Bound">t</a> <a id="23382" href="WellFormed.Base.html#23332" class="Bound">r</a>
  <a id="23386" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23401" class="Symbol">{</a><a id="23402" class="Argument">n</a> <a id="23404" class="Symbol">=</a> <a id="23406" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="23410" href="WellFormed.Base.html#23410" class="Bound">n</a><a id="23411" class="Symbol">}</a> <a id="23413" href="WellFormed.Base.html#23413" class="Bound">f</a> <a id="23415" href="WellFormed.Base.html#23415" class="Bound">r</a> <a id="23417" href="WellFormed.Base.html#23417" class="Bound">s</a> <a id="23419" href="WellFormed.Base.html#23419" class="Bound">t</a> <a id="23421" class="Keyword">with</a> <a id="23426" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="23435" href="WellFormed.Base.html#23415" class="Bound">r</a> <a id="23437" href="Function.Base.html#4736" class="Function">it</a>
  <a id="23442" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23457" class="Symbol">{</a><a id="23458" class="Argument">n</a> <a id="23460" class="Symbol">=</a> <a id="23462" class="InductiveConstructor">suc</a> <a id="23466" href="WellFormed.Base.html#23466" class="Bound">n</a><a id="23467" class="Symbol">}</a> <a id="23469" href="WellFormed.Base.html#23469" class="Bound">f</a> <a id="23471" class="Symbol">_</a> <a id="23473" href="WellFormed.Base.html#23473" class="Bound">s</a> <a id="23475" href="WellFormed.Base.html#23475" class="Bound">t</a>            <a id="23488" class="Symbol">|</a> <a id="23490" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="23494" href="WellFormed.Base.html#23494" class="Bound">r</a>           <a id="23506" class="Symbol">=</a> <a id="23508" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23523" href="WellFormed.Base.html#23469" class="Bound">f</a> <a id="23525" href="WellFormed.Base.html#23494" class="Bound">r</a> <a id="23527" href="WellFormed.Base.html#23473" class="Bound">s</a> <a id="23529" href="WellFormed.Base.html#23475" class="Bound">t</a>
  <a id="23533" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23548" class="Symbol">{</a><a id="23549" class="Argument">n</a> <a id="23551" class="Symbol">=</a> <a id="23553" class="InductiveConstructor">suc</a> <a id="23557" href="WellFormed.Base.html#23557" class="Bound">n</a><a id="23558" class="Symbol">}</a> <a id="23560" href="WellFormed.Base.html#23560" class="Bound">f</a> <a id="23562" href="WellFormed.Base.html#23562" class="Bound">r</a> <a id="23564" class="Symbol">_</a> <a id="23566" class="Symbol">(</a><a id="23567" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="23571" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="23575" class="Symbol">)</a>   <a id="23579" class="Symbol">|</a> <a id="23581" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="23585" class="Symbol">(</a><a id="23586" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="23590" href="WellFormed.Base.html#23590" class="Bound">fn&lt;fm</a><a id="23595" class="Symbol">)</a> <a id="23597" class="Symbol">=</a> <a id="23599" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="23606" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23608" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="23621" href="WellFormed.Base.html#23560" class="Bound">f</a> <a id="23623" href="WellFormed.Base.html#23590" class="Bound">fn&lt;fm</a> <a id="23629" href="WellFormed.Base.html#23562" class="Bound">r</a>
  <a id="23633" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23648" class="Symbol">{</a><a id="23649" class="Argument">n</a> <a id="23651" class="Symbol">=</a> <a id="23653" class="InductiveConstructor">suc</a> <a id="23657" href="WellFormed.Base.html#23657" class="Bound">n</a><a id="23658" class="Symbol">}</a> <a id="23660" href="WellFormed.Base.html#23660" class="Bound">f</a> <a id="23662" class="Symbol">_</a> <a id="23664" href="WellFormed.Base.html#23664" class="Bound">s</a> <a id="23666" class="Symbol">(</a><a id="23667" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="23671" href="WellFormed.Base.html#23671" class="Bound">fm&lt;fn</a><a id="23676" class="Symbol">)</a>  <a id="23679" class="Symbol">|</a> <a id="23681" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="23685" class="Symbol">(</a><a id="23686" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="23690" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="23694" class="Symbol">)</a>  <a id="23697" class="Symbol">=</a> <a id="23699" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="23706" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23708" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="23721" href="WellFormed.Base.html#23660" class="Bound">f</a> <a id="23723" href="WellFormed.Base.html#23671" class="Bound">fm&lt;fn</a> <a id="23729" href="WellFormed.Base.html#23664" class="Bound">s</a>
  <a id="23733" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23748" class="Symbol">{</a><a id="23749" class="Argument">n</a> <a id="23751" class="Symbol">=</a> <a id="23753" class="InductiveConstructor">suc</a> <a id="23757" href="WellFormed.Base.html#23757" class="Bound">n</a><a id="23758" class="Symbol">}</a> <a id="23760" href="WellFormed.Base.html#23760" class="Bound">f</a> <a id="23762" href="WellFormed.Base.html#23762" class="Bound">r</a> <a id="23764" href="WellFormed.Base.html#23764" class="Bound">s</a> <a id="23766" class="Symbol">(</a><a id="23767" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="23771" href="WellFormed.Base.html#23771" class="Bound">u</a><a id="23772" class="Symbol">)</a>      <a id="23779" class="Symbol">|</a> <a id="23781" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="23785" class="Symbol">(</a><a id="23786" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="23790" href="WellFormed.Base.html#23790" class="Bound">t</a><a id="23791" class="Symbol">)</a>     <a id="23797" class="Symbol">=</a>
    <a id="23803" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="23808" href="WellFormed.Base.html#23868" class="Function">n≡m</a> <a id="23812" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="23815" class="Symbol">λ</a> <a id="23817" class="Symbol">{</a> <a id="23819" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="23824" class="Symbol">→</a> <a id="23826" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="23833" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23835" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="23842" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23844" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="23852" class="Symbol">_</a> <a id="23854" class="Symbol">_</a> <a id="23856" class="Symbol">}</a> <a id="23858" class="Keyword">where</a>
    <a id="23868" href="WellFormed.Base.html#23868" class="Function">n≡m</a> <a id="23872" class="Symbol">=</a> <a id="23874" href="Data.Nat.Properties.html#5292" class="Function">ℕ.≤-antisym</a>
      <a id="23892" class="Symbol">(</a><a id="23893" href="Data.Nat.Properties.html#13010" class="Function">ℕ.m&lt;1+n⇒m≤n</a> <a id="23905" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23907" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="23916" href="WellFormed.Base.html#23760" class="Bound">f</a> <a id="23918" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23920" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="23928" href="WellFormed.Base.html#23790" class="Bound">t</a> <a id="23930" href="WellFormed.Base.html#23764" class="Bound">s</a><a id="23931" class="Symbol">)</a>
      <a id="23939" class="Symbol">(</a><a id="23940" href="Data.Nat.Properties.html#13010" class="Function">ℕ.m&lt;1+n⇒m≤n</a> <a id="23952" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23954" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="23963" href="WellFormed.Base.html#23760" class="Bound">f</a> <a id="23965" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="23967" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="23975" href="WellFormed.Base.html#23771" class="Bound">u</a> <a id="23977" href="WellFormed.Base.html#23762" class="Bound">r</a><a id="23978" class="Symbol">)</a>
  <a id="23982" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="23997" class="Symbol">{</a><a id="23998" class="Argument">n</a> <a id="24000" class="Symbol">=</a> <a id="24002" class="InductiveConstructor">suc</a> <a id="24006" href="WellFormed.Base.html#24006" class="Bound">n</a><a id="24007" class="Symbol">}</a> <a id="24009" href="WellFormed.Base.html#24009" class="Bound">f</a> <a id="24011" href="WellFormed.Base.html#24011" class="Bound">r</a> <a id="24013" href="WellFormed.Base.html#24013" class="Bound">s</a> <a id="24015" class="Symbol">(</a><a id="24016" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24020" href="WellFormed.Base.html#24020" class="Bound">fm≡fn</a><a id="24025" class="Symbol">)</a>  <a id="24028" class="Symbol">|</a> <a id="24030" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24034" class="Symbol">(</a><a id="24035" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24039" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="24043" class="Symbol">)</a>  <a id="24046" class="Keyword">with</a> <a id="24051" href="WellFormed.Base.html#15749" class="Function">seq-inj≡</a> <a id="24060" href="WellFormed.Base.html#24009" class="Bound">f</a> <a id="24062" href="WellFormed.Base.html#24020" class="Bound">fm≡fn</a>
  <a id="24070" class="Symbol">...</a> <a id="24074" class="Symbol">|</a> <a id="24076" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="24081" class="Symbol">=</a> <a id="24083" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="24090" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24092" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="24099" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="24101" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="24109" class="Symbol">_</a> <a id="24111" class="Symbol">_</a>

  <a id="CanonicalRoad.min-unique"></a><a id="24116" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24127" class="Symbol">:</a> <a id="24129" class="Symbol">(</a><a id="24130" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24132" class="Symbol">:</a> <a id="24134" href="WellFormed.Base.html#3450" class="Function">Seq</a><a id="24137" class="Symbol">)</a> <a id="24139" class="Symbol">⦃</a> <a id="24141" href="WellFormed.Base.html#24141" class="Bound">wff</a> <a id="24145" class="Symbol">:</a> <a id="24147" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="24150" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24152" class="Symbol">⦄</a> <a id="24154" class="Symbol">(</a><a id="24155" href="WellFormed.Base.html#24155" class="Bound">r</a> <a id="24157" class="Symbol">:</a> <a id="24159" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="24161" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="24163" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24165" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="24166" class="Symbol">)</a> <a id="24168" class="Symbol">(</a><a id="24169" href="WellFormed.Base.html#24169" class="Bound">s</a> <a id="24171" class="Symbol">:</a> <a id="24173" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="24175" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="24177" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24179" href="WellFormed.Base.html#3768" class="Generalizable">m</a><a id="24180" class="Symbol">)</a> <a id="24182" class="Symbol">→</a> <a id="24184" href="Cubical.Core.Primitives.html#1828" class="Function">Path</a> <a id="24189" class="Symbol">_</a> <a id="24191" class="Symbol">(</a><a id="24192" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="24196" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24198" href="WellFormed.Base.html#24155" class="Bound">r</a><a id="24199" class="Symbol">)</a> <a id="24201" class="Symbol">(</a><a id="24202" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="24206" href="WellFormed.Base.html#24130" class="Bound">f</a> <a id="24208" href="WellFormed.Base.html#24169" class="Bound">s</a><a id="24209" class="Symbol">)</a>
  <a id="24213" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24224" class="Symbol">{</a><a id="24225" class="Argument">n</a> <a id="24227" class="Symbol">=</a> <a id="24229" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="24233" class="Symbol">}</a>  <a id="24236" class="Symbol">{</a><a id="24237" class="Argument">m</a> <a id="24239" class="Symbol">=</a> <a id="24241" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="24245" class="Symbol">}</a>  <a id="24248" href="WellFormed.Base.html#24248" class="Bound">f</a> <a id="24250" href="WellFormed.Base.html#24250" class="Bound">r</a> <a id="24252" href="WellFormed.Base.html#24252" class="Bound">s</a> <a id="24254" class="Symbol">=</a> <a id="24256" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="24263" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24265" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="24272" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="24274" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="24282" class="Symbol">_</a> <a id="24284" class="Symbol">_</a>
  <a id="24288" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24299" class="Symbol">{</a><a id="24300" class="Argument">n</a> <a id="24302" class="Symbol">=</a> <a id="24304" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="24308" class="Symbol">}</a>  <a id="24311" class="Symbol">{</a><a id="24312" class="Argument">m</a> <a id="24314" class="Symbol">=</a> <a id="24316" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24320" href="WellFormed.Base.html#24320" class="Bound">m</a><a id="24321" class="Symbol">}</a> <a id="24323" href="WellFormed.Base.html#24323" class="Bound">f</a> <a id="24325" href="WellFormed.Base.html#24325" class="Bound">r</a> <a id="24327" href="WellFormed.Base.html#24327" class="Bound">s</a> <a id="24329" class="Keyword">with</a> <a id="24334" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="24343" href="WellFormed.Base.html#24327" class="Bound">s</a> <a id="24345" href="Function.Base.html#4736" class="Function">it</a>
  <a id="24350" class="Symbol">...</a> <a id="24354" class="Symbol">|</a> <a id="24356" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24360" href="WellFormed.Base.html#24360" class="Bound">s</a> <a id="24362" class="Symbol">=</a> <a id="24364" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24375" class="Bound">f</a> <a id="24377" class="Bound">r</a> <a id="24379" href="WellFormed.Base.html#24360" class="Bound">s</a>
  <a id="24383" class="Symbol">...</a> <a id="24387" class="Symbol">|</a> <a id="24389" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24393" href="WellFormed.Base.html#24393" class="Bound">s</a> <a id="24395" class="Symbol">=</a> <a id="24397" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="24404" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24406" href="Data.Nat.Properties.html#12165" class="Function">ℕ.n≮0</a> <a id="24412" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24414" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="24423" class="Bound">f</a> <a id="24425" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24427" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="24437" href="WellFormed.Base.html#24393" class="Bound">s</a> <a id="24439" class="Bound">r</a>
  <a id="24443" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24454" class="Symbol">{</a><a id="24455" class="Argument">n</a> <a id="24457" class="Symbol">=</a> <a id="24459" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24463" href="WellFormed.Base.html#24463" class="Bound">n</a><a id="24464" class="Symbol">}</a> <a id="24466" class="Symbol">{</a><a id="24467" class="Argument">m</a> <a id="24469" class="Symbol">=</a> <a id="24471" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="24475" class="Symbol">}</a>  <a id="24478" href="WellFormed.Base.html#24478" class="Bound">f</a> <a id="24480" href="WellFormed.Base.html#24480" class="Bound">r</a> <a id="24482" href="WellFormed.Base.html#24482" class="Bound">s</a> <a id="24484" class="Keyword">with</a> <a id="24489" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="24498" href="WellFormed.Base.html#24480" class="Bound">r</a> <a id="24500" href="Function.Base.html#4736" class="Function">it</a>
  <a id="24505" class="Symbol">...</a> <a id="24509" class="Symbol">|</a> <a id="24511" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24515" href="WellFormed.Base.html#24515" class="Bound">r</a> <a id="24517" class="Symbol">=</a> <a id="24519" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24530" class="Bound">f</a> <a id="24532" href="WellFormed.Base.html#24515" class="Bound">r</a> <a id="24534" class="Bound">s</a>
  <a id="24538" class="Symbol">...</a> <a id="24542" class="Symbol">|</a> <a id="24544" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24548" href="WellFormed.Base.html#24548" class="Bound">r</a> <a id="24550" class="Symbol">=</a> <a id="24552" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="24559" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24561" href="Data.Nat.Properties.html#12165" class="Function">ℕ.n≮0</a> <a id="24567" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24569" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="24578" class="Bound">f</a> <a id="24580" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24582" href="WellFormed.Base.html#13885" class="Function">≤-&lt;-trans</a> <a id="24592" href="WellFormed.Base.html#24548" class="Bound">r</a> <a id="24594" class="Bound">s</a>
  <a id="24598" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24609" class="Symbol">{</a><a id="24610" class="Argument">n</a> <a id="24612" class="Symbol">=</a> <a id="24614" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24618" href="WellFormed.Base.html#24618" class="Bound">n</a><a id="24619" class="Symbol">}</a> <a id="24621" class="Symbol">{</a><a id="24622" class="Argument">m</a> <a id="24624" class="Symbol">=</a> <a id="24626" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="24630" href="WellFormed.Base.html#24630" class="Bound">m</a><a id="24631" class="Symbol">}</a> <a id="24633" href="WellFormed.Base.html#24633" class="Bound">f</a> <a id="24635" href="WellFormed.Base.html#24635" class="Bound">r</a> <a id="24637" href="WellFormed.Base.html#24637" class="Bound">s</a> <a id="24639" class="Keyword">with</a> <a id="24644" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="24653" href="WellFormed.Base.html#24635" class="Bound">r</a> <a id="24655" href="Function.Base.html#4736" class="Function">it</a> <a id="24658" class="Symbol">|</a> <a id="24660" href="WellFormed.Base.html#18740" class="Function">&lt;-connex</a> <a id="24669" href="WellFormed.Base.html#24637" class="Bound">s</a> <a id="24671" href="Function.Base.html#4736" class="Function">it</a>
  <a id="24676" class="Symbol">...</a> <a id="24680" class="Symbol">|</a> <a id="24682" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24686" href="WellFormed.Base.html#24686" class="Bound">r</a>           <a id="24698" class="Symbol">|</a> <a id="24700" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24704" href="WellFormed.Base.html#24704" class="Bound">s</a>           <a id="24716" class="Symbol">=</a> <a id="24718" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="24729" class="Bound">f</a> <a id="24731" href="WellFormed.Base.html#24686" class="Bound">r</a> <a id="24733" href="WellFormed.Base.html#24704" class="Bound">s</a>
  <a id="24737" class="Symbol">...</a> <a id="24741" class="Symbol">|</a> <a id="24743" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24747" href="WellFormed.Base.html#24747" class="Bound">r</a>           <a id="24759" class="Symbol">|</a> <a id="24761" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24765" href="WellFormed.Base.html#24765" class="Bound">t</a>           <a id="24777" class="Symbol">=</a> <a id="24779" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="24794" class="Bound">f</a> <a id="24796" href="WellFormed.Base.html#24747" class="Bound">r</a> <a id="24798" class="Bound">s</a> <a id="24800" href="WellFormed.Base.html#24765" class="Bound">t</a>
  <a id="24804" class="Symbol">...</a> <a id="24808" class="Symbol">|</a> <a id="24810" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24814" href="WellFormed.Base.html#24814" class="Bound">t</a>           <a id="24826" class="Symbol">|</a> <a id="24828" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24832" href="WellFormed.Base.html#24832" class="Bound">s</a>           <a id="24844" class="Symbol">=</a> <a id="24846" href="Cubical.Foundations.Prelude.html#968" class="Function">🧊.sym</a> <a id="24852" class="Symbol">(</a><a id="24853" href="WellFormed.Base.html#23178" class="Function">min-unique-pre</a> <a id="24868" class="Bound">f</a> <a id="24870" href="WellFormed.Base.html#24832" class="Bound">s</a> <a id="24872" class="Bound">r</a> <a id="24874" href="WellFormed.Base.html#24814" class="Bound">t</a><a id="24875" class="Symbol">)</a>
  <a id="24879" class="Symbol">...</a> <a id="24883" class="Symbol">|</a> <a id="24885" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24889" class="Symbol">(</a><a id="24890" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24894" href="WellFormed.Base.html#24894" class="Bound">fm&lt;fn</a><a id="24899" class="Symbol">)</a> <a id="24901" class="Symbol">|</a> <a id="24903" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24907" class="Symbol">(</a><a id="24908" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24912" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="24916" class="Symbol">)</a>  <a id="24919" class="Symbol">=</a> <a id="24921" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="24928" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="24930" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="24943" class="Bound">f</a> <a id="24945" href="WellFormed.Base.html#24894" class="Bound">fm&lt;fn</a> <a id="24951" class="Bound">r</a>
  <a id="24955" class="Symbol">...</a> <a id="24959" class="Symbol">|</a> <a id="24961" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24965" class="Symbol">(</a><a id="24966" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24970" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="24974" class="Symbol">)</a>  <a id="24977" class="Symbol">|</a> <a id="24979" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="24983" class="Symbol">(</a><a id="24984" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="24988" href="WellFormed.Base.html#24988" class="Bound">fm&lt;fn</a><a id="24993" class="Symbol">)</a> <a id="24995" class="Symbol">=</a> <a id="24997" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="25004" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25006" href="WellFormed.Base.html#16405" class="Function">seq-notDense</a> <a id="25019" class="Bound">f</a> <a id="25021" href="WellFormed.Base.html#24988" class="Bound">fm&lt;fn</a> <a id="25027" class="Bound">s</a>
  <a id="25031" class="Symbol">...</a> <a id="25035" class="Symbol">|</a> <a id="25037" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25041" class="Symbol">(</a><a id="25042" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="25046" href="WellFormed.Base.html#25046" class="Bound">t</a><a id="25047" class="Symbol">)</a>     <a id="25053" class="Symbol">|</a> <a id="25055" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25059" class="Symbol">(</a><a id="25060" href="Data.Sum.Base.html#675" class="InductiveConstructor">inl</a> <a id="25064" href="WellFormed.Base.html#25064" class="Bound">u</a><a id="25065" class="Symbol">)</a>     <a id="25071" class="Symbol">=</a>
    <a id="25077" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="25082" href="WellFormed.Base.html#25142" class="Function">n≡m</a> <a id="25086" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="25089" class="Symbol">λ</a> <a id="25091" class="Symbol">{</a> <a id="25093" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="25098" class="Symbol">→</a> <a id="25100" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="25107" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25109" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="25116" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="25118" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="25126" class="Symbol">_</a> <a id="25128" class="Symbol">_</a> <a id="25130" class="Symbol">}</a> <a id="25132" class="Keyword">where</a>
    <a id="25142" href="WellFormed.Base.html#25142" class="Function">n≡m</a> <a id="25146" class="Symbol">=</a> <a id="25148" href="Data.Nat.Properties.html#5292" class="Function">ℕ.≤-antisym</a>
      <a id="25166" class="Symbol">(</a><a id="25167" href="Data.Nat.Properties.html#13010" class="Function">ℕ.m&lt;1+n⇒m≤n</a> <a id="25179" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25181" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="25190" class="Bound">f</a> <a id="25192" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25194" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="25202" href="WellFormed.Base.html#25046" class="Bound">t</a> <a id="25204" class="Bound">s</a><a id="25205" class="Symbol">)</a> 
      <a id="25214" class="Symbol">(</a><a id="25215" href="Data.Nat.Properties.html#13010" class="Function">ℕ.m&lt;1+n⇒m≤n</a> <a id="25227" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25229" href="WellFormed.Base.html#16073" class="Function">seq-inj&lt;</a> <a id="25238" class="Bound">f</a> <a id="25240" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25242" href="WellFormed.Base.html#9388" class="Function">&lt;-trans</a> <a id="25250" href="WellFormed.Base.html#25064" class="Bound">u</a> <a id="25252" class="Bound">r</a><a id="25253" class="Symbol">)</a>
  <a id="25257" class="Symbol">...</a> <a id="25261" class="Symbol">|</a> <a id="25263" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25267" class="Symbol">(</a><a id="25268" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25272" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="25276" class="Symbol">)</a>  <a id="25279" class="Symbol">|</a> <a id="25281" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25285" class="Symbol">(</a><a id="25286" href="Data.Sum.Base.html#700" class="InductiveConstructor">inr</a> <a id="25290" href="WellFormed.Base.html#25290" class="Bound">fm≡fn</a><a id="25295" class="Symbol">)</a> <a id="25297" class="Keyword">with</a> <a id="25302" href="WellFormed.Base.html#15749" class="Function">seq-inj≡</a> <a id="25311" class="Bound">f</a> <a id="25313" href="WellFormed.Base.html#25290" class="Bound">fm≡fn</a>
  <a id="25321" class="Symbol">...</a> <a id="25325" class="Symbol">|</a> <a id="25327" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="25332" class="Symbol">=</a> <a id="25334" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="25341" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="25343" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="25350" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="25352" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="25360" class="Symbol">_</a> <a id="25362" class="Symbol">_</a>
</pre>
有了最小化函数, 我们可以定义典范映射. 有了典范映射, 就可以将集合的命题截断还原为集合, 此还原我们称为大消去. 一般来说是先定义完典范映射, 然后得到大消去. 但神奇的是, 此处我们必须互递归得到典范映射和大消去, 即互递归定义以下两者.

- 路径的典范映射 $\text{cano}:\text{Rd}(a,b)→\text{Rd}(a,b)$
- 子树到路径的大消去 $\text{set}:a\lt b→\text{Rd}(a,b)$

<pre class="Agda">  <a id="CanonicalRoad.cano"></a><a id="25605" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="25610" class="Symbol">:</a> <a id="25612" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="25617" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="25619" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="25621" class="Symbol">→</a> <a id="25623" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="25628" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="25630" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
  <a id="CanonicalRoad.set"></a><a id="25634" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="25638" class="Symbol">:</a> <a id="25640" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="25642" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="25644" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="25646" class="Symbol">→</a> <a id="25648" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="25653" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="25655" href="WellFormed.Base.html#3780" class="Generalizable">b</a>
</pre>
首先给出 $\text{cano}$ 的具体定义.

**定义 2-0-44** 讨论 $\text{cano}$ 的输入 $r:\text{Rd}(a,b)$.

- 若 $r=0$, 取 $\text{cano}(r):=0$, 也就是说我们规定 $0$ 是 $\text{Rd}(a,a^+)$ 的典范路径. 这不难理解, 因为 $0$ 是唯一的.
- 若 $r=r'^+$, 取 $\text{cano}(r):=\text{cano}(r')^+$. 也就是说对于 $\text{Rd}(a,b^+)$ 的典范路径, 我们希望没有大跨度, 而是一步一步上去.
- 若 $r=\lim(f,n,w,r')$, 令 $(m,s)=\min(|r'|)$, 取 $\text{cano}(r):=\lim(f,m,w,\text{cano}(\text{set}(s)))$. 也就是说我们先通过 $|r'|:a\lt f(n)$ 找到最小的 $m$ 满足 $s:a\lt f(m)$, 将 $s$ 还原为集合, 再递归调用 $\text{cano}$, 最后输入到 $\lim$ 得到 $\text{Rd}(a,\lim(f))$ 的典范路径. ∎

<pre class="Agda">  <a id="26201" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="26206" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a> <a id="26211" class="Symbol">=</a> <a id="26213" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>
  <a id="26220" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="26225" class="Symbol">(</a><a id="26226" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="26230" href="WellFormed.Base.html#26230" class="Bound">r</a><a id="26231" class="Symbol">)</a> <a id="26233" class="Symbol">=</a> <a id="26235" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="26239" class="Symbol">(</a><a id="26240" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="26245" href="WellFormed.Base.html#26230" class="Bound">r</a><a id="26246" class="Symbol">)</a>
  <a id="26250" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="26255" class="Symbol">(</a><a id="26256" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="26260" class="Symbol">{</a><a id="26261" href="WellFormed.Base.html#26261" class="Bound">f</a><a id="26262" class="Symbol">}</a> <a id="26264" href="WellFormed.Base.html#26264" class="Bound">r</a><a id="26265" class="Symbol">)</a> <a id="26267" class="Symbol">=</a> <a id="26269" class="Keyword">let</a> <a id="26273" href="WellFormed.Base.html#26273" class="Bound">m</a> <a id="26275" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="26277" href="WellFormed.Base.html#26277" class="Bound">s</a> <a id="26279" class="Symbol">=</a> <a id="26281" href="WellFormed.Base.html#22818" class="Function">min</a> <a id="26285" href="WellFormed.Base.html#26261" class="Bound">f</a> <a id="26287" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="26289" href="WellFormed.Base.html#26264" class="Bound">r</a> <a id="26291" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="26294" class="Keyword">in</a>
    <a id="26301" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="26305" class="Symbol">{</a><a id="26306" class="Argument">n</a> <a id="26308" class="Symbol">=</a> <a id="26310" href="WellFormed.Base.html#26273" class="Bound">m</a><a id="26311" class="Symbol">}</a> <a id="26313" class="Symbol">(</a><a id="26314" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="26319" class="Symbol">(</a><a id="26320" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="26324" href="WellFormed.Base.html#26277" class="Bound">s</a><a id="26325" class="Symbol">))</a>
</pre>
**定理 2-0-45** 典范映射 $\text{cano}$ 是2-恒等的.  
**证明** 要证对任意 $r,s:\text{Rd}(a,b)$ 有 $\text{cano}(r)=\text{cano}(s)$. 对 $r,s$ 归纳.

- 若 $r=0$, 此时 $s:\text{Rd}(a,a^+)$, 由引理 2-0-36 可知 $s=0$, 因此 $\text{cano}(r)=\text{cano}(s)$.
- 若 $r=0$ 且 $s=s'^+$, 必然有 $a=b$ 且 $s:\text{Rd}(a,a)$, 违反路径的反自反性.
- 若 $r=r'^+$ 且 $s=s'^+$, 由归纳假设 $\text{cano}(r')=\text{cano}(s')$, 因此
  - $\text{cano}(r)=\text{cano}(r')^+=\text{cano}(s')^+=\text{cano}(s)$.
- 若 $r=\lim(f,n,w,r')$ 且 $s=\lim(f,m,w,s')$, 由引理 2-0-43 可知 $\min(r')=\min(s')$, 因此

$$
\begin{aligned}
\text{cano}(r)&=\lim(f,π_1(\min(r')),w,\text{cano}(\text{set}(π_2(\min(r')))))\\
&=\lim(f,π_1(\min(s')),w,\text{cano}(\text{set}(π_2(\min(s')))))\\
&=\text{cano}(s)\quad ∎
\end{aligned}
$$

<pre class="Agda">  <a id="CanonicalRoad.cano-2const"></a><a id="27061" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27073" class="Symbol">:</a> <a id="27075" href="Cubical.Foundations.Function.html#2864" class="Function">2-Constant</a> <a id="27086" class="Symbol">{</a><a id="27087" class="Argument">A</a> <a id="27089" class="Symbol">=</a> <a id="27091" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="27096" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="27098" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="27099" class="Symbol">}</a> <a id="27101" href="WellFormed.Base.html#25605" class="Function">cano</a>
  <a id="27108" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27120" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="27128" href="WellFormed.Base.html#27128" class="Bound">s</a>       <a id="27136" class="Symbol">=</a> <a id="27138" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="27143" href="Cubical.Data.Equality.Conversion.html#1846" class="Function">pathToEq</a> <a id="27152" class="Symbol">(</a><a id="27153" href="WellFormed.Base.html#19862" class="Function">RoadSet.zero-unique</a> <a id="27173" href="WellFormed.Base.html#27128" class="Bound">s</a><a id="27174" class="Symbol">)</a> <a id="27176" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="27179" class="Symbol">λ</a> <a id="27181" class="Symbol">{</a> <a id="27183" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="27188" class="Symbol">→</a> <a id="27190" href="Cubical.Foundations.Prelude.html#915" class="Function">🧊.refl</a> <a id="27197" class="Symbol">}</a>
  <a id="27201" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27213" class="Symbol">(</a><a id="27214" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="27218" href="WellFormed.Base.html#27218" class="Bound">r</a><a id="27219" class="Symbol">)</a> <a id="27221" href="WellFormed.Base.html#4664" class="InductiveConstructor">zero</a>    <a id="27229" class="Symbol">=</a> <a id="27231" href="Data.Empty.html#1050" class="Function">⊥-elim</a> <a id="27238" class="Symbol">(</a><a id="27239" href="WellFormed.Base.html#10894" class="Function">&lt;-irrefl</a> <a id="27248" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="27253" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27255" href="WellFormed.Base.html#27218" class="Bound">r</a> <a id="27257" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="27259" class="Symbol">)</a>
  <a id="27263" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27275" class="Symbol">(</a><a id="27276" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="27280" href="WellFormed.Base.html#27280" class="Bound">r</a><a id="27281" class="Symbol">)</a> <a id="27283" class="Symbol">(</a><a id="27284" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="27288" href="WellFormed.Base.html#27288" class="Bound">s</a><a id="27289" class="Symbol">)</a> <a id="27291" class="Symbol">=</a> <a id="27293" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="27300" href="WellFormed.Base.html#4688" class="InductiveConstructor">suc</a> <a id="27304" class="Symbol">(</a><a id="27305" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27317" href="WellFormed.Base.html#27280" class="Bound">r</a> <a id="27319" href="WellFormed.Base.html#27288" class="Bound">s</a><a id="27320" class="Symbol">)</a>
  <a id="27324" href="WellFormed.Base.html#27061" class="Function">cano-2const</a> <a id="27336" class="Symbol">{</a><a id="27337" href="WellFormed.Base.html#27337" class="Bound">a</a><a id="27338" class="Symbol">}</a> <a id="27340" class="Symbol">(</a><a id="27341" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="27345" class="Symbol">{</a><a id="27346" href="WellFormed.Base.html#27346" class="Bound">f</a><a id="27347" class="Symbol">}</a> <a id="27349" class="Symbol">{</a><a id="27350" href="WellFormed.Base.html#27350" class="Bound">n</a><a id="27351" class="Symbol">}</a> <a id="27353" href="WellFormed.Base.html#27353" class="Bound">r</a><a id="27354" class="Symbol">)</a> <a id="27356" class="Symbol">(</a><a id="27357" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="27361" class="Symbol">{</a><a id="27362" class="Argument">n</a> <a id="27364" class="Symbol">=</a> <a id="27366" href="WellFormed.Base.html#27366" class="Bound">m</a><a id="27367" class="Symbol">}</a> <a id="27369" href="WellFormed.Base.html#27369" class="Bound">s</a><a id="27370" class="Symbol">)</a> <a id="27372" class="Symbol">=</a> <a id="27374" href="Cubical.Foundations.Prelude.html#2025" class="Function">🧊.cong₂</a>
    <a id="27386" class="Symbol">(λ</a> <a id="27389" href="WellFormed.Base.html#27389" class="Bound">k</a> <a id="27391" class="Symbol">(</a><a id="27392" href="WellFormed.Base.html#27392" class="Bound">t</a> <a id="27394" class="Symbol">:</a> <a id="27396" href="WellFormed.Base.html#27337" class="Bound">a</a> <a id="27398" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="27400" href="WellFormed.Base.html#27346" class="Bound">f</a> <a id="27402" href="WellFormed.Base.html#27389" class="Bound">k</a><a id="27403" class="Symbol">)</a> <a id="27405" class="Symbol">→</a> <a id="27407" href="WellFormed.Base.html#4723" class="InductiveConstructor">Road.lim</a> <a id="27416" class="Symbol">{</a><a id="27417" class="Argument">f</a> <a id="27419" class="Symbol">=</a> <a id="27421" href="WellFormed.Base.html#27346" class="Bound">f</a><a id="27422" class="Symbol">}</a> <a id="27424" class="Symbol">{</a><a id="27425" class="Argument">n</a> <a id="27427" class="Symbol">=</a> <a id="27429" href="WellFormed.Base.html#27389" class="Bound">k</a><a id="27430" class="Symbol">}</a> <a id="27432" class="Symbol">(</a><a id="27433" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="27438" class="Symbol">(</a><a id="27439" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="27443" href="WellFormed.Base.html#27392" class="Bound">t</a><a id="27444" class="Symbol">)))</a>
    <a id="27452" class="Symbol">(</a><a id="27453" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="27460" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="27464" class="Symbol">(</a><a id="27465" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="27476" href="WellFormed.Base.html#27346" class="Bound">f</a> <a id="27478" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27480" href="WellFormed.Base.html#27353" class="Bound">r</a> <a id="27482" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="27485" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27487" href="WellFormed.Base.html#27369" class="Bound">s</a> <a id="27489" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="27491" class="Symbol">))</a>
    <a id="27498" class="Symbol">(</a><a id="27499" href="Cubical.Foundations.Prelude.html#1430" class="Function">🧊.cong</a> <a id="27506" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="27510" class="Symbol">(</a><a id="27511" href="WellFormed.Base.html#24116" class="Function">min-unique</a> <a id="27522" href="WellFormed.Base.html#27346" class="Bound">f</a> <a id="27524" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27526" href="WellFormed.Base.html#27353" class="Bound">r</a> <a id="27528" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="27531" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27533" href="WellFormed.Base.html#27369" class="Bound">s</a> <a id="27535" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="27537" class="Symbol">))</a>
</pre>
**定义 2-0-46** 子树关系到路径关系的大消去 $\text{set}$: 由于我们已经证明了路径类型是集合, 且找到了路径的典范映射, 由 HoTT 的相关引理即得. 该引理可展开为[一篇论文](https://arxiv.org/pdf/1411.2682.pdf), 这里不展开. ∎

<pre class="Agda">  <a id="27706" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="27710" class="Symbol">=</a> <a id="27712" href="Cubical.HITs.PropositionalTruncation.Properties.html#7028" class="Function">rec→Set</a> <a id="27720" href="WellFormed.Base.html#22060" class="Function">isSetRoad</a> <a id="27730" href="WellFormed.Base.html#25605" class="Function">cano</a> <a id="27735" href="WellFormed.Base.html#27061" class="Function">cano-2const</a>

<a id="27748" class="Keyword">open</a> <a id="27753" href="WellFormed.Base.html#22305" class="Module">CanonicalRoad</a> <a id="27767" class="Keyword">public</a> <a id="27774" class="Keyword">using</a> <a id="27780" class="Symbol">(</a><a id="27781" href="WellFormed.Base.html#25634" class="Function">set</a><a id="27784" class="Symbol">)</a>
</pre>
**推论 2-0-47** 子树的蕴含可以还原为路径的运算.

<pre class="Agda"><a id="setmap"></a><a id="27831" href="WellFormed.Base.html#27831" class="Function">setmap</a> <a id="27838" class="Symbol">:</a> <a id="27840" class="Symbol">(</a><a id="27841" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="27843" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="27845" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="27847" class="Symbol">→</a> <a id="27849" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="27851" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="27853" href="WellFormed.Base.html#3784" class="Generalizable">d</a><a id="27854" class="Symbol">)</a> <a id="27856" class="Symbol">→</a> <a id="27858" class="Symbol">(</a><a id="27859" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="27864" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="27866" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="27868" class="Symbol">→</a> <a id="27870" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="27875" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="27877" href="WellFormed.Base.html#3784" class="Generalizable">d</a><a id="27878" class="Symbol">)</a>
<a id="27880" href="WellFormed.Base.html#27831" class="Function">setmap</a> <a id="27887" href="WellFormed.Base.html#27887" class="Bound">p</a> <a id="27889" href="WellFormed.Base.html#27889" class="Bound">r</a> <a id="27891" class="Symbol">=</a> <a id="27893" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="27897" class="Symbol">(</a><a id="27898" href="WellFormed.Base.html#27887" class="Bound">p</a> <a id="27900" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="27902" href="WellFormed.Base.html#27889" class="Bound">r</a> <a id="27904" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a><a id="27906" class="Symbol">)</a>
</pre>
一旦建立子树关系到路径关系的消去, 我们可以构造之前无法构造的路径.

**定理 2-0-48** 对任意良构序列 $f$ 有路径 $\text{Rd}(f(n), \lim(f))$.  
**证明** 先通过良构性证明 $f(n)\lt \lim(f)$, 然后还原为路径. ∎

<pre class="Agda"><a id="f&lt;l"></a><a id="28064" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a> <a id="28068" class="Symbol">:</a> <a id="28070" class="Symbol">{</a><a id="28071" href="WellFormed.Base.html#28071" class="Bound">w</a> <a id="28073" class="Symbol">:</a> <a id="28075" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="28078" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="28079" class="Symbol">}</a> <a id="28081" class="Symbol">→</a> <a id="28083" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="28085" href="WellFormed.Base.html#3770" class="Generalizable">n</a> <a id="28087" href="WellFormed.Base.html#3168" class="Function Operator">&lt;</a> <a id="28089" class="InductiveConstructor">lim</a> <a id="28093" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="28095" class="Symbol">⦃</a> <a id="28097" href="WellFormed.Base.html#28071" class="Bound">w</a> <a id="28099" class="Symbol">⦄</a>
<a id="28101" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a> <a id="28105" class="Symbol">{</a><a id="28106" href="WellFormed.Base.html#28106" class="Bound">w</a><a id="28107" class="Symbol">}</a> <a id="28109" class="Symbol">=</a> <a id="28111" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="28115" class="Symbol">(</a><a id="28116" href="WellFormed.Base.html#4723" class="InductiveConstructor">lim</a> <a id="28120" class="Symbol">⦃</a> <a id="28122" class="Symbol">_</a> <a id="28124" class="Symbol">⦄)</a> <a id="28127" href="WellFormed.Base.html#28106" class="Bound">w</a>

<a id="f&lt;l-rd"></a><a id="28130" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="28137" class="Symbol">:</a> <a id="28139" class="Symbol">{</a><a id="28140" href="WellFormed.Base.html#28140" class="Bound">w</a> <a id="28142" class="Symbol">:</a> <a id="28144" href="WellFormed.Base.html#3624" class="Function">wf</a> <a id="28147" href="WellFormed.Base.html#3794" class="Generalizable">f</a><a id="28148" class="Symbol">}</a> <a id="28150" class="Symbol">→</a> <a id="28152" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="28157" class="Symbol">(</a><a id="28158" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="28160" href="WellFormed.Base.html#3770" class="Generalizable">n</a><a id="28161" class="Symbol">)</a> <a id="28163" class="Symbol">(</a><a id="28164" class="InductiveConstructor">lim</a> <a id="28168" href="WellFormed.Base.html#3794" class="Generalizable">f</a> <a id="28170" class="Symbol">⦃</a> <a id="28172" href="WellFormed.Base.html#28140" class="Bound">w</a> <a id="28174" class="Symbol">⦄)</a>
<a id="28177" href="WellFormed.Base.html#28130" class="Function">f&lt;l-rd</a> <a id="28184" class="Symbol">=</a> <a id="28186" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="28190" href="WellFormed.Base.html#28064" class="Function">f&lt;l</a>
</pre>
**定理 2-0-49** 子树的三歧性可以强化为路径的三歧性.  
**证明** 从引理 2-0-35 还原为路径. ∎

<pre class="Agda"><a id="rd-trich"></a><a id="28270" href="WellFormed.Base.html#28270" class="Function">rd-trich</a> <a id="28279" class="Symbol">:</a> <a id="28281" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="28286" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="28288" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="28290" class="Symbol">→</a> <a id="28292" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="28297" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="28299" href="WellFormed.Base.html#3782" class="Generalizable">c</a> <a id="28301" class="Symbol">→</a> <a id="28303" href="Relation.Binary.Definitions.html#3038" class="Datatype">Tri</a> <a id="28307" class="Symbol">(</a><a id="28308" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="28313" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="28315" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="28316" class="Symbol">)</a> <a id="28318" class="Symbol">(</a><a id="28319" href="WellFormed.Base.html#3778" class="Generalizable">a</a> <a id="28321" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="28323" href="WellFormed.Base.html#3780" class="Generalizable">b</a><a id="28324" class="Symbol">)</a> <a id="28326" class="Symbol">(</a><a id="28327" href="WellFormed.Base.html#2987" class="Datatype">Road</a> <a id="28332" href="WellFormed.Base.html#3780" class="Generalizable">b</a> <a id="28334" href="WellFormed.Base.html#3778" class="Generalizable">a</a><a id="28335" class="Symbol">)</a>
<a id="28337" href="WellFormed.Base.html#28270" class="Function">rd-trich</a> <a id="28346" href="WellFormed.Base.html#28346" class="Bound">r</a> <a id="28348" href="WellFormed.Base.html#28348" class="Bound">s</a> <a id="28350" class="Keyword">with</a> <a id="28355" href="WellFormed.Base.html#18942" class="Function">&lt;-trich</a> <a id="28363" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="28365" href="WellFormed.Base.html#28346" class="Bound">r</a> <a id="28367" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="28370" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="28372" href="WellFormed.Base.html#28348" class="Bound">s</a> <a id="28374" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
<a id="28377" class="Symbol">...</a> <a id="28381" class="Symbol">|</a> <a id="28383" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="28388" href="WellFormed.Base.html#28388" class="Bound">t</a> <a id="28390" href="WellFormed.Base.html#28390" class="Bound">¬u</a> <a id="28393" href="WellFormed.Base.html#28393" class="Bound">¬v</a> <a id="28396" class="Symbol">=</a> <a id="28398" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="28403" class="Symbol">(</a><a id="28404" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="28408" href="WellFormed.Base.html#28388" class="Bound">t</a><a id="28409" class="Symbol">)</a>     <a id="28415" href="WellFormed.Base.html#28390" class="Bound">¬u</a>  <a id="28419" class="Symbol">(</a><a id="28420" href="WellFormed.Base.html#28393" class="Bound">¬v</a> <a id="28423" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28425" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="28429" class="Symbol">)</a>
<a id="28431" class="Symbol">...</a> <a id="28435" class="Symbol">|</a> <a id="28437" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="28442" href="WellFormed.Base.html#28442" class="Bound">¬t</a> <a id="28445" href="WellFormed.Base.html#28445" class="Bound">u</a> <a id="28447" href="WellFormed.Base.html#28447" class="Bound">¬v</a> <a id="28450" class="Symbol">=</a> <a id="28452" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="28457" class="Symbol">(</a><a id="28458" href="WellFormed.Base.html#28442" class="Bound">¬t</a> <a id="28461" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28463" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="28467" class="Symbol">)</a> <a id="28469" href="WellFormed.Base.html#28445" class="Bound">u</a>   <a id="28473" class="Symbol">(</a><a id="28474" href="WellFormed.Base.html#28447" class="Bound">¬v</a> <a id="28477" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28479" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="28483" class="Symbol">)</a>
<a id="28485" class="Symbol">...</a> <a id="28489" class="Symbol">|</a> <a id="28491" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="28496" href="WellFormed.Base.html#28496" class="Bound">¬t</a> <a id="28499" href="WellFormed.Base.html#28499" class="Bound">¬u</a> <a id="28502" href="WellFormed.Base.html#28502" class="Bound">v</a> <a id="28504" class="Symbol">=</a> <a id="28506" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="28511" class="Symbol">(</a><a id="28512" href="WellFormed.Base.html#28496" class="Bound">¬t</a> <a id="28515" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="28517" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="28521" class="Symbol">)</a> <a id="28523" href="WellFormed.Base.html#28499" class="Bound">¬u</a>  <a id="28527" class="Symbol">(</a><a id="28528" href="WellFormed.Base.html#25634" class="Function">set</a> <a id="28532" href="WellFormed.Base.html#28502" class="Bound">v</a><a id="28533" class="Symbol">)</a>
</pre>
**结论 2-0-50** 忽略非同株序数 (up to homo), 路径关系 $\text{Rd}$ (作为集合) 和子树关系 $\lt$ (作为命题) 分别构成了序数集 $\text{Ord}$ 上的良序.

**约定 2-0-51** 鉴于路径关系与子树关系的高度可互换性, 我们今后可能只会构造/证明其中一种, 读者应该理解其另一种也隐式地立即得到了.
