<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(9) 二元Veblen函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Agda大序数(9) 二元Veblen函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数9-二元veblen函数" id="toc-agda大序数9-二元veblen函数">Agda大序数(9) 二元Veblen函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#定义" id="toc-定义">定义</a></li>
  <li><a href="#性质" id="toc-性质">性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数9-二元veblen函数">Agda大序数(9) 二元Veblen函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
总目录: <a href="https://choukh.github.io/agda-lvo/Everything.html">Everything.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/Veblen/Function.lagda.md">Veblen/Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/Veblen.Function.html">Veblen.Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<p><strong>(本章施工中)</strong></p>
<pre class="Agda"><a id="460" class="Symbol">{-#</a> <a id="464" class="Keyword">OPTIONS</a> <a id="472" class="Pragma">--without-K</a> <a id="484" class="Pragma">--safe</a> <a id="491" class="Pragma">--experimental-lossy-unification</a> <a id="524" class="Symbol">#-}</a>

<a id="529" class="Keyword">module</a> <a id="536" href="Veblen.Function.html" class="Module">Veblen.Function</a> <a id="552" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<pre class="Agda"><a id="578" class="Keyword">open</a> <a id="583" class="Keyword">import</a> <a id="590" href="Ordinal.html" class="Module">Ordinal</a>
<a id="598" class="Keyword">open</a> <a id="603" href="Ordinal.html#14675" class="Module">Ordinal.≤-Reasoning</a>
<a id="623" class="Keyword">open</a> <a id="628" class="Keyword">import</a> <a id="635" href="Ordinal.WellFormed.html" class="Module">Ordinal.WellFormed</a> <a id="654" class="Keyword">using</a> <a id="660" class="Symbol">(</a><a id="661" href="Ordinal.WellFormed.html#1802" class="Function">ω</a><a id="662" class="Symbol">;</a> <a id="664" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜_⌝</a><a id="667" class="Symbol">)</a>
<a id="669" class="Keyword">open</a> <a id="674" class="Keyword">import</a> <a id="681" href="Ordinal.Function.html" class="Module">Ordinal.Function</a>
<a id="698" class="Keyword">open</a> <a id="703" class="Keyword">import</a> <a id="710" href="Ordinal.Recursion.html" class="Module">Ordinal.Recursion</a>
<a id="728" class="Keyword">open</a> <a id="733" class="Keyword">import</a> <a id="740" href="Ordinal.Arithmetic.html" class="Module">Ordinal.Arithmetic</a> <a id="759" class="Keyword">using</a> <a id="765" class="Symbol">(</a><a id="766" href="Ordinal.Arithmetic.html#2236" class="Function Operator">_^_</a><a id="769" class="Symbol">)</a>
<a id="771" class="Keyword">open</a> <a id="776" class="Keyword">import</a> <a id="783" href="Veblen.Fixpoint.html" class="Module">Veblen.Fixpoint</a>
<a id="799" class="Keyword">open</a> <a id="804" class="Keyword">import</a> <a id="811" href="Veblen.Epsilon.html" class="Module">Veblen.Epsilon</a> <a id="826" class="Keyword">using</a> <a id="832" class="Symbol">(</a><a id="833" href="Veblen.Epsilon.html#1257" class="Function">ω^-normal</a><a id="842" class="Symbol">;</a> <a id="844" href="Veblen.Epsilon.html#2091" class="Function">ε</a><a id="845" class="Symbol">;</a> <a id="847" href="Veblen.Epsilon.html#3131" class="Function">ζ</a><a id="848" class="Symbol">;</a> <a id="850" href="Veblen.Epsilon.html#3928" class="Function">η</a><a id="851" class="Symbol">)</a>

<a id="854" class="Keyword">open</a> <a id="859" class="Keyword">import</a> <a id="866" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="875" class="Symbol">as</a> <a id="878" class="Module">ℕ</a> <a id="880" class="Keyword">using</a> <a id="886" class="Symbol">(</a><a id="887" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="888" class="Symbol">;</a> <a id="890" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="894" class="Symbol">;</a> <a id="896" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="899" class="Symbol">)</a>
<a id="901" class="Keyword">open</a> <a id="906" class="Keyword">import</a> <a id="913" href="Function.html" class="Module">Function</a> <a id="922" class="Keyword">using</a> <a id="928" class="Symbol">(</a><a id="929" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="932" class="Symbol">)</a>
<a id="934" class="Keyword">open</a> <a id="939" class="Keyword">import</a> <a id="946" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="955" class="Keyword">using</a> <a id="961" class="Symbol">(</a><a id="962" href="Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="965" class="Symbol">;</a> <a id="967" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="971" class="Symbol">;</a> <a id="973" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="977" class="Symbol">)</a>
<a id="979" class="Keyword">open</a> <a id="984" class="Keyword">import</a> <a id="991" href="Data.Product.html" class="Module">Data.Product</a> <a id="1004" class="Keyword">using</a> <a id="1010" class="Symbol">(</a><a id="1011" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="1012" class="Symbol">;</a> <a id="1014" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="1017" class="Symbol">;</a> <a id="1019" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="1022" class="Symbol">;</a> <a id="1024" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1029" class="Symbol">;</a> <a id="1031" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1036" class="Symbol">)</a>
<a id="1038" class="Keyword">open</a> <a id="1043" class="Keyword">import</a> <a id="1050" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1088" class="Symbol">as</a> <a id="1091" class="Module">Eq</a> <a id="1094" class="Keyword">using</a> <a id="1100" class="Symbol">(</a><a id="1101" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1104" class="Symbol">;</a> <a id="1106" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1110" class="Symbol">)</a>
</pre>
<h2 id="定义">定义</h2>
<p>上一章讲到, 将 <code>ω ^_</code>, <code>ε</code>, <code>ζ</code>, <code>η</code> 分别看作第0, 1, 2, 3层级, 可以推广到任意序数层级, 从而得到二元 Veblen 函数.</p>
<p>形式上, 我们需要辅助函数 <code>veblen</code>, 它是一个高阶函数, 接受一个序数函数 <code>F</code> 作为初始值, 并接受一个序数 <code>α</code> 作为 <code>_′</code> 的迭代次数, 返回迭代后的序数函数. 于是 <code>φ</code> 就定义为以 <code>ω ^_</code> 为初始值的 <code>_′</code> 迭代.</p>
<p><strong>注意</strong> 极限情况下的形式较为复杂. naive地看似乎 <code>F ∘ₗ f</code> 就够了, 但为了更好的性质以及更高的增长率要再套一层 <code>_⁺</code>.</p>
<pre class="Agda"><a id="veblen"></a><a id="1417" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1424" class="Symbol">:</a> <a id="1426" class="Symbol">(</a><a id="1427" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1431" class="Symbol">→</a> <a id="1433" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1436" class="Symbol">)</a> <a id="1438" class="Symbol">→</a> <a id="1440" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1444" class="Symbol">→</a> <a id="1446" class="Symbol">(</a><a id="1447" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1451" class="Symbol">→</a> <a id="1453" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1456" class="Symbol">)</a>
<a id="_∘ₗ_"></a><a id="1458" href="Veblen.Function.html#1458" class="Function Operator">_∘ₗ_</a> <a id="1463" class="Symbol">:</a> <a id="1465" class="Symbol">(</a><a id="1466" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1470" class="Symbol">→</a> <a id="1472" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1475" class="Symbol">)</a> <a id="1477" class="Symbol">→</a> <a id="1479" class="Symbol">(</a><a id="1480" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1482" class="Symbol">→</a> <a id="1484" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1487" class="Symbol">)</a> <a id="1489" class="Symbol">→</a> <a id="1491" class="Symbol">(</a><a id="1492" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1496" class="Symbol">→</a> <a id="1498" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1501" class="Symbol">)</a>

<a id="1504" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1511" href="Veblen.Function.html#1511" class="Bound">F</a> <a id="1513" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="1521" class="Symbol">=</a> <a id="1523" href="Veblen.Function.html#1511" class="Bound">F</a>
<a id="1525" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1532" href="Veblen.Function.html#1532" class="Bound">F</a> <a id="1534" class="Symbol">(</a><a id="1535" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="1539" href="Veblen.Function.html#1539" class="Bound">α</a><a id="1540" class="Symbol">)</a> <a id="1542" class="Symbol">=</a> <a id="1544" class="Symbol">(</a><a id="1545" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1552" href="Veblen.Function.html#1532" class="Bound">F</a> <a id="1554" href="Veblen.Function.html#1539" class="Bound">α</a><a id="1555" class="Symbol">)</a> <a id="1557" href="Veblen.Fixpoint.html#2305" class="Function Operator">′</a>
<a id="1559" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1566" href="Veblen.Function.html#1566" class="Bound">F</a> <a id="1568" class="Symbol">(</a><a id="1569" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="1573" href="Veblen.Function.html#1573" class="Bound">f</a><a id="1574" class="Symbol">)</a> <a id="1576" class="Symbol">=</a> <a id="1578" class="Symbol">(</a><a id="1579" href="Veblen.Function.html#1566" class="Bound">F</a> <a id="1581" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="1584" href="Veblen.Function.html#1573" class="Bound">f</a><a id="1585" class="Symbol">)</a> <a id="1587" href="Veblen.Fixpoint.html#1746" class="Function Operator">⁺</a>
<a id="1589" href="Veblen.Function.html#1589" class="Bound">F</a> <a id="1591" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="1594" href="Veblen.Function.html#1594" class="Bound">f</a> <a id="1596" class="Symbol">=</a> <a id="1598" class="Symbol">λ</a> <a id="1600" href="Veblen.Function.html#1600" class="Bound">α</a> <a id="1602" class="Symbol">→</a> <a id="1604" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="1608" class="Symbol">(λ</a> <a id="1611" href="Veblen.Function.html#1611" class="Bound">n</a> <a id="1613" class="Symbol">→</a> <a id="1615" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1622" href="Veblen.Function.html#1589" class="Bound">F</a> <a id="1624" class="Symbol">(</a><a id="1625" href="Veblen.Function.html#1594" class="Bound">f</a> <a id="1627" href="Veblen.Function.html#1611" class="Bound">n</a><a id="1628" class="Symbol">)</a> <a id="1630" href="Veblen.Function.html#1600" class="Bound">α</a><a id="1631" class="Symbol">)</a>

<a id="φ"></a><a id="1634" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1636" class="Symbol">:</a> <a id="1638" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1642" class="Symbol">→</a> <a id="1644" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1648" class="Symbol">→</a> <a id="1650" href="Ordinal.html#3062" class="Datatype">Ord</a>
<a id="1654" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1656" class="Symbol">=</a> <a id="1658" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="1665" class="Symbol">(</a><a id="1666" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="1668" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a><a id="1670" class="Symbol">)</a>
</pre>
<p>由定义有</p>
<p><span class="math display">φ_{0}(α) = ω^α</span></p>
<pre class="Agda"><a id="1711" href="Veblen.Function.html#1711" class="Function">_</a> <a id="1713" class="Symbol">:</a> <a id="1715" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1717" class="InductiveConstructor">zero</a> <a id="1722" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1724" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="1726" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a>
<a id="1729" class="Symbol">_</a> <a id="1731" class="Symbol">=</a> <a id="1733" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p> </p>
<p><span class="math display">φ_{1}(α) = ε_α</span></p>
<pre class="Agda"><a id="1778" href="Veblen.Function.html#1778" class="Function">_</a> <a id="1780" class="Symbol">:</a> <a id="1782" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1784" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1786" class="Number">1</a> <a id="1788" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1790" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1792" href="Veblen.Epsilon.html#2091" class="Function">ε</a>
<a id="1794" class="Symbol">_</a> <a id="1796" class="Symbol">=</a> <a id="1798" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p> </p>
<p><span class="math display">φ_{2}(α) = ζ_α</span></p>
<pre class="Agda"><a id="1843" href="Veblen.Function.html#1843" class="Function">_</a> <a id="1845" class="Symbol">:</a> <a id="1847" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1849" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1851" class="Number">2</a> <a id="1853" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1855" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1857" href="Veblen.Epsilon.html#3131" class="Function">ζ</a>
<a id="1859" class="Symbol">_</a> <a id="1861" class="Symbol">=</a> <a id="1863" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p> </p>
<p><span class="math display">φ_{3}(α) = η_α</span></p>
<pre class="Agda"><a id="1908" href="Veblen.Function.html#1908" class="Function">_</a> <a id="1910" class="Symbol">:</a> <a id="1912" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1914" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1916" class="Number">3</a> <a id="1918" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1920" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1922" href="Veblen.Epsilon.html#3928" class="Function">η</a>
<a id="1924" class="Symbol">_</a> <a id="1926" class="Symbol">=</a> <a id="1928" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p> </p>
<p><span class="math display">φ_{α+1}(β) = {φ_{α}}&#39;(β)</span></p>
<pre class="Agda"><a id="1983" href="Veblen.Function.html#1983" class="Function">_</a> <a id="1985" class="Symbol">:</a> <a id="1987" class="Symbol">∀</a> <a id="1989" href="Veblen.Function.html#1989" class="Bound">α</a> <a id="1991" class="Symbol">→</a> <a id="1993" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="1995" class="Symbol">(</a><a id="1996" class="InductiveConstructor">suc</a> <a id="2000" href="Veblen.Function.html#1989" class="Bound">α</a><a id="2001" class="Symbol">)</a> <a id="2003" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2005" class="Symbol">(</a><a id="2006" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2008" href="Veblen.Function.html#1989" class="Bound">α</a><a id="2009" class="Symbol">)</a> <a id="2011" href="Veblen.Fixpoint.html#2305" class="Function Operator">′</a>
<a id="2013" class="Symbol">_</a> <a id="2015" class="Symbol">=</a> <a id="2017" class="Symbol">λ</a> <a id="2019" href="Veblen.Function.html#2019" class="Bound">_</a> <a id="2021" class="Symbol">→</a> <a id="2023" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>第一个参数是极限时又按第二个参数分三种情况:</p>
<p><span class="math display">φ_{\lim f}(0) = \sup\{φ_{f(0)}(0), φ_{f(1)}(0), φ_{f(2)}(0), ...\}</span></p>
<p>或者按基本序列记作</p>
<p><span class="math display">φ_{γ}(0)[n] = φ_{γ[n]}(0)</span></p>
<p>我们今后都采用这种非形式记法.</p>
<pre class="Agda"><a id="2196" href="Veblen.Function.html#2196" class="Function">_</a> <a id="2198" class="Symbol">:</a> <a id="2200" class="Symbol">∀</a> <a id="2202" href="Veblen.Function.html#2202" class="Bound">f</a> <a id="2204" class="Symbol">→</a> <a id="2206" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2208" class="Symbol">(</a><a id="2209" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2213" href="Veblen.Function.html#2202" class="Bound">f</a><a id="2214" class="Symbol">)</a> <a id="2216" class="InductiveConstructor">zero</a> <a id="2221" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2223" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2227" class="Symbol">(λ</a> <a id="2230" href="Veblen.Function.html#2230" class="Bound">n</a> <a id="2232" class="Symbol">→</a> <a id="2234" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2236" class="Symbol">(</a><a id="2237" href="Veblen.Function.html#2202" class="Bound">f</a> <a id="2239" href="Veblen.Function.html#2230" class="Bound">n</a><a id="2240" class="Symbol">)</a> <a id="2242" class="InductiveConstructor">zero</a><a id="2246" class="Symbol">)</a>
<a id="2248" class="Symbol">_</a> <a id="2250" class="Symbol">=</a> <a id="2252" class="Symbol">λ</a> <a id="2254" href="Veblen.Function.html#2254" class="Bound">_</a> <a id="2256" class="Symbol">→</a> <a id="2258" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>后继的情况有</p>
<p><span class="math display">φ_{γ}(α+1)[n] = φ_{γ[n]}(φ_{γ}(α)+1)</span></p>
<pre class="Agda"><a id="2326" href="Veblen.Function.html#2326" class="Function">_</a> <a id="2328" class="Symbol">:</a> <a id="2330" class="Symbol">∀</a> <a id="2332" href="Veblen.Function.html#2332" class="Bound">f</a> <a id="2334" href="Veblen.Function.html#2334" class="Bound">α</a> <a id="2336" class="Symbol">→</a> <a id="2338" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2340" class="Symbol">(</a><a id="2341" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2345" href="Veblen.Function.html#2332" class="Bound">f</a><a id="2346" class="Symbol">)</a> <a id="2348" class="Symbol">(</a><a id="2349" class="InductiveConstructor">suc</a> <a id="2353" href="Veblen.Function.html#2334" class="Bound">α</a><a id="2354" class="Symbol">)</a> <a id="2356" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2358" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2362" class="Symbol">(λ</a> <a id="2365" href="Veblen.Function.html#2365" class="Bound">n</a> <a id="2367" class="Symbol">→</a> <a id="2369" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2371" class="Symbol">(</a><a id="2372" href="Veblen.Function.html#2332" class="Bound">f</a> <a id="2374" href="Veblen.Function.html#2365" class="Bound">n</a><a id="2375" class="Symbol">)</a> <a id="2377" class="Symbol">(</a><a id="2378" class="InductiveConstructor">suc</a> <a id="2382" class="Symbol">(</a><a id="2383" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2385" class="Symbol">(</a><a id="2386" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2390" href="Veblen.Function.html#2332" class="Bound">f</a><a id="2391" class="Symbol">)</a> <a id="2393" href="Veblen.Function.html#2334" class="Bound">α</a><a id="2394" class="Symbol">)))</a>
<a id="2398" class="Symbol">_</a> <a id="2400" class="Symbol">=</a> <a id="2402" class="Symbol">λ</a> <a id="2404" href="Veblen.Function.html#2404" class="Bound">_</a> <a id="2406" href="Veblen.Function.html#2406" class="Bound">_</a> <a id="2408" class="Symbol">→</a> <a id="2410" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>两个参数都是极限的情况:</p>
<p><span class="math display">φ_{α}(γ)[n] = φ_{α}(γ[n])</span></p>
<pre class="Agda"><a id="2473" href="Veblen.Function.html#2473" class="Function">_</a> <a id="2475" class="Symbol">:</a> <a id="2477" class="Symbol">∀</a> <a id="2479" href="Veblen.Function.html#2479" class="Bound">f</a> <a id="2481" href="Veblen.Function.html#2481" class="Bound">g</a> <a id="2483" class="Symbol">→</a> <a id="2485" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2487" class="Symbol">(</a><a id="2488" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2492" href="Veblen.Function.html#2479" class="Bound">f</a><a id="2493" class="Symbol">)</a> <a id="2495" class="Symbol">(</a><a id="2496" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2500" href="Veblen.Function.html#2481" class="Bound">g</a><a id="2501" class="Symbol">)</a> <a id="2503" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2505" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2509" class="Symbol">(λ</a> <a id="2512" href="Veblen.Function.html#2512" class="Bound">n</a> <a id="2514" class="Symbol">→</a> <a id="2516" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="2518" class="Symbol">(</a><a id="2519" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2523" href="Veblen.Function.html#2479" class="Bound">f</a><a id="2524" class="Symbol">)</a> <a id="2526" class="Symbol">(</a><a id="2527" href="Veblen.Function.html#2481" class="Bound">g</a> <a id="2529" href="Veblen.Function.html#2512" class="Bound">n</a><a id="2530" class="Symbol">))</a>
<a id="2533" class="Symbol">_</a> <a id="2535" class="Symbol">=</a> <a id="2537" class="Symbol">λ</a> <a id="2539" href="Veblen.Function.html#2539" class="Bound">_</a> <a id="2541" href="Veblen.Function.html#2541" class="Bound">_</a> <a id="2543" class="Symbol">→</a> <a id="2545" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<h2 id="性质">性质</h2>
<p>给定一个序数嵌入 <code>F</code>.</p>
<pre class="Agda"><a id="2585" class="Keyword">module</a> <a id="Properties"></a><a id="2592" href="Veblen.Function.html#2592" class="Module">Properties</a> <a id="2603" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="2605" class="Symbol">(</a><a id="2606" href="Veblen.Function.html#2606" class="Bound">nml</a><a id="2609" class="Symbol">@(</a><a id="2611" href="Veblen.Function.html#2611" class="Bound">≤-mono</a> <a id="2618" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2620" href="Veblen.Function.html#2620" class="Bound">&lt;-mono</a> <a id="2627" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2629" href="Veblen.Function.html#2629" class="Bound">lim-ct</a><a id="2635" class="Symbol">)</a> <a id="2637" class="Symbol">:</a> <a id="2639" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2646" href="Veblen.Function.html#2603" class="Bound">F</a><a id="2647" class="Symbol">)</a> <a id="2649" class="Keyword">where</a>
</pre>
<p>对 <code>veblen</code> 来说, 如果初始函数 <code>F</code> 是序数嵌入, 那么每个迭代 <code>veblen F α</code> 都是序数嵌入.</p>
<pre class="Agda">  <a id="Properties.veblen-normal"></a><a id="2732" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="2746" class="Symbol">:</a> <a id="2748" class="Symbol">∀</a> <a id="2750" href="Veblen.Function.html#2750" class="Bound">α</a> <a id="2752" class="Symbol">→</a> <a id="2754" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2761" class="Symbol">(</a><a id="2762" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="2769" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="2771" href="Veblen.Function.html#2750" class="Bound">α</a><a id="2772" class="Symbol">)</a>
  <a id="2776" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="2790" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="2798" class="Symbol">=</a> <a id="2800" href="Veblen.Function.html#2606" class="Bound">nml</a>
  <a id="2806" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="2820" class="Symbol">(</a><a id="2821" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2825" href="Veblen.Function.html#2825" class="Bound">α</a><a id="2826" class="Symbol">)</a> <a id="2828" class="Symbol">=</a> <a id="2830" href="Veblen.Fixpoint.html#7142" class="Function">′-normal</a> <a id="2839" class="Symbol">(</a><a id="2840" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="2854" href="Veblen.Function.html#2825" class="Bound">α</a><a id="2855" class="Symbol">)</a>
  <a id="2859" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="2873" class="Symbol">(</a><a id="2874" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2878" href="Veblen.Function.html#2878" class="Bound">f</a><a id="2879" class="Symbol">)</a> <a id="2881" class="Symbol">=</a> <a id="2883" href="Veblen.Fixpoint.html#1871" class="Function">⁺-normal</a> <a id="2892" class="Symbol">(</a><a id="2893" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="2895" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="2898" href="Veblen.Function.html#2878" class="Bound">f</a><a id="2899" class="Symbol">)</a> <a id="2901" href="Veblen.Function.html#2921" class="Function">mono</a> <a id="2906" href="Veblen.Function.html#3093" class="Function">incr</a> <a id="2911" class="Keyword">where</a>
    <a id="2921" href="Veblen.Function.html#2921" class="Function">mono</a> <a id="2926" class="Symbol">:</a> <a id="2928" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2940" class="Symbol">(</a><a id="2941" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="2943" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="2946" href="Veblen.Function.html#2878" class="Bound">f</a><a id="2947" class="Symbol">)</a>
    <a id="2953" href="Veblen.Function.html#2921" class="Function">mono</a> <a id="2958" class="Symbol">{</a><a id="2959" href="Veblen.Function.html#2959" class="Bound">α</a><a id="2960" class="Symbol">}</a> <a id="2962" class="Symbol">{</a><a id="2963" href="Veblen.Function.html#2963" class="Bound">β</a><a id="2964" class="Symbol">}</a> <a id="2966" href="Veblen.Function.html#2966" class="Bound">≤</a> <a id="2968" class="Symbol">=</a> <a id="2970" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="2974" class="Symbol">(λ</a> <a id="2977" href="Veblen.Function.html#2977" class="Bound">n</a> <a id="2979" class="Symbol">→</a> <a id="2981" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="2993" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="3000" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3002" class="Symbol">(</a><a id="3003" href="Veblen.Function.html#2878" class="Bound">f</a> <a id="3005" href="Veblen.Function.html#2977" class="Bound">n</a><a id="3006" class="Symbol">)</a> <a id="3008" class="Symbol">(</a><a id="3009" href="Veblen.Function.html#2959" class="Bound">α</a><a id="3010" class="Symbol">)</a>        <a id="3019" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3022" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="3028" class="Symbol">(</a><a id="3029" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="3043" class="Symbol">(</a><a id="3044" href="Veblen.Function.html#2878" class="Bound">f</a> <a id="3046" href="Veblen.Function.html#2977" class="Bound">n</a><a id="3047" class="Symbol">))</a> <a id="3050" href="Veblen.Function.html#2966" class="Bound">≤</a> <a id="3052" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3060" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="3067" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3069" class="Symbol">(</a><a id="3070" href="Veblen.Function.html#2878" class="Bound">f</a> <a id="3072" href="Veblen.Function.html#2977" class="Bound">n</a><a id="3073" class="Symbol">)</a> <a id="3075" class="Symbol">(</a><a id="3076" href="Veblen.Function.html#2963" class="Bound">β</a><a id="3077" class="Symbol">)</a>        <a id="3086" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="3087" class="Symbol">)</a>
    <a id="3093" href="Veblen.Function.html#3093" class="Function">incr</a> <a id="3098" class="Symbol">:</a> <a id="3100" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="3113" class="Symbol">(</a><a id="3114" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3116" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="3119" href="Veblen.Function.html#2878" class="Bound">f</a><a id="3120" class="Symbol">)</a>
    <a id="3126" href="Veblen.Function.html#3093" class="Function">incr</a> <a id="3131" href="Veblen.Function.html#3131" class="Bound">α</a> <a id="3133" class="Symbol">=</a>                    <a id="3154" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="3166" href="Veblen.Function.html#3131" class="Bound">α</a>                         <a id="3192" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3195" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="3209" class="Symbol">(</a><a id="3210" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="3224" class="Symbol">(</a><a id="3225" href="Veblen.Function.html#2878" class="Bound">f</a> <a id="3227" class="Number">0</a><a id="3228" class="Symbol">))</a> <a id="3231" href="Veblen.Function.html#3131" class="Bound">α</a> <a id="3233" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3241" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="3248" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3250" class="Symbol">(</a><a id="3251" href="Veblen.Function.html#2878" class="Bound">f</a> <a id="3253" class="Number">0</a><a id="3254" class="Symbol">)</a> <a id="3256" href="Veblen.Function.html#3131" class="Bound">α</a>          <a id="3267" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3270" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="3274" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3282" class="Symbol">(</a><a id="3283" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3285" href="Veblen.Function.html#1458" class="Function Operator">∘ₗ</a> <a id="3288" href="Veblen.Function.html#2878" class="Bound">f</a><a id="3289" class="Symbol">)</a> <a id="3291" href="Veblen.Function.html#3131" class="Bound">α</a>                <a id="3308" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>由此可知每个 <code>veblen F (suc α) γ</code> 也是 <code>veblen F α</code> 的不动点.</p>
<pre class="Agda">  <a id="Properties.veblen-fp-suc"></a><a id="3376" href="Veblen.Function.html#3376" class="Function">veblen-fp-suc</a> <a id="3390" class="Symbol">:</a> <a id="3392" class="Symbol">∀</a> <a id="3394" href="Veblen.Function.html#3394" class="Bound">α</a> <a id="3396" href="Veblen.Function.html#3396" class="Bound">γ</a> <a id="3398" class="Symbol">→</a> <a id="3400" class="Symbol">(</a><a id="3401" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="3408" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3410" class="Symbol">(</a><a id="3411" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3415" href="Veblen.Function.html#3394" class="Bound">α</a><a id="3416" class="Symbol">)</a> <a id="3418" href="Veblen.Function.html#3396" class="Bound">γ</a><a id="3419" class="Symbol">)</a> <a id="3421" href="Veblen.Fixpoint.html#1203" class="Function Operator">isFixpointOf</a> <a id="3434" class="Symbol">(</a><a id="3435" href="Veblen.Function.html#1417" class="Function">veblen</a> <a id="3442" href="Veblen.Function.html#2603" class="Bound">F</a> <a id="3444" href="Veblen.Function.html#3394" class="Bound">α</a><a id="3445" class="Symbol">)</a>
  <a id="3449" href="Veblen.Function.html#3376" class="Function">veblen-fp-suc</a> <a id="3463" href="Veblen.Function.html#3463" class="Bound">α</a> <a id="3465" href="Veblen.Function.html#3465" class="Bound">γ</a> <a id="3467" class="Symbol">=</a> <a id="3469" href="Veblen.Fixpoint.html#6809" class="Function">′-fp</a> <a id="3474" class="Symbol">(</a><a id="3475" href="Veblen.Function.html#2732" class="Function">veblen-normal</a> <a id="3489" href="Veblen.Function.html#3463" class="Bound">α</a><a id="3490" class="Symbol">)</a> <a id="3492" href="Veblen.Function.html#3465" class="Bound">γ</a>
</pre>
<p>我们想把上面的事实推广到任意满足 <code>α &lt; β</code> 的两个序数. 这需要一系列引理. 首先最基本的是 <code>veblen F</code> 对第一个参数的合同性, 而这又直接依赖于单调性.</p>
<pre class="Agda">
</pre>
<p>最后, 我们将 <code>veblen</code> 的性质实例化到 <code>φ</code>.</p>
<pre class="Agda"><a id="3639" class="Keyword">open</a> <a id="3644" href="Veblen.Function.html#2592" class="Module">Properties</a> <a id="3655" class="Symbol">(</a><a id="3656" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="3658" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a><a id="3660" class="Symbol">)</a> <a id="3662" href="Veblen.Epsilon.html#1257" class="Function">ω^-normal</a>
</pre>
<p>每个 <code>φ α</code> 都是序数嵌入.</p>
<pre class="Agda"><a id="φ-normal"></a><a id="3703" href="Veblen.Function.html#3703" class="Function">φ-normal</a> <a id="3712" class="Symbol">:</a> <a id="3714" class="Symbol">∀</a> <a id="3716" href="Veblen.Function.html#3716" class="Bound">α</a> <a id="3718" class="Symbol">→</a> <a id="3720" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="3727" class="Symbol">(</a><a id="3728" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="3730" href="Veblen.Function.html#3716" class="Bound">α</a><a id="3731" class="Symbol">)</a>
<a id="3733" href="Veblen.Function.html#3703" class="Function">φ-normal</a> <a id="3742" class="Symbol">=</a> <a id="3744" href="Veblen.Function.html#2732" class="Function">veblen-normal</a>
</pre>
<p><span class="math display">φ_α(φ_{α+1}(β))=φ_{α+1}(β)</span></p>
<pre class="Agda"><a id="φ-fp-suc"></a><a id="3803" href="Veblen.Function.html#3803" class="Function">φ-fp-suc</a> <a id="3812" class="Symbol">:</a> <a id="3814" class="Symbol">∀</a> <a id="3816" href="Veblen.Function.html#3816" class="Bound">α</a> <a id="3818" href="Veblen.Function.html#3818" class="Bound">β</a> <a id="3820" class="Symbol">→</a> <a id="3822" class="Symbol">(</a><a id="3823" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="3825" class="Symbol">(</a><a id="3826" class="InductiveConstructor">suc</a> <a id="3830" href="Veblen.Function.html#3816" class="Bound">α</a><a id="3831" class="Symbol">)</a> <a id="3833" href="Veblen.Function.html#3818" class="Bound">β</a><a id="3834" class="Symbol">)</a> <a id="3836" href="Veblen.Fixpoint.html#1203" class="Function Operator">isFixpointOf</a> <a id="3849" class="Symbol">(</a><a id="3850" href="Veblen.Function.html#1634" class="Function">φ</a> <a id="3852" href="Veblen.Function.html#3816" class="Bound">α</a><a id="3853" class="Symbol">)</a>
<a id="3855" href="Veblen.Function.html#3803" class="Function">φ-fp-suc</a> <a id="3864" class="Symbol">=</a> <a id="3866" href="Veblen.Function.html#3376" class="Function">veblen-fp-suc</a>
</pre>
<p><code>φ</code> 对第一个参数的单调性.</p>
<pre class="Agda"><a id="3910" class="Comment">--φ-monoˡ-≤ : ∀ γ → ≤-monotonic (λ α → φ α γ)</a>
<a id="3956" class="Comment">--φ-monoˡ-≤ = veblen-monoˡ-≤</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
