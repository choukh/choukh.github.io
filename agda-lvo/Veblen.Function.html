<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(9) 二元Veblen函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Agda大序数(9) 二元Veblen函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数9-二元veblen函数" id="toc-agda大序数9-二元veblen函数">Agda大序数(9) 二元Veblen函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#定义" id="toc-定义">定义</a></li>
  <li><a href="#性质" id="toc-性质">性质</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数9-二元veblen函数">Agda大序数(9) 二元Veblen函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
总目录: <a href="https://choukh.github.io/agda-lvo/Everything.html">Everything.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/Veblen/Function.lagda.md">Veblen/Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/Veblen.Function.html">Veblen.Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<p><strong>(本章施工中)</strong></p>
<pre class="Agda"><a id="460" class="Symbol">{-#</a> <a id="464" class="Keyword">OPTIONS</a> <a id="472" class="Pragma">--without-K</a> <a id="484" class="Pragma">--safe</a> <a id="491" class="Pragma">--experimental-lossy-unification</a> <a id="524" class="Symbol">#-}</a>

<a id="529" class="Keyword">module</a> <a id="536" href="Veblen.Function.html" class="Module">Veblen.Function</a> <a id="552" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<pre class="Agda"><a id="578" class="Keyword">open</a> <a id="583" class="Keyword">import</a> <a id="590" href="Ordinal.html" class="Module">Ordinal</a>
<a id="598" class="Keyword">open</a> <a id="603" href="Ordinal.html#14675" class="Module">Ordinal.≤-Reasoning</a>
<a id="623" class="Keyword">open</a> <a id="628" class="Keyword">import</a> <a id="635" href="Ordinal.WellFormed.html" class="Module">Ordinal.WellFormed</a> <a id="654" class="Keyword">using</a> <a id="660" class="Symbol">(</a><a id="661" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a><a id="671" class="Symbol">;</a> <a id="673" href="Ordinal.WellFormed.html#1802" class="Function">ω</a><a id="674" class="Symbol">;</a> <a id="676" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜_⌝</a><a id="679" class="Symbol">;</a> <a id="681" href="Ordinal.WellFormed.html#6898" class="Function">≤z⇒≡z</a><a id="686" class="Symbol">;</a> <a id="688" href="Ordinal.WellFormed.html#6031" class="Function">l≤s⇒l≤</a><a id="694" class="Symbol">;</a> <a id="696" href="Ordinal.WellFormed.html#5457" class="Function">∃[m]fn&lt;gm</a><a id="705" class="Symbol">)</a>
<a id="707" class="Keyword">open</a> <a id="712" class="Keyword">import</a> <a id="719" href="Ordinal.Function.html" class="Module">Ordinal.Function</a>
<a id="736" class="Keyword">open</a> <a id="741" class="Keyword">import</a> <a id="748" href="Ordinal.Recursion.html" class="Module">Ordinal.Recursion</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Ordinal.Arithmetic.html" class="Module">Ordinal.Arithmetic</a> <a id="797" class="Keyword">using</a> <a id="803" class="Symbol">(</a><a id="804" href="Ordinal.Arithmetic.html#2236" class="Function Operator">_^_</a><a id="807" class="Symbol">)</a>
<a id="809" class="Keyword">open</a> <a id="814" class="Keyword">import</a> <a id="821" href="Veblen.Fixpoint.html" class="Module">Veblen.Fixpoint</a>
<a id="837" class="Keyword">open</a> <a id="842" class="Keyword">import</a> <a id="849" href="Veblen.Epsilon.html" class="Module">Veblen.Epsilon</a> <a id="864" class="Keyword">using</a> <a id="870" class="Symbol">(</a><a id="871" href="Veblen.Epsilon.html#1257" class="Function">ω^-normal</a><a id="880" class="Symbol">;</a> <a id="882" href="Veblen.Epsilon.html#2091" class="Function">ε</a><a id="883" class="Symbol">;</a> <a id="885" href="Veblen.Epsilon.html#3097" class="Function">ζ</a><a id="886" class="Symbol">;</a> <a id="888" href="Veblen.Epsilon.html#3894" class="Function">η</a><a id="889" class="Symbol">)</a>

<a id="892" class="Keyword">open</a> <a id="897" class="Keyword">import</a> <a id="904" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="913" class="Symbol">as</a> <a id="916" class="Module">ℕ</a> <a id="918" class="Keyword">using</a> <a id="924" class="Symbol">(</a><a id="925" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="926" class="Symbol">;</a> <a id="928" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="932" class="Symbol">;</a> <a id="934" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="937" class="Symbol">)</a>
<a id="939" class="Keyword">open</a> <a id="944" class="Keyword">import</a> <a id="951" href="Function.html" class="Module">Function</a> <a id="960" class="Keyword">using</a> <a id="966" class="Symbol">(</a><a id="967" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="970" class="Symbol">)</a>
<a id="972" class="Keyword">open</a> <a id="977" class="Keyword">import</a> <a id="984" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="993" class="Keyword">using</a> <a id="999" class="Symbol">(</a><a id="1000" href="Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="1003" class="Symbol">;</a> <a id="1005" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="1009" class="Symbol">;</a> <a id="1011" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="1015" class="Symbol">)</a>
<a id="1017" class="Keyword">open</a> <a id="1022" class="Keyword">import</a> <a id="1029" href="Data.Product.html" class="Module">Data.Product</a> <a id="1042" class="Keyword">using</a> <a id="1048" class="Symbol">(</a><a id="1049" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="1050" class="Symbol">;</a> <a id="1052" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="1055" class="Symbol">;</a> <a id="1057" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="1060" class="Symbol">;</a> <a id="1062" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1067" class="Symbol">;</a> <a id="1069" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1074" class="Symbol">)</a>
<a id="1076" class="Keyword">open</a> <a id="1081" class="Keyword">import</a> <a id="1088" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1126" class="Symbol">as</a> <a id="1129" class="Module">Eq</a> <a id="1132" class="Keyword">using</a> <a id="1138" class="Symbol">(</a><a id="1139" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1142" class="Symbol">;</a> <a id="1144" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1148" class="Symbol">)</a>
</pre>
<h2 id="定义">定义</h2>
<p>上一章讲到, 将 <code>ω ^_</code>, <code>ε</code>, <code>ζ</code>, <code>η</code> 分别看作第0, 1, 2, 3层级, 可以推广到任意序数层级, 从而得到二元 Veblen 函数.</p>
<p>形式上, 我们需要辅助函数 <code>veblen</code>, 它是一个高阶函数, 接受一个序数函数 <code>F</code> 作为初始值, 并接受一个序数 <code>α</code> 作为 <code>_′</code> 的迭代次数, 返回迭代后的序数函数. 于是 <code>φ</code> 就定义为以 <code>ω ^_</code> 为初始值的 <code>_′</code> 迭代.</p>
<p><strong>注意</strong> 极限情况下的形式较为复杂. naive地看似乎 <code>F ∘ₗ f</code> 就够了, 但为了更好的性质以及更高的增长率要再套一层 <code>_⁺</code>.</p>
<pre class="Agda"><a id="veblen"></a><a id="1455" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1462" class="Symbol">:</a> <a id="1464" class="Symbol">(</a><a id="1465" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1469" class="Symbol">→</a> <a id="1471" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1474" class="Symbol">)</a> <a id="1476" class="Symbol">→</a> <a id="1478" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1482" class="Symbol">→</a> <a id="1484" class="Symbol">(</a><a id="1485" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1489" class="Symbol">→</a> <a id="1491" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1494" class="Symbol">)</a>
<a id="_∘ₗ_"></a><a id="1496" href="Veblen.Function.html#1496" class="Function Operator">_∘ₗ_</a> <a id="1501" class="Symbol">:</a> <a id="1503" class="Symbol">(</a><a id="1504" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1508" class="Symbol">→</a> <a id="1510" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1513" class="Symbol">)</a> <a id="1515" class="Symbol">→</a> <a id="1517" class="Symbol">(</a><a id="1518" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1520" class="Symbol">→</a> <a id="1522" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1525" class="Symbol">)</a> <a id="1527" class="Symbol">→</a> <a id="1529" class="Symbol">(</a><a id="1530" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1534" class="Symbol">→</a> <a id="1536" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1539" class="Symbol">)</a>

<a id="1542" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1549" href="Veblen.Function.html#1549" class="Bound">F</a> <a id="1551" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="1559" class="Symbol">=</a> <a id="1561" href="Veblen.Function.html#1549" class="Bound">F</a>
<a id="1563" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1570" href="Veblen.Function.html#1570" class="Bound">F</a> <a id="1572" class="Symbol">(</a><a id="1573" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="1577" href="Veblen.Function.html#1577" class="Bound">α</a><a id="1578" class="Symbol">)</a> <a id="1580" class="Symbol">=</a> <a id="1582" class="Symbol">(</a><a id="1583" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1590" href="Veblen.Function.html#1570" class="Bound">F</a> <a id="1592" href="Veblen.Function.html#1577" class="Bound">α</a><a id="1593" class="Symbol">)</a> <a id="1595" href="Veblen.Fixpoint.html#2305" class="Function Operator">′</a>
<a id="1597" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1604" href="Veblen.Function.html#1604" class="Bound">F</a> <a id="1606" class="Symbol">(</a><a id="1607" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="1611" href="Veblen.Function.html#1611" class="Bound">f</a><a id="1612" class="Symbol">)</a> <a id="1614" class="Symbol">=</a> <a id="1616" class="Symbol">(</a><a id="1617" href="Veblen.Function.html#1604" class="Bound">F</a> <a id="1619" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="1622" href="Veblen.Function.html#1611" class="Bound">f</a><a id="1623" class="Symbol">)</a> <a id="1625" href="Veblen.Fixpoint.html#1746" class="Function Operator">⁺</a>
<a id="1627" href="Veblen.Function.html#1627" class="Bound">F</a> <a id="1629" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="1632" href="Veblen.Function.html#1632" class="Bound">f</a> <a id="1634" class="Symbol">=</a> <a id="1636" class="Symbol">λ</a> <a id="1638" href="Veblen.Function.html#1638" class="Bound">α</a> <a id="1640" class="Symbol">→</a> <a id="1642" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="1646" class="Symbol">(λ</a> <a id="1649" href="Veblen.Function.html#1649" class="Bound">n</a> <a id="1651" class="Symbol">→</a> <a id="1653" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1660" href="Veblen.Function.html#1627" class="Bound">F</a> <a id="1662" class="Symbol">(</a><a id="1663" href="Veblen.Function.html#1632" class="Bound">f</a> <a id="1665" href="Veblen.Function.html#1649" class="Bound">n</a><a id="1666" class="Symbol">)</a> <a id="1668" href="Veblen.Function.html#1638" class="Bound">α</a><a id="1669" class="Symbol">)</a>

<a id="φ"></a><a id="1672" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1674" class="Symbol">:</a> <a id="1676" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1680" class="Symbol">→</a> <a id="1682" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1686" class="Symbol">→</a> <a id="1688" href="Ordinal.html#3062" class="Datatype">Ord</a>
<a id="1692" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1694" class="Symbol">=</a> <a id="1696" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="1703" class="Symbol">(</a><a id="1704" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="1706" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a><a id="1708" class="Symbol">)</a>
</pre>
<p>由定义有</p>
<p><span class="math display">φ_{0}(α) = ω^α</span></p>
<pre class="Agda"><a id="1749" href="Veblen.Function.html#1749" class="Function">_</a> <a id="1751" class="Symbol">:</a> <a id="1753" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1755" class="InductiveConstructor">zero</a> <a id="1760" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1762" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="1764" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a>
<a id="1767" class="Symbol">_</a> <a id="1769" class="Symbol">=</a> <a id="1771" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math display">φ_{1}(α) = ε_α</span></p>
<pre class="Agda"><a id="1809" href="Veblen.Function.html#1809" class="Function">_</a> <a id="1811" class="Symbol">:</a> <a id="1813" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1815" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1817" class="Number">1</a> <a id="1819" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1821" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1823" href="Veblen.Epsilon.html#2091" class="Function">ε</a>
<a id="1825" class="Symbol">_</a> <a id="1827" class="Symbol">=</a> <a id="1829" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math display">φ_{2}(α) = ζ_α</span></p>
<pre class="Agda"><a id="1867" href="Veblen.Function.html#1867" class="Function">_</a> <a id="1869" class="Symbol">:</a> <a id="1871" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1873" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1875" class="Number">2</a> <a id="1877" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1879" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1881" href="Veblen.Epsilon.html#3097" class="Function">ζ</a>
<a id="1883" class="Symbol">_</a> <a id="1885" class="Symbol">=</a> <a id="1887" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math display">φ_{3}(α) = η_α</span></p>
<pre class="Agda"><a id="1925" href="Veblen.Function.html#1925" class="Function">_</a> <a id="1927" class="Symbol">:</a> <a id="1929" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="1931" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌜</a> <a id="1933" class="Number">3</a> <a id="1935" href="Ordinal.WellFormed.html#1712" class="Function Operator">⌝</a> <a id="1937" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1939" href="Veblen.Epsilon.html#3894" class="Function">η</a>
<a id="1941" class="Symbol">_</a> <a id="1943" class="Symbol">=</a> <a id="1945" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p><span class="math display">φ_{α+1}(β) = {φ_{α}}&#39;(β)</span></p>
<pre class="Agda"><a id="1993" href="Veblen.Function.html#1993" class="Function">_</a> <a id="1995" class="Symbol">:</a> <a id="1997" class="Symbol">∀</a> <a id="1999" href="Veblen.Function.html#1999" class="Bound">α</a> <a id="2001" class="Symbol">→</a> <a id="2003" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2005" class="Symbol">(</a><a id="2006" class="InductiveConstructor">suc</a> <a id="2010" href="Veblen.Function.html#1999" class="Bound">α</a><a id="2011" class="Symbol">)</a> <a id="2013" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2015" class="Symbol">(</a><a id="2016" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2018" href="Veblen.Function.html#1999" class="Bound">α</a><a id="2019" class="Symbol">)</a> <a id="2021" href="Veblen.Fixpoint.html#2305" class="Function Operator">′</a>
<a id="2023" class="Symbol">_</a> <a id="2025" class="Symbol">=</a> <a id="2027" class="Symbol">λ</a> <a id="2029" href="Veblen.Function.html#2029" class="Bound">_</a> <a id="2031" class="Symbol">→</a> <a id="2033" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>第一个参数是极限时又按第二个参数分三种情况:</p>
<p><span class="math display">φ_{\lim f}(0) = \sup\{φ_{f(0)}(0), φ_{f(1)}(0), φ_{f(2)}(0), ...\}</span></p>
<p>或者按基本序列记作</p>
<p><span class="math display">φ_{γ}(0)[n] = φ_{γ[n]}(0)</span></p>
<p>我们今后都采用这种非形式记法.</p>
<pre class="Agda"><a id="2206" href="Veblen.Function.html#2206" class="Function">_</a> <a id="2208" class="Symbol">:</a> <a id="2210" class="Symbol">∀</a> <a id="2212" href="Veblen.Function.html#2212" class="Bound">f</a> <a id="2214" class="Symbol">→</a> <a id="2216" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2218" class="Symbol">(</a><a id="2219" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2223" href="Veblen.Function.html#2212" class="Bound">f</a><a id="2224" class="Symbol">)</a> <a id="2226" class="InductiveConstructor">zero</a> <a id="2231" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2233" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2237" class="Symbol">(λ</a> <a id="2240" href="Veblen.Function.html#2240" class="Bound">n</a> <a id="2242" class="Symbol">→</a> <a id="2244" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2246" class="Symbol">(</a><a id="2247" href="Veblen.Function.html#2212" class="Bound">f</a> <a id="2249" href="Veblen.Function.html#2240" class="Bound">n</a><a id="2250" class="Symbol">)</a> <a id="2252" class="InductiveConstructor">zero</a><a id="2256" class="Symbol">)</a>
<a id="2258" class="Symbol">_</a> <a id="2260" class="Symbol">=</a> <a id="2262" class="Symbol">λ</a> <a id="2264" href="Veblen.Function.html#2264" class="Bound">_</a> <a id="2266" class="Symbol">→</a> <a id="2268" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>后继的情况有</p>
<p><span class="math display">φ_{γ}(α+1)[n] = φ_{γ[n]}(φ_{γ}(α)+1)</span></p>
<pre class="Agda"><a id="2336" href="Veblen.Function.html#2336" class="Function">_</a> <a id="2338" class="Symbol">:</a> <a id="2340" class="Symbol">∀</a> <a id="2342" href="Veblen.Function.html#2342" class="Bound">f</a> <a id="2344" href="Veblen.Function.html#2344" class="Bound">α</a> <a id="2346" class="Symbol">→</a> <a id="2348" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2350" class="Symbol">(</a><a id="2351" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2355" href="Veblen.Function.html#2342" class="Bound">f</a><a id="2356" class="Symbol">)</a> <a id="2358" class="Symbol">(</a><a id="2359" class="InductiveConstructor">suc</a> <a id="2363" href="Veblen.Function.html#2344" class="Bound">α</a><a id="2364" class="Symbol">)</a> <a id="2366" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2368" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2372" class="Symbol">(λ</a> <a id="2375" href="Veblen.Function.html#2375" class="Bound">n</a> <a id="2377" class="Symbol">→</a> <a id="2379" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2381" class="Symbol">(</a><a id="2382" href="Veblen.Function.html#2342" class="Bound">f</a> <a id="2384" href="Veblen.Function.html#2375" class="Bound">n</a><a id="2385" class="Symbol">)</a> <a id="2387" class="Symbol">(</a><a id="2388" class="InductiveConstructor">suc</a> <a id="2392" class="Symbol">(</a><a id="2393" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2395" class="Symbol">(</a><a id="2396" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2400" href="Veblen.Function.html#2342" class="Bound">f</a><a id="2401" class="Symbol">)</a> <a id="2403" href="Veblen.Function.html#2344" class="Bound">α</a><a id="2404" class="Symbol">)))</a>
<a id="2408" class="Symbol">_</a> <a id="2410" class="Symbol">=</a> <a id="2412" class="Symbol">λ</a> <a id="2414" href="Veblen.Function.html#2414" class="Bound">_</a> <a id="2416" href="Veblen.Function.html#2416" class="Bound">_</a> <a id="2418" class="Symbol">→</a> <a id="2420" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>两个参数都是极限的情况:</p>
<p><span class="math display">φ_{α}(γ)[n] = φ_{α}(γ[n])</span></p>
<pre class="Agda"><a id="2483" href="Veblen.Function.html#2483" class="Function">_</a> <a id="2485" class="Symbol">:</a> <a id="2487" class="Symbol">∀</a> <a id="2489" href="Veblen.Function.html#2489" class="Bound">f</a> <a id="2491" href="Veblen.Function.html#2491" class="Bound">g</a> <a id="2493" class="Symbol">→</a> <a id="2495" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2497" class="Symbol">(</a><a id="2498" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2502" href="Veblen.Function.html#2489" class="Bound">f</a><a id="2503" class="Symbol">)</a> <a id="2505" class="Symbol">(</a><a id="2506" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2510" href="Veblen.Function.html#2491" class="Bound">g</a><a id="2511" class="Symbol">)</a> <a id="2513" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2515" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2519" class="Symbol">(λ</a> <a id="2522" href="Veblen.Function.html#2522" class="Bound">n</a> <a id="2524" class="Symbol">→</a> <a id="2526" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="2528" class="Symbol">(</a><a id="2529" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2533" href="Veblen.Function.html#2489" class="Bound">f</a><a id="2534" class="Symbol">)</a> <a id="2536" class="Symbol">(</a><a id="2537" href="Veblen.Function.html#2491" class="Bound">g</a> <a id="2539" href="Veblen.Function.html#2522" class="Bound">n</a><a id="2540" class="Symbol">))</a>
<a id="2543" class="Symbol">_</a> <a id="2545" class="Symbol">=</a> <a id="2547" class="Symbol">λ</a> <a id="2549" href="Veblen.Function.html#2549" class="Bound">_</a> <a id="2551" href="Veblen.Function.html#2551" class="Bound">_</a> <a id="2553" class="Symbol">→</a> <a id="2555" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<h2 id="性质">性质</h2>
<p>给定一个序数嵌入 <code>F</code>.</p>
<pre class="Agda"><a id="2595" class="Keyword">module</a> <a id="Properties"></a><a id="2602" href="Veblen.Function.html#2602" class="Module">Properties</a> <a id="2613" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="2615" class="Symbol">(</a><a id="2616" href="Veblen.Function.html#2616" class="Bound">nml</a><a id="2619" class="Symbol">@(</a><a id="2621" href="Veblen.Function.html#2621" class="Bound">≤-mono</a> <a id="2628" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2630" href="Veblen.Function.html#2630" class="Bound">&lt;-mono</a> <a id="2637" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2639" href="Veblen.Function.html#2639" class="Bound">lim-ct</a><a id="2645" class="Symbol">)</a> <a id="2647" class="Symbol">:</a> <a id="2649" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2656" href="Veblen.Function.html#2613" class="Bound">F</a><a id="2657" class="Symbol">)</a> <a id="2659" class="Keyword">where</a>
</pre>
<p><strong>引理</strong> 对 <code>veblen</code> 来说, 如果初始函数 <code>F</code> 是序数嵌入, 那么每个迭代 <code>veblen F α</code> 都是序数嵌入.</p>
<pre class="Agda">  <a id="Properties.veblen-normal"></a><a id="2749" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="2763" class="Symbol">:</a> <a id="2765" class="Symbol">∀</a> <a id="2767" href="Veblen.Function.html#2767" class="Bound">α</a> <a id="2769" class="Symbol">→</a> <a id="2771" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2778" class="Symbol">(</a><a id="2779" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="2786" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="2788" href="Veblen.Function.html#2767" class="Bound">α</a><a id="2789" class="Symbol">)</a>
  <a id="2793" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="2807" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="2815" class="Symbol">=</a> <a id="2817" href="Veblen.Function.html#2616" class="Bound">nml</a>
  <a id="2823" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="2837" class="Symbol">(</a><a id="2838" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2842" href="Veblen.Function.html#2842" class="Bound">α</a><a id="2843" class="Symbol">)</a> <a id="2845" class="Symbol">=</a> <a id="2847" href="Veblen.Fixpoint.html#7142" class="Function">′-normal</a> <a id="2856" class="Symbol">(</a><a id="2857" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="2871" href="Veblen.Function.html#2842" class="Bound">α</a><a id="2872" class="Symbol">)</a>
  <a id="2876" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="2890" class="Symbol">(</a><a id="2891" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2895" href="Veblen.Function.html#2895" class="Bound">f</a><a id="2896" class="Symbol">)</a> <a id="2898" class="Symbol">=</a> <a id="2900" href="Veblen.Fixpoint.html#1871" class="Function">⁺-normal</a> <a id="2909" class="Symbol">(</a><a id="2910" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="2912" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="2915" href="Veblen.Function.html#2895" class="Bound">f</a><a id="2916" class="Symbol">)</a> <a id="2918" href="Veblen.Function.html#2938" class="Function">mono</a> <a id="2923" href="Veblen.Function.html#3108" class="Function">incr</a> <a id="2928" class="Keyword">where</a>
    <a id="2938" href="Veblen.Function.html#2938" class="Function">mono</a> <a id="2943" class="Symbol">:</a> <a id="2945" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2957" class="Symbol">(</a><a id="2958" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="2960" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="2963" href="Veblen.Function.html#2895" class="Bound">f</a><a id="2964" class="Symbol">)</a>
    <a id="2970" href="Veblen.Function.html#2938" class="Function">mono</a> <a id="2975" class="Symbol">{</a><a id="2976" href="Veblen.Function.html#2976" class="Bound">α</a><a id="2977" class="Symbol">}</a> <a id="2979" class="Symbol">{</a><a id="2980" href="Veblen.Function.html#2980" class="Bound">β</a><a id="2981" class="Symbol">}</a> <a id="2983" href="Veblen.Function.html#2983" class="Bound">≤</a> <a id="2985" class="Symbol">=</a> <a id="2987" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="2991" class="Symbol">λ</a> <a id="2993" href="Veblen.Function.html#2993" class="Bound">n</a> <a id="2995" class="Symbol">→</a> <a id="2997" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="3009" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3016" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3018" class="Symbol">(</a><a id="3019" href="Veblen.Function.html#2895" class="Bound">f</a> <a id="3021" href="Veblen.Function.html#2993" class="Bound">n</a><a id="3022" class="Symbol">)</a> <a id="3024" class="Symbol">(</a><a id="3025" href="Veblen.Function.html#2976" class="Bound">α</a><a id="3026" class="Symbol">)</a>        <a id="3035" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3038" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="3044" class="Symbol">(</a><a id="3045" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="3059" class="Symbol">(</a><a id="3060" href="Veblen.Function.html#2895" class="Bound">f</a> <a id="3062" href="Veblen.Function.html#2993" class="Bound">n</a><a id="3063" class="Symbol">))</a> <a id="3066" href="Veblen.Function.html#2983" class="Bound">≤</a> <a id="3068" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3076" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3083" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3085" class="Symbol">(</a><a id="3086" href="Veblen.Function.html#2895" class="Bound">f</a> <a id="3088" href="Veblen.Function.html#2993" class="Bound">n</a><a id="3089" class="Symbol">)</a> <a id="3091" class="Symbol">(</a><a id="3092" href="Veblen.Function.html#2980" class="Bound">β</a><a id="3093" class="Symbol">)</a>        <a id="3102" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
    <a id="3108" href="Veblen.Function.html#3108" class="Function">incr</a> <a id="3113" class="Symbol">:</a> <a id="3115" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="3128" class="Symbol">(</a><a id="3129" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3131" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="3134" href="Veblen.Function.html#2895" class="Bound">f</a><a id="3135" class="Symbol">)</a>
    <a id="3141" href="Veblen.Function.html#3108" class="Function">incr</a> <a id="3146" href="Veblen.Function.html#3146" class="Bound">α</a> <a id="3148" class="Symbol">=</a>                    <a id="3169" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="3181" href="Veblen.Function.html#3146" class="Bound">α</a>                         <a id="3207" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3210" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="3224" class="Symbol">(</a><a id="3225" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="3239" class="Symbol">(</a><a id="3240" href="Veblen.Function.html#2895" class="Bound">f</a> <a id="3242" class="Number">0</a><a id="3243" class="Symbol">))</a> <a id="3246" href="Veblen.Function.html#3146" class="Bound">α</a> <a id="3248" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3256" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3263" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3265" class="Symbol">(</a><a id="3266" href="Veblen.Function.html#2895" class="Bound">f</a> <a id="3268" class="Number">0</a><a id="3269" class="Symbol">)</a> <a id="3271" href="Veblen.Function.html#3146" class="Bound">α</a>          <a id="3282" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3285" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="3289" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="3297" class="Symbol">(</a><a id="3298" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3300" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="3303" href="Veblen.Function.html#2895" class="Bound">f</a><a id="3304" class="Symbol">)</a> <a id="3306" href="Veblen.Function.html#3146" class="Bound">α</a>                <a id="3323" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p><strong>引理</strong> 每个 <code>veblen F (suc α) γ</code> 也是 <code>veblen F α</code> 的不动点.</p>
<pre class="Agda">  <a id="Properties.veblen-fp-suc"></a><a id="3394" href="Veblen.Function.html#3394" class="Function">veblen-fp-suc</a> <a id="3408" class="Symbol">:</a> <a id="3410" class="Symbol">∀</a> <a id="3412" href="Veblen.Function.html#3412" class="Bound">α</a> <a id="3414" href="Veblen.Function.html#3414" class="Bound">γ</a> <a id="3416" class="Symbol">→</a> <a id="3418" class="Symbol">(</a><a id="3419" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3426" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3428" class="Symbol">(</a><a id="3429" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3433" href="Veblen.Function.html#3412" class="Bound">α</a><a id="3434" class="Symbol">)</a> <a id="3436" href="Veblen.Function.html#3414" class="Bound">γ</a><a id="3437" class="Symbol">)</a> <a id="3439" href="Veblen.Fixpoint.html#1203" class="Function Operator">isFixpointOf</a> <a id="3452" class="Symbol">(</a><a id="3453" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3460" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3462" href="Veblen.Function.html#3412" class="Bound">α</a><a id="3463" class="Symbol">)</a>
  <a id="3467" href="Veblen.Function.html#3394" class="Function">veblen-fp-suc</a> <a id="3481" href="Veblen.Function.html#3481" class="Bound">α</a> <a id="3483" href="Veblen.Function.html#3483" class="Bound">γ</a> <a id="3485" class="Symbol">=</a> <a id="3487" href="Veblen.Fixpoint.html#6809" class="Function">′-fp</a> <a id="3492" class="Symbol">(</a><a id="3493" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="3507" href="Veblen.Function.html#3481" class="Bound">α</a><a id="3508" class="Symbol">)</a> <a id="3510" href="Veblen.Function.html#3483" class="Bound">γ</a>
</pre>
<p>我们想把上述事实推广到任意满足 <code>α &lt; β</code> 的两个序数. 这需要一系列引理. 其中最基本的是 <code>veblen F</code> 对第一个参数的合同性, 而这又直接依赖于单调性.</p>
<p><strong>引理</strong> <code>veblen F</code> 对第一个参数满足单调性.</p>
<p>该命题较为繁琐. 首先在表述上, 参数要求是良构序数. 证明上, 要同时讨论 <code>_≤_</code> 的两边, 这就分出了九种情况, 然后还衍生出一个互递归命题又分出五种情况.</p>
<pre class="Agda">  <a id="Properties.veblen-monoˡ-≤"></a><a id="3729" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="3744" class="Symbol">:</a> <a id="3746" class="Symbol">∀</a> <a id="3748" class="Symbol">{</a><a id="3749" href="Veblen.Function.html#3749" class="Bound">α</a> <a id="3751" href="Veblen.Function.html#3751" class="Bound">β</a> <a id="3753" href="Veblen.Function.html#3753" class="Bound">γ</a><a id="3754" class="Symbol">}</a> <a id="3756" class="Symbol">→</a> <a id="3758" class="Symbol">⦃</a> <a id="3760" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="3771" href="Veblen.Function.html#3749" class="Bound">α</a> <a id="3773" class="Symbol">⦄</a> <a id="3775" class="Symbol">→</a> <a id="3777" class="Symbol">⦃</a> <a id="3779" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="3790" href="Veblen.Function.html#3751" class="Bound">β</a> <a id="3792" class="Symbol">⦄</a> <a id="3794" class="Symbol">→</a>
    <a id="3800" href="Veblen.Function.html#3749" class="Bound">α</a> <a id="3802" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="3804" href="Veblen.Function.html#3751" class="Bound">β</a> <a id="3806" class="Symbol">→</a> <a id="3808" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3815" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3817" href="Veblen.Function.html#3749" class="Bound">α</a> <a id="3819" href="Veblen.Function.html#3753" class="Bound">γ</a> <a id="3821" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="3823" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3830" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3832" href="Veblen.Function.html#3751" class="Bound">β</a> <a id="3834" href="Veblen.Function.html#3753" class="Bound">γ</a>
  <a id="Properties.veblen-monoˡ-≤l"></a><a id="3838" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="3854" class="Symbol">:</a> <a id="3856" class="Symbol">∀</a> <a id="3858" class="Symbol">{</a><a id="3859" href="Veblen.Function.html#3859" class="Bound">α</a> <a id="3861" href="Veblen.Function.html#3861" class="Bound">f</a> <a id="3863" href="Veblen.Function.html#3863" class="Bound">n</a> <a id="3865" href="Veblen.Function.html#3865" class="Bound">γ</a><a id="3866" class="Symbol">}</a> <a id="3868" class="Symbol">→</a> <a id="3870" class="Symbol">⦃</a> <a id="3872" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="3883" href="Veblen.Function.html#3859" class="Bound">α</a> <a id="3885" class="Symbol">⦄</a> <a id="3887" class="Symbol">→</a> <a id="3889" class="Symbol">⦃</a> <a id="3891" class="Symbol">∀</a> <a id="3893" class="Symbol">{</a><a id="3894" href="Veblen.Function.html#3894" class="Bound">n</a><a id="3895" class="Symbol">}</a> <a id="3897" class="Symbol">→</a> <a id="3899" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="3910" class="Symbol">(</a><a id="3911" href="Veblen.Function.html#3861" class="Bound">f</a> <a id="3913" href="Veblen.Function.html#3894" class="Bound">n</a><a id="3914" class="Symbol">)</a> <a id="3916" class="Symbol">⦄</a> <a id="3918" class="Symbol">→</a>
    <a id="3924" href="Veblen.Function.html#3859" class="Bound">α</a> <a id="3926" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="3928" href="Veblen.Function.html#3861" class="Bound">f</a> <a id="3930" href="Veblen.Function.html#3863" class="Bound">n</a> <a id="3932" class="Symbol">→</a> <a id="3934" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3941" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3943" href="Veblen.Function.html#3859" class="Bound">α</a> <a id="3945" href="Veblen.Function.html#3865" class="Bound">γ</a> <a id="3947" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="3949" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="3956" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="3958" class="Symbol">(</a><a id="3959" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3963" href="Veblen.Function.html#3861" class="Bound">f</a><a id="3964" class="Symbol">)</a> <a id="3966" href="Veblen.Function.html#3865" class="Bound">γ</a>
</pre>
<p><strong>证明</strong> 我们先证衍生出的命题. <code>γ</code> 为零或后继时都要递归调用主命题, 后继的情况还用到了第二个参数的序数嵌入条件.</p>
<pre class="Agda">  <a id="4047" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="4063" class="Symbol">{</a><a id="4064" href="Veblen.Function.html#4064" class="Bound">α</a><a id="4065" class="Symbol">}</a> <a id="4067" class="Symbol">{</a><a id="4068" href="Veblen.Function.html#4068" class="Bound">f</a><a id="4069" class="Symbol">}</a> <a id="4071" class="Symbol">{</a><a id="4072" href="Veblen.Function.html#4072" class="Bound">n</a><a id="4073" class="Symbol">}</a> <a id="4075" class="Symbol">{</a><a id="4076" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="4080" class="Symbol">}</a> <a id="4082" href="Veblen.Function.html#4082" class="Bound">α≤fn</a> <a id="4087" class="Symbol">=</a>   <a id="4091" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="4101" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4108" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4110" href="Veblen.Function.html#4064" class="Bound">α</a> <a id="4112" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>                           <a id="4143" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4146" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="4161" href="Veblen.Function.html#4082" class="Bound">α≤fn</a> <a id="4166" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4172" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4179" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4181" class="Symbol">(</a><a id="4182" href="Veblen.Function.html#4068" class="Bound">f</a> <a id="4184" href="Veblen.Function.html#4072" class="Bound">n</a><a id="4185" class="Symbol">)</a> <a id="4187" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>                       <a id="4214" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4217" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="4221" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4227" class="Symbol">(</a><a id="4228" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4230" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="4233" href="Veblen.Function.html#4068" class="Bound">f</a><a id="4234" class="Symbol">)</a> <a id="4236" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>                             <a id="4269" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>

  <a id="4274" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="4290" class="Symbol">{</a><a id="4291" href="Veblen.Function.html#4291" class="Bound">α</a><a id="4292" class="Symbol">}</a> <a id="4294" class="Symbol">{</a><a id="4295" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4296" class="Symbol">}</a> <a id="4298" class="Symbol">{</a><a id="4299" href="Veblen.Function.html#4299" class="Bound">n</a><a id="4300" class="Symbol">}</a> <a id="4302" class="Symbol">{</a><a id="4303" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="4307" href="Veblen.Function.html#4307" class="Bound">γ</a><a id="4308" class="Symbol">}</a> <a id="4310" href="Veblen.Function.html#4310" class="Bound">α≤fn</a> <a id="4315" class="Symbol">=</a>  <a id="4318" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="4328" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4335" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4337" href="Veblen.Function.html#4291" class="Bound">α</a> <a id="4339" class="Symbol">(</a><a id="4340" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="4344" href="Veblen.Function.html#4307" class="Bound">γ</a><a id="4345" class="Symbol">)</a>                        <a id="4370" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4373" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="4388" href="Veblen.Function.html#4310" class="Bound">α≤fn</a> <a id="4393" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4399" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4406" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4408" class="Symbol">(</a><a id="4409" href="Veblen.Function.html#4295" class="Bound">f</a> <a id="4411" href="Veblen.Function.html#4299" class="Bound">n</a><a id="4412" class="Symbol">)</a> <a id="4414" class="Symbol">(</a><a id="4415" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="4419" href="Veblen.Function.html#4307" class="Bound">γ</a><a id="4420" class="Symbol">)</a>                    <a id="4441" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4444" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="4450" class="Symbol">(</a><a id="4451" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="4465" class="Symbol">(</a><a id="4466" href="Veblen.Function.html#4295" class="Bound">f</a> <a id="4468" href="Veblen.Function.html#4299" class="Bound">n</a><a id="4469" class="Symbol">))</a> <a id="4472" class="Symbol">(</a><a id="4473" href="Ordinal.html#6414" class="Function">s≤s</a> <a id="4477" href="Veblen.Function.html#4597" class="Function">≤</a><a id="4478" class="Symbol">)</a> <a id="4480" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4486" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4493" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4495" class="Symbol">(</a><a id="4496" href="Veblen.Function.html#4295" class="Bound">f</a> <a id="4498" href="Veblen.Function.html#4299" class="Bound">n</a><a id="4499" class="Symbol">)</a> <a id="4501" class="Symbol">(</a><a id="4502" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="4506" class="Symbol">(</a><a id="4507" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4514" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4516" class="Symbol">(</a><a id="4517" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4521" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4522" class="Symbol">)</a> <a id="4524" href="Veblen.Function.html#4307" class="Bound">γ</a><a id="4525" class="Symbol">))</a> <a id="4528" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4531" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="4535" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4541" class="Symbol">(</a><a id="4542" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4544" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="4547" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4548" class="Symbol">)</a> <a id="4550" class="Symbol">(</a><a id="4551" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="4555" class="Symbol">(</a><a id="4556" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4563" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4565" class="Symbol">(</a><a id="4566" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4570" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4571" class="Symbol">)</a> <a id="4573" href="Veblen.Function.html#4307" class="Bound">γ</a><a id="4574" class="Symbol">))</a>       <a id="4583" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a> <a id="4585" class="Keyword">where</a>
      <a id="4597" href="Veblen.Function.html#4597" class="Function">≤</a> <a id="4599" class="Symbol">:</a> <a id="4601" href="Veblen.Function.html#4307" class="Bound">γ</a> <a id="4603" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="4605" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4612" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4614" class="Symbol">(</a><a id="4615" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4619" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4620" class="Symbol">)</a> <a id="4622" href="Veblen.Function.html#4307" class="Bound">γ</a>
      <a id="4630" href="Veblen.Function.html#4597" class="Function">≤</a> <a id="4632" class="Symbol">=</a> <a id="4634" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="4648" class="Symbol">(</a><a id="4649" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="4663" class="Symbol">(</a><a id="4664" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4668" href="Veblen.Function.html#4295" class="Bound">f</a><a id="4669" class="Symbol">))</a> <a id="4672" href="Veblen.Function.html#4307" class="Bound">γ</a>
</pre>
<p><code>γ</code> 为极限时要看 <code>α</code>. <code>α</code> 为零或后继时都要递归调用衍生命题, 为后继时还要递归调用主命题. <code>α</code> 为极限的情况使用 <code>_⁺</code> 的高阶单调性得证.</p>
<pre class="Agda">  <a id="4771" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="4787" class="Symbol">{</a><a id="4788" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="4792" class="Symbol">}</a> <a id="4794" class="Symbol">{</a><a id="4795" href="Veblen.Function.html#4795" class="Bound">f</a><a id="4796" class="Symbol">}</a> <a id="4798" class="Symbol">{</a><a id="4799" href="Veblen.Function.html#4799" class="Bound">n</a><a id="4800" class="Symbol">}</a> <a id="4802" class="Symbol">{</a><a id="4803" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4807" href="Veblen.Function.html#4807" class="Bound">γ</a><a id="4808" class="Symbol">}</a> <a id="4810" href="Veblen.Function.html#4810" class="Bound">z≤fn</a> <a id="4815" class="Symbol">=</a> <a id="4817" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="4827" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4829" class="Symbol">(</a><a id="4830" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4834" href="Veblen.Function.html#4807" class="Bound">γ</a><a id="4835" class="Symbol">)</a>                                 <a id="4869" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4872" href="Veblen.Function.html#2639" class="Bound">lim-ct</a> <a id="4879" href="Veblen.Function.html#4807" class="Bound">γ</a> <a id="4881" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
    <a id="4887" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4891" class="Symbol">(λ</a> <a id="4894" href="Veblen.Function.html#4894" class="Bound">n</a> <a id="4896" class="Symbol">→</a> <a id="4898" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4900" class="Symbol">(</a><a id="4901" href="Veblen.Function.html#4807" class="Bound">γ</a> <a id="4903" href="Veblen.Function.html#4894" class="Bound">n</a><a id="4904" class="Symbol">))</a>                       <a id="4929" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4932" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="4936" class="Symbol">(λ</a> <a id="4939" href="Veblen.Function.html#4939" class="Bound">n</a> <a id="4941" class="Symbol">→</a> <a id="4943" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="4959" class="Symbol">{</a><a id="4960" class="Argument">n</a> <a id="4962" class="Symbol">=</a> <a id="4964" href="Veblen.Function.html#4939" class="Bound">n</a><a id="4965" class="Symbol">}</a> <a id="4967" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a><a id="4969" class="Symbol">)</a> <a id="4971" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="4977" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4981" class="Symbol">(λ</a> <a id="4984" href="Veblen.Function.html#4984" class="Bound">n</a> <a id="4986" class="Symbol">→</a> <a id="4988" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="4995" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="4997" class="Symbol">(</a><a id="4998" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="5002" href="Veblen.Function.html#4795" class="Bound">f</a><a id="5003" class="Symbol">)</a> <a id="5005" class="Symbol">(</a><a id="5006" href="Veblen.Function.html#4807" class="Bound">γ</a> <a id="5008" href="Veblen.Function.html#4984" class="Bound">n</a><a id="5009" class="Symbol">))</a>        <a id="5019" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
  <a id="5023" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="5039" class="Symbol">{</a><a id="5040" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5044" href="Veblen.Function.html#5044" class="Bound">α</a><a id="5045" class="Symbol">}</a> <a id="5047" class="Symbol">{</a><a id="5048" href="Veblen.Function.html#5048" class="Bound">f</a><a id="5049" class="Symbol">}</a> <a id="5051" class="Symbol">{</a><a id="5052" href="Veblen.Function.html#5052" class="Bound">n</a><a id="5053" class="Symbol">}</a> <a id="5055" class="Symbol">{</a><a id="5056" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="5060" href="Veblen.Function.html#5060" class="Bound">γ</a><a id="5061" class="Symbol">}</a> <a id="5063" href="Veblen.Function.html#5063" class="Bound">sα≤fn</a> <a id="5069" class="Symbol">=</a> <a id="5071" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="5075" class="Symbol">λ</a> <a id="5077" href="Veblen.Function.html#5077" class="Bound">m</a> <a id="5079" class="Symbol">→</a> <a id="5081" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="5091" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5098" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5100" class="Symbol">(</a><a id="5101" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5105" href="Veblen.Function.html#5044" class="Bound">α</a><a id="5106" class="Symbol">)</a> <a id="5108" class="Symbol">(</a><a id="5109" href="Veblen.Function.html#5060" class="Bound">γ</a> <a id="5111" href="Veblen.Function.html#5077" class="Bound">m</a><a id="5112" class="Symbol">)</a>                    <a id="5133" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5136" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="5151" href="Veblen.Function.html#5063" class="Bound">sα≤fn</a> <a id="5157" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="5163" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5170" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5172" class="Symbol">(</a><a id="5173" href="Veblen.Function.html#5048" class="Bound">f</a> <a id="5175" href="Veblen.Function.html#5052" class="Bound">n</a><a id="5176" class="Symbol">)</a> <a id="5178" class="Symbol">(</a><a id="5179" href="Veblen.Function.html#5060" class="Bound">γ</a> <a id="5181" href="Veblen.Function.html#5077" class="Bound">m</a><a id="5182" class="Symbol">)</a>                      <a id="5205" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5208" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="5224" href="Ordinal.html#6955" class="Function">≤-refl</a> <a id="5231" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="5237" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5244" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5246" class="Symbol">(</a><a id="5247" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="5251" href="Veblen.Function.html#5048" class="Bound">f</a><a id="5252" class="Symbol">)</a> <a id="5254" class="Symbol">(</a><a id="5255" href="Veblen.Function.html#5060" class="Bound">γ</a> <a id="5257" href="Veblen.Function.html#5077" class="Bound">m</a><a id="5258" class="Symbol">)</a>                    <a id="5279" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
  <a id="5283" href="Veblen.Function.html#3838" class="CatchallClause Function">veblen-monoˡ-≤l</a><a id="5298" class="CatchallClause"> </a><a id="5299" class="CatchallClause Symbol">{</a><a id="5300" href="Ordinal.html#3112" class="CatchallClause InductiveConstructor">lim</a><a id="5303" class="CatchallClause"> </a><a id="5304" href="Veblen.Function.html#5304" class="CatchallClause Bound">α</a><a id="5305" class="CatchallClause Symbol">}</a><a id="5306" class="CatchallClause"> </a><a id="5307" class="CatchallClause Symbol">{</a><a id="5308" href="Veblen.Function.html#5308" class="CatchallClause Bound">β</a><a id="5309" class="CatchallClause Symbol">}</a><a id="5310" class="CatchallClause"> </a><a id="5311" class="CatchallClause Symbol">{</a><a id="5312" href="Veblen.Function.html#5312" class="CatchallClause Bound">n</a><a id="5313" class="CatchallClause Symbol">}</a><a id="5314" class="CatchallClause"> </a><a id="5315" class="CatchallClause Symbol">⦃</a><a id="5316" class="CatchallClause"> </a><a id="5317" href="Veblen.Function.html#5317" class="CatchallClause Bound">wfα</a><a id="5320" class="CatchallClause"> </a><a id="5321" class="CatchallClause Symbol">⦄</a><a id="5322" class="CatchallClause"> </a><a id="5323" class="CatchallClause Symbol">(</a><a id="5324" href="Ordinal.html#4786" class="CatchallClause InductiveConstructor">l≤</a><a id="5326" class="CatchallClause"> </a><a id="5327" href="Veblen.Function.html#5327" class="CatchallClause Bound">α≤βn</a><a id="5331" class="CatchallClause Symbol">)</a> <a id="5333" class="Symbol">=</a> <a id="5335" href="Veblen.Fixpoint.html#8437" class="Function">⁺-monoʰ-≤</a> <a id="5345" href="Veblen.Function.html#5367" class="Function">mono</a> <a id="5350" class="Symbol">(</a><a id="5351" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="5354" href="Veblen.Function.html#5452" class="Function">≤</a><a id="5355" class="Symbol">)</a> <a id="5357" class="Keyword">where</a>
    <a id="5367" href="Veblen.Function.html#5367" class="Function">mono</a> <a id="5372" class="Symbol">:</a> <a id="5374" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="5386" class="Symbol">(</a><a id="5387" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5389" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="5392" href="Veblen.Function.html#5304" class="Bound">α</a><a id="5393" class="Symbol">)</a>
    <a id="5399" href="Veblen.Function.html#5367" class="Function">mono</a> <a id="5404" href="Veblen.Function.html#5404" class="Bound">≤</a> <a id="5406" class="Symbol">=</a> <a id="5408" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="5412" class="Symbol">λ</a> <a id="5414" href="Veblen.Function.html#5414" class="Bound">_</a> <a id="5416" class="Symbol">→</a> <a id="5418" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="5424" class="Symbol">(</a><a id="5425" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="5439" class="Symbol">(</a><a id="5440" href="Veblen.Function.html#5304" class="Bound">α</a> <a id="5442" class="Symbol">_))</a> <a id="5446" href="Veblen.Function.html#5404" class="Bound">≤</a>
    <a id="5452" href="Veblen.Function.html#5452" class="Function">≤</a> <a id="5454" class="Symbol">:</a> <a id="5456" class="Symbol">∀</a> <a id="5458" class="Symbol">{</a><a id="5459" href="Veblen.Function.html#5459" class="Bound">ξ</a><a id="5460" class="Symbol">}</a> <a id="5462" href="Veblen.Function.html#5462" class="Bound">m</a> <a id="5464" class="Symbol">→</a> <a id="5466" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5473" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5475" class="Symbol">(</a><a id="5476" href="Veblen.Function.html#5304" class="Bound">α</a> <a id="5478" href="Veblen.Function.html#5462" class="Bound">m</a><a id="5479" class="Symbol">)</a> <a id="5481" href="Veblen.Function.html#5459" class="Bound">ξ</a> <a id="5483" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="5485" class="Symbol">(</a><a id="5486" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5488" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="5491" href="Veblen.Function.html#5308" class="Bound">β</a><a id="5492" class="Symbol">)</a> <a id="5494" href="Veblen.Function.html#5459" class="Bound">ξ</a>
    <a id="5500" href="Veblen.Function.html#5452" class="Function">≤</a> <a id="5502" class="Symbol">{</a><a id="5503" href="Veblen.Function.html#5503" class="Bound">ξ</a><a id="5504" class="Symbol">}</a> <a id="5506" href="Veblen.Function.html#5506" class="Bound">m</a> <a id="5508" class="Symbol">=</a>                                 <a id="5542" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="5554" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5561" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5563" class="Symbol">(</a><a id="5564" href="Veblen.Function.html#5304" class="Bound">α</a> <a id="5566" href="Veblen.Function.html#5506" class="Bound">m</a><a id="5567" class="Symbol">)</a> <a id="5569" href="Veblen.Function.html#5503" class="Bound">ξ</a>                        <a id="5594" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5597" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="5612" class="Symbol">⦃</a> <a id="5614" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="5620" href="Veblen.Function.html#5317" class="Bound">wfα</a> <a id="5624" class="Symbol">⦄</a> <a id="5626" class="Symbol">(</a><a id="5627" href="Veblen.Function.html#5327" class="Bound">α≤βn</a> <a id="5632" href="Veblen.Function.html#5506" class="Bound">m</a><a id="5633" class="Symbol">)</a> <a id="5635" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="5643" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5650" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5652" class="Symbol">(</a><a id="5653" href="Veblen.Function.html#5308" class="Bound">β</a> <a id="5655" href="Veblen.Function.html#5312" class="Bound">n</a><a id="5656" class="Symbol">)</a> <a id="5658" href="Veblen.Function.html#5503" class="Bound">ξ</a>                        <a id="5683" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5686" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="5690" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="5698" class="Symbol">(</a><a id="5699" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5701" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="5704" href="Veblen.Function.html#5308" class="Bound">β</a><a id="5705" class="Symbol">)</a> <a id="5707" href="Veblen.Function.html#5503" class="Bound">ξ</a>                              <a id="5738" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>接着证明主命题. <code>α</code> 和 <code>β</code> 都为零时显然成立. <code>α</code> 为零 <code>β</code> 为后继时递归调用自身, 并使用 <code>_′</code> 的高阶增长性得证.</p>
<pre class="Agda">  <a id="5827" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="5842" class="Symbol">{</a><a id="5843" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="5847" class="Symbol">}</a> <a id="5849" class="Symbol">{</a><a id="5850" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="5854" class="Symbol">}</a>      <a id="5861" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a> <a id="5864" class="Symbol">=</a>      <a id="5871" href="Ordinal.html#6955" class="Function">≤-refl</a>
  <a id="5880" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="5895" class="Symbol">{</a><a id="5896" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="5900" class="Symbol">}</a> <a id="5902" class="Symbol">{</a><a id="5903" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5907" href="Veblen.Function.html#5907" class="Bound">β</a><a id="5908" class="Symbol">}</a> <a id="5910" class="Symbol">{</a><a id="5911" href="Veblen.Function.html#5911" class="Bound">γ</a><a id="5912" class="Symbol">}</a> <a id="5914" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a> <a id="5917" class="Symbol">=</a>      <a id="5924" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="5934" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="5941" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="5943" href="Ordinal.html#3080" class="InductiveConstructor">zero</a> <a id="5948" href="Veblen.Function.html#5911" class="Bound">γ</a>                           <a id="5976" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5979" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="5994" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a> <a id="5997" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="6003" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6010" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6012" href="Veblen.Function.html#5907" class="Bound">β</a> <a id="6014" href="Veblen.Function.html#5911" class="Bound">γ</a>                              <a id="6045" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="6048" href="Veblen.Fixpoint.html#8185" class="Function">′-incrʰ-≤</a> <a id="6058" class="Symbol">(</a><a id="6059" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="6073" href="Veblen.Function.html#5907" class="Bound">β</a><a id="6074" class="Symbol">)</a> <a id="6076" href="Veblen.Function.html#5911" class="Bound">γ</a> <a id="6078" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="6084" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6091" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6093" class="Symbol">(</a><a id="6094" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6098" href="Veblen.Function.html#5907" class="Bound">β</a><a id="6099" class="Symbol">)</a> <a id="6101" href="Veblen.Function.html#5911" class="Bound">γ</a>                        <a id="6126" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>以下两种情况递归调用衍生命题得证.</p>
<pre class="Agda">  <a id="6162" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="6177" class="Symbol">{</a><a id="6178" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="6182" class="Symbol">}</a> <a id="6184" class="Symbol">{</a><a id="6185" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6189" href="Veblen.Function.html#6189" class="Bound">f</a><a id="6190" class="Symbol">}</a> <a id="6192" class="Symbol">⦃</a> <a id="6194" class="Symbol">_</a> <a id="6196" class="Symbol">⦄</a> <a id="6198" class="Symbol">⦃</a> <a id="6200" href="Veblen.Function.html#6200" class="Bound">wfβ</a> <a id="6204" class="Symbol">⦄</a> <a id="6206" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a>
    <a id="6213" class="Symbol">=</a> <a id="6215" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="6231" class="Symbol">{</a><a id="6232" class="Argument">n</a> <a id="6234" class="Symbol">=</a> <a id="6236" class="Number">0</a><a id="6237" class="Symbol">}</a> <a id="6239" class="Symbol">⦃</a> <a id="6241" class="Symbol">_</a> <a id="6243" class="Symbol">⦄</a> <a id="6245" class="Symbol">⦃</a> <a id="6247" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="6253" href="Veblen.Function.html#6200" class="Bound">wfβ</a> <a id="6257" class="Symbol">⦄</a> <a id="6259" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a>
  <a id="6264" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="6279" class="Symbol">{</a><a id="6280" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6284" href="Veblen.Function.html#6284" class="Bound">α</a><a id="6285" class="Symbol">}</a> <a id="6287" class="Symbol">{</a><a id="6288" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6292" href="Veblen.Function.html#6292" class="Bound">f</a><a id="6293" class="Symbol">}</a> <a id="6295" class="Symbol">⦃</a> <a id="6297" href="Veblen.Function.html#6297" class="Bound">wfα</a> <a id="6301" class="Symbol">⦄</a> <a id="6303" class="Symbol">⦃</a> <a id="6305" href="Veblen.Function.html#6305" class="Bound">wfβ</a> <a id="6309" class="Symbol">⦄</a> <a id="6311" class="Symbol">(</a><a id="6312" href="Ordinal.html#4738" class="InductiveConstructor">s≤</a> <a id="6315" class="Symbol">{</a><a id="6316" class="Argument">d</a> <a id="6318" class="Symbol">=</a> <a id="6320" href="Veblen.Function.html#6320" class="Bound">n</a> <a id="6322" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6324" href="Veblen.Function.html#6324" class="Bound">d</a><a id="6325" class="Symbol">}</a> <a id="6327" href="Veblen.Function.html#6327" class="Bound">α&lt;fn</a><a id="6331" class="Symbol">)</a>
    <a id="6337" class="Symbol">=</a> <a id="6339" href="Veblen.Function.html#3838" class="Function">veblen-monoˡ-≤l</a> <a id="6355" class="Symbol">{</a><a id="6356" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6360" href="Veblen.Function.html#6284" class="Bound">α</a><a id="6361" class="Symbol">}</a> <a id="6363" class="Symbol">⦃</a> <a id="6365" href="Veblen.Function.html#6297" class="Bound">wfα</a> <a id="6369" class="Symbol">⦄</a> <a id="6371" class="Symbol">⦃</a> <a id="6373" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="6379" href="Veblen.Function.html#6305" class="Bound">wfβ</a> <a id="6383" class="Symbol">⦄</a> <a id="6385" class="Symbol">(</a><a id="6386" href="Ordinal.html#12182" class="Function">&lt;⇒s≤</a> <a id="6391" class="Symbol">(</a><a id="6392" href="Veblen.Function.html#6324" class="Bound">d</a> <a id="6394" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6396" href="Veblen.Function.html#6327" class="Bound">α&lt;fn</a><a id="6400" class="Symbol">))</a>
</pre>
<p><code>α</code> 和 <code>β</code> 都为后继时使用 <code>_′</code> 的高阶单调性得证.</p>
<pre class="Agda">  <a id="6452" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="6467" class="Symbol">{</a><a id="6468" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6472" href="Veblen.Function.html#6472" class="Bound">α</a><a id="6473" class="Symbol">}</a> <a id="6475" class="Symbol">{</a><a id="6476" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6480" href="Veblen.Function.html#6480" class="Bound">β</a><a id="6481" class="Symbol">}</a> <a id="6483" class="Symbol">{</a><a id="6484" href="Veblen.Function.html#6484" class="Bound">γ</a><a id="6485" class="Symbol">}</a> <a id="6487" class="Symbol">(</a><a id="6488" href="Ordinal.html#4738" class="InductiveConstructor">s≤</a> <a id="6491" href="Veblen.Function.html#6491" class="Bound">α&lt;s</a><a id="6494" class="Symbol">)</a> <a id="6496" class="Symbol">=</a> <a id="6498" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="6508" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6515" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6517" class="Symbol">(</a><a id="6518" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6522" href="Veblen.Function.html#6472" class="Bound">α</a><a id="6523" class="Symbol">)</a> <a id="6525" href="Veblen.Function.html#6484" class="Bound">γ</a>                        <a id="6550" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="6553" href="Veblen.Fixpoint.html#8947" class="Function">′-monoʰ-≤</a> <a id="6563" class="Symbol">(</a><a id="6564" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="6570" class="Symbol">(</a><a id="6571" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="6585" href="Veblen.Function.html#6472" class="Bound">α</a><a id="6586" class="Symbol">))</a> <a id="6589" href="Veblen.Function.html#6654" class="Function">IH</a> <a id="6592" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="6598" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6605" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6607" class="Symbol">(</a><a id="6608" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="6612" href="Veblen.Function.html#6480" class="Bound">β</a><a id="6613" class="Symbol">)</a> <a id="6615" href="Veblen.Function.html#6484" class="Bound">γ</a>                        <a id="6640" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a> <a id="6642" class="Keyword">where</a>
      <a id="6654" href="Veblen.Function.html#6654" class="Function">IH</a> <a id="6657" class="Symbol">:</a> <a id="6659" class="Symbol">∀</a> <a id="6661" class="Symbol">{</a><a id="6662" href="Veblen.Function.html#6662" class="Bound">γ</a><a id="6663" class="Symbol">}</a> <a id="6665" class="Symbol">→</a> <a id="6667" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6674" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6676" href="Veblen.Function.html#6472" class="Bound">α</a> <a id="6678" href="Veblen.Function.html#6662" class="Bound">γ</a> <a id="6680" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="6682" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="6689" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="6691" href="Veblen.Function.html#6480" class="Bound">β</a> <a id="6693" href="Veblen.Function.html#6662" class="Bound">γ</a>
      <a id="6701" href="Veblen.Function.html#6654" class="Function">IH</a> <a id="6704" class="Symbol">=</a> <a id="6706" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="6721" class="Symbol">(</a><a id="6722" href="Ordinal.html#12448" class="Function">&lt;s⇒≤</a> <a id="6727" class="Symbol">(_</a> <a id="6730" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6732" href="Veblen.Function.html#6491" class="Bound">α&lt;s</a><a id="6735" class="Symbol">))</a>
</pre>
<p>后继小于等于零的情况不存在, 且对良构序数来说极限小于等于零的情况也不存在.</p>
<pre class="Agda">  <a id="6793" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="6808" class="Symbol">{</a><a id="6809" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6813" href="Veblen.Function.html#6813" class="Bound">α</a><a id="6814" class="Symbol">}</a> <a id="6816" class="Symbol">{</a><a id="6817" href="Ordinal.html#3080" class="InductiveConstructor">zero</a><a id="6821" class="Symbol">}</a>      <a id="6828" class="Symbol">⦃</a> <a id="6830" href="Veblen.Function.html#6830" class="Bound">wfα</a> <a id="6834" class="Symbol">⦄</a> <a id="6836" class="Symbol">(</a><a id="6837" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="6840" href="Veblen.Function.html#6840" class="Bound">αn≤β</a><a id="6844" class="Symbol">)</a> <a id="6846" class="Keyword">with</a> <a id="6851" href="Ordinal.WellFormed.html#6898" class="Function">≤z⇒≡z</a> <a id="6857" href="Veblen.Function.html#6830" class="Bound">wfα</a> <a id="6861" class="Symbol">(</a><a id="6862" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="6865" href="Veblen.Function.html#6840" class="Bound">αn≤β</a><a id="6869" class="Symbol">)</a>
  <a id="6873" class="Symbol">...</a> <a id="6877" class="Symbol">|</a> <a id="6879" class="Symbol">()</a>
</pre>
<p><code>α</code> 为极限 <code>β</code> 为后继的情况与 <code>α</code> 为零 <code>β</code> 为后继的情况类似. 递归调用自身, 并使用 <code>_′</code> 的高阶增长性得证. 注意这里使用了良构序数特有的性质 <code>l≤s⇒l≤</code>.</p>
<pre class="Agda">  <a id="6993" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="7008" class="Symbol">{</a><a id="7009" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="7013" href="Veblen.Function.html#7013" class="Bound">α</a><a id="7014" class="Symbol">}</a> <a id="7016" class="Symbol">{</a><a id="7017" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="7021" href="Veblen.Function.html#7021" class="Bound">β</a><a id="7022" class="Symbol">}</a> <a id="7024" class="Symbol">{</a><a id="7025" href="Veblen.Function.html#7025" class="Bound">γ</a><a id="7026" class="Symbol">}</a> <a id="7028" class="Symbol">⦃</a> <a id="7030" href="Veblen.Function.html#7030" class="Bound">wfα</a> <a id="7034" class="Symbol">⦄</a> <a id="7036" class="Symbol">(</a><a id="7037" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="7040" href="Veblen.Function.html#7040" class="Bound">αn≤β</a><a id="7044" class="Symbol">)</a> <a id="7046" class="Symbol">=</a> <a id="7048" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="7058" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7065" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7067" class="Symbol">(</a><a id="7068" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="7072" href="Veblen.Function.html#7013" class="Bound">α</a><a id="7073" class="Symbol">)</a> <a id="7075" href="Veblen.Function.html#7025" class="Bound">γ</a>                        <a id="7100" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="7103" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="7118" class="Symbol">(</a><a id="7119" href="Ordinal.WellFormed.html#6031" class="Function">l≤s⇒l≤</a> <a id="7126" class="Symbol">(</a><a id="7127" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a> <a id="7133" href="Veblen.Function.html#7030" class="Bound">wfα</a><a id="7136" class="Symbol">)</a> <a id="7138" class="Symbol">(</a><a id="7139" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="7142" href="Veblen.Function.html#7040" class="Bound">αn≤β</a><a id="7146" class="Symbol">))</a> <a id="7149" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="7155" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7162" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7164" href="Veblen.Function.html#7021" class="Bound">β</a> <a id="7166" href="Veblen.Function.html#7025" class="Bound">γ</a>                              <a id="7197" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="7200" href="Veblen.Fixpoint.html#8185" class="Function">′-incrʰ-≤</a> <a id="7210" class="Symbol">(</a><a id="7211" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="7225" href="Veblen.Function.html#7021" class="Bound">β</a><a id="7226" class="Symbol">)</a> <a id="7228" href="Veblen.Function.html#7025" class="Bound">γ</a> <a id="7230" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="7236" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7243" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7245" class="Symbol">(</a><a id="7246" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="7250" href="Veblen.Function.html#7021" class="Bound">β</a><a id="7251" class="Symbol">)</a> <a id="7253" href="Veblen.Function.html#7025" class="Bound">γ</a>                        <a id="7278" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p><code>α</code> 和 <code>β</code> 都为极限时使用 <code>_⁺</code> 的高阶单调性得证. 注意这里使用了良构序数特有的性质 <code>∃[m]fn&lt;gm</code>. ∎</p>
<pre class="Agda">  <a id="7361" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="7376" class="Symbol">{</a><a id="7377" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="7381" href="Veblen.Function.html#7381" class="Bound">α</a><a id="7382" class="Symbol">}</a> <a id="7384" class="Symbol">{</a><a id="7385" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="7389" href="Veblen.Function.html#7389" class="Bound">β</a><a id="7390" class="Symbol">}</a> <a id="7392" class="Symbol">⦃</a> <a id="7394" href="Veblen.Function.html#7394" class="Bound">wfα</a> <a id="7398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7400" href="Veblen.Function.html#7400" class="Bound">mα</a> <a id="7403" class="Symbol">⦄</a> <a id="7405" class="Symbol">⦃</a> <a id="7407" href="Veblen.Function.html#7407" class="Bound">wfβ</a> <a id="7411" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7413" href="Veblen.Function.html#7413" class="Bound">mβ</a> <a id="7416" class="Symbol">⦄</a> <a id="7418" class="Symbol">(</a><a id="7419" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="7422" href="Veblen.Function.html#7422" class="Bound">αn≤β</a><a id="7426" class="Symbol">)</a> <a id="7428" class="Symbol">=</a> <a id="7430" href="Veblen.Fixpoint.html#8437" class="Function">⁺-monoʰ-≤</a> <a id="7440" href="Veblen.Function.html#7462" class="Function">mono</a> <a id="7445" class="Symbol">(</a><a id="7446" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="7449" href="Veblen.Function.html#7547" class="Function">≤</a><a id="7450" class="Symbol">)</a> <a id="7452" class="Keyword">where</a>
    <a id="7462" href="Veblen.Function.html#7462" class="Function">mono</a> <a id="7467" class="Symbol">:</a> <a id="7469" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="7481" class="Symbol">(</a><a id="7482" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7484" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="7487" href="Veblen.Function.html#7381" class="Bound">α</a><a id="7488" class="Symbol">)</a>
    <a id="7494" href="Veblen.Function.html#7462" class="Function">mono</a> <a id="7499" href="Veblen.Function.html#7499" class="Bound">≤</a> <a id="7501" class="Symbol">=</a> <a id="7503" href="Ordinal.html#6810" class="Function">l≤l</a> <a id="7507" class="Symbol">λ</a> <a id="7509" href="Veblen.Function.html#7509" class="Bound">_</a> <a id="7511" class="Symbol">→</a> <a id="7513" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="7519" class="Symbol">(</a><a id="7520" href="Veblen.Function.html#2749" class="Function">veblen-normal</a> <a id="7534" class="Symbol">(</a><a id="7535" href="Veblen.Function.html#7381" class="Bound">α</a> <a id="7537" class="Symbol">_))</a> <a id="7541" href="Veblen.Function.html#7499" class="Bound">≤</a>
    <a id="7547" href="Veblen.Function.html#7547" class="Function">≤</a> <a id="7549" class="Symbol">:</a> <a id="7551" class="Symbol">∀</a> <a id="7553" class="Symbol">{</a><a id="7554" href="Veblen.Function.html#7554" class="Bound">ξ</a><a id="7555" class="Symbol">}</a> <a id="7557" href="Veblen.Function.html#7557" class="Bound">n</a> <a id="7559" class="Symbol">→</a> <a id="7561" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7568" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7570" class="Symbol">(</a><a id="7571" href="Veblen.Function.html#7381" class="Bound">α</a> <a id="7573" href="Veblen.Function.html#7557" class="Bound">n</a><a id="7574" class="Symbol">)</a> <a id="7576" href="Veblen.Function.html#7554" class="Bound">ξ</a> <a id="7578" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="7580" class="Symbol">(</a><a id="7581" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7583" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="7586" href="Veblen.Function.html#7389" class="Bound">β</a><a id="7587" class="Symbol">)</a> <a id="7589" href="Veblen.Function.html#7554" class="Bound">ξ</a>
    <a id="7595" href="Veblen.Function.html#7547" class="Function">≤</a> <a id="7597" class="Symbol">{</a><a id="7598" href="Veblen.Function.html#7598" class="Bound">ξ</a><a id="7599" class="Symbol">}</a> <a id="7601" href="Veblen.Function.html#7601" class="Bound">n</a> <a id="7603" class="Keyword">with</a> <a id="7608" href="Ordinal.WellFormed.html#5457" class="Function">∃[m]fn&lt;gm</a> <a id="7618" href="Veblen.Function.html#7400" class="Bound">mα</a> <a id="7621" href="Veblen.Function.html#7413" class="Bound">mβ</a> <a id="7624" class="Symbol">(</a><a id="7625" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="7628" href="Veblen.Function.html#7422" class="Bound">αn≤β</a><a id="7632" class="Symbol">)</a> <a id="7634" href="Veblen.Function.html#7601" class="Bound">n</a>
    <a id="7640" class="Symbol">...</a> <a id="7644" class="Symbol">|</a> <a id="7646" class="Symbol">(</a><a id="7647" href="Veblen.Function.html#7647" class="Bound">m</a> <a id="7649" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7651" href="Veblen.Function.html#7651" class="Bound">&lt;</a><a id="7652" class="Symbol">)</a> <a id="7654" class="Symbol">=</a>                           <a id="7682" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
      <a id="7694" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7701" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7703" class="Symbol">(</a><a id="7704" href="Veblen.Function.html#7381" class="Bound">α</a> <a id="7706" class="Bound">n</a><a id="7707" class="Symbol">)</a> <a id="7709" class="Bound">ξ</a>                        <a id="7734" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="7737" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="7752" class="Symbol">⦃</a> <a id="7754" href="Veblen.Function.html#7394" class="Bound">wfα</a> <a id="7758" class="Symbol">⦄</a> <a id="7760" class="Symbol">⦃</a> <a id="7762" href="Veblen.Function.html#7407" class="Bound">wfβ</a> <a id="7766" class="Symbol">⦄</a> <a id="7768" class="Symbol">(</a><a id="7769" href="Ordinal.html#11926" class="Function">&lt;⇒≤</a> <a id="7773" href="Veblen.Function.html#7651" class="Bound">&lt;</a><a id="7774" class="Symbol">)</a> <a id="7776" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="7784" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="7791" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7793" class="Symbol">(</a><a id="7794" href="Veblen.Function.html#7389" class="Bound">β</a> <a id="7796" href="Veblen.Function.html#7647" class="Bound">m</a><a id="7797" class="Symbol">)</a> <a id="7799" class="Bound">ξ</a>                        <a id="7824" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="7827" href="Ordinal.html#7901" class="Function">f≤l</a> <a id="7831" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
      <a id="7839" class="Symbol">(</a><a id="7840" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="7842" href="Veblen.Function.html#1496" class="Function Operator">∘ₗ</a> <a id="7845" href="Veblen.Function.html#7389" class="Bound">β</a><a id="7846" class="Symbol">)</a> <a id="7848" class="Bound">ξ</a>                              <a id="7879" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p><strong>推论</strong> <code>veblen F</code> 对第一个参数满足合同性.</p>
<pre class="Agda">  <a id="7928" class="Keyword">module</a> <a id="7935" href="Veblen.Function.html#7935" class="Module">_</a> <a id="7937" class="Symbol">{</a><a id="7938" href="Veblen.Function.html#7938" class="Bound">α</a> <a id="7940" href="Veblen.Function.html#7940" class="Bound">β</a> <a id="7942" href="Veblen.Function.html#7942" class="Bound">γ</a><a id="7943" class="Symbol">}</a> <a id="7945" class="Symbol">⦃</a> <a id="7947" href="Veblen.Function.html#7947" class="Bound">wfα</a> <a id="7951" class="Symbol">:</a> <a id="7953" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="7964" href="Veblen.Function.html#7938" class="Bound">α</a> <a id="7966" class="Symbol">⦄</a> <a id="7968" class="Symbol">⦃</a> <a id="7970" href="Veblen.Function.html#7970" class="Bound">wfβ</a> <a id="7974" class="Symbol">:</a> <a id="7976" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="7987" href="Veblen.Function.html#7940" class="Bound">β</a> <a id="7989" class="Symbol">⦄</a> <a id="7991" class="Keyword">where</a>
    <a id="8001" href="Veblen.Function.html#8001" class="Function">veblen-congˡ-≤</a> <a id="8016" class="Symbol">:</a> <a id="8018" href="Veblen.Function.html#7938" class="Bound">α</a> <a id="8020" href="Ordinal.html#8129" class="Function Operator">≈</a> <a id="8022" href="Veblen.Function.html#7940" class="Bound">β</a> <a id="8024" class="Symbol">→</a> <a id="8026" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="8033" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="8035" href="Veblen.Function.html#7938" class="Bound">α</a> <a id="8037" href="Veblen.Function.html#7942" class="Bound">γ</a> <a id="8039" href="Ordinal.html#8129" class="Function Operator">≈</a> <a id="8041" href="Veblen.Function.html#1455" class="Function">veblen</a> <a id="8048" href="Veblen.Function.html#2613" class="Bound">F</a> <a id="8050" href="Veblen.Function.html#7940" class="Bound">β</a> <a id="8052" href="Veblen.Function.html#7942" class="Bound">γ</a>
    <a id="8058" href="Veblen.Function.html#8001" class="Function">veblen-congˡ-≤</a> <a id="8073" class="Symbol">(</a><a id="8074" href="Veblen.Function.html#8074" class="Bound">≤</a> <a id="8076" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8078" href="Veblen.Function.html#8078" class="Bound">≥</a><a id="8079" class="Symbol">)</a> <a id="8081" class="Symbol">=</a> <a id="8083" class="Symbol">(</a><a id="8084" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="8099" href="Veblen.Function.html#8074" class="Bound">≤</a><a id="8100" class="Symbol">)</a> <a id="8102" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8104" class="Symbol">(</a><a id="8105" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a> <a id="8120" href="Veblen.Function.html#8078" class="Bound">≥</a><a id="8121" class="Symbol">)</a>
</pre>
<p>最后, 我们将 <code>veblen</code> 的性质实例化到 <code>φ</code>.</p>
<pre class="Agda"><a id="8167" class="Keyword">open</a> <a id="8172" href="Veblen.Function.html#2602" class="Module">Properties</a> <a id="8183" class="Symbol">(</a><a id="8184" href="Ordinal.WellFormed.html#1802" class="Function">ω</a> <a id="8186" href="Ordinal.Arithmetic.html#2236" class="Function Operator">^_</a><a id="8188" class="Symbol">)</a> <a id="8190" href="Veblen.Epsilon.html#1257" class="Function">ω^-normal</a>
</pre>
<p><strong>事实</strong> 每个 <code>φ α</code> 都是序数嵌入.</p>
<pre class="Agda"><a id="φ-normal"></a><a id="8238" href="Veblen.Function.html#8238" class="Function">φ-normal</a> <a id="8247" class="Symbol">:</a> <a id="8249" class="Symbol">∀</a> <a id="8251" href="Veblen.Function.html#8251" class="Bound">α</a> <a id="8253" class="Symbol">→</a> <a id="8255" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="8262" class="Symbol">(</a><a id="8263" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8265" href="Veblen.Function.html#8251" class="Bound">α</a><a id="8266" class="Symbol">)</a>
<a id="8268" href="Veblen.Function.html#8238" class="Function">φ-normal</a> <a id="8277" class="Symbol">=</a> <a id="8279" href="Veblen.Function.html#2749" class="Function">veblen-normal</a>
</pre>
<p><strong>事实</strong> <span class="math inline">φ_α(φ_{α+1}(β))=φ_{α+1}(β)</span>.</p>
<pre class="Agda"><a id="φ-fp-suc"></a><a id="8344" href="Veblen.Function.html#8344" class="Function">φ-fp-suc</a> <a id="8353" class="Symbol">:</a> <a id="8355" class="Symbol">∀</a> <a id="8357" href="Veblen.Function.html#8357" class="Bound">α</a> <a id="8359" href="Veblen.Function.html#8359" class="Bound">β</a> <a id="8361" class="Symbol">→</a> <a id="8363" class="Symbol">(</a><a id="8364" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8366" class="Symbol">(</a><a id="8367" class="InductiveConstructor">suc</a> <a id="8371" href="Veblen.Function.html#8357" class="Bound">α</a><a id="8372" class="Symbol">)</a> <a id="8374" href="Veblen.Function.html#8359" class="Bound">β</a><a id="8375" class="Symbol">)</a> <a id="8377" href="Veblen.Fixpoint.html#1203" class="Function Operator">isFixpointOf</a> <a id="8390" class="Symbol">(</a><a id="8391" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8393" href="Veblen.Function.html#8357" class="Bound">α</a><a id="8394" class="Symbol">)</a>
<a id="8396" href="Veblen.Function.html#8344" class="Function">φ-fp-suc</a> <a id="8405" class="Symbol">=</a> <a id="8407" href="Veblen.Function.html#3394" class="Function">veblen-fp-suc</a>
</pre>
<p><strong>事实</strong> <code>φ</code> 对第一个参数满足单调性与合同性.</p>
<pre class="Agda"><a id="8463" class="Keyword">module</a> <a id="8470" href="Veblen.Function.html#8470" class="Module">_</a> <a id="8472" class="Symbol">{</a><a id="8473" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8475" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8477" href="Veblen.Function.html#8477" class="Bound">γ</a><a id="8478" class="Symbol">}</a> <a id="8480" class="Symbol">⦃</a> <a id="8482" href="Veblen.Function.html#8482" class="Bound">wfα</a> <a id="8486" class="Symbol">:</a> <a id="8488" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="8499" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8501" class="Symbol">⦄</a> <a id="8503" class="Symbol">⦃</a> <a id="8505" href="Veblen.Function.html#8505" class="Bound">wfβ</a> <a id="8509" class="Symbol">:</a> <a id="8511" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="8522" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8524" class="Symbol">⦄</a> <a id="8526" class="Keyword">where</a>

  <a id="8535" href="Veblen.Function.html#8535" class="Function">φ-monoˡ-≤</a> <a id="8545" class="Symbol">:</a> <a id="8547" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8549" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="8551" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8553" class="Symbol">→</a> <a id="8555" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8557" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8559" href="Veblen.Function.html#8477" class="Bound">γ</a> <a id="8561" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="8563" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8565" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8567" href="Veblen.Function.html#8477" class="Bound">γ</a>
  <a id="8571" href="Veblen.Function.html#8535" class="Function">φ-monoˡ-≤</a> <a id="8581" class="Symbol">=</a> <a id="8583" href="Veblen.Function.html#3729" class="Function">veblen-monoˡ-≤</a>

  <a id="8601" href="Veblen.Function.html#8601" class="Function">φ-congˡ-≤</a> <a id="8611" class="Symbol">:</a> <a id="8613" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8615" href="Ordinal.html#8129" class="Function Operator">≈</a> <a id="8617" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8619" class="Symbol">→</a> <a id="8621" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8623" href="Veblen.Function.html#8473" class="Bound">α</a> <a id="8625" href="Veblen.Function.html#8477" class="Bound">γ</a> <a id="8627" href="Ordinal.html#8129" class="Function Operator">≈</a> <a id="8629" href="Veblen.Function.html#1672" class="Function">φ</a> <a id="8631" href="Veblen.Function.html#8475" class="Bound">β</a> <a id="8633" href="Veblen.Function.html#8477" class="Bound">γ</a>
  <a id="8637" href="Veblen.Function.html#8601" class="Function">φ-congˡ-≤</a> <a id="8647" class="Symbol">=</a> <a id="8649" href="Veblen.Function.html#8001" class="Function">veblen-congˡ-≤</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
