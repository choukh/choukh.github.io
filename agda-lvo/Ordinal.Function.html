<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数3-序数函数" id="toc-agda大序数3-序数函数">Agda大序数(3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数3-序数函数">Agda大序数(3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
总目录: <a href="https://choukh.github.io/agda-lvo/Everything.html">Everything.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/Ordinal/Function.lagda.md">Ordinal/Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/Ordinal.Function.html">Ordinal.Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<pre class="Agda"><a id="489" class="Symbol">{-#</a> <a id="493" class="Keyword">OPTIONS</a> <a id="501" class="Pragma">--without-K</a> <a id="513" class="Pragma">--safe</a> <a id="520" class="Symbol">#-}</a>
<a id="524" class="Symbol">{-#</a> <a id="528" class="Keyword">OPTIONS</a> <a id="536" class="Pragma">--no-qualified-instances</a> <a id="561" class="Symbol">#-}</a>

<a id="566" class="Keyword">module</a> <a id="573" href="Ordinal.Function.html" class="Module">Ordinal.Function</a> <a id="590" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="630" class="Keyword">open</a> <a id="635" class="Keyword">import</a> <a id="642" href="Ordinal.html" class="Module">Ordinal</a>
<a id="650" class="Keyword">open</a> <a id="655" href="Ordinal.html#14658" class="Module">Ordinal.≤-Reasoning</a>
<a id="675" class="Keyword">open</a> <a id="680" class="Keyword">import</a> <a id="687" href="Ordinal.WellFormed.html" class="Module">Ordinal.WellFormed</a> <a id="706" class="Keyword">using</a> <a id="712" class="Symbol">(</a><a id="713" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a><a id="723" class="Symbol">;</a> <a id="725" href="Ordinal.WellFormed.html#5293" class="Function">∃[n]&lt;fn</a><a id="732" class="Symbol">;</a> <a id="734" href="Ordinal.WellFormed.html#5038" class="Function">f&lt;l</a><a id="737" class="Symbol">;</a> <a id="739" href="Ordinal.WellFormed.html#1650" class="InductiveConstructor">wrap</a><a id="743" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="853" class="Keyword">open</a> <a id="858" class="Keyword">import</a> <a id="865" href="Data.Product.html" class="Module">Data.Product</a> <a id="878" class="Keyword">using</a> <a id="884" class="Symbol">(</a><a id="885" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="888" class="Symbol">;</a> <a id="890" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="893" class="Symbol">;</a> <a id="895" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="900" class="Symbol">;</a> <a id="902" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="907" class="Symbol">)</a>
<a id="909" class="Keyword">open</a> <a id="914" class="Keyword">import</a> <a id="921" href="Function.html" class="Module">Function</a> <a id="930" class="Keyword">using</a> <a id="936" class="Symbol">(</a><a id="937" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="940" class="Symbol">;</a> <a id="942" href="Function.Base.html#695" class="Function">id</a><a id="944" class="Symbol">)</a>
<a id="946" class="Keyword">open</a> <a id="951" class="Keyword">import</a> <a id="958" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="974" class="Keyword">using</a> <a id="980" class="Symbol">(</a><a id="981" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a><a id="991" class="Symbol">;</a> <a id="993" href="Relation.Binary.Definitions.html#4853" class="Function Operator">_Respects_</a><a id="1003" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1069" class="Keyword">private</a> <a id="1077" class="Keyword">variable</a>
  <a id="1088" class="Symbol">{</a><a id="1089" href="Ordinal.Function.html#1089" class="Generalizable">F</a><a id="1090" class="Symbol">}</a> <a id="1092" class="Symbol">:</a> <a id="1094" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1098" class="Symbol">→</a> <a id="1100" href="Ordinal.html#3062" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1200" href="Ordinal.Function.html#1200" class="Function">wf-preserving</a> <a id="1214" class="Symbol">:</a> <a id="1216" class="Symbol">(</a><a id="1217" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1221" class="Symbol">→</a> <a id="1223" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1226" class="Symbol">)</a> <a id="1228" class="Symbol">→</a> <a id="1230" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1234" href="Ordinal.Function.html#1200" class="Function">wf-preserving</a> <a id="1248" href="Ordinal.Function.html#1248" class="Bound">F</a> <a id="1250" class="Symbol">=</a> <a id="1252" class="Symbol">∀</a> <a id="1254" class="Symbol">{</a><a id="1255" href="Ordinal.Function.html#1255" class="Bound">α</a><a id="1256" class="Symbol">}</a> <a id="1258" class="Symbol">→</a> <a id="1260" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="1271" href="Ordinal.Function.html#1255" class="Bound">α</a> <a id="1273" class="Symbol">→</a> <a id="1275" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="1286" class="Symbol">(</a><a id="1287" href="Ordinal.Function.html#1248" class="Bound">F</a> <a id="1289" href="Ordinal.Function.html#1255" class="Bound">α</a><a id="1290" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1320" href="Ordinal.Function.html#1320" class="Function">_</a> <a id="1322" class="Symbol">:</a> <a id="1324" href="Ordinal.Function.html#1200" class="Function">wf-preserving</a> <a id="1338" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1342" class="Symbol">_</a> <a id="1344" class="Symbol">=</a> <a id="1346" href="Function.Base.html#695" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1441" href="Ordinal.Function.html#1441" class="Function">≤-increasing</a> <a id="1454" class="Symbol">:</a> <a id="1456" class="Symbol">(</a><a id="1457" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1461" class="Symbol">→</a> <a id="1463" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1466" class="Symbol">)</a> <a id="1468" class="Symbol">→</a> <a id="1470" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1474" href="Ordinal.Function.html#1441" class="Function">≤-increasing</a> <a id="1487" href="Ordinal.Function.html#1487" class="Bound">F</a> <a id="1489" class="Symbol">=</a> <a id="1491" class="Symbol">∀</a> <a id="1493" href="Ordinal.Function.html#1493" class="Bound">α</a> <a id="1495" class="Symbol">→</a> <a id="1497" href="Ordinal.Function.html#1493" class="Bound">α</a> <a id="1499" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="1501" href="Ordinal.Function.html#1487" class="Bound">F</a> <a id="1503" href="Ordinal.Function.html#1493" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1506" href="Ordinal.Function.html#1506" class="Function">&lt;-increasing</a> <a id="1519" class="Symbol">:</a> <a id="1521" class="Symbol">(</a><a id="1522" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1526" class="Symbol">→</a> <a id="1528" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1531" class="Symbol">)</a> <a id="1533" class="Symbol">→</a> <a id="1535" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1539" href="Ordinal.Function.html#1506" class="Function">&lt;-increasing</a> <a id="1552" href="Ordinal.Function.html#1552" class="Bound">F</a> <a id="1554" class="Symbol">=</a> <a id="1556" class="Symbol">∀</a> <a id="1558" href="Ordinal.Function.html#1558" class="Bound">α</a> <a id="1560" class="Symbol">→</a> <a id="1562" href="Ordinal.Function.html#1558" class="Bound">α</a> <a id="1564" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="1566" href="Ordinal.Function.html#1552" class="Bound">F</a> <a id="1568" href="Ordinal.Function.html#1558" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1600" href="Ordinal.Function.html#1600" class="Function">_</a> <a id="1602" class="Symbol">:</a> <a id="1604" href="Ordinal.Function.html#1441" class="Function">≤-increasing</a> <a id="1617" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1621" class="Symbol">_</a> <a id="1623" class="Symbol">=</a> <a id="1625" class="Symbol">λ</a> <a id="1627" href="Ordinal.Function.html#1627" class="Bound">_</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="Ordinal.html#7677" class="Function">≤s</a>

<a id="1635" href="Ordinal.Function.html#1635" class="Function">_</a> <a id="1637" class="Symbol">:</a> <a id="1639" href="Ordinal.Function.html#1506" class="Function">&lt;-increasing</a> <a id="1652" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1656" class="Symbol">_</a> <a id="1658" class="Symbol">=</a> <a id="1660" class="Symbol">λ</a> <a id="1662" href="Ordinal.Function.html#1662" class="Bound">_</a> <a id="1664" class="Symbol">→</a> <a id="1666" href="Ordinal.html#11109" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1697" href="Ordinal.Function.html#1697" class="Function">&lt;⇒≤-incr</a> <a id="1706" class="Symbol">:</a> <a id="1708" href="Ordinal.Function.html#1506" class="Function">&lt;-increasing</a> <a id="1721" href="Ordinal.Function.html#1089" class="Generalizable">F</a> <a id="1723" class="Symbol">→</a> <a id="1725" href="Ordinal.Function.html#1441" class="Function">≤-increasing</a> <a id="1738" href="Ordinal.Function.html#1089" class="Generalizable">F</a>
<a id="1740" href="Ordinal.Function.html#1697" class="Function">&lt;⇒≤-incr</a> <a id="1749" class="Symbol">=</a> <a id="1751" class="Symbol">λ</a> <a id="1753" href="Ordinal.Function.html#1753" class="Bound">&lt;-incr</a> <a id="1760" href="Ordinal.Function.html#1760" class="Bound">α</a> <a id="1762" class="Symbol">→</a> <a id="1764" href="Ordinal.html#11909" class="Function">&lt;⇒≤</a> <a id="1768" class="Symbol">(</a><a id="1769" href="Ordinal.Function.html#1753" class="Bound">&lt;-incr</a> <a id="1776" href="Ordinal.Function.html#1760" class="Bound">α</a><a id="1777" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1868" href="Ordinal.Function.html#1868" class="Function">zero-increasing</a> <a id="1884" class="Symbol">:</a> <a id="1886" class="Symbol">(</a><a id="1887" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1891" class="Symbol">→</a> <a id="1893" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1896" class="Symbol">)</a> <a id="1898" class="Symbol">→</a> <a id="1900" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1904" href="Ordinal.Function.html#1868" class="Function">zero-increasing</a> <a id="1920" href="Ordinal.Function.html#1920" class="Bound">F</a> <a id="1922" class="Symbol">=</a> <a id="1924" href="Ordinal.html#3080" class="InductiveConstructor">zero</a> <a id="1929" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="1931" href="Ordinal.Function.html#1920" class="Bound">F</a> <a id="1933" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1939" href="Ordinal.Function.html#1939" class="Function">suc-increasing</a> <a id="1954" class="Symbol">:</a> <a id="1956" class="Symbol">(</a><a id="1957" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1961" class="Symbol">→</a> <a id="1963" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1966" class="Symbol">)</a> <a id="1968" class="Symbol">→</a> <a id="1970" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1974" href="Ordinal.Function.html#1939" class="Function">suc-increasing</a> <a id="1989" href="Ordinal.Function.html#1989" class="Bound">F</a> <a id="1991" class="Symbol">=</a> <a id="1993" class="Symbol">∀</a> <a id="1995" href="Ordinal.Function.html#1995" class="Bound">α</a> <a id="1997" class="Symbol">→</a> <a id="1999" class="Symbol">⦃</a> <a id="2001" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="2012" href="Ordinal.Function.html#1995" class="Bound">α</a> <a id="2014" class="Symbol">⦄</a> <a id="2016" class="Symbol">→</a> <a id="2018" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2022" href="Ordinal.Function.html#1995" class="Bound">α</a> <a id="2024" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="2026" href="Ordinal.Function.html#1989" class="Bound">F</a> <a id="2028" class="Symbol">(</a><a id="2029" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2033" href="Ordinal.Function.html#1995" class="Bound">α</a><a id="2034" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2091" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="2103" class="Symbol">:</a> <a id="2105" class="Symbol">(</a><a id="2106" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2110" class="Symbol">→</a> <a id="2112" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2115" class="Symbol">)</a> <a id="2117" class="Symbol">→</a> <a id="2119" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2123" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="2135" href="Ordinal.Function.html#2135" class="Bound">F</a> <a id="2137" class="Symbol">=</a> <a id="2139" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2150" href="Ordinal.html#4665" class="Datatype Operator">_≤_</a> <a id="2154" href="Ordinal.html#4665" class="Datatype Operator">_≤_</a> <a id="2158" href="Ordinal.Function.html#2135" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2161" href="Ordinal.Function.html#2161" class="Function">&lt;-monotonic</a> <a id="2173" class="Symbol">:</a> <a id="2175" class="Symbol">(</a><a id="2176" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2180" class="Symbol">→</a> <a id="2182" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2185" class="Symbol">)</a> <a id="2187" class="Symbol">→</a> <a id="2189" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2193" href="Ordinal.Function.html#2161" class="Function">&lt;-monotonic</a> <a id="2205" href="Ordinal.Function.html#2205" class="Bound">F</a> <a id="2207" class="Symbol">=</a> <a id="2209" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2220" href="Ordinal.html#10297" class="Function Operator">_&lt;_</a> <a id="2224" href="Ordinal.html#10297" class="Function Operator">_&lt;_</a> <a id="2228" href="Ordinal.Function.html#2205" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2260" href="Ordinal.Function.html#2260" class="Function">_</a> <a id="2262" class="Symbol">:</a> <a id="2264" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="2276" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="2280" class="Symbol">_</a> <a id="2282" class="Symbol">=</a> <a id="2284" href="Ordinal.html#6414" class="Function">s≤s</a>

<a id="2289" href="Ordinal.Function.html#2289" class="Function">_</a> <a id="2291" class="Symbol">:</a> <a id="2293" href="Ordinal.Function.html#2161" class="Function">&lt;-monotonic</a> <a id="2305" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="2309" class="Symbol">_</a> <a id="2311" class="Symbol">=</a> <a id="2313" href="Ordinal.html#12767" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2372" href="Ordinal.Function.html#2372" class="Function">suc-monotonic</a> <a id="2386" class="Symbol">:</a> <a id="2388" class="Symbol">(</a><a id="2389" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2393" class="Symbol">→</a> <a id="2395" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2398" class="Symbol">)</a> <a id="2400" class="Symbol">→</a> <a id="2402" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2406" href="Ordinal.Function.html#2372" class="Function">suc-monotonic</a> <a id="2420" href="Ordinal.Function.html#2420" class="Bound">F</a> <a id="2422" class="Symbol">=</a> <a id="2424" class="Symbol">∀</a> <a id="2426" href="Ordinal.Function.html#2426" class="Bound">α</a> <a id="2428" class="Symbol">→</a> <a id="2430" href="Ordinal.Function.html#2420" class="Bound">F</a> <a id="2432" href="Ordinal.Function.html#2426" class="Bound">α</a> <a id="2434" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="2436" href="Ordinal.Function.html#2420" class="Bound">F</a> <a id="2438" class="Symbol">(</a><a id="2439" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2443" href="Ordinal.Function.html#2426" class="Bound">α</a><a id="2444" class="Symbol">)</a>

<a id="2447" href="Ordinal.Function.html#2447" class="Function">_</a> <a id="2449" class="Symbol">:</a> <a id="2451" href="Ordinal.Function.html#2161" class="Function">&lt;-monotonic</a> <a id="2463" href="Ordinal.Function.html#1089" class="Generalizable">F</a> <a id="2465" class="Symbol">→</a> <a id="2467" href="Ordinal.Function.html#2372" class="Function">suc-monotonic</a> <a id="2481" href="Ordinal.Function.html#1089" class="Generalizable">F</a>
<a id="2483" class="Symbol">_</a> <a id="2485" class="Symbol">=</a> <a id="2487" class="Symbol">λ</a> <a id="2489" href="Ordinal.Function.html#2489" class="Bound">&lt;-mono</a> <a id="2496" href="Ordinal.Function.html#2496" class="Bound">_</a> <a id="2498" class="Symbol">→</a> <a id="2500" href="Ordinal.Function.html#2489" class="Bound">&lt;-mono</a> <a id="2507" href="Ordinal.html#11109" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="lim-continuous"></a><a id="2573" href="Ordinal.Function.html#2573" class="Function">lim-continuous</a> <a id="2588" class="Symbol">:</a> <a id="2590" class="Symbol">(</a><a id="2591" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2595" class="Symbol">→</a> <a id="2597" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2600" class="Symbol">)</a> <a id="2602" class="Symbol">→</a> <a id="2604" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2608" href="Ordinal.Function.html#2573" class="Function">lim-continuous</a> <a id="2623" href="Ordinal.Function.html#2623" class="Bound">F</a> <a id="2625" class="Symbol">=</a> <a id="2627" class="Symbol">∀</a> <a id="2629" href="Ordinal.Function.html#2629" class="Bound">f</a> <a id="2631" class="Symbol">→</a> <a id="2633" href="Ordinal.Function.html#2623" class="Bound">F</a> <a id="2635" class="Symbol">(</a><a id="2636" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2640" href="Ordinal.Function.html#2629" class="Bound">f</a><a id="2641" class="Symbol">)</a> <a id="2643" href="Ordinal.html#8112" class="Function Operator">≈</a> <a id="2645" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2649" class="Symbol">(</a><a id="2650" href="Ordinal.Function.html#2623" class="Bound">F</a> <a id="2652" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2654" href="Ordinal.Function.html#2629" class="Bound">f</a><a id="2655" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2745" href="Ordinal.Function.html#2745" class="Function">normal</a> <a id="2752" class="Symbol">:</a> <a id="2754" class="Symbol">(</a><a id="2755" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2759" class="Symbol">→</a> <a id="2761" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2764" class="Symbol">)</a> <a id="2766" class="Symbol">→</a> <a id="2768" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2772" href="Ordinal.Function.html#2745" class="Function">normal</a> <a id="2779" href="Ordinal.Function.html#2779" class="Bound">F</a> <a id="2781" class="Symbol">=</a> <a id="2783" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="2795" href="Ordinal.Function.html#2779" class="Bound">F</a> <a id="2797" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2799" href="Ordinal.Function.html#2161" class="Function">&lt;-monotonic</a> <a id="2811" href="Ordinal.Function.html#2779" class="Bound">F</a> <a id="2813" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2815" href="Ordinal.Function.html#2573" class="Function">lim-continuous</a> <a id="2830" href="Ordinal.Function.html#2779" class="Bound">F</a>
</pre>
<p>对该定义的解释放在下一小节. 我们先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="normal⇒≤-incr"></a><a id="2948" href="Ordinal.Function.html#2948" class="Function">normal⇒≤-incr</a> <a id="2962" class="Symbol">:</a> <a id="2964" href="Ordinal.Function.html#2745" class="Function">normal</a> <a id="2971" href="Ordinal.Function.html#1089" class="Generalizable">F</a> <a id="2973" class="Symbol">→</a> <a id="2975" href="Ordinal.Function.html#1441" class="Function">≤-increasing</a> <a id="2988" href="Ordinal.Function.html#1089" class="Generalizable">F</a>
<a id="2990" href="Ordinal.Function.html#2948" class="Function">normal⇒≤-incr</a> <a id="3004" class="Symbol">{</a><a id="3005" href="Ordinal.Function.html#3005" class="Bound">F</a><a id="3006" class="Symbol">}</a> <a id="3008" href="Ordinal.Function.html#3008" class="Bound">nml</a><a id="3011" class="Symbol">@(_</a> <a id="3015" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3017" href="Ordinal.Function.html#3017" class="Bound">&lt;-mono</a> <a id="3024" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3026" href="Ordinal.Function.html#3026" class="Bound">lim-ct</a><a id="3032" class="Symbol">)</a> <a id="3034" class="Symbol">=</a>
  <a id="3038" class="Symbol">λ</a> <a id="3040" class="Symbol">{</a> <a id="3042" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="3050" class="Symbol">→</a> <a id="3052" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">    <a id="3207" class="Symbol">;</a> <a id="3209" class="Symbol">(</a><a id="3210" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3214" href="Ordinal.Function.html#3214" class="Bound">α</a><a id="3215" class="Symbol">)</a> <a id="3217" class="Symbol">→</a>   <a id="3221" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
        <a id="3235" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3239" href="Ordinal.Function.html#3214" class="Bound">α</a>     <a id="3245" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3248" href="Ordinal.html#6414" class="Function">s≤s</a> <a id="3252" class="Symbol">(</a><a id="3253" href="Ordinal.Function.html#2948" class="Function">normal⇒≤-incr</a> <a id="3267" href="Ordinal.Function.html#3008" class="Bound">nml</a> <a id="3271" href="Ordinal.Function.html#3214" class="Bound">α</a><a id="3272" class="Symbol">)</a> <a id="3274" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3284" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3288" class="Symbol">(</a><a id="3289" href="Ordinal.Function.html#3005" class="Bound">F</a> <a id="3291" href="Ordinal.Function.html#3214" class="Bound">α</a><a id="3292" class="Symbol">)</a> <a id="3294" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3297" href="Ordinal.html#12165" class="Function">&lt;⇒s≤</a> <a id="3302" class="Symbol">(</a><a id="3303" href="Ordinal.Function.html#3017" class="Bound">&lt;-mono</a> <a id="3310" href="Ordinal.html#11109" class="Function">&lt;s</a><a id="3312" class="Symbol">)</a> <a id="3314" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3324" href="Ordinal.Function.html#3005" class="Bound">F</a> <a id="3326" class="Symbol">(</a><a id="3327" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3331" href="Ordinal.Function.html#3214" class="Bound">α</a><a id="3332" class="Symbol">)</a> <a id="3334" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">    <a id="3476" class="Symbol">;</a> <a id="3478" class="Symbol">(</a><a id="3479" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3483" href="Ordinal.Function.html#3483" class="Bound">f</a><a id="3484" class="Symbol">)</a> <a id="3486" class="Symbol">→</a> <a id="3488" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="3491" class="Symbol">λ</a> <a id="3493" href="Ordinal.Function.html#3493" class="Bound">n</a> <a id="3495" class="Symbol">→</a> <a id="3497" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
        <a id="3511" href="Ordinal.Function.html#3483" class="Bound">f</a> <a id="3513" href="Ordinal.Function.html#3493" class="Bound">n</a>              <a id="3528" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3531" href="Ordinal.html#6093" class="Function">≤f⇒≤l</a> <a id="3537" class="Symbol">(</a><a id="3538" href="Ordinal.Function.html#2948" class="Function">normal⇒≤-incr</a> <a id="3552" href="Ordinal.Function.html#3008" class="Bound">nml</a> <a id="3556" class="Symbol">(</a><a id="3557" href="Ordinal.Function.html#3483" class="Bound">f</a> <a id="3559" href="Ordinal.Function.html#3493" class="Bound">n</a><a id="3560" class="Symbol">))</a> <a id="3563" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3573" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3577" class="Symbol">(</a><a id="3578" href="Ordinal.Function.html#3005" class="Bound">F</a> <a id="3580" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="3582" href="Ordinal.Function.html#3483" class="Bound">f</a><a id="3583" class="Symbol">)</a>      <a id="3590" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="3594" href="Ordinal.Function.html#3026" class="Bound">lim-ct</a> <a id="3601" href="Ordinal.Function.html#3483" class="Bound">f</a> <a id="3603" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
        <a id="3613" href="Ordinal.Function.html#3005" class="Bound">F</a> <a id="3615" class="Symbol">(</a><a id="3616" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3620" href="Ordinal.Function.html#3483" class="Bound">f</a><a id="3621" class="Symbol">)</a>        <a id="3630" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
    <a id="3636" class="Symbol">}</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3681" href="Ordinal.Function.html#3681" class="Function Operator">_≈ᶠ_</a> <a id="3686" class="Symbol">:</a> <a id="3688" class="Symbol">(</a><a id="3689" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="3693" class="Symbol">→</a> <a id="3695" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="3698" class="Symbol">)</a> <a id="3700" class="Symbol">→</a> <a id="3702" class="Symbol">(</a><a id="3703" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="3707" class="Symbol">→</a> <a id="3709" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="3712" class="Symbol">)</a> <a id="3714" class="Symbol">→</a> <a id="3716" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="3720" href="Ordinal.Function.html#3720" class="Bound">F</a> <a id="3722" href="Ordinal.Function.html#3681" class="Function Operator">≈ᶠ</a> <a id="3725" href="Ordinal.Function.html#3725" class="Bound">G</a> <a id="3727" class="Symbol">=</a> <a id="3729" class="Symbol">∀</a> <a id="3731" class="Symbol">{</a><a id="3732" href="Ordinal.Function.html#3732" class="Bound">α</a><a id="3733" class="Symbol">}</a> <a id="3735" class="Symbol">→</a> <a id="3737" href="Ordinal.Function.html#3720" class="Bound">F</a> <a id="3739" href="Ordinal.Function.html#3732" class="Bound">α</a> <a id="3741" href="Ordinal.html#8112" class="Function Operator">≈</a> <a id="3743" href="Ordinal.Function.html#3725" class="Bound">G</a> <a id="3745" href="Ordinal.Function.html#3732" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3748" href="Ordinal.Function.html#3748" class="Function">normal-resp-≈</a> <a id="3762" class="Symbol">:</a> <a id="3764" href="Ordinal.Function.html#2745" class="Function">normal</a> <a id="3771" href="Relation.Binary.Definitions.html#4853" class="Function Operator">Respects</a> <a id="3780" href="Ordinal.Function.html#3681" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>lim-ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3896" href="Ordinal.Function.html#3748" class="Function">normal-resp-≈</a> <a id="3910" class="Symbol">{</a><a id="3911" href="Ordinal.Function.html#3911" class="Bound">F</a><a id="3912" class="Symbol">}</a> <a id="3914" class="Symbol">{</a><a id="3915" href="Ordinal.Function.html#3915" class="Bound">G</a><a id="3916" class="Symbol">}</a> <a id="3918" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="3922" class="Symbol">(</a><a id="3923" href="Ordinal.Function.html#3923" class="Bound">≤-mono</a> <a id="3930" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3932" href="Ordinal.Function.html#3932" class="Bound">&lt;-mono</a> <a id="3939" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3941" href="Ordinal.Function.html#3941" class="Bound">lim-ct</a><a id="3947" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4046" class="Symbol">=</a> <a id="4048" class="Symbol">(λ</a> <a id="4051" class="Symbol">{</a><a id="4052" href="Ordinal.Function.html#4052" class="Bound">α</a><a id="4053" class="Symbol">}</a> <a id="4055" class="Symbol">{</a><a id="4056" href="Ordinal.Function.html#4056" class="Bound">β</a><a id="4057" class="Symbol">}</a> <a id="4059" href="Ordinal.Function.html#4059" class="Bound">α≤β</a> <a id="4063" class="Symbol">→</a> <a id="4065" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a> <a id="4071" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4073" href="Ordinal.Function.html#4052" class="Bound">α</a> <a id="4075" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4079" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4083" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4085" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4087" href="Ordinal.Function.html#4052" class="Bound">α</a> <a id="4089" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4092" href="Ordinal.Function.html#3923" class="Bound">≤-mono</a> <a id="4099" href="Ordinal.Function.html#4059" class="Bound">α≤β</a> <a id="4103" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a> <a id="4105" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4107" href="Ordinal.Function.html#4056" class="Bound">β</a> <a id="4109" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4112" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4116" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4118" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4120" href="Ordinal.Function.html#4056" class="Bound">β</a> <a id="4122" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4123" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4222" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4224" class="Symbol">(λ</a> <a id="4227" class="Symbol">{</a><a id="4228" href="Ordinal.Function.html#4228" class="Bound">α</a><a id="4229" class="Symbol">}</a> <a id="4231" class="Symbol">{</a><a id="4232" href="Ordinal.Function.html#4232" class="Bound">β</a><a id="4233" class="Symbol">}</a> <a id="4235" href="Ordinal.Function.html#4235" class="Bound">α&lt;β</a> <a id="4239" class="Symbol">→</a> <a id="4241" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a> <a id="4254" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4256" href="Ordinal.Function.html#4228" class="Bound">α</a> <a id="4258" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4262" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4266" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4268" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4270" href="Ordinal.Function.html#4228" class="Bound">α</a> <a id="4272" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="4275" href="Ordinal.Function.html#3932" class="Bound">&lt;-mono</a> <a id="4282" href="Ordinal.Function.html#4235" class="Bound">α&lt;β</a> <a id="4286" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a> <a id="4288" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4290" href="Ordinal.Function.html#4232" class="Bound">β</a> <a id="4292" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4295" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4299" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4301" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4303" href="Ordinal.Function.html#4232" class="Bound">β</a> <a id="4305" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4306" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4350" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4352" class="Symbol">(λ</a> <a id="4355" href="Ordinal.Function.html#4355" class="Bound">f</a> <a id="4357" class="Symbol">→</a> <a id="4359" href="Relation.Binary.Reasoning.Base.Triple.html#3286" class="Function Operator">begin-equality</a>
      <a id="4380" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4382" class="Symbol">(</a><a id="4383" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4387" href="Ordinal.Function.html#4355" class="Bound">f</a><a id="4388" class="Symbol">)</a>   <a id="4392" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4396" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4400" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
      <a id="4408" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4410" class="Symbol">(</a><a id="4411" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4415" href="Ordinal.Function.html#4355" class="Bound">f</a><a id="4416" class="Symbol">)</a>   <a id="4420" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4423" href="Ordinal.Function.html#3941" class="Bound">lim-ct</a> <a id="4430" href="Ordinal.Function.html#4355" class="Bound">f</a> <a id="4432" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4440" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4444" class="Symbol">(</a><a id="4445" href="Ordinal.Function.html#3911" class="Bound">F</a> <a id="4447" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4449" href="Ordinal.Function.html#4355" class="Bound">f</a><a id="4450" class="Symbol">)</a> <a id="4452" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4455" href="Ordinal.html#9122" class="Function">l≈l</a> <a id="4459" href="Ordinal.Function.html#3918" class="Bound">ext</a> <a id="4463" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4471" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4475" class="Symbol">(</a><a id="4476" href="Ordinal.Function.html#3915" class="Bound">G</a> <a id="4478" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4480" href="Ordinal.Function.html#4355" class="Bound">f</a><a id="4481" class="Symbol">)</a> <a id="4483" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4484" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="4985" class="Keyword">open</a> <a id="4990" class="Keyword">import</a> <a id="4997" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="5018" class="Symbol">(</a><a id="5019" href="Ordinal.html#8112" class="Function Operator">_≈_</a><a id="5022" class="Symbol">)</a> <a id="5024" class="Symbol">(</a><a id="5025" href="Ordinal.html#8112" class="Function Operator">_≈_</a><a id="5028" class="Symbol">)</a> <a id="5030" class="Keyword">using</a> <a id="5036" class="Symbol">(</a><a id="5037" href="Function.Definitions.html#803" class="Function">Congruent</a><a id="5046" class="Symbol">)</a>

<a id="≤-mono⇒cong"></a><a id="5049" href="Ordinal.Function.html#5049" class="Function">≤-mono⇒cong</a> <a id="5061" class="Symbol">:</a> <a id="5063" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="5075" href="Ordinal.Function.html#1089" class="Generalizable">F</a> <a id="5077" class="Symbol">→</a> <a id="5079" href="Function.Definitions.html#803" class="Function">Congruent</a> <a id="5089" href="Ordinal.Function.html#1089" class="Generalizable">F</a>
<a id="5091" href="Ordinal.Function.html#5049" class="Function">≤-mono⇒cong</a> <a id="5103" href="Ordinal.Function.html#5103" class="Bound">≤-mono</a> <a id="5110" class="Symbol">=</a> <a id="5112" class="Symbol">λ</a> <a id="5114" class="Symbol">{</a> <a id="5116" class="Symbol">(</a><a id="5117" href="Ordinal.Function.html#5117" class="Bound">≤</a> <a id="5119" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5121" href="Ordinal.Function.html#5121" class="Bound">≥</a><a id="5122" class="Symbol">)</a> <a id="5124" class="Symbol">→</a> <a id="5126" href="Ordinal.Function.html#5103" class="Bound">≤-mono</a> <a id="5133" href="Ordinal.Function.html#5117" class="Bound">≤</a> <a id="5135" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5137" href="Ordinal.Function.html#5103" class="Bound">≤-mono</a> <a id="5144" href="Ordinal.Function.html#5121" class="Bound">≥</a> <a id="5146" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5320" href="Ordinal.Function.html#5320" class="Function">wf-&lt;-monotonic</a> <a id="5335" class="Symbol">:</a> <a id="5337" class="Symbol">(</a><a id="5338" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5342" class="Symbol">→</a> <a id="5344" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5347" class="Symbol">)</a> <a id="5349" class="Symbol">→</a> <a id="5351" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5355" href="Ordinal.Function.html#5320" class="Function">wf-&lt;-monotonic</a> <a id="5370" href="Ordinal.Function.html#5370" class="Bound">F</a> <a id="5372" class="Symbol">=</a> <a id="5374" class="Symbol">∀</a> <a id="5376" class="Symbol">{</a><a id="5377" href="Ordinal.Function.html#5377" class="Bound">α</a> <a id="5379" href="Ordinal.Function.html#5379" class="Bound">β</a><a id="5380" class="Symbol">}</a> <a id="5382" class="Symbol">→</a> <a id="5384" class="Symbol">⦃</a> <a id="5386" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="5397" href="Ordinal.Function.html#5377" class="Bound">α</a> <a id="5399" class="Symbol">⦄</a> <a id="5401" class="Symbol">→</a> <a id="5403" class="Symbol">⦃</a> <a id="5405" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="5416" href="Ordinal.Function.html#5379" class="Bound">β</a> <a id="5418" class="Symbol">⦄</a> <a id="5420" class="Symbol">→</a> <a id="5422" href="Ordinal.Function.html#5377" class="Bound">α</a> <a id="5424" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="5426" href="Ordinal.Function.html#5379" class="Bound">β</a> <a id="5428" class="Symbol">→</a> <a id="5430" href="Ordinal.Function.html#5370" class="Bound">F</a> <a id="5432" href="Ordinal.Function.html#5377" class="Bound">α</a> <a id="5434" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="5436" href="Ordinal.Function.html#5370" class="Bound">F</a> <a id="5438" href="Ordinal.Function.html#5379" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5441" href="Ordinal.Function.html#5441" class="Function">wf-suc-monotonic</a> <a id="5458" class="Symbol">:</a> <a id="5460" class="Symbol">(</a><a id="5461" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5465" class="Symbol">→</a> <a id="5467" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5470" class="Symbol">)</a> <a id="5472" class="Symbol">→</a> <a id="5474" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5478" href="Ordinal.Function.html#5441" class="Function">wf-suc-monotonic</a> <a id="5495" href="Ordinal.Function.html#5495" class="Bound">F</a> <a id="5497" class="Symbol">=</a> <a id="5499" class="Symbol">∀</a> <a id="5501" href="Ordinal.Function.html#5501" class="Bound">α</a> <a id="5503" class="Symbol">→</a> <a id="5505" class="Symbol">⦃</a> <a id="5507" href="Ordinal.WellFormed.html#1771" class="Function">wellFormed</a> <a id="5518" href="Ordinal.Function.html#5501" class="Bound">α</a> <a id="5520" class="Symbol">⦄</a> <a id="5522" class="Symbol">→</a> <a id="5524" href="Ordinal.Function.html#5495" class="Bound">F</a> <a id="5526" href="Ordinal.Function.html#5501" class="Bound">α</a> <a id="5528" href="Ordinal.html#10297" class="Function Operator">&lt;</a> <a id="5530" href="Ordinal.Function.html#5495" class="Bound">F</a> <a id="5532" class="Symbol">(</a><a id="5533" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5537" href="Ordinal.Function.html#5501" class="Bound">α</a><a id="5538" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5541" href="Ordinal.Function.html#5541" class="Function">wf-normal</a> <a id="5551" class="Symbol">:</a> <a id="5553" class="Symbol">(</a><a id="5554" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5558" class="Symbol">→</a> <a id="5560" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5563" class="Symbol">)</a> <a id="5565" class="Symbol">→</a> <a id="5567" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5571" href="Ordinal.Function.html#5541" class="Function">wf-normal</a> <a id="5581" href="Ordinal.Function.html#5581" class="Bound">F</a> <a id="5583" class="Symbol">=</a> <a id="5585" href="Ordinal.Function.html#2091" class="Function">≤-monotonic</a> <a id="5597" href="Ordinal.Function.html#5581" class="Bound">F</a> <a id="5599" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5601" href="Ordinal.Function.html#5441" class="Function">wf-suc-monotonic</a> <a id="5618" href="Ordinal.Function.html#5581" class="Bound">F</a> <a id="5620" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5622" href="Ordinal.Function.html#2573" class="Function">lim-continuous</a> <a id="5637" href="Ordinal.Function.html#5581" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="5735" class="Keyword">module</a> <a id="5742" href="Ordinal.Function.html#5742" class="Module">_</a> <a id="5744" class="Symbol">(</a><a id="5745" href="Ordinal.Function.html#5745" class="Bound">nml</a><a id="5748" class="Symbol">@(</a><a id="5750" href="Ordinal.Function.html#5750" class="Bound">≤-mono</a> <a id="5757" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5759" href="Ordinal.Function.html#5759" class="Bound">suc-mono</a> <a id="5768" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5770" href="Ordinal.Function.html#5770" class="Bound">lim-ct</a><a id="5776" class="Symbol">)</a> <a id="5778" class="Symbol">:</a> <a id="5780" href="Ordinal.Function.html#5541" class="Function">wf-normal</a> <a id="5790" href="Ordinal.Function.html#1089" class="Generalizable">F</a><a id="5791" class="Symbol">)</a> <a id="5793" class="Keyword">where</a>
  <a id="5801" href="Ordinal.Function.html#5801" class="Function">wf-nml⇒&lt;-mono</a> <a id="5815" class="Symbol">:</a> <a id="5817" href="Ordinal.Function.html#5320" class="Function">wf-&lt;-monotonic</a> <a id="5832" href="Ordinal.Function.html#5790" class="Bound">F</a>

  <a id="5837" href="Ordinal.Function.html#5801" class="Function">wf-nml⇒&lt;-mono</a> <a id="5851" class="Symbol">{</a><a id="5852" href="Ordinal.Function.html#5852" class="Bound">α</a><a id="5853" class="Symbol">}</a> <a id="5855" class="Symbol">{</a><a id="5856" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5860" href="Ordinal.Function.html#5860" class="Bound">β</a><a id="5861" class="Symbol">}</a> <a id="5863" href="Ordinal.Function.html#5863" class="Bound">α&lt;s</a> <a id="5867" class="Symbol">=</a> <a id="5869" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="5886" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="5888" href="Ordinal.Function.html#5852" class="Bound">α</a>           <a id="5900" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5903" href="Ordinal.Function.html#5750" class="Bound">≤-mono</a> <a id="5910" class="Symbol">(</a><a id="5911" href="Ordinal.html#12431" class="Function">&lt;s⇒≤</a> <a id="5916" href="Ordinal.Function.html#5863" class="Bound">α&lt;s</a><a id="5919" class="Symbol">)</a> <a id="5921" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="5927" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="5929" href="Ordinal.Function.html#5860" class="Bound">β</a>           <a id="5941" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="5944" href="Ordinal.Function.html#5759" class="Bound">suc-mono</a> <a id="5953" href="Ordinal.Function.html#5860" class="Bound">β</a> <a id="5955" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="5961" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="5963" class="Symbol">(</a><a id="5964" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5968" href="Ordinal.Function.html#5860" class="Bound">β</a><a id="5969" class="Symbol">)</a>     <a id="5975" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>

  <a id="5980" href="Ordinal.Function.html#5801" class="Function">wf-nml⇒&lt;-mono</a> <a id="5994" class="Symbol">{</a><a id="5995" href="Ordinal.Function.html#5995" class="Bound">α</a><a id="5996" class="Symbol">}</a> <a id="5998" class="Symbol">{</a><a id="5999" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6003" href="Ordinal.Function.html#6003" class="Bound">f</a><a id="6004" class="Symbol">}</a> <a id="6006" class="Symbol">⦃</a> <a id="6008" class="Symbol">_</a> <a id="6010" class="Symbol">⦄</a> <a id="6012" class="Symbol">⦃</a> <a id="6014" href="Ordinal.Function.html#6014" class="Bound">wfn</a> <a id="6018" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6020" href="Ordinal.WellFormed.html#1650" class="InductiveConstructor">wrap</a> <a id="6025" href="Ordinal.Function.html#6025" class="Bound">mono</a> <a id="6030" class="Symbol">⦄</a> <a id="6032" href="Ordinal.Function.html#6032" class="Bound">α&lt;l</a> <a id="6036" class="Keyword">with</a> <a id="6041" href="Ordinal.WellFormed.html#5293" class="Function">∃[n]&lt;fn</a> <a id="6049" class="Symbol">⦃</a> <a id="6051" href="Ordinal.WellFormed.html#1650" class="InductiveConstructor">wrap</a> <a id="6056" href="Ordinal.Function.html#6025" class="Bound">mono</a> <a id="6061" class="Symbol">⦄</a> <a id="6063" href="Ordinal.Function.html#6032" class="Bound">α&lt;l</a>
  <a id="6069" class="Symbol">...</a> <a id="6073" class="Symbol">|</a> <a id="6075" class="Symbol">(</a><a id="6076" href="Ordinal.Function.html#6076" class="Bound">n</a> <a id="6078" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6080" href="Ordinal.Function.html#6080" class="Bound">α&lt;fn</a><a id="6084" class="Symbol">)</a> <a id="6086" class="Symbol">=</a> <a id="6088" class="Keyword">let</a> <a id="6092" class="Keyword">instance</a> <a id="6101" href="Ordinal.Function.html#6101" class="Bound">wfn</a> <a id="6105" class="Symbol">=</a> <a id="6107" class="Bound">wfn</a> <a id="6111" class="Keyword">in</a> <a id="6114" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="6131" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="6133" class="Bound">α</a>           <a id="6145" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6148" href="Ordinal.Function.html#5801" class="Function">wf-nml⇒&lt;-mono</a> <a id="6162" href="Ordinal.Function.html#6080" class="Bound">α&lt;fn</a> <a id="6167" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6173" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="6175" class="Symbol">(</a><a id="6176" class="Bound">f</a> <a id="6178" href="Ordinal.Function.html#6076" class="Bound">n</a><a id="6179" class="Symbol">)</a>       <a id="6187" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6190" href="Ordinal.WellFormed.html#5038" class="Function">f&lt;l</a> <a id="6194" class="Symbol">⦃</a> <a id="6196" href="Ordinal.WellFormed.html#1650" class="InductiveConstructor">wrap</a> <a id="6201" class="Symbol">λ</a> <a id="6203" href="Ordinal.Function.html#6203" class="Bound">m&lt;n</a> <a id="6207" class="Symbol">→</a> <a id="6209" href="Ordinal.Function.html#5801" class="Function">wf-nml⇒&lt;-mono</a> <a id="6223" class="Symbol">(</a><a id="6224" class="Bound">mono</a> <a id="6229" href="Ordinal.Function.html#6203" class="Bound">m&lt;n</a><a id="6232" class="Symbol">)</a> <a id="6234" class="Symbol">⦄</a> <a id="6236" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6242" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6246" class="Symbol">(</a><a id="6247" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="6249" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="6251" class="Bound">f</a><a id="6252" class="Symbol">)</a>   <a id="6256" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="6260" href="Ordinal.Function.html#5770" class="Bound">lim-ct</a> <a id="6267" class="Bound">f</a> <a id="6269" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
    <a id="6275" href="Ordinal.Function.html#5790" class="Bound">F</a> <a id="6277" class="Symbol">(</a><a id="6278" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6282" class="Bound">f</a><a id="6283" class="Symbol">)</a>     <a id="6289" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
