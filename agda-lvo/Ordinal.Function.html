<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数3-序数函数" id="toc-agda大序数3-序数函数">Agda大序数(3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数3-序数函数">Agda大序数(3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
总目录: <a href="https://choukh.github.io/agda-lvo/Everything.html">Everything.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/Ordinal/Function.lagda.md">Ordinal/Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/Ordinal.Function.html">Ordinal.Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<pre class="Agda"><a id="489" class="Symbol">{-#</a> <a id="493" class="Keyword">OPTIONS</a> <a id="501" class="Pragma">--without-K</a> <a id="513" class="Pragma">--safe</a> <a id="520" class="Symbol">#-}</a>

<a id="525" class="Keyword">module</a> <a id="532" href="Ordinal.Function.html" class="Module">Ordinal.Function</a> <a id="549" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="589" class="Keyword">open</a> <a id="594" class="Keyword">import</a> <a id="601" href="Ordinal.html" class="Module">Ordinal</a>
<a id="609" class="Keyword">open</a> <a id="614" href="Ordinal.html#14566" class="Module">Ordinal.≤-Reasoning</a>
<a id="634" class="Keyword">open</a> <a id="639" class="Keyword">import</a> <a id="646" href="Ordinal.WellFormed.html" class="Module">Ordinal.WellFormed</a> <a id="665" class="Keyword">using</a> <a id="671" class="Symbol">(</a><a id="672" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a><a id="682" class="Symbol">;</a> <a id="684" href="Ordinal.WellFormed.html#4878" class="Function">∃[n]&lt;fn</a><a id="691" class="Symbol">;</a> <a id="693" href="Ordinal.WellFormed.html#4574" class="Function">f&lt;l</a><a id="696" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="806" class="Keyword">open</a> <a id="811" class="Keyword">import</a> <a id="818" href="Data.Product.html" class="Module">Data.Product</a> <a id="831" class="Keyword">using</a> <a id="837" class="Symbol">(</a><a id="838" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="841" class="Symbol">;</a> <a id="843" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="846" class="Symbol">;</a> <a id="848" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="853" class="Symbol">;</a> <a id="855" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="860" class="Symbol">)</a>
<a id="862" class="Keyword">open</a> <a id="867" class="Keyword">import</a> <a id="874" href="Function.html" class="Module">Function</a> <a id="883" class="Keyword">using</a> <a id="889" class="Symbol">(</a><a id="890" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="893" class="Symbol">;</a> <a id="895" href="Function.Base.html#695" class="Function">id</a><a id="897" class="Symbol">)</a>
<a id="899" class="Keyword">open</a> <a id="904" class="Keyword">import</a> <a id="911" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="927" class="Keyword">using</a> <a id="933" class="Symbol">(</a><a id="934" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a><a id="944" class="Symbol">;</a> <a id="946" href="Relation.Binary.Definitions.html#4853" class="Function Operator">_Respects_</a><a id="956" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1022" class="Keyword">private</a> <a id="1030" class="Keyword">variable</a>
  <a id="1041" class="Symbol">{</a><a id="1042" href="Ordinal.Function.html#1042" class="Generalizable">F</a><a id="1043" class="Symbol">}</a> <a id="1045" class="Symbol">:</a> <a id="1047" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1051" class="Symbol">→</a> <a id="1053" href="Ordinal.html#3062" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1153" href="Ordinal.Function.html#1153" class="Function">wf-preserving</a> <a id="1167" class="Symbol">:</a> <a id="1169" class="Symbol">(</a><a id="1170" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1174" class="Symbol">→</a> <a id="1176" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1179" class="Symbol">)</a> <a id="1181" class="Symbol">→</a> <a id="1183" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1187" href="Ordinal.Function.html#1153" class="Function">wf-preserving</a> <a id="1201" href="Ordinal.Function.html#1201" class="Bound">F</a> <a id="1203" class="Symbol">=</a> <a id="1205" class="Symbol">∀</a> <a id="1207" class="Symbol">{</a><a id="1208" href="Ordinal.Function.html#1208" class="Bound">α</a><a id="1209" class="Symbol">}</a> <a id="1211" class="Symbol">→</a> <a id="1213" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="1224" href="Ordinal.Function.html#1208" class="Bound">α</a> <a id="1226" class="Symbol">→</a> <a id="1228" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="1239" class="Symbol">(</a><a id="1240" href="Ordinal.Function.html#1201" class="Bound">F</a> <a id="1242" href="Ordinal.Function.html#1208" class="Bound">α</a><a id="1243" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1273" href="Ordinal.Function.html#1273" class="Function">_</a> <a id="1275" class="Symbol">:</a> <a id="1277" href="Ordinal.Function.html#1153" class="Function">wf-preserving</a> <a id="1291" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1295" class="Symbol">_</a> <a id="1297" class="Symbol">=</a> <a id="1299" href="Function.Base.html#695" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1394" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="1407" class="Symbol">:</a> <a id="1409" class="Symbol">(</a><a id="1410" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1414" class="Symbol">→</a> <a id="1416" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1419" class="Symbol">)</a> <a id="1421" class="Symbol">→</a> <a id="1423" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1427" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="1440" href="Ordinal.Function.html#1440" class="Bound">F</a> <a id="1442" class="Symbol">=</a> <a id="1444" class="Symbol">∀</a> <a id="1446" href="Ordinal.Function.html#1446" class="Bound">α</a> <a id="1448" class="Symbol">→</a> <a id="1450" href="Ordinal.Function.html#1446" class="Bound">α</a> <a id="1452" href="Ordinal.html#4665" class="Datatype Operator">≤</a> <a id="1454" href="Ordinal.Function.html#1440" class="Bound">F</a> <a id="1456" href="Ordinal.Function.html#1446" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1459" href="Ordinal.Function.html#1459" class="Function">&lt;-increasing</a> <a id="1472" class="Symbol">:</a> <a id="1474" class="Symbol">(</a><a id="1475" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1479" class="Symbol">→</a> <a id="1481" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1484" class="Symbol">)</a> <a id="1486" class="Symbol">→</a> <a id="1488" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1492" href="Ordinal.Function.html#1459" class="Function">&lt;-increasing</a> <a id="1505" href="Ordinal.Function.html#1505" class="Bound">F</a> <a id="1507" class="Symbol">=</a> <a id="1509" class="Symbol">∀</a> <a id="1511" href="Ordinal.Function.html#1511" class="Bound">α</a> <a id="1513" class="Symbol">→</a> <a id="1515" href="Ordinal.Function.html#1511" class="Bound">α</a> <a id="1517" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="1519" href="Ordinal.Function.html#1505" class="Bound">F</a> <a id="1521" href="Ordinal.Function.html#1511" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1553" href="Ordinal.Function.html#1553" class="Function">_</a> <a id="1555" class="Symbol">:</a> <a id="1557" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="1570" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1574" class="Symbol">_</a> <a id="1576" class="Symbol">=</a> <a id="1578" class="Symbol">λ</a> <a id="1580" href="Ordinal.Function.html#1580" class="Bound">_</a> <a id="1582" class="Symbol">→</a> <a id="1584" href="Ordinal.html#7571" class="Function">≤s</a>

<a id="1588" href="Ordinal.Function.html#1588" class="Function">_</a> <a id="1590" class="Symbol">:</a> <a id="1592" href="Ordinal.Function.html#1459" class="Function">&lt;-increasing</a> <a id="1605" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="1609" class="Symbol">_</a> <a id="1611" class="Symbol">=</a> <a id="1613" class="Symbol">λ</a> <a id="1615" href="Ordinal.Function.html#1615" class="Bound">_</a> <a id="1617" class="Symbol">→</a> <a id="1619" href="Ordinal.html#11017" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1650" href="Ordinal.Function.html#1650" class="Function">&lt;⇒≤-incr</a> <a id="1659" class="Symbol">:</a> <a id="1661" href="Ordinal.Function.html#1459" class="Function">&lt;-increasing</a> <a id="1674" href="Ordinal.Function.html#1042" class="Generalizable">F</a> <a id="1676" class="Symbol">→</a> <a id="1678" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="1691" href="Ordinal.Function.html#1042" class="Generalizable">F</a>
<a id="1693" href="Ordinal.Function.html#1650" class="Function">&lt;⇒≤-incr</a> <a id="1702" class="Symbol">=</a> <a id="1704" class="Symbol">λ</a> <a id="1706" href="Ordinal.Function.html#1706" class="Bound">&lt;-incr</a> <a id="1713" href="Ordinal.Function.html#1713" class="Bound">α</a> <a id="1715" class="Symbol">→</a> <a id="1717" href="Ordinal.html#11817" class="Function">&lt;⇒≤</a> <a id="1721" class="Symbol">(</a><a id="1722" href="Ordinal.Function.html#1706" class="Bound">&lt;-incr</a> <a id="1729" href="Ordinal.Function.html#1713" class="Bound">α</a><a id="1730" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1821" href="Ordinal.Function.html#1821" class="Function">zero-increasing</a> <a id="1837" class="Symbol">:</a> <a id="1839" class="Symbol">(</a><a id="1840" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1844" class="Symbol">→</a> <a id="1846" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1849" class="Symbol">)</a> <a id="1851" class="Symbol">→</a> <a id="1853" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1857" href="Ordinal.Function.html#1821" class="Function">zero-increasing</a> <a id="1873" href="Ordinal.Function.html#1873" class="Bound">F</a> <a id="1875" class="Symbol">=</a> <a id="1877" href="Ordinal.html#3080" class="InductiveConstructor">zero</a> <a id="1882" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="1884" href="Ordinal.Function.html#1873" class="Bound">F</a> <a id="1886" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1892" href="Ordinal.Function.html#1892" class="Function">suc-increasing</a> <a id="1907" class="Symbol">:</a> <a id="1909" class="Symbol">(</a><a id="1910" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="1914" class="Symbol">→</a> <a id="1916" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="1919" class="Symbol">)</a> <a id="1921" class="Symbol">→</a> <a id="1923" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1927" href="Ordinal.Function.html#1892" class="Function">suc-increasing</a> <a id="1942" href="Ordinal.Function.html#1942" class="Bound">F</a> <a id="1944" class="Symbol">=</a> <a id="1946" class="Symbol">∀</a> <a id="1948" class="Symbol">{</a><a id="1949" href="Ordinal.Function.html#1949" class="Bound">α</a><a id="1950" class="Symbol">}</a> <a id="1952" class="Symbol">→</a> <a id="1954" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="1965" href="Ordinal.Function.html#1949" class="Bound">α</a> <a id="1967" class="Symbol">→</a> <a id="1969" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="1973" href="Ordinal.Function.html#1949" class="Bound">α</a> <a id="1975" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="1977" href="Ordinal.Function.html#1942" class="Bound">F</a> <a id="1979" class="Symbol">(</a><a id="1980" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="1984" href="Ordinal.Function.html#1949" class="Bound">α</a><a id="1985" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2042" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2054" class="Symbol">:</a> <a id="2056" class="Symbol">(</a><a id="2057" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2061" class="Symbol">→</a> <a id="2063" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2066" class="Symbol">)</a> <a id="2068" class="Symbol">→</a> <a id="2070" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2074" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2086" href="Ordinal.Function.html#2086" class="Bound">F</a> <a id="2088" class="Symbol">=</a> <a id="2090" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2101" href="Ordinal.html#4665" class="Datatype Operator">_≤_</a> <a id="2105" href="Ordinal.html#4665" class="Datatype Operator">_≤_</a> <a id="2109" href="Ordinal.Function.html#2086" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2112" href="Ordinal.Function.html#2112" class="Function">&lt;-monotonic</a> <a id="2124" class="Symbol">:</a> <a id="2126" class="Symbol">(</a><a id="2127" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2131" class="Symbol">→</a> <a id="2133" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2136" class="Symbol">)</a> <a id="2138" class="Symbol">→</a> <a id="2140" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2144" href="Ordinal.Function.html#2112" class="Function">&lt;-monotonic</a> <a id="2156" href="Ordinal.Function.html#2156" class="Bound">F</a> <a id="2158" class="Symbol">=</a> <a id="2160" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2171" href="Ordinal.html#10205" class="Function Operator">_&lt;_</a> <a id="2175" href="Ordinal.html#10205" class="Function Operator">_&lt;_</a> <a id="2179" href="Ordinal.Function.html#2156" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2211" href="Ordinal.Function.html#2211" class="Function">_</a> <a id="2213" class="Symbol">:</a> <a id="2215" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2227" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="2231" class="Symbol">_</a> <a id="2233" class="Symbol">=</a> <a id="2235" href="Ordinal.html#6414" class="Function">s≤s</a>

<a id="2240" href="Ordinal.Function.html#2240" class="Function">_</a> <a id="2242" class="Symbol">:</a> <a id="2244" href="Ordinal.Function.html#2112" class="Function">&lt;-monotonic</a> <a id="2256" href="Ordinal.html#3093" class="InductiveConstructor">suc</a>
<a id="2260" class="Symbol">_</a> <a id="2262" class="Symbol">=</a> <a id="2264" href="Ordinal.html#12675" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2323" href="Ordinal.Function.html#2323" class="Function">suc-monotonic</a> <a id="2337" class="Symbol">:</a> <a id="2339" class="Symbol">(</a><a id="2340" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2344" class="Symbol">→</a> <a id="2346" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2349" class="Symbol">)</a> <a id="2351" class="Symbol">→</a> <a id="2353" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2357" href="Ordinal.Function.html#2323" class="Function">suc-monotonic</a> <a id="2371" href="Ordinal.Function.html#2371" class="Bound">F</a> <a id="2373" class="Symbol">=</a> <a id="2375" class="Symbol">∀</a> <a id="2377" href="Ordinal.Function.html#2377" class="Bound">α</a> <a id="2379" class="Symbol">→</a> <a id="2381" href="Ordinal.Function.html#2371" class="Bound">F</a> <a id="2383" href="Ordinal.Function.html#2377" class="Bound">α</a> <a id="2385" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="2387" href="Ordinal.Function.html#2371" class="Bound">F</a> <a id="2389" class="Symbol">(</a><a id="2390" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="2394" href="Ordinal.Function.html#2377" class="Bound">α</a><a id="2395" class="Symbol">)</a>

<a id="2398" href="Ordinal.Function.html#2398" class="Function">_</a> <a id="2400" class="Symbol">:</a> <a id="2402" href="Ordinal.Function.html#2112" class="Function">&lt;-monotonic</a> <a id="2414" href="Ordinal.Function.html#1042" class="Generalizable">F</a> <a id="2416" class="Symbol">→</a> <a id="2418" href="Ordinal.Function.html#2323" class="Function">suc-monotonic</a> <a id="2432" href="Ordinal.Function.html#1042" class="Generalizable">F</a>
<a id="2434" class="Symbol">_</a> <a id="2436" class="Symbol">=</a> <a id="2438" class="Symbol">λ</a> <a id="2440" href="Ordinal.Function.html#2440" class="Bound">&lt;-mono</a> <a id="2447" href="Ordinal.Function.html#2447" class="Bound">_</a> <a id="2449" class="Symbol">→</a> <a id="2451" href="Ordinal.Function.html#2440" class="Bound">&lt;-mono</a> <a id="2458" href="Ordinal.html#11017" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="lim-continuous"></a><a id="2524" href="Ordinal.Function.html#2524" class="Function">lim-continuous</a> <a id="2539" class="Symbol">:</a> <a id="2541" class="Symbol">(</a><a id="2542" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2546" class="Symbol">→</a> <a id="2548" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2551" class="Symbol">)</a> <a id="2553" class="Symbol">→</a> <a id="2555" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2559" href="Ordinal.Function.html#2524" class="Function">lim-continuous</a> <a id="2574" href="Ordinal.Function.html#2574" class="Bound">F</a> <a id="2576" class="Symbol">=</a> <a id="2578" class="Symbol">∀</a> <a id="2580" href="Ordinal.Function.html#2580" class="Bound">f</a> <a id="2582" class="Symbol">→</a> <a id="2584" href="Ordinal.Function.html#2574" class="Bound">F</a> <a id="2586" class="Symbol">(</a><a id="2587" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2591" href="Ordinal.Function.html#2580" class="Bound">f</a><a id="2592" class="Symbol">)</a> <a id="2594" href="Ordinal.html#8006" class="Function Operator">≈</a> <a id="2596" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="2600" class="Symbol">(</a><a id="2601" href="Ordinal.Function.html#2574" class="Bound">F</a> <a id="2603" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2605" href="Ordinal.Function.html#2580" class="Bound">f</a><a id="2606" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2696" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2703" class="Symbol">:</a> <a id="2705" class="Symbol">(</a><a id="2706" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="2710" class="Symbol">→</a> <a id="2712" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="2715" class="Symbol">)</a> <a id="2717" class="Symbol">→</a> <a id="2719" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2723" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2730" href="Ordinal.Function.html#2730" class="Bound">F</a> <a id="2732" class="Symbol">=</a> <a id="2734" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="2746" href="Ordinal.Function.html#2730" class="Bound">F</a> <a id="2748" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2750" href="Ordinal.Function.html#2112" class="Function">&lt;-monotonic</a> <a id="2762" href="Ordinal.Function.html#2730" class="Bound">F</a> <a id="2764" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2766" href="Ordinal.Function.html#2524" class="Function">lim-continuous</a> <a id="2781" href="Ordinal.Function.html#2730" class="Bound">F</a>
</pre>
<p>对该定义的解释放在下一小节. 我们先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="normal⇒≤-incr"></a><a id="2899" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="2913" class="Symbol">:</a> <a id="2915" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="2922" href="Ordinal.Function.html#1042" class="Generalizable">F</a> <a id="2924" class="Symbol">→</a> <a id="2926" href="Ordinal.Function.html#1394" class="Function">≤-increasing</a> <a id="2939" href="Ordinal.Function.html#1042" class="Generalizable">F</a>
<a id="2941" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="2955" class="Symbol">{</a><a id="2956" href="Ordinal.Function.html#2956" class="Bound">F</a><a id="2957" class="Symbol">}</a> <a id="2959" href="Ordinal.Function.html#2959" class="Bound">nml</a><a id="2962" class="Symbol">@(_</a> <a id="2966" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2968" href="Ordinal.Function.html#2968" class="Bound">&lt;-mono</a> <a id="2975" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2977" href="Ordinal.Function.html#2977" class="Bound">lim-ct</a><a id="2983" class="Symbol">)</a> <a id="2985" class="Symbol">=</a>
  <a id="2989" class="Symbol">λ</a> <a id="2991" class="Symbol">{</a> <a id="2993" href="Ordinal.html#3080" class="InductiveConstructor">zero</a>    <a id="3001" class="Symbol">→</a> <a id="3003" href="Ordinal.html#4690" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">    <a id="3158" class="Symbol">;</a> <a id="3160" class="Symbol">(</a><a id="3161" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3165" href="Ordinal.Function.html#3165" class="Bound">α</a><a id="3166" class="Symbol">)</a> <a id="3168" class="Symbol">→</a>   <a id="3172" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
        <a id="3186" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3190" href="Ordinal.Function.html#3165" class="Bound">α</a>     <a id="3196" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3199" href="Ordinal.html#6414" class="Function">s≤s</a> <a id="3203" class="Symbol">(</a><a id="3204" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="3218" href="Ordinal.Function.html#2959" class="Bound">nml</a> <a id="3222" href="Ordinal.Function.html#3165" class="Bound">α</a><a id="3223" class="Symbol">)</a> <a id="3225" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3235" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3239" class="Symbol">(</a><a id="3240" href="Ordinal.Function.html#2956" class="Bound">F</a> <a id="3242" href="Ordinal.Function.html#3165" class="Bound">α</a><a id="3243" class="Symbol">)</a> <a id="3245" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3248" href="Ordinal.html#12073" class="Function">&lt;⇒s≤</a> <a id="3253" class="Symbol">(</a><a id="3254" href="Ordinal.Function.html#2968" class="Bound">&lt;-mono</a> <a id="3261" href="Ordinal.html#11017" class="Function">&lt;s</a><a id="3263" class="Symbol">)</a> <a id="3265" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3275" href="Ordinal.Function.html#2956" class="Bound">F</a> <a id="3277" class="Symbol">(</a><a id="3278" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="3282" href="Ordinal.Function.html#3165" class="Bound">α</a><a id="3283" class="Symbol">)</a> <a id="3285" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">    <a id="3427" class="Symbol">;</a> <a id="3429" class="Symbol">(</a><a id="3430" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3434" href="Ordinal.Function.html#3434" class="Bound">f</a><a id="3435" class="Symbol">)</a> <a id="3437" class="Symbol">→</a> <a id="3439" href="Ordinal.html#4786" class="InductiveConstructor">l≤</a> <a id="3442" class="Symbol">λ</a> <a id="3444" href="Ordinal.Function.html#3444" class="Bound">n</a> <a id="3446" class="Symbol">→</a> <a id="3448" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
        <a id="3462" href="Ordinal.Function.html#3434" class="Bound">f</a> <a id="3464" href="Ordinal.Function.html#3444" class="Bound">n</a>              <a id="3479" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3482" href="Ordinal.html#6093" class="Function">≤f⇒≤l</a> <a id="3488" class="Symbol">(</a><a id="3489" href="Ordinal.Function.html#2899" class="Function">normal⇒≤-incr</a> <a id="3503" href="Ordinal.Function.html#2959" class="Bound">nml</a> <a id="3507" class="Symbol">(</a><a id="3508" href="Ordinal.Function.html#3434" class="Bound">f</a> <a id="3510" href="Ordinal.Function.html#3444" class="Bound">n</a><a id="3511" class="Symbol">))</a> <a id="3514" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
        <a id="3524" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3528" class="Symbol">(</a><a id="3529" href="Ordinal.Function.html#2956" class="Bound">F</a> <a id="3531" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="3533" href="Ordinal.Function.html#3434" class="Bound">f</a><a id="3534" class="Symbol">)</a>      <a id="3541" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="3545" href="Ordinal.Function.html#2977" class="Bound">lim-ct</a> <a id="3552" href="Ordinal.Function.html#3434" class="Bound">f</a> <a id="3554" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
        <a id="3564" href="Ordinal.Function.html#2956" class="Bound">F</a> <a id="3566" class="Symbol">(</a><a id="3567" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="3571" href="Ordinal.Function.html#3434" class="Bound">f</a><a id="3572" class="Symbol">)</a>        <a id="3581" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
    <a id="3587" class="Symbol">}</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3632" href="Ordinal.Function.html#3632" class="Function Operator">_≈ᶠ_</a> <a id="3637" class="Symbol">:</a> <a id="3639" class="Symbol">(</a><a id="3640" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="3644" class="Symbol">→</a> <a id="3646" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="3649" class="Symbol">)</a> <a id="3651" class="Symbol">→</a> <a id="3653" class="Symbol">(</a><a id="3654" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="3658" class="Symbol">→</a> <a id="3660" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="3663" class="Symbol">)</a> <a id="3665" class="Symbol">→</a> <a id="3667" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="3671" href="Ordinal.Function.html#3671" class="Bound">F</a> <a id="3673" href="Ordinal.Function.html#3632" class="Function Operator">≈ᶠ</a> <a id="3676" href="Ordinal.Function.html#3676" class="Bound">G</a> <a id="3678" class="Symbol">=</a> <a id="3680" class="Symbol">∀</a> <a id="3682" class="Symbol">{</a><a id="3683" href="Ordinal.Function.html#3683" class="Bound">α</a><a id="3684" class="Symbol">}</a> <a id="3686" class="Symbol">→</a> <a id="3688" href="Ordinal.Function.html#3671" class="Bound">F</a> <a id="3690" href="Ordinal.Function.html#3683" class="Bound">α</a> <a id="3692" href="Ordinal.html#8006" class="Function Operator">≈</a> <a id="3694" href="Ordinal.Function.html#3676" class="Bound">G</a> <a id="3696" href="Ordinal.Function.html#3683" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3699" href="Ordinal.Function.html#3699" class="Function">normal-resp-≈</a> <a id="3713" class="Symbol">:</a> <a id="3715" href="Ordinal.Function.html#2696" class="Function">normal</a> <a id="3722" href="Relation.Binary.Definitions.html#4853" class="Function Operator">Respects</a> <a id="3731" href="Ordinal.Function.html#3632" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>lim-ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3847" href="Ordinal.Function.html#3699" class="Function">normal-resp-≈</a> <a id="3861" class="Symbol">{</a><a id="3862" href="Ordinal.Function.html#3862" class="Bound">F</a><a id="3863" class="Symbol">}</a> <a id="3865" class="Symbol">{</a><a id="3866" href="Ordinal.Function.html#3866" class="Bound">G</a><a id="3867" class="Symbol">}</a> <a id="3869" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="3873" class="Symbol">(</a><a id="3874" href="Ordinal.Function.html#3874" class="Bound">≤-mono</a> <a id="3881" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3883" href="Ordinal.Function.html#3883" class="Bound">&lt;-mono</a> <a id="3890" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3892" href="Ordinal.Function.html#3892" class="Bound">lim-ct</a><a id="3898" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="3997" class="Symbol">=</a> <a id="3999" class="Symbol">(λ</a> <a id="4002" class="Symbol">{</a><a id="4003" href="Ordinal.Function.html#4003" class="Bound">α</a><a id="4004" class="Symbol">}</a> <a id="4006" class="Symbol">{</a><a id="4007" href="Ordinal.Function.html#4007" class="Bound">β</a><a id="4008" class="Symbol">}</a> <a id="4010" href="Ordinal.Function.html#4010" class="Bound">α≤β</a> <a id="4014" class="Symbol">→</a> <a id="4016" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a> <a id="4022" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4024" href="Ordinal.Function.html#4003" class="Bound">α</a> <a id="4026" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4030" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4034" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4036" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4038" href="Ordinal.Function.html#4003" class="Bound">α</a> <a id="4040" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4043" href="Ordinal.Function.html#3874" class="Bound">≤-mono</a> <a id="4050" href="Ordinal.Function.html#4010" class="Bound">α≤β</a> <a id="4054" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a> <a id="4056" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4058" href="Ordinal.Function.html#4007" class="Bound">β</a> <a id="4060" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4063" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4067" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4069" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4071" href="Ordinal.Function.html#4007" class="Bound">β</a> <a id="4073" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4074" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4173" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4175" class="Symbol">(λ</a> <a id="4178" class="Symbol">{</a><a id="4179" href="Ordinal.Function.html#4179" class="Bound">α</a><a id="4180" class="Symbol">}</a> <a id="4182" class="Symbol">{</a><a id="4183" href="Ordinal.Function.html#4183" class="Bound">β</a><a id="4184" class="Symbol">}</a> <a id="4186" href="Ordinal.Function.html#4186" class="Bound">α&lt;β</a> <a id="4190" class="Symbol">→</a> <a id="4192" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a> <a id="4205" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4207" href="Ordinal.Function.html#4179" class="Bound">α</a> <a id="4209" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4213" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4217" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4219" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4221" href="Ordinal.Function.html#4179" class="Bound">α</a> <a id="4223" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="4226" href="Ordinal.Function.html#3883" class="Bound">&lt;-mono</a> <a id="4233" href="Ordinal.Function.html#4186" class="Bound">α&lt;β</a> <a id="4237" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a> <a id="4239" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4241" href="Ordinal.Function.html#4183" class="Bound">β</a> <a id="4243" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4246" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4250" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4252" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4254" href="Ordinal.Function.html#4183" class="Bound">β</a> <a id="4256" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4257" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4301" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4303" class="Symbol">(λ</a> <a id="4306" href="Ordinal.Function.html#4306" class="Bound">f</a> <a id="4308" class="Symbol">→</a> <a id="4310" href="Relation.Binary.Reasoning.Base.Triple.html#3286" class="Function Operator">begin-equality</a>
      <a id="4331" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4333" class="Symbol">(</a><a id="4334" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4338" href="Ordinal.Function.html#4306" class="Bound">f</a><a id="4339" class="Symbol">)</a>   <a id="4343" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4347" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4351" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
      <a id="4359" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4361" class="Symbol">(</a><a id="4362" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4366" href="Ordinal.Function.html#4306" class="Bound">f</a><a id="4367" class="Symbol">)</a>   <a id="4371" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4374" href="Ordinal.Function.html#3892" class="Bound">lim-ct</a> <a id="4381" href="Ordinal.Function.html#4306" class="Bound">f</a> <a id="4383" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4391" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4395" class="Symbol">(</a><a id="4396" href="Ordinal.Function.html#3862" class="Bound">F</a> <a id="4398" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4400" href="Ordinal.Function.html#4306" class="Bound">f</a><a id="4401" class="Symbol">)</a> <a id="4403" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4406" href="Ordinal.html#9016" class="Function">l≈l</a> <a id="4410" href="Ordinal.Function.html#3869" class="Bound">ext</a> <a id="4414" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4422" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="4426" class="Symbol">(</a><a id="4427" href="Ordinal.Function.html#3866" class="Bound">G</a> <a id="4429" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4431" href="Ordinal.Function.html#4306" class="Bound">f</a><a id="4432" class="Symbol">)</a> <a id="4434" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4435" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="4936" class="Keyword">open</a> <a id="4941" class="Keyword">import</a> <a id="4948" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="4969" class="Symbol">(</a><a id="4970" href="Ordinal.html#8006" class="Function Operator">_≈_</a><a id="4973" class="Symbol">)</a> <a id="4975" class="Symbol">(</a><a id="4976" href="Ordinal.html#8006" class="Function Operator">_≈_</a><a id="4979" class="Symbol">)</a> <a id="4981" class="Keyword">using</a> <a id="4987" class="Symbol">(</a><a id="4988" href="Function.Definitions.html#803" class="Function">Congruent</a><a id="4997" class="Symbol">)</a>

<a id="≤-inc⇒cong"></a><a id="5000" href="Ordinal.Function.html#5000" class="Function">≤-inc⇒cong</a> <a id="5011" class="Symbol">:</a> <a id="5013" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="5025" href="Ordinal.Function.html#1042" class="Generalizable">F</a> <a id="5027" class="Symbol">→</a> <a id="5029" href="Function.Definitions.html#803" class="Function">Congruent</a> <a id="5039" href="Ordinal.Function.html#1042" class="Generalizable">F</a>
<a id="5041" href="Ordinal.Function.html#5000" class="Function">≤-inc⇒cong</a> <a id="5052" href="Ordinal.Function.html#5052" class="Bound">≤-mono</a> <a id="5059" class="Symbol">=</a> <a id="5061" class="Symbol">λ</a> <a id="5063" class="Symbol">{</a> <a id="5065" class="Symbol">(</a><a id="5066" href="Ordinal.Function.html#5066" class="Bound">≤</a> <a id="5068" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5070" href="Ordinal.Function.html#5070" class="Bound">≥</a><a id="5071" class="Symbol">)</a> <a id="5073" class="Symbol">→</a> <a id="5075" href="Ordinal.Function.html#5052" class="Bound">≤-mono</a> <a id="5082" href="Ordinal.Function.html#5066" class="Bound">≤</a> <a id="5084" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5086" href="Ordinal.Function.html#5052" class="Bound">≤-mono</a> <a id="5093" href="Ordinal.Function.html#5070" class="Bound">≥</a> <a id="5095" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5269" href="Ordinal.Function.html#5269" class="Function">wf-&lt;-monotonic</a> <a id="5284" class="Symbol">:</a> <a id="5286" class="Symbol">(</a><a id="5287" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5291" class="Symbol">→</a> <a id="5293" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5296" class="Symbol">)</a> <a id="5298" class="Symbol">→</a> <a id="5300" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5304" href="Ordinal.Function.html#5269" class="Function">wf-&lt;-monotonic</a> <a id="5319" href="Ordinal.Function.html#5319" class="Bound">F</a> <a id="5321" class="Symbol">=</a> <a id="5323" class="Symbol">∀</a> <a id="5325" class="Symbol">{</a><a id="5326" href="Ordinal.Function.html#5326" class="Bound">α</a> <a id="5328" href="Ordinal.Function.html#5328" class="Bound">β</a><a id="5329" class="Symbol">}</a> <a id="5331" class="Symbol">→</a> <a id="5333" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="5344" href="Ordinal.Function.html#5326" class="Bound">α</a> <a id="5346" class="Symbol">→</a> <a id="5348" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="5359" href="Ordinal.Function.html#5328" class="Bound">β</a> <a id="5361" class="Symbol">→</a> <a id="5363" href="Ordinal.Function.html#5326" class="Bound">α</a> <a id="5365" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="5367" href="Ordinal.Function.html#5328" class="Bound">β</a> <a id="5369" class="Symbol">→</a> <a id="5371" href="Ordinal.Function.html#5319" class="Bound">F</a> <a id="5373" href="Ordinal.Function.html#5326" class="Bound">α</a> <a id="5375" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="5377" href="Ordinal.Function.html#5319" class="Bound">F</a> <a id="5379" href="Ordinal.Function.html#5328" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5382" href="Ordinal.Function.html#5382" class="Function">wf-suc-monotonic</a> <a id="5399" class="Symbol">:</a> <a id="5401" class="Symbol">(</a><a id="5402" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5406" class="Symbol">→</a> <a id="5408" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5411" class="Symbol">)</a> <a id="5413" class="Symbol">→</a> <a id="5415" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5419" href="Ordinal.Function.html#5382" class="Function">wf-suc-monotonic</a> <a id="5436" href="Ordinal.Function.html#5436" class="Bound">F</a> <a id="5438" class="Symbol">=</a> <a id="5440" class="Symbol">∀</a> <a id="5442" class="Symbol">{</a><a id="5443" href="Ordinal.Function.html#5443" class="Bound">α</a><a id="5444" class="Symbol">}</a> <a id="5446" class="Symbol">→</a> <a id="5448" href="Ordinal.WellFormed.html#1498" class="Function">wellFormed</a> <a id="5459" href="Ordinal.Function.html#5443" class="Bound">α</a> <a id="5461" class="Symbol">→</a> <a id="5463" href="Ordinal.Function.html#5436" class="Bound">F</a> <a id="5465" href="Ordinal.Function.html#5443" class="Bound">α</a> <a id="5467" href="Ordinal.html#10205" class="Function Operator">&lt;</a> <a id="5469" href="Ordinal.Function.html#5436" class="Bound">F</a> <a id="5471" class="Symbol">(</a><a id="5472" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5476" href="Ordinal.Function.html#5443" class="Bound">α</a><a id="5477" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5480" href="Ordinal.Function.html#5480" class="Function">wf-normal</a> <a id="5490" class="Symbol">:</a> <a id="5492" class="Symbol">(</a><a id="5493" href="Ordinal.html#3062" class="Datatype">Ord</a> <a id="5497" class="Symbol">→</a> <a id="5499" href="Ordinal.html#3062" class="Datatype">Ord</a><a id="5502" class="Symbol">)</a> <a id="5504" class="Symbol">→</a> <a id="5506" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5510" href="Ordinal.Function.html#5480" class="Function">wf-normal</a> <a id="5520" href="Ordinal.Function.html#5520" class="Bound">F</a> <a id="5522" class="Symbol">=</a> <a id="5524" href="Ordinal.Function.html#2042" class="Function">≤-monotonic</a> <a id="5536" href="Ordinal.Function.html#5520" class="Bound">F</a> <a id="5538" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5540" href="Ordinal.Function.html#5382" class="Function">wf-suc-monotonic</a> <a id="5557" href="Ordinal.Function.html#5520" class="Bound">F</a> <a id="5559" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5561" href="Ordinal.Function.html#2524" class="Function">lim-continuous</a> <a id="5576" href="Ordinal.Function.html#5520" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="wf-nml⇒&lt;-mono"></a><a id="5674" href="Ordinal.Function.html#5674" class="Function">wf-nml⇒&lt;-mono</a> <a id="5688" class="Symbol">:</a> <a id="5690" href="Ordinal.Function.html#5480" class="Function">wf-normal</a> <a id="5700" href="Ordinal.Function.html#1042" class="Generalizable">F</a> <a id="5702" class="Symbol">→</a> <a id="5704" href="Ordinal.Function.html#5269" class="Function">wf-&lt;-monotonic</a> <a id="5719" href="Ordinal.Function.html#1042" class="Generalizable">F</a>

<a id="5722" href="Ordinal.Function.html#5674" class="Function">wf-nml⇒&lt;-mono</a> <a id="5736" class="Symbol">{</a><a id="5737" href="Ordinal.Function.html#5737" class="Bound">F</a><a id="5738" class="Symbol">}</a> <a id="5740" href="Ordinal.Function.html#5740" class="Bound">nml</a><a id="5743" class="Symbol">@(</a><a id="5745" href="Ordinal.Function.html#5745" class="Bound">≤-mono</a> <a id="5752" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5754" href="Ordinal.Function.html#5754" class="Bound">suc-mono</a> <a id="5763" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5765" class="Symbol">_)</a> <a id="5768" class="Symbol">{</a><a id="5769" href="Ordinal.Function.html#5769" class="Bound">α</a><a id="5770" class="Symbol">}</a> <a id="5772" class="Symbol">{</a><a id="5773" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5777" href="Ordinal.Function.html#5777" class="Bound">β</a><a id="5778" class="Symbol">}</a> <a id="5780" href="Ordinal.Function.html#5780" class="Bound">wfα</a> <a id="5784" href="Ordinal.Function.html#5784" class="Bound">wfβ</a> <a id="5788" href="Ordinal.Function.html#5788" class="Bound">α&lt;s</a> <a id="5792" class="Symbol">=</a> <a id="5794" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
  <a id="5809" href="Ordinal.Function.html#5737" class="Bound">F</a> <a id="5811" href="Ordinal.Function.html#5769" class="Bound">α</a>       <a id="5819" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5822" href="Ordinal.Function.html#5745" class="Bound">≤-mono</a> <a id="5829" class="Symbol">(</a><a id="5830" href="Ordinal.html#12339" class="Function">&lt;s⇒≤</a> <a id="5835" href="Ordinal.Function.html#5788" class="Bound">α&lt;s</a><a id="5838" class="Symbol">)</a> <a id="5840" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
  <a id="5844" href="Ordinal.Function.html#5737" class="Bound">F</a> <a id="5846" href="Ordinal.Function.html#5777" class="Bound">β</a>       <a id="5854" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="5857" href="Ordinal.Function.html#5754" class="Bound">suc-mono</a> <a id="5866" href="Ordinal.Function.html#5784" class="Bound">wfβ</a> <a id="5870" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
  <a id="5874" href="Ordinal.Function.html#5737" class="Bound">F</a> <a id="5876" class="Symbol">(</a><a id="5877" href="Ordinal.html#3093" class="InductiveConstructor">suc</a> <a id="5881" href="Ordinal.Function.html#5777" class="Bound">β</a><a id="5882" class="Symbol">)</a> <a id="5884" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>

<a id="5887" href="Ordinal.Function.html#5674" class="Function">wf-nml⇒&lt;-mono</a> <a id="5901" class="Symbol">{</a><a id="5902" href="Ordinal.Function.html#5902" class="Bound">F</a><a id="5903" class="Symbol">}</a> <a id="5905" href="Ordinal.Function.html#5905" class="Bound">nml</a><a id="5908" class="Symbol">@(_</a> <a id="5912" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5914" class="Symbol">_</a> <a id="5916" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5918" href="Ordinal.Function.html#5918" class="Bound">lim-ct</a><a id="5924" class="Symbol">)</a> <a id="5926" class="Symbol">{</a><a id="5927" href="Ordinal.Function.html#5927" class="Bound">α</a><a id="5928" class="Symbol">}</a> <a id="5930" class="Symbol">{</a><a id="5931" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="5935" href="Ordinal.Function.html#5935" class="Bound">f</a><a id="5936" class="Symbol">}</a> <a id="5938" href="Ordinal.Function.html#5938" class="Bound">wfα</a> <a id="5942" href="Ordinal.Function.html#5942" class="Bound">wfβ</a><a id="5945" class="Symbol">@(</a><a id="5947" href="Ordinal.Function.html#5947" class="Bound">wfn</a> <a id="5951" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5953" href="Ordinal.Function.html#5953" class="Bound">mono</a><a id="5957" class="Symbol">)</a> <a id="5959" href="Ordinal.Function.html#5959" class="Bound">α&lt;l</a>
  <a id="5965" class="Keyword">with</a> <a id="5970" href="Ordinal.WellFormed.html#4878" class="Function">∃[n]&lt;fn</a> <a id="5978" href="Ordinal.Function.html#5953" class="Bound">mono</a> <a id="5983" href="Ordinal.Function.html#5959" class="Bound">α&lt;l</a>
<a id="5987" class="Symbol">...</a> <a id="5991" class="Symbol">|</a> <a id="5993" class="Symbol">(</a><a id="5994" href="Ordinal.Function.html#5994" class="Bound">n</a> <a id="5996" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5998" href="Ordinal.Function.html#5998" class="Bound">α&lt;fn</a><a id="6002" class="Symbol">)</a> <a id="6004" class="Symbol">=</a> <a id="6006" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
      <a id="6025" class="Bound">F</a> <a id="6027" class="Bound">α</a>          <a id="6038" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6041" href="Ordinal.Function.html#5674" class="Function">wf-nml⇒&lt;-mono</a> <a id="6055" class="Bound">nml</a> <a id="6059" class="Bound">wfα</a> <a id="6063" class="Bound">wfn</a> <a id="6067" href="Ordinal.Function.html#5998" class="Bound">α&lt;fn</a> <a id="6072" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
      <a id="6080" class="Bound">F</a> <a id="6082" class="Symbol">(</a><a id="6083" class="Bound">f</a> <a id="6085" href="Ordinal.Function.html#5994" class="Bound">n</a><a id="6086" class="Symbol">)</a>      <a id="6093" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6096" href="Ordinal.WellFormed.html#4574" class="Function">f&lt;l</a> <a id="6100" class="Symbol">(λ</a> <a id="6103" href="Ordinal.Function.html#6103" class="Bound">m&lt;n</a> <a id="6107" class="Symbol">→</a> <a id="6109" href="Ordinal.Function.html#5674" class="Function">wf-nml⇒&lt;-mono</a> <a id="6123" class="Bound">nml</a> <a id="6127" class="Bound">wfn</a> <a id="6131" class="Bound">wfn</a> <a id="6135" class="Symbol">(</a><a id="6136" class="Bound">mono</a> <a id="6141" href="Ordinal.Function.html#6103" class="Bound">m&lt;n</a><a id="6144" class="Symbol">))</a> <a id="6147" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
      <a id="6155" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6159" class="Symbol">(</a><a id="6160" class="Bound">F</a> <a id="6162" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="6164" class="Bound">f</a><a id="6165" class="Symbol">)</a>  <a id="6168" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="6172" class="Bound">lim-ct</a> <a id="6179" class="Bound">f</a> <a id="6181" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
      <a id="6189" class="Bound">F</a> <a id="6191" class="Symbol">(</a><a id="6192" href="Ordinal.html#3112" class="InductiveConstructor">lim</a> <a id="6196" class="Bound">f</a><a id="6197" class="Symbol">)</a>    <a id="6202" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
