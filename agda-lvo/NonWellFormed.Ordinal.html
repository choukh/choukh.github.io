<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(1-1) 序数的定义</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Agda大序数(1-1) 序数的定义</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数1-1-序数的定义" id="toc-agda大序数1-1-序数的定义">Agda大序数(1-1) 序数的定义</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数" id="toc-序数">序数</a></li>
  <li><a href="#前驱" id="toc-前驱">前驱</a></li>
  <li><a href="#非严格序" id="toc-非严格序">非严格序</a></li>
  <li><a href="#外延相等" id="toc-外延相等">外延相等</a></li>
  <li><a href="#否命题" id="toc-否命题">否命题</a></li>
  <li><a href="#严格序" id="toc-严格序">严格序</a></li>
  <li><a href="#与-的相互转化" id="toc-与-的相互转化"><code>&lt;</code> 与 <code>≤</code> 的相互转化</a></li>
  <li><a href="#序结构" id="toc-序结构">序结构</a></li>
  <li><a href="#序数广集" id="toc-序数广集">序数广集</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数1-1-序数的定义">Agda大序数(1-1) 序数的定义</h1>
<blockquote>
<p>交流Q群: 893531731<br />
目录: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.html">NonWellFormed.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/NonWellFormed/Ordinal.lagda.md">Ordinal.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.Ordinal.html">Ordinal.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章介绍一种基于类型论的序数理论, 并以实现大 Veblen 序数, 即 <a href="https://en.wikipedia.org/wiki/Large_Veblen_ordinal">LVO</a> 的形式化为最终目标. 我们采用标准 Agda 作为基础, 仅依赖于标准库 <a href="https://agda.github.io/agda-stdlib/index">agda-stdlib</a>, 并且打开了社区公认安全 (可期待一致性) 的 flag</p>
<pre class="Agda"><a id="672" class="Symbol">{-#</a> <a id="676" class="Keyword">OPTIONS</a> <a id="684" class="Pragma">--without-K</a> <a id="696" class="Pragma">--safe</a> <a id="703" class="Symbol">#-}</a>
</pre>
<p>以实现无公理且构造主义的直谓可计算序数.</p>
<p>具体地, 我们实现了超限归纳法的类型论对应, 以及序数算术和 Veblen 不动点理论, 并以此定义了二元 Veblen 函数, n元 Veblen 函数乃至序数元 Veblen 函数. 得益于其可计算特性, 我们的序数可用于快速增长层级等大数函数,并得到可计算的大数, 如 <span class="math inline">f_{LVO}(3)</span>. 虽然现实中计算不出来, 但其停机性由 Agda 的 <a href="https://agda.readthedocs.io/en/v2.6.2.2/language/termination-checking.html">Termination Checking</a> 保证.</p>
<p>本文为文学Agda脚本, 既是 markdown 文件, 也是可通过类型检查的 Agda 源码. 原文件托管于本项目的 Github 仓库 <a href="https://github.com/choukh/agda-lvo">agda-lvo</a>.</p>
<pre class="Agda"><a id="1143" class="Keyword">module</a> <a id="1150" href="NonWellFormed.Ordinal.html" class="Module">NonWellFormed.Ordinal</a> <a id="1172" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<ul>
<li>了解<a href="https://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers">冯诺依曼序数</a></li>
<li>Agda语言达到 <a href="https://agda-zh.github.io/PLFA-zh/">PLFA</a> 第一册水平</li>
<li>理解以下<a href="https://agda.github.io/agda-stdlib/index">标准库</a>依赖所涉及的数学概念</li>
</ul>
<p>我们只使用最底层的宇宙, 因此导入了 <code>0ℓ</code> 以实例化库中其他宇宙多态类型. 我们需要自然数来定义序数, 但本章暂不需要关于自然数的理论, 所以只导入了 <code>ℕ</code>. 我们还导入了函数复合 <code>_∘_</code> 以及显式参数转隐式的算子 <code>λ-</code>.</p>
<pre class="Agda"><a id="1531" class="Keyword">open</a> <a id="1536" class="Keyword">import</a> <a id="1543" href="Level.html" class="Module">Level</a> <a id="1549" class="Keyword">using</a> <a id="1555" class="Symbol">(</a><a id="1556" href="Level.html#521" class="Function">0ℓ</a><a id="1558" class="Symbol">)</a>
<a id="1560" class="Keyword">open</a> <a id="1565" class="Keyword">import</a> <a id="1572" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="1581" class="Keyword">using</a> <a id="1587" class="Symbol">(</a><a id="1588" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1589" class="Symbol">)</a>
<a id="1591" class="Keyword">open</a> <a id="1596" class="Keyword">import</a> <a id="1603" href="Function.html" class="Module">Function</a> <a id="1612" class="Keyword">using</a> <a id="1618" class="Symbol">(</a><a id="1619" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="1622" class="Symbol">;</a> <a id="1624" href="Function.Base.html#2790" class="Function">λ-</a><a id="1626" class="Symbol">)</a>
</pre>
<p>接下来是一些基本的逻辑概念. 其中空类型 <code>⊥</code> 和单值类型 <code>⊤</code> 都将用于序数的定义. 和类型 <code>_⊎_</code> 用作析取, 积类型 <code>_×_</code> 用作合取, 而存在量词 <code>∃</code> 只是 Σ类型上的一种 syntax. 本质上, <code>_×_</code> 和 <code>∃</code> 都是 Σ类型的特化, 都可以用 <code>_,_</code> 解构.</p>
<pre class="Agda"><a id="1792" class="Keyword">open</a> <a id="1797" class="Keyword">import</a> <a id="1804" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="1815" class="Keyword">using</a> <a id="1821" class="Symbol">(</a><a id="1822" href="Data.Empty.html#895" class="Function">⊥</a><a id="1823" class="Symbol">)</a>
<a id="1825" class="Keyword">open</a> <a id="1830" class="Keyword">import</a> <a id="1837" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="1847" class="Keyword">using</a> <a id="1853" class="Symbol">(</a><a id="1854" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="1855" class="Symbol">;</a> <a id="1857" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1859" class="Symbol">)</a>
<a id="1861" class="Keyword">open</a> <a id="1866" class="Keyword">import</a> <a id="1873" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1890" class="Keyword">using</a> <a id="1896" class="Symbol">(</a><a id="1897" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬_</a><a id="1899" class="Symbol">)</a>
<a id="1901" class="Keyword">open</a> <a id="1906" class="Keyword">import</a> <a id="1913" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="1922" class="Keyword">using</a> <a id="1928" class="Symbol">(</a><a id="1929" href="Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="1932" class="Symbol">;</a> <a id="1934" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="1938" class="Symbol">;</a> <a id="1940" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="1944" class="Symbol">)</a>
<a id="1946" class="Keyword">open</a> <a id="1951" class="Keyword">import</a> <a id="1958" href="Data.Product.html" class="Module">Data.Product</a> <a id="1971" class="Keyword">using</a> <a id="1977" class="Symbol">(</a><a id="1978" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="1979" class="Symbol">;</a> <a id="1981" href="Data.Product.Base.html#1118" class="Function Operator">_×_</a><a id="1984" class="Symbol">;</a> <a id="1986" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="1989" class="Symbol">;</a> <a id="1991" href="Data.Product.Base.html#617" class="Field">proj₁</a><a id="1996" class="Symbol">;</a> <a id="1998" href="Data.Product.Base.html#631" class="Field">proj₂</a><a id="2003" class="Symbol">;</a> <a id="2005" href="Data.Product.html#1094" class="Function">∃-syntax</a><a id="2013" class="Symbol">)</a>
</pre>
<p><code>Rel</code> 用于定义序数上的序关系. 我们将证明这些序关系的性质, 如自反性, 对称性, 等等, 因此导入了相应的定义和引理. 虽然大部分情况下我们都使用 <code>OrdSetoid</code> 中的等价关系 <code>_≈_</code>, 但我们会尽量尝试建立内涵相等 <code>_≡_</code>, 它蕴含我们的 <code>_≈_</code>.</p>
<pre class="Agda"><a id="2169" class="Keyword">open</a> <a id="2174" class="Keyword">import</a> <a id="2181" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="2197" class="Keyword">using</a> <a id="2203" class="Symbol">(</a><a id="2204" href="Relation.Binary.Core.html#891" class="Function">Rel</a><a id="2207" class="Symbol">;</a> <a id="2209" href="Relation.Binary.Core.html#1263" class="Function Operator">_⇒_</a><a id="2212" class="Symbol">)</a>
<a id="2214" class="Keyword">open</a> <a id="2219" class="Keyword">import</a> <a id="2226" href="Relation.Binary.Definitions.html" class="Module">Relation.Binary.Definitions</a>
  <a id="2256" class="Keyword">using</a> <a id="2262" class="Symbol">(</a><a id="2263" href="Relation.Binary.Definitions.html#1413" class="Function">Reflexive</a><a id="2272" class="Symbol">;</a> <a id="2274" href="Relation.Binary.Definitions.html#1572" class="Function">Symmetric</a><a id="2283" class="Symbol">;</a> <a id="2285" href="Relation.Binary.Definitions.html#1940" class="Function">Transitive</a><a id="2295" class="Symbol">;</a> <a id="2297" href="Relation.Binary.Definitions.html#1659" class="Function">Trans</a><a id="2302" class="Symbol">;</a> <a id="2304" href="Relation.Binary.Definitions.html#2315" class="Function">Irreflexive</a><a id="2315" class="Symbol">;</a> <a id="2317" href="Relation.Binary.Definitions.html#2427" class="Function">Asymmetric</a><a id="2327" class="Symbol">)</a>
<a id="2329" class="Keyword">open</a> <a id="2334" class="Keyword">import</a> <a id="2341" href="Relation.Binary.Consequences.html" class="Module">Relation.Binary.Consequences</a> <a id="2370" class="Keyword">using</a> <a id="2376" class="Symbol">(</a><a id="2377" href="Relation.Binary.Consequences.html#4013" class="Function">trans∧irr⇒asym</a><a id="2391" class="Symbol">)</a>
<a id="2393" class="Keyword">open</a> <a id="2398" class="Keyword">import</a> <a id="2405" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2443" class="Symbol">as</a> <a id="2446" class="Module">Eq</a> <a id="2449" class="Keyword">using</a> <a id="2455" class="Symbol">(</a><a id="2456" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="2459" class="Symbol">;</a> <a id="2461" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2465" class="Symbol">)</a>
</pre>
<p>以下三个模块, 第一个以”当且仅当”为等价关系建立了 <code>⇔-setoid</code>, 第二个允许我们对 <code>_⇔_</code> 等价式做改写推理, 第三个允许我们从 <code>_⇔_</code> 中恢复蕴含式.</p>
<pre class="Agda"><a id="2568" class="Keyword">open</a> <a id="2573" class="Keyword">import</a> <a id="2580" href="Function.Equivalence.html" class="Module">Function.Equivalence</a>
  <a id="2603" class="Keyword">using</a> <a id="2609" class="Symbol">(</a><a id="2610" href="Function.Equivalence.html#838" class="Record">Equivalence</a><a id="2621" class="Symbol">;</a> <a id="2623" href="Function.Equivalence.html#1213" class="Function Operator">_⇔_</a><a id="2626" class="Symbol">;</a> <a id="2628" href="Function.Equivalence.html#2586" class="Function">⇔-setoid</a><a id="2636" class="Symbol">)</a> <a id="2638" class="Keyword">renaming</a> <a id="2647" class="Symbol">(</a><a id="2648" href="Function.Equivalence.html#1306" class="Function">equivalence</a> <a id="2660" class="Symbol">to</a> <a id="2663" class="Function">mk⇔</a><a id="2666" class="Symbol">)</a>
<a id="2668" class="Keyword">open</a> <a id="2673" class="Keyword">import</a> <a id="2680" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="2713" class="Symbol">(</a><a id="2714" href="Function.Equivalence.html#2586" class="Function">⇔-setoid</a> <a id="2723" href="Level.html#521" class="Function">0ℓ</a><a id="2725" class="Symbol">)</a>
  <a id="2729" class="Keyword">using</a> <a id="2735" class="Symbol">(</a><a id="2736" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin_</a><a id="2742" class="Symbol">;</a> <a id="2744" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">step-≈</a><a id="2750" class="Symbol">;</a> <a id="2752" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">_∎</a><a id="2754" class="Symbol">)</a>
<a id="2756" class="Keyword">open</a> <a id="2761" class="Keyword">import</a> <a id="2768" href="Function.Equality.html" class="Module">Function.Equality</a> <a id="2786" class="Keyword">using</a> <a id="2792" class="Symbol">(</a><a id="2793" href="Function.Equality.html#1073" class="Field Operator">_⟨$⟩_</a><a id="2798" class="Symbol">)</a>
</pre>
<h2 id="序数">序数</h2>
<p>我们知道自然数 <code>ℕ</code> 有两个构造子: 零和后继. 序数则在此基础上增加了极限构造子 <code>lim</code>. 如果 <code>f</code> 是 <code>ℕ</code> 到序数的函数, 那么 <code>lim f</code> 也是序数. 这样的 <code>f</code> 又叫做 <code>lim f</code> 的基本序列 (fundamental sequence)<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 严格来说基本序列要求典范性, 但我们这里不追求, 转而使用广集来处理多个序列表示同一个序数的问题.<br />
<br />
</span></span>, 而 <code>lim f</code> 则是基本序列 <code>f</code> 的极限. 这样的定义允许我们很方便地讨论零, 后继序数, 极限序数三种情况.</p>
<pre class="Agda"><a id="3082" class="Keyword">data</a> <a id="Ord"></a><a id="3087" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="3091" class="Symbol">:</a> <a id="3093" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3097" class="Keyword">where</a>
  <a id="Ord.zero"></a><a id="3105" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a> <a id="3110" class="Symbol">:</a> <a id="3112" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
  <a id="Ord.suc"></a><a id="3118" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>  <a id="3123" class="Symbol">:</a> <a id="3125" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="3129" class="Symbol">→</a> <a id="3131" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
  <a id="Ord.lim"></a><a id="3137" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a>  <a id="3142" class="Symbol">:</a> <a id="3144" class="Symbol">(</a><a id="3145" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3147" class="Symbol">→</a> <a id="3149" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="3152" class="Symbol">)</a> <a id="3154" class="Symbol">→</a> <a id="3156" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
</pre>
<p>严格来说基本序列要求单调性, 因此这里定义的 <code>Ord</code> 比真正的序数要宽泛很多. 我们将在下一章引入一个”良构”谓词来解决这个问题. 并且我们会在后续章节证明我们构造的序数函数都是保良构的. 不过现在这点并不影响我们建立序数的序关系, 如果影响的话我们根本就不可能表达单调性.</p>
<p>以下是构造子单射的例行证明.</p>
<pre class="Agda"><a id="suc-injective"></a><a id="3330" href="NonWellFormed.Ordinal.html#3330" class="Function">suc-injective</a> <a id="3344" class="Symbol">:</a> <a id="3346" class="Symbol">∀</a> <a id="3348" class="Symbol">{</a><a id="3349" href="NonWellFormed.Ordinal.html#3349" class="Bound">α</a> <a id="3351" href="NonWellFormed.Ordinal.html#3351" class="Bound">β</a><a id="3352" class="Symbol">}</a> <a id="3354" class="Symbol">→</a> <a id="3356" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3360" href="NonWellFormed.Ordinal.html#3349" class="Bound">α</a> <a id="3362" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3364" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3368" href="NonWellFormed.Ordinal.html#3351" class="Bound">β</a> <a id="3370" class="Symbol">→</a> <a id="3372" href="NonWellFormed.Ordinal.html#3349" class="Bound">α</a> <a id="3374" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3376" href="NonWellFormed.Ordinal.html#3351" class="Bound">β</a>
<a id="3378" href="NonWellFormed.Ordinal.html#3330" class="Function">suc-injective</a> <a id="3392" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3397" class="Symbol">=</a> <a id="3399" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lim-injective"></a><a id="3405" href="NonWellFormed.Ordinal.html#3405" class="Function">lim-injective</a> <a id="3419" class="Symbol">:</a> <a id="3421" class="Symbol">∀</a> <a id="3423" class="Symbol">{</a><a id="3424" href="NonWellFormed.Ordinal.html#3424" class="Bound">f</a> <a id="3426" href="NonWellFormed.Ordinal.html#3426" class="Bound">g</a><a id="3427" class="Symbol">}</a> <a id="3429" class="Symbol">→</a> <a id="3431" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3435" href="NonWellFormed.Ordinal.html#3424" class="Bound">f</a> <a id="3437" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3439" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3443" href="NonWellFormed.Ordinal.html#3426" class="Bound">g</a> <a id="3445" class="Symbol">→</a> <a id="3447" href="NonWellFormed.Ordinal.html#3424" class="Bound">f</a> <a id="3449" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3451" href="NonWellFormed.Ordinal.html#3426" class="Bound">g</a>
<a id="3453" href="NonWellFormed.Ordinal.html#3405" class="Function">lim-injective</a> <a id="3467" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3472" class="Symbol">=</a> <a id="3474" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="前驱">前驱</h2>
<p>为了定义序关系我们需要引入一个辅助概念, 叫做前驱<strong>深度</strong> <code>Depth</code>, 它是以序数为索引的类型. 零没有前驱, 因此 <code>Depth zero</code> 没有任何可能的取值, 即为 ⊥. 后继序数 <code>suc α</code> 的前驱要么是其直接前驱 <code>α</code>, 要么是 <code>α</code> 的前驱, 因此 <code>Depth (suc α)</code> 的可能取值要么是 <code>tt</code> 要么是 <code>Depth α</code>. 极限序数 <code>lim f</code> 的前驱是所有 <code>f n</code> 的前驱, 因此 <code>Depth (lim f)</code> 的可能取值是 <code>Depth (f n)</code> 对 <code>n</code> 求和.</p>
<pre class="Agda"><a id="Depth"></a><a id="3766" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3772" class="Symbol">:</a> <a id="3774" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="3778" class="Symbol">→</a> <a id="3780" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="3784" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3790" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a>    <a id="3798" class="Symbol">=</a> <a id="3800" href="Data.Empty.html#895" class="Function">⊥</a>
<a id="3802" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3808" class="Symbol">(</a><a id="3809" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3813" href="NonWellFormed.Ordinal.html#3813" class="Bound">α</a><a id="3814" class="Symbol">)</a> <a id="3816" class="Symbol">=</a> <a id="3818" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="3820" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="3822" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3828" href="NonWellFormed.Ordinal.html#3813" class="Bound">α</a>
<a id="3830" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3836" class="Symbol">(</a><a id="3837" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3841" href="NonWellFormed.Ordinal.html#3841" class="Bound">f</a><a id="3842" class="Symbol">)</a> <a id="3844" class="Symbol">=</a> <a id="3846" href="Data.Product.html#1094" class="Function">∃[</a> <a id="3849" href="NonWellFormed.Ordinal.html#3849" class="Bound">n</a> <a id="3851" href="Data.Product.html#1094" class="Function">]</a> <a id="3853" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="3859" class="Symbol">(</a><a id="3860" href="NonWellFormed.Ordinal.html#3841" class="Bound">f</a> <a id="3862" href="NonWellFormed.Ordinal.html#3849" class="Bound">n</a><a id="3863" class="Symbol">)</a>
</pre>
<p>现在我们可以定义前驱运算 <code>_∸_</code> 了. 对任意序数 <code>α</code> 和 <code>α</code> 的任意前驱深度 <code>d : Depth α</code>, 我们可以计算出 <code>α</code> 在深度 <code>d</code> 处的前驱 <code>α ∸ d</code>. 具体地</p>
<ul>
<li><code>α</code> 为零的情况不存在, Agda 可以直接识别出这一点</li>
<li>对后继序数 <code>suc α</code>, 解构 <code>d : Depth (suc α)</code>
<ul>
<li>若为 <code>tt</code>, 那么取直接前驱 <code>α</code></li>
<li>若为 <code>d : Depth α</code>, 那么递归计算 <code>α ∸ d</code></li>
</ul></li>
<li>对极限序数 <code>lim f</code>, 解构 <code>d : Depth (lim f)</code>, 必然存在 <code>n : ℕ</code> 使得 <code>d : Depth (f n)</code>, 我们递归计算 <code>f n ∸ d</code></li>
</ul>
<pre class="Agda"><a id="4206" class="Keyword">infixl</a> <a id="4213" class="Number">6</a> <a id="4215" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">_∸_</a>

<a id="_∸_"></a><a id="4220" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">_∸_</a> <a id="4224" class="Symbol">:</a> <a id="4226" class="Symbol">∀</a> <a id="4228" href="NonWellFormed.Ordinal.html#4228" class="Bound">α</a> <a id="4230" class="Symbol">→</a> <a id="4232" href="NonWellFormed.Ordinal.html#3766" class="Function">Depth</a> <a id="4238" href="NonWellFormed.Ordinal.html#4228" class="Bound">α</a> <a id="4240" class="Symbol">→</a> <a id="4242" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
<a id="4246" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="4250" href="NonWellFormed.Ordinal.html#4250" class="Bound">α</a> <a id="4252" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4254" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="4259" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="4262" class="Symbol">=</a> <a id="4264" href="NonWellFormed.Ordinal.html#4250" class="Bound">α</a>
<a id="4266" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="4270" href="NonWellFormed.Ordinal.html#4270" class="Bound">α</a> <a id="4272" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4274" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4279" href="NonWellFormed.Ordinal.html#4279" class="Bound">d</a>  <a id="4282" class="Symbol">=</a> <a id="4284" href="NonWellFormed.Ordinal.html#4270" class="Bound">α</a> <a id="4286" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4288" href="NonWellFormed.Ordinal.html#4279" class="Bound">d</a>
<a id="4290" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4294" href="NonWellFormed.Ordinal.html#4294" class="Bound">f</a> <a id="4296" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4298" class="Symbol">(</a><a id="4299" href="NonWellFormed.Ordinal.html#4299" class="Bound">n</a> <a id="4301" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4303" href="NonWellFormed.Ordinal.html#4303" class="Bound">d</a><a id="4304" class="Symbol">)</a> <a id="4306" class="Symbol">=</a> <a id="4308" href="NonWellFormed.Ordinal.html#4294" class="Bound">f</a> <a id="4310" href="NonWellFormed.Ordinal.html#4299" class="Bound">n</a> <a id="4312" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4314" href="NonWellFormed.Ordinal.html#4303" class="Bound">d</a>
</pre>
<h2 id="非严格序">非严格序</h2>
<p>序数上的非严格序 <code>_≤_</code> 归纳定义为三种情况. 第一种 <code>zero ≤ β</code> 是无条件成立的, 这与 <code>ℕ</code> 的 <a href="https://choukh.github.io/agda-lvo/Data.Nat.Base.html#1547"><code>z≤n</code></a> 一样. 第二种 <code>suc α ≤ β</code> 要求存在 <code>β</code> 的某个前驱 <code>β ∸ d</code> 使得 <code>α ≤ β ∸ d</code>. 这类似于自然数的 <a href="https://choukh.github.io/agda-lvo/Data.Nat.Base.html#1589"><code>s≤s</code></a>, 只是右边还包括了极限的情况. 第三种 <code>lim f ≤ β</code> 要求 <code>β</code> 大于等于基本序列 <code>f</code> 的每一个取值.</p>
<pre class="Agda"><a id="4660" class="Keyword">infix</a> <a id="4666" class="Number">4</a> <a id="4668" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="4672" href="NonWellFormed.Ordinal.html#4858" class="Function Operator">_≥_</a> <a id="4676" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">_≰_</a> <a id="4680" href="NonWellFormed.Ordinal.html#4924" class="Function Operator">_≱_</a>

<a id="4685" class="Keyword">data</a> <a id="_≤_"></a><a id="4690" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="4694" class="Symbol">:</a> <a id="4696" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="4700" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="4704" href="Level.html#521" class="Function">0ℓ</a> <a id="4707" class="Keyword">where</a>
  <a id="_≤_.z≤"></a><a id="4715" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a> <a id="4718" class="Symbol">:</a> <a id="4720" class="Symbol">∀</a> <a id="4722" class="Symbol">{</a><a id="4723" href="NonWellFormed.Ordinal.html#4723" class="Bound">β</a><a id="4724" class="Symbol">}</a>                        <a id="4749" class="Symbol">→</a> <a id="4751" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a>  <a id="4757" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4759" href="NonWellFormed.Ordinal.html#4723" class="Bound">β</a>
  <a id="_≤_.s≤"></a><a id="4763" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="4766" class="Symbol">:</a> <a id="4768" class="Symbol">∀</a> <a id="4770" class="Symbol">{</a><a id="4771" href="NonWellFormed.Ordinal.html#4771" class="Bound">α</a> <a id="4773" href="NonWellFormed.Ordinal.html#4773" class="Bound">β</a> <a id="4775" href="NonWellFormed.Ordinal.html#4775" class="Bound">d</a><a id="4776" class="Symbol">}</a>  <a id="4779" class="Symbol">→</a> <a id="4781" href="NonWellFormed.Ordinal.html#4771" class="Bound">α</a> <a id="4783" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4785" href="NonWellFormed.Ordinal.html#4773" class="Bound">β</a> <a id="4787" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="4789" href="NonWellFormed.Ordinal.html#4775" class="Bound">d</a>       <a id="4797" class="Symbol">→</a> <a id="4799" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="4803" href="NonWellFormed.Ordinal.html#4771" class="Bound">α</a> <a id="4805" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4807" href="NonWellFormed.Ordinal.html#4773" class="Bound">β</a>
  <a id="_≤_.l≤"></a><a id="4811" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="4814" class="Symbol">:</a> <a id="4816" class="Symbol">∀</a> <a id="4818" class="Symbol">{</a><a id="4819" href="NonWellFormed.Ordinal.html#4819" class="Bound">f</a> <a id="4821" href="NonWellFormed.Ordinal.html#4821" class="Bound">β</a><a id="4822" class="Symbol">}</a>    <a id="4827" class="Symbol">→</a> <a id="4829" class="Symbol">(∀</a> <a id="4832" href="NonWellFormed.Ordinal.html#4832" class="Bound">n</a> <a id="4834" class="Symbol">→</a> <a id="4836" href="NonWellFormed.Ordinal.html#4819" class="Bound">f</a> <a id="4838" href="NonWellFormed.Ordinal.html#4832" class="Bound">n</a> <a id="4840" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4842" href="NonWellFormed.Ordinal.html#4821" class="Bound">β</a><a id="4843" class="Symbol">)</a> <a id="4845" class="Symbol">→</a> <a id="4847" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4851" href="NonWellFormed.Ordinal.html#4819" class="Bound">f</a> <a id="4853" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4855" href="NonWellFormed.Ordinal.html#4821" class="Bound">β</a>

<a id="_≥_"></a><a id="4858" href="NonWellFormed.Ordinal.html#4858" class="Function Operator">_≥_</a> <a id="4862" class="Symbol">:</a> <a id="4864" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="4868" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="4872" href="Level.html#521" class="Function">0ℓ</a>
<a id="4875" href="NonWellFormed.Ordinal.html#4875" class="Bound">α</a> <a id="4877" href="NonWellFormed.Ordinal.html#4858" class="Function Operator">≥</a> <a id="4879" href="NonWellFormed.Ordinal.html#4879" class="Bound">β</a> <a id="4881" class="Symbol">=</a> <a id="4883" href="NonWellFormed.Ordinal.html#4879" class="Bound">β</a> <a id="4885" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4887" href="NonWellFormed.Ordinal.html#4875" class="Bound">α</a>

<a id="_≰_"></a><a id="4890" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">_≰_</a> <a id="4894" class="Symbol">:</a> <a id="4896" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="4900" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="4904" href="Level.html#521" class="Function">0ℓ</a>
<a id="4907" href="NonWellFormed.Ordinal.html#4907" class="Bound">α</a> <a id="4909" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">≰</a> <a id="4911" href="NonWellFormed.Ordinal.html#4911" class="Bound">β</a> <a id="4913" class="Symbol">=</a> <a id="4915" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬</a> <a id="4917" href="NonWellFormed.Ordinal.html#4907" class="Bound">α</a> <a id="4919" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4921" href="NonWellFormed.Ordinal.html#4911" class="Bound">β</a>

<a id="_≱_"></a><a id="4924" href="NonWellFormed.Ordinal.html#4924" class="Function Operator">_≱_</a> <a id="4928" class="Symbol">:</a> <a id="4930" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="4934" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="4938" href="Level.html#521" class="Function">0ℓ</a>
<a id="4941" href="NonWellFormed.Ordinal.html#4941" class="Bound">α</a> <a id="4943" href="NonWellFormed.Ordinal.html#4924" class="Function Operator">≱</a> <a id="4945" href="NonWellFormed.Ordinal.html#4945" class="Bound">β</a> <a id="4947" class="Symbol">=</a> <a id="4949" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬</a> <a id="4951" href="NonWellFormed.Ordinal.html#4945" class="Bound">β</a> <a id="4953" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="4955" href="NonWellFormed.Ordinal.html#4941" class="Bound">α</a>
</pre>
<p>由此定义可以证明以下基本事实.</p>
<p><strong>引理</strong> 如果 <code>α</code> 小于等于 <code>β</code> 的任意前驱, 那么 <code>α ≤ β</code>.<br />
<strong>证明</strong> 讨论 <code>α</code> 并反演 <code>≤</code> 即可. 我们对第二和第三种情况递归调用了要证的命题 <code>≤∸⇒≤</code> 本身, 也即用了归纳法. ∎</p>
<pre class="Agda"><a id="≤∸⇒≤"></a><a id="5102" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5107" class="Symbol">:</a> <a id="5109" class="Symbol">∀</a> <a id="5111" class="Symbol">{</a><a id="5112" href="NonWellFormed.Ordinal.html#5112" class="Bound">α</a> <a id="5114" href="NonWellFormed.Ordinal.html#5114" class="Bound">β</a> <a id="5116" href="NonWellFormed.Ordinal.html#5116" class="Bound">d</a><a id="5117" class="Symbol">}</a> <a id="5119" class="Symbol">→</a> <a id="5121" href="NonWellFormed.Ordinal.html#5112" class="Bound">α</a> <a id="5123" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5125" href="NonWellFormed.Ordinal.html#5114" class="Bound">β</a> <a id="5127" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="5129" href="NonWellFormed.Ordinal.html#5116" class="Bound">d</a> <a id="5131" class="Symbol">→</a> <a id="5133" href="NonWellFormed.Ordinal.html#5112" class="Bound">α</a> <a id="5135" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5137" href="NonWellFormed.Ordinal.html#5114" class="Bound">β</a>
<a id="5139" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5144" class="Symbol">{</a><a id="5145" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="5149" class="Symbol">}</a>  <a id="5152" class="Symbol">_</a>       <a id="5160" class="Symbol">=</a> <a id="5162" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
<a id="5165" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5170" class="Symbol">{</a><a id="5171" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5175" href="NonWellFormed.Ordinal.html#5175" class="Bound">α</a><a id="5176" class="Symbol">}</a> <a id="5178" class="Symbol">(</a><a id="5179" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5182" href="NonWellFormed.Ordinal.html#5182" class="Bound">≤∸</a><a id="5184" class="Symbol">)</a> <a id="5186" class="Symbol">=</a> <a id="5188" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5191" class="Symbol">(</a><a id="5192" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5197" href="NonWellFormed.Ordinal.html#5182" class="Bound">≤∸</a><a id="5199" class="Symbol">)</a>
<a id="5201" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5206" class="Symbol">{</a><a id="5207" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="5211" href="NonWellFormed.Ordinal.html#5211" class="Bound">f</a><a id="5212" class="Symbol">}</a> <a id="5214" class="Symbol">(</a><a id="5215" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="5218" href="NonWellFormed.Ordinal.html#5218" class="Bound">f≤</a><a id="5220" class="Symbol">)</a> <a id="5222" class="Symbol">=</a> <a id="5224" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="5227" class="Symbol">λ</a> <a id="5229" href="NonWellFormed.Ordinal.html#5229" class="Bound">n</a> <a id="5231" class="Symbol">→</a> <a id="5233" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5238" class="Symbol">(</a><a id="5239" href="NonWellFormed.Ordinal.html#5218" class="Bound">f≤</a> <a id="5242" href="NonWellFormed.Ordinal.html#5229" class="Bound">n</a><a id="5243" class="Symbol">)</a>
</pre>
<p><strong>引理</strong> 如果 <code>α ≤ β</code>, 那么 <code>α</code> 的任意前驱小于等于 <code>β</code>.<br />
<strong>证明</strong> 这次除了讨论 <code>α</code> 并反演 <code>≤</code> 之外, 还要解构 <code>α</code> 的前驱深度 <code>d</code>. 看起来组合很多, 但大多数组合都是不可能的, Agda 可以自动识别. 归结下来就 3 种情况:</p>
<ul>
<li><code>α</code> 小于等于 <code>β</code> 的直接前驱</li>
<li><code>α</code> 小于等于 <code>β</code> 的直接前驱以外的前驱</li>
<li><code>α</code> 的基本序列的每个取值 <code>f n</code> 都小于等于 <code>β</code></li>
</ul>
<p>第一和第二种情况调用了上一条命题 <code>≤∸⇒≤</code>, 第二和第三种情况递归调用了要证的命题 <code>≤⇒∸≤</code> 本身. ∎</p>
<pre class="Agda"><a id="≤⇒∸≤"></a><a id="5540" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5545" class="Symbol">:</a> <a id="5547" class="Symbol">∀</a> <a id="5549" class="Symbol">{</a><a id="5550" href="NonWellFormed.Ordinal.html#5550" class="Bound">α</a> <a id="5552" href="NonWellFormed.Ordinal.html#5552" class="Bound">β</a> <a id="5554" href="NonWellFormed.Ordinal.html#5554" class="Bound">d</a><a id="5555" class="Symbol">}</a> <a id="5557" class="Symbol">→</a> <a id="5559" href="NonWellFormed.Ordinal.html#5550" class="Bound">α</a> <a id="5561" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5563" href="NonWellFormed.Ordinal.html#5552" class="Bound">β</a> <a id="5565" class="Symbol">→</a> <a id="5567" href="NonWellFormed.Ordinal.html#5550" class="Bound">α</a> <a id="5569" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="5571" href="NonWellFormed.Ordinal.html#5554" class="Bound">d</a> <a id="5573" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5575" href="NonWellFormed.Ordinal.html#5552" class="Bound">β</a>
<a id="5577" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5582" class="Symbol">{</a><a id="5583" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5587" href="NonWellFormed.Ordinal.html#5587" class="Bound">α</a><a id="5588" class="Symbol">}</a> <a id="5590" class="Symbol">{</a><a id="5591" class="Argument">d</a> <a id="5593" class="Symbol">=</a> <a id="5595" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="5600" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="5602" class="Symbol">}</a> <a id="5604" class="Symbol">(</a><a id="5605" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5608" href="NonWellFormed.Ordinal.html#5608" class="Bound">≤∸</a><a id="5610" class="Symbol">)</a> <a id="5612" class="Symbol">=</a> <a id="5614" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5619" href="NonWellFormed.Ordinal.html#5608" class="Bound">≤∸</a>
<a id="5622" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5627" class="Symbol">{</a><a id="5628" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5632" href="NonWellFormed.Ordinal.html#5632" class="Bound">α</a><a id="5633" class="Symbol">}</a> <a id="5635" class="Symbol">{</a><a id="5636" class="Argument">d</a> <a id="5638" class="Symbol">=</a> <a id="5640" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5645" href="NonWellFormed.Ordinal.html#5645" class="Bound">d</a><a id="5646" class="Symbol">}</a>  <a id="5649" class="Symbol">(</a><a id="5650" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5653" href="NonWellFormed.Ordinal.html#5653" class="Bound">≤∸</a><a id="5655" class="Symbol">)</a> <a id="5657" class="Symbol">=</a> <a id="5659" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5664" class="Symbol">(</a><a id="5665" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5670" href="NonWellFormed.Ordinal.html#5653" class="Bound">≤∸</a><a id="5672" class="Symbol">)</a>
<a id="5674" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5679" class="Symbol">{</a><a id="5680" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="5684" href="NonWellFormed.Ordinal.html#5684" class="Bound">f</a><a id="5685" class="Symbol">}</a> <a id="5687" class="Symbol">{</a><a id="5688" class="Argument">d</a> <a id="5690" class="Symbol">=</a> <a id="5692" href="NonWellFormed.Ordinal.html#5692" class="Bound">n</a> <a id="5694" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5696" href="NonWellFormed.Ordinal.html#5696" class="Bound">d</a><a id="5697" class="Symbol">}</a>   <a id="5701" class="Symbol">(</a><a id="5702" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="5705" href="NonWellFormed.Ordinal.html#5705" class="Bound">f≤</a><a id="5707" class="Symbol">)</a> <a id="5709" class="Symbol">=</a> <a id="5711" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="5716" class="Symbol">(</a><a id="5717" href="NonWellFormed.Ordinal.html#5705" class="Bound">f≤</a> <a id="5720" href="NonWellFormed.Ordinal.html#5692" class="Bound">n</a><a id="5721" class="Symbol">)</a>
</pre>
<p>用类似的方法, 我们证明了以下四条引理. 其中第一条只是 <code>≤∸⇒≤</code> 的特殊情况, 第二和第四条需要讨论 <code>α</code> 并反演 <code>≤</code>, 第三条只需反演 <code>≤</code>.</p>
<pre class="Agda"><a id="s≤⇒≤"></a><a id="5817" href="NonWellFormed.Ordinal.html#5817" class="Function">s≤⇒≤</a> <a id="5822" class="Symbol">:</a> <a id="5824" class="Symbol">∀</a> <a id="5826" class="Symbol">{</a><a id="5827" href="NonWellFormed.Ordinal.html#5827" class="Bound">α</a> <a id="5829" href="NonWellFormed.Ordinal.html#5829" class="Bound">β</a><a id="5830" class="Symbol">}</a> <a id="5832" class="Symbol">→</a> <a id="5834" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5838" href="NonWellFormed.Ordinal.html#5827" class="Bound">α</a> <a id="5840" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5842" href="NonWellFormed.Ordinal.html#5829" class="Bound">β</a> <a id="5844" class="Symbol">→</a> <a id="5846" href="NonWellFormed.Ordinal.html#5827" class="Bound">α</a> <a id="5848" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5850" href="NonWellFormed.Ordinal.html#5829" class="Bound">β</a>
<a id="5852" href="NonWellFormed.Ordinal.html#5817" class="Function">s≤⇒≤</a> <a id="5857" class="Symbol">(</a><a id="5858" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5861" href="NonWellFormed.Ordinal.html#5861" class="Bound">≤∸</a><a id="5863" class="Symbol">)</a> <a id="5865" class="Symbol">=</a> <a id="5867" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="5872" href="NonWellFormed.Ordinal.html#5861" class="Bound">≤∸</a>

<a id="≤⇒≤s"></a><a id="5876" href="NonWellFormed.Ordinal.html#5876" class="Function">≤⇒≤s</a> <a id="5881" class="Symbol">:</a> <a id="5883" class="Symbol">∀</a> <a id="5885" class="Symbol">{</a><a id="5886" href="NonWellFormed.Ordinal.html#5886" class="Bound">α</a> <a id="5888" href="NonWellFormed.Ordinal.html#5888" class="Bound">β</a><a id="5889" class="Symbol">}</a> <a id="5891" class="Symbol">→</a> <a id="5893" href="NonWellFormed.Ordinal.html#5886" class="Bound">α</a> <a id="5895" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5897" href="NonWellFormed.Ordinal.html#5888" class="Bound">β</a> <a id="5899" class="Symbol">→</a> <a id="5901" href="NonWellFormed.Ordinal.html#5886" class="Bound">α</a> <a id="5903" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="5905" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5909" href="NonWellFormed.Ordinal.html#5888" class="Bound">β</a>
<a id="5911" href="NonWellFormed.Ordinal.html#5876" class="Function">≤⇒≤s</a> <a id="5916" class="Symbol">{</a><a id="5917" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="5921" class="Symbol">}</a>  <a id="5924" class="Symbol">_</a>               <a id="5940" class="Symbol">=</a> <a id="5942" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
<a id="5945" href="NonWellFormed.Ordinal.html#5876" class="Function">≤⇒≤s</a> <a id="5950" class="Symbol">{</a><a id="5951" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5955" href="NonWellFormed.Ordinal.html#5955" class="Bound">α</a><a id="5956" class="Symbol">}</a> <a id="5958" class="Symbol">(</a><a id="5959" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5962" class="Symbol">{</a><a id="5963" class="Argument">d</a> <a id="5965" class="Symbol">=</a> <a id="5967" href="NonWellFormed.Ordinal.html#5967" class="Bound">d</a><a id="5968" class="Symbol">}</a> <a id="5970" href="NonWellFormed.Ordinal.html#5970" class="Bound">≤∸</a><a id="5972" class="Symbol">)</a> <a id="5974" class="Symbol">=</a> <a id="5976" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="5979" class="Symbol">{</a><a id="5980" class="Argument">d</a> <a id="5982" class="Symbol">=</a> <a id="5984" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5989" href="NonWellFormed.Ordinal.html#5967" class="Bound">d</a><a id="5990" class="Symbol">}</a> <a id="5992" href="NonWellFormed.Ordinal.html#5970" class="Bound">≤∸</a>
<a id="5995" href="NonWellFormed.Ordinal.html#5876" class="Function">≤⇒≤s</a> <a id="6000" class="Symbol">{</a><a id="6001" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6005" href="NonWellFormed.Ordinal.html#6005" class="Bound">f</a><a id="6006" class="Symbol">}</a> <a id="6008" class="Symbol">(</a><a id="6009" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6012" href="NonWellFormed.Ordinal.html#6012" class="Bound">f≤</a><a id="6014" class="Symbol">)</a>         <a id="6024" class="Symbol">=</a> <a id="6026" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6029" class="Symbol">λ</a> <a id="6031" href="NonWellFormed.Ordinal.html#6031" class="Bound">n</a> <a id="6033" class="Symbol">→</a> <a id="6035" href="NonWellFormed.Ordinal.html#5876" class="Function">≤⇒≤s</a> <a id="6040" class="Symbol">(</a><a id="6041" href="NonWellFormed.Ordinal.html#6012" class="Bound">f≤</a> <a id="6044" href="NonWellFormed.Ordinal.html#6031" class="Bound">n</a><a id="6045" class="Symbol">)</a>

<a id="l≤⇒f≤"></a><a id="6048" href="NonWellFormed.Ordinal.html#6048" class="Function">l≤⇒f≤</a> <a id="6054" class="Symbol">:</a> <a id="6056" class="Symbol">∀</a> <a id="6058" class="Symbol">{</a><a id="6059" href="NonWellFormed.Ordinal.html#6059" class="Bound">α</a> <a id="6061" href="NonWellFormed.Ordinal.html#6061" class="Bound">f</a> <a id="6063" href="NonWellFormed.Ordinal.html#6063" class="Bound">n</a><a id="6064" class="Symbol">}</a> <a id="6066" class="Symbol">→</a> <a id="6068" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6072" href="NonWellFormed.Ordinal.html#6061" class="Bound">f</a> <a id="6074" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6076" href="NonWellFormed.Ordinal.html#6059" class="Bound">α</a> <a id="6078" class="Symbol">→</a> <a id="6080" href="NonWellFormed.Ordinal.html#6061" class="Bound">f</a> <a id="6082" href="NonWellFormed.Ordinal.html#6063" class="Bound">n</a> <a id="6084" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6086" href="NonWellFormed.Ordinal.html#6059" class="Bound">α</a>
<a id="6088" href="NonWellFormed.Ordinal.html#6048" class="Function">l≤⇒f≤</a> <a id="6094" class="Symbol">{</a><a id="6095" class="Argument">n</a> <a id="6097" class="Symbol">=</a> <a id="6099" href="NonWellFormed.Ordinal.html#6099" class="Bound">n</a><a id="6100" class="Symbol">}</a> <a id="6102" class="Symbol">(</a><a id="6103" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6106" href="NonWellFormed.Ordinal.html#6106" class="Bound">f≤</a><a id="6108" class="Symbol">)</a> <a id="6110" class="Symbol">=</a> <a id="6112" href="NonWellFormed.Ordinal.html#6106" class="Bound">f≤</a> <a id="6115" href="NonWellFormed.Ordinal.html#6099" class="Bound">n</a>

<a id="≤f⇒≤l"></a><a id="6118" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6124" class="Symbol">:</a> <a id="6126" class="Symbol">∀</a> <a id="6128" class="Symbol">{</a><a id="6129" href="NonWellFormed.Ordinal.html#6129" class="Bound">α</a> <a id="6131" href="NonWellFormed.Ordinal.html#6131" class="Bound">f</a> <a id="6133" href="NonWellFormed.Ordinal.html#6133" class="Bound">n</a><a id="6134" class="Symbol">}</a> <a id="6136" class="Symbol">→</a> <a id="6138" href="NonWellFormed.Ordinal.html#6129" class="Bound">α</a> <a id="6140" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6142" href="NonWellFormed.Ordinal.html#6131" class="Bound">f</a> <a id="6144" href="NonWellFormed.Ordinal.html#6133" class="Bound">n</a> <a id="6146" class="Symbol">→</a> <a id="6148" href="NonWellFormed.Ordinal.html#6129" class="Bound">α</a> <a id="6150" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6152" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6156" href="NonWellFormed.Ordinal.html#6131" class="Bound">f</a>
<a id="6158" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6164" class="Symbol">{</a><a id="6165" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="6169" class="Symbol">}</a>  <a id="6172" class="Symbol">_</a>       <a id="6180" class="Symbol">=</a> <a id="6182" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
<a id="6185" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6191" class="Symbol">{</a><a id="6192" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6196" href="NonWellFormed.Ordinal.html#6196" class="Bound">α</a><a id="6197" class="Symbol">}</a> <a id="6199" class="Symbol">(</a><a id="6200" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="6203" href="NonWellFormed.Ordinal.html#6203" class="Bound">≤∸</a><a id="6205" class="Symbol">)</a> <a id="6207" class="Symbol">=</a> <a id="6209" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="6212" href="NonWellFormed.Ordinal.html#6203" class="Bound">≤∸</a>
<a id="6215" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6221" class="Symbol">{</a><a id="6222" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6226" href="NonWellFormed.Ordinal.html#6226" class="Bound">f</a><a id="6227" class="Symbol">}</a> <a id="6229" class="Symbol">(</a><a id="6230" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6233" href="NonWellFormed.Ordinal.html#6233" class="Bound">f≤</a><a id="6235" class="Symbol">)</a> <a id="6237" class="Symbol">=</a> <a id="6239" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6242" class="Symbol">λ</a> <a id="6244" href="NonWellFormed.Ordinal.html#6244" class="Bound">n</a> <a id="6246" class="Symbol">→</a> <a id="6248" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6254" class="Symbol">(</a><a id="6255" href="NonWellFormed.Ordinal.html#6233" class="Bound">f≤</a> <a id="6258" href="NonWellFormed.Ordinal.html#6244" class="Bound">n</a><a id="6259" class="Symbol">)</a>
</pre>
<p>接下来是一条重要引理.</p>
<p><strong>引理</strong> 后继运算 <code>suc</code> 保持 <code>_≤_</code> 关系.<br />
<strong>证明</strong> 证明相当简短. 首先调用构造子 <code>s≤</code>, 那么只需证对某 <code>d</code> 有 <code>α ≤ suc β ∸ d</code>. 令 <code>d</code> 为 <code>tt</code>, 也即取 <code>suc β</code> 的直接前驱 <code>β</code>, 只需证 <code>α ≤ β</code>, 此即前提. ∎</p>
<pre class="Agda"><a id="s≤s"></a><a id="6439" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="6443" class="Symbol">:</a> <a id="6445" class="Symbol">∀</a> <a id="6447" class="Symbol">{</a><a id="6448" href="NonWellFormed.Ordinal.html#6448" class="Bound">α</a> <a id="6450" href="NonWellFormed.Ordinal.html#6450" class="Bound">β</a><a id="6451" class="Symbol">}</a> <a id="6453" class="Symbol">→</a> <a id="6455" href="NonWellFormed.Ordinal.html#6448" class="Bound">α</a> <a id="6457" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6459" href="NonWellFormed.Ordinal.html#6450" class="Bound">β</a> <a id="6461" class="Symbol">→</a> <a id="6463" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6467" href="NonWellFormed.Ordinal.html#6448" class="Bound">α</a> <a id="6469" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6471" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6475" href="NonWellFormed.Ordinal.html#6450" class="Bound">β</a>
<a id="6477" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="6481" href="NonWellFormed.Ordinal.html#6481" class="Bound">≤</a> <a id="6483" class="Symbol">=</a> <a id="6485" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="6488" class="Symbol">{</a><a id="6489" class="Argument">d</a> <a id="6491" class="Symbol">=</a> <a id="6493" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6498" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="6500" class="Symbol">}</a> <a id="6502" href="NonWellFormed.Ordinal.html#6481" class="Bound">≤</a>
</pre>
<p>逆命题同样可证, 只需反演 <code>≤</code> 并讨论 <code>d</code> 即可.</p>
<pre class="Agda"><a id="s≤s⇒≤"></a><a id="6548" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="6554" class="Symbol">:</a> <a id="6556" class="Symbol">∀</a> <a id="6558" class="Symbol">{</a><a id="6559" href="NonWellFormed.Ordinal.html#6559" class="Bound">α</a> <a id="6561" href="NonWellFormed.Ordinal.html#6561" class="Bound">β</a><a id="6562" class="Symbol">}</a> <a id="6564" class="Symbol">→</a> <a id="6566" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6570" href="NonWellFormed.Ordinal.html#6559" class="Bound">α</a> <a id="6572" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6574" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6578" href="NonWellFormed.Ordinal.html#6561" class="Bound">β</a> <a id="6580" class="Symbol">→</a> <a id="6582" href="NonWellFormed.Ordinal.html#6559" class="Bound">α</a> <a id="6584" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6586" href="NonWellFormed.Ordinal.html#6561" class="Bound">β</a>
<a id="6588" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="6594" class="Symbol">(</a><a id="6595" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="6598" class="Symbol">{</a><a id="6599" class="Argument">d</a> <a id="6601" class="Symbol">=</a> <a id="6603" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6608" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="6610" class="Symbol">}</a> <a id="6612" href="NonWellFormed.Ordinal.html#6612" class="Bound">≤</a> <a id="6614" class="Symbol">)</a> <a id="6616" class="Symbol">=</a> <a id="6618" href="NonWellFormed.Ordinal.html#6612" class="Bound">≤</a>
<a id="6620" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="6626" class="Symbol">(</a><a id="6627" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="6630" class="Symbol">{</a><a id="6631" class="Argument">d</a> <a id="6633" class="Symbol">=</a> <a id="6635" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6640" href="NonWellFormed.Ordinal.html#6640" class="Bound">d</a><a id="6641" class="Symbol">}</a>  <a id="6644" href="NonWellFormed.Ordinal.html#6644" class="Bound">≤∸</a><a id="6646" class="Symbol">)</a> <a id="6648" class="Symbol">=</a> <a id="6650" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="6655" href="NonWellFormed.Ordinal.html#6644" class="Bound">≤∸</a>
</pre>
<p>结合以上两条, 可知 <code>suc</code> <em>反映</em> <code>_≤_</code>. 该命题是一个 <code>_⇔_</code> 等价式, 后续章节我们会用它做改写推理.</p>
<pre class="Agda"><a id="≤⇔s≤s"></a><a id="6735" href="NonWellFormed.Ordinal.html#6735" class="Function">≤⇔s≤s</a> <a id="6741" class="Symbol">:</a> <a id="6743" class="Symbol">∀</a> <a id="6745" class="Symbol">{</a><a id="6746" href="NonWellFormed.Ordinal.html#6746" class="Bound">α</a> <a id="6748" href="NonWellFormed.Ordinal.html#6748" class="Bound">β</a><a id="6749" class="Symbol">}</a> <a id="6751" class="Symbol">→</a> <a id="6753" href="NonWellFormed.Ordinal.html#6746" class="Bound">α</a> <a id="6755" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6757" href="NonWellFormed.Ordinal.html#6748" class="Bound">β</a> <a id="6759" href="Function.Equivalence.html#1213" class="Function Operator">⇔</a> <a id="6761" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6765" href="NonWellFormed.Ordinal.html#6746" class="Bound">α</a> <a id="6767" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6769" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="6773" href="NonWellFormed.Ordinal.html#6748" class="Bound">β</a>
<a id="6775" href="NonWellFormed.Ordinal.html#6735" class="Function">≤⇔s≤s</a> <a id="6781" class="Symbol">=</a> <a id="6783" href="NonWellFormed.Ordinal.html#2663" class="Function">mk⇔</a> <a id="6787" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="6791" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a>
</pre>
<p>两边都是极限的情况有类似的, 但逆命题不成立.</p>
<pre class="Agda"><a id="l≤l"></a><a id="6835" href="NonWellFormed.Ordinal.html#6835" class="Function">l≤l</a> <a id="6839" class="Symbol">:</a> <a id="6841" class="Symbol">∀</a> <a id="6843" class="Symbol">{</a><a id="6844" href="NonWellFormed.Ordinal.html#6844" class="Bound">f</a> <a id="6846" href="NonWellFormed.Ordinal.html#6846" class="Bound">g</a><a id="6847" class="Symbol">}</a> <a id="6849" class="Symbol">→</a> <a id="6851" class="Symbol">(∀</a> <a id="6854" href="NonWellFormed.Ordinal.html#6854" class="Bound">n</a> <a id="6856" class="Symbol">→</a> <a id="6858" href="NonWellFormed.Ordinal.html#6844" class="Bound">f</a> <a id="6860" href="NonWellFormed.Ordinal.html#6854" class="Bound">n</a> <a id="6862" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6864" href="NonWellFormed.Ordinal.html#6846" class="Bound">g</a> <a id="6866" href="NonWellFormed.Ordinal.html#6854" class="Bound">n</a><a id="6867" class="Symbol">)</a> <a id="6869" class="Symbol">→</a> <a id="6871" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6875" href="NonWellFormed.Ordinal.html#6844" class="Bound">f</a> <a id="6877" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="6879" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6883" href="NonWellFormed.Ordinal.html#6846" class="Bound">g</a>
<a id="6885" href="NonWellFormed.Ordinal.html#6835" class="Function">l≤l</a> <a id="6889" href="NonWellFormed.Ordinal.html#6889" class="Bound">f≤g</a> <a id="6893" class="Symbol">=</a> <a id="6895" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="6898" class="Symbol">(λ</a> <a id="6901" href="NonWellFormed.Ordinal.html#6901" class="Bound">n</a> <a id="6903" class="Symbol">→</a> <a id="6905" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="6911" class="Symbol">(</a><a id="6912" href="NonWellFormed.Ordinal.html#6889" class="Bound">f≤g</a> <a id="6916" href="NonWellFormed.Ordinal.html#6901" class="Bound">n</a><a id="6917" class="Symbol">))</a>
</pre>
<p>由引理 <code>s≤s</code> 和 <code>≤f⇒≤l</code> 不难证明 <code>≤</code> 是自反的.</p>
<pre class="Agda"><a id="≤-refl"></a><a id="6969" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="6976" class="Symbol">:</a> <a id="6978" href="Relation.Binary.Definitions.html#1413" class="Function">Reflexive</a> <a id="6988" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a>
<a id="6992" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="6999" class="Symbol">{</a><a id="7000" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="7004" class="Symbol">}</a>  <a id="7007" class="Symbol">=</a> <a id="7009" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
<a id="7012" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="7019" class="Symbol">{</a><a id="7020" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7024" href="NonWellFormed.Ordinal.html#7024" class="Bound">α</a><a id="7025" class="Symbol">}</a> <a id="7027" class="Symbol">=</a> <a id="7029" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="7033" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
<a id="7040" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="7047" class="Symbol">{</a><a id="7048" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="7052" href="NonWellFormed.Ordinal.html#7052" class="Bound">f</a><a id="7053" class="Symbol">}</a> <a id="7055" class="Symbol">=</a> <a id="7057" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="7060" class="Symbol">λ</a> <a id="7062" href="NonWellFormed.Ordinal.html#7062" class="Bound">n</a> <a id="7064" class="Symbol">→</a> <a id="7066" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="7072" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
</pre>
<p>传递性的证明比较麻烦, 需要讨论 <code>α</code>, 并反演两个 <code>≤</code> 式, 归结为五种情况, 其中后四种都用了归纳假设.</p>
<pre class="Agda"><a id="≤-trans"></a><a id="7151" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7159" class="Symbol">:</a> <a id="7161" href="Relation.Binary.Definitions.html#1940" class="Function">Transitive</a> <a id="7172" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a>
<a id="7176" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7184" class="Symbol">{</a><a id="7185" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="7189" class="Symbol">}</a>  <a id="7192" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>                     <a id="7215" class="Symbol">_</a>        <a id="7224" class="Symbol">=</a> <a id="7226" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
<a id="7229" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7237" class="Symbol">{</a><a id="7238" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7242" href="NonWellFormed.Ordinal.html#7242" class="Bound">α</a><a id="7243" class="Symbol">}</a> <a id="7245" class="Symbol">(</a><a id="7246" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7249" class="Symbol">{</a><a id="7250" class="Argument">d</a> <a id="7252" class="Symbol">=</a> <a id="7254" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7259" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="7261" class="Symbol">}</a> <a id="7263" href="NonWellFormed.Ordinal.html#7263" class="Bound">α≤β</a><a id="7266" class="Symbol">)</a> <a id="7268" class="Symbol">(</a><a id="7269" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7272" href="NonWellFormed.Ordinal.html#7272" class="Bound">β≤γ</a><a id="7275" class="Symbol">)</a> <a id="7277" class="Symbol">=</a> <a id="7279" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7282" class="Symbol">(</a><a id="7283" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7291" href="NonWellFormed.Ordinal.html#7263" class="Bound">α≤β</a> <a id="7295" href="NonWellFormed.Ordinal.html#7272" class="Bound">β≤γ</a><a id="7298" class="Symbol">)</a>
<a id="7300" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7308" class="Symbol">{</a><a id="7309" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7313" href="NonWellFormed.Ordinal.html#7313" class="Bound">α</a><a id="7314" class="Symbol">}</a> <a id="7316" class="Symbol">(</a><a id="7317" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7320" class="Symbol">{</a><a id="7321" class="Argument">d</a> <a id="7323" class="Symbol">=</a> <a id="7325" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7330" href="NonWellFormed.Ordinal.html#7330" class="Bound">d</a><a id="7331" class="Symbol">}</a>  <a id="7334" href="NonWellFormed.Ordinal.html#7334" class="Bound">α≤β</a><a id="7337" class="Symbol">)</a> <a id="7339" class="Symbol">(</a><a id="7340" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7343" href="NonWellFormed.Ordinal.html#7343" class="Bound">β≤γ</a><a id="7346" class="Symbol">)</a> <a id="7348" class="Symbol">=</a> <a id="7350" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7353" class="Symbol">(</a><a id="7354" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7362" href="NonWellFormed.Ordinal.html#7334" class="Bound">α≤β</a> <a id="7366" class="Symbol">(</a><a id="7367" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="7372" href="NonWellFormed.Ordinal.html#7343" class="Bound">β≤γ</a><a id="7375" class="Symbol">))</a>
<a id="7378" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7386" class="Symbol">{</a><a id="7387" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7391" href="NonWellFormed.Ordinal.html#7391" class="Bound">α</a><a id="7392" class="Symbol">}</a> <a id="7394" class="Symbol">(</a><a id="7395" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7398" class="Symbol">{</a><a id="7399" class="Argument">d</a> <a id="7401" class="Symbol">=</a> <a id="7403" href="NonWellFormed.Ordinal.html#7403" class="Bound">n</a> <a id="7405" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7407" href="NonWellFormed.Ordinal.html#7407" class="Bound">d</a><a id="7408" class="Symbol">}</a>   <a id="7412" href="NonWellFormed.Ordinal.html#7412" class="Bound">α≤β</a><a id="7415" class="Symbol">)</a> <a id="7417" class="Symbol">(</a><a id="7418" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="7421" href="NonWellFormed.Ordinal.html#7421" class="Bound">f≤γ</a><a id="7424" class="Symbol">)</a> <a id="7426" class="Symbol">=</a> <a id="7428" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7436" class="Symbol">(</a><a id="7437" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7440" href="NonWellFormed.Ordinal.html#7412" class="Bound">α≤β</a><a id="7443" class="Symbol">)</a> <a id="7445" class="Symbol">(</a><a id="7446" href="NonWellFormed.Ordinal.html#7421" class="Bound">f≤γ</a> <a id="7450" href="NonWellFormed.Ordinal.html#7403" class="Bound">n</a><a id="7451" class="Symbol">)</a>
<a id="7453" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7461" class="Symbol">{</a><a id="7462" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="7466" href="NonWellFormed.Ordinal.html#7466" class="Bound">f</a><a id="7467" class="Symbol">}</a> <a id="7469" class="Symbol">(</a><a id="7470" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="7473" href="NonWellFormed.Ordinal.html#7473" class="Bound">f≤β</a><a id="7476" class="Symbol">)</a>               <a id="7492" href="NonWellFormed.Ordinal.html#7492" class="Bound">β≤γ</a>      <a id="7501" class="Symbol">=</a> <a id="7503" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="7506" class="Symbol">λ</a> <a id="7508" href="NonWellFormed.Ordinal.html#7508" class="Bound">n</a> <a id="7510" class="Symbol">→</a> <a id="7512" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="7520" class="Symbol">(</a><a id="7521" href="NonWellFormed.Ordinal.html#7473" class="Bound">f≤β</a> <a id="7525" href="NonWellFormed.Ordinal.html#7508" class="Bound">n</a><a id="7526" class="Symbol">)</a> <a id="7528" href="NonWellFormed.Ordinal.html#7492" class="Bound">β≤γ</a>
</pre>
<p>最后证明三条引理结束本小节. 第一条 <code>≤s</code> 是因为 <code>α ≤ α ≡ suc α ∸ inj₁ tt ≤ suc α</code>. 第二条 <code>s∸≤</code> 是说 <code>α</code> 的任意前驱的后继都小于等于 <code>α</code>, 讨论 <code>α</code> 和 <code>d</code> 并由上面的一些引理即证. 第三条是 <code>≤f⇒≤l</code> 和 <code>≤-refl</code> 的直接推论.</p>
<pre class="Agda"><a id="≤s"></a><a id="7702" href="NonWellFormed.Ordinal.html#7702" class="Function">≤s</a> <a id="7705" class="Symbol">:</a> <a id="7707" class="Symbol">∀</a> <a id="7709" class="Symbol">{</a><a id="7710" href="NonWellFormed.Ordinal.html#7710" class="Bound">α</a><a id="7711" class="Symbol">}</a> <a id="7713" class="Symbol">→</a> <a id="7715" href="NonWellFormed.Ordinal.html#7710" class="Bound">α</a> <a id="7717" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="7719" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7723" href="NonWellFormed.Ordinal.html#7710" class="Bound">α</a>
<a id="7725" href="NonWellFormed.Ordinal.html#7702" class="Function">≤s</a> <a id="7728" class="Symbol">=</a> <a id="7730" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="7735" class="Symbol">{</a><a id="7736" class="Argument">d</a> <a id="7738" class="Symbol">=</a> <a id="7740" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7745" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="7747" class="Symbol">}</a> <a id="7749" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>

<a id="s∸≤"></a><a id="7757" href="NonWellFormed.Ordinal.html#7757" class="Function">s∸≤</a> <a id="7761" class="Symbol">:</a> <a id="7763" class="Symbol">∀</a> <a id="7765" class="Symbol">{</a><a id="7766" href="NonWellFormed.Ordinal.html#7766" class="Bound">α</a> <a id="7768" href="NonWellFormed.Ordinal.html#7768" class="Bound">d</a><a id="7769" class="Symbol">}</a> <a id="7771" class="Symbol">→</a> <a id="7773" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7777" class="Symbol">(</a><a id="7778" href="NonWellFormed.Ordinal.html#7766" class="Bound">α</a> <a id="7780" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="7782" href="NonWellFormed.Ordinal.html#7768" class="Bound">d</a><a id="7783" class="Symbol">)</a> <a id="7785" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="7787" href="NonWellFormed.Ordinal.html#7766" class="Bound">α</a>
<a id="7789" href="NonWellFormed.Ordinal.html#7757" class="Function">s∸≤</a> <a id="7793" class="Symbol">{</a><a id="7794" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7798" href="NonWellFormed.Ordinal.html#7798" class="Bound">α</a><a id="7799" class="Symbol">}</a> <a id="7801" class="Symbol">{</a><a id="7802" class="Argument">d</a> <a id="7804" class="Symbol">=</a> <a id="7806" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7811" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="7813" class="Symbol">}</a> <a id="7815" class="Symbol">=</a> <a id="7817" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
<a id="7824" href="NonWellFormed.Ordinal.html#7757" class="Function">s∸≤</a> <a id="7828" class="Symbol">{</a><a id="7829" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="7833" href="NonWellFormed.Ordinal.html#7833" class="Bound">α</a><a id="7834" class="Symbol">}</a> <a id="7836" class="Symbol">{</a><a id="7837" class="Argument">d</a> <a id="7839" class="Symbol">=</a> <a id="7841" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7846" href="NonWellFormed.Ordinal.html#7846" class="Bound">d</a> <a id="7848" class="Symbol">}</a> <a id="7850" class="Symbol">=</a> <a id="7852" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="7856" class="Symbol">(</a><a id="7857" href="NonWellFormed.Ordinal.html#5540" class="Function">≤⇒∸≤</a> <a id="7862" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a><a id="7868" class="Symbol">)</a>
<a id="7870" href="NonWellFormed.Ordinal.html#7757" class="Function">s∸≤</a> <a id="7874" class="Symbol">{</a><a id="7875" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="7879" href="NonWellFormed.Ordinal.html#7879" class="Bound">f</a><a id="7880" class="Symbol">}</a> <a id="7882" class="Symbol">{</a><a id="7883" class="Argument">d</a> <a id="7885" class="Symbol">=</a> <a id="7887" href="NonWellFormed.Ordinal.html#7887" class="Bound">d</a><a id="7888" class="Symbol">}</a>       <a id="7896" class="Symbol">=</a> <a id="7898" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="7901" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>

<a id="f≤l"></a><a id="7909" href="NonWellFormed.Ordinal.html#7909" class="Function">f≤l</a> <a id="7913" class="Symbol">:</a> <a id="7915" class="Symbol">∀</a> <a id="7917" class="Symbol">{</a><a id="7918" href="NonWellFormed.Ordinal.html#7918" class="Bound">f</a> <a id="7920" href="NonWellFormed.Ordinal.html#7920" class="Bound">n</a><a id="7921" class="Symbol">}</a> <a id="7923" class="Symbol">→</a> <a id="7925" href="NonWellFormed.Ordinal.html#7918" class="Bound">f</a> <a id="7927" href="NonWellFormed.Ordinal.html#7920" class="Bound">n</a> <a id="7929" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="7931" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="7935" href="NonWellFormed.Ordinal.html#7918" class="Bound">f</a>
<a id="7937" href="NonWellFormed.Ordinal.html#7909" class="Function">f≤l</a> <a id="7941" class="Symbol">=</a> <a id="7943" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="7949" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
</pre>
<h2 id="外延相等">外延相等</h2>
<p><code>≤-refl</code> 和 <code>≤-trans</code> 说明 <code>_≤_</code> 是预序. 我们期望 <code>_≤_</code> 是偏序, 现在只缺反对称性, 但我们无法证明 <code>_≤_</code> 对内涵等词 <code>_≡_</code> 反对称. 实际上, 我们从 <code>_≤_</code> 直接定义出满足反对称的 <code>_≈_</code>, 我们称之为<em>序列外延相等</em>.</p>
<pre class="Agda"><a id="8120" class="Keyword">infix</a> <a id="8126" class="Number">4</a> <a id="8128" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a> <a id="8132" href="NonWellFormed.Ordinal.html#8177" class="Function Operator">_≉_</a>

<a id="_≈_"></a><a id="8137" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a> <a id="8141" class="Symbol">:</a> <a id="8143" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="8147" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="8151" href="Level.html#521" class="Function">0ℓ</a>
<a id="8154" href="NonWellFormed.Ordinal.html#8154" class="Bound">α</a> <a id="8156" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8158" href="NonWellFormed.Ordinal.html#8158" class="Bound">β</a> <a id="8160" class="Symbol">=</a> <a id="8162" href="NonWellFormed.Ordinal.html#8154" class="Bound">α</a> <a id="8164" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="8166" href="NonWellFormed.Ordinal.html#8158" class="Bound">β</a> <a id="8168" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="8170" href="NonWellFormed.Ordinal.html#8158" class="Bound">β</a> <a id="8172" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="8174" href="NonWellFormed.Ordinal.html#8154" class="Bound">α</a>

<a id="_≉_"></a><a id="8177" href="NonWellFormed.Ordinal.html#8177" class="Function Operator">_≉_</a> <a id="8181" class="Symbol">:</a> <a id="8183" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="8187" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="8191" href="Level.html#521" class="Function">0ℓ</a>
<a id="8194" href="NonWellFormed.Ordinal.html#8194" class="Bound">α</a> <a id="8196" href="NonWellFormed.Ordinal.html#8177" class="Function Operator">≉</a> <a id="8198" href="NonWellFormed.Ordinal.html#8198" class="Bound">β</a> <a id="8200" class="Symbol">=</a> <a id="8202" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬</a> <a id="8204" href="NonWellFormed.Ordinal.html#8194" class="Bound">α</a> <a id="8206" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8208" href="NonWellFormed.Ordinal.html#8198" class="Bound">β</a>
</pre>
<p><code>_≈_</code> 的自反性和传递性由 <code>_≤_</code> 的相应性质得到, 对称性依定义只需调换两个 <code>_≤_</code> 式的先后顺序即可.</p>
<pre class="Agda"><a id="≈-refl"></a><a id="8284" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a> <a id="8291" class="Symbol">:</a> <a id="8293" href="Relation.Binary.Definitions.html#1413" class="Function">Reflexive</a> <a id="8303" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a>
<a id="8307" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a> <a id="8314" class="Symbol">=</a> <a id="8316" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="8323" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8325" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>

<a id="≈-sym"></a><a id="8333" href="NonWellFormed.Ordinal.html#8333" class="Function">≈-sym</a> <a id="8339" class="Symbol">:</a> <a id="8341" href="Relation.Binary.Definitions.html#1572" class="Function">Symmetric</a> <a id="8351" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a>
<a id="8355" href="NonWellFormed.Ordinal.html#8333" class="Function">≈-sym</a> <a id="8361" class="Symbol">=</a> <a id="8363" class="Symbol">λ</a> <a id="8365" class="Symbol">{</a> <a id="8367" class="Symbol">(</a><a id="8368" href="NonWellFormed.Ordinal.html#8368" class="Bound">α≤β</a> <a id="8372" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8374" href="NonWellFormed.Ordinal.html#8374" class="Bound">β≤α</a><a id="8377" class="Symbol">)</a> <a id="8379" class="Symbol">→</a> <a id="8381" href="NonWellFormed.Ordinal.html#8374" class="Bound">β≤α</a> <a id="8385" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8387" href="NonWellFormed.Ordinal.html#8368" class="Bound">α≤β</a> <a id="8391" class="Symbol">}</a>

<a id="≈-trans"></a><a id="8394" href="NonWellFormed.Ordinal.html#8394" class="Function">≈-trans</a> <a id="8402" class="Symbol">:</a> <a id="8404" href="Relation.Binary.Definitions.html#1940" class="Function">Transitive</a> <a id="8415" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a>
<a id="8419" href="NonWellFormed.Ordinal.html#8394" class="Function">≈-trans</a> <a id="8427" class="Symbol">=</a> <a id="8429" class="Symbol">λ</a> <a id="8431" class="Symbol">{</a> <a id="8433" class="Symbol">(</a><a id="8434" href="NonWellFormed.Ordinal.html#8434" class="Bound">α≤β</a> <a id="8438" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8440" href="NonWellFormed.Ordinal.html#8440" class="Bound">β≤α</a><a id="8443" class="Symbol">)</a> <a id="8445" class="Symbol">(</a><a id="8446" href="NonWellFormed.Ordinal.html#8446" class="Bound">β≤γ</a> <a id="8450" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8452" href="NonWellFormed.Ordinal.html#8452" class="Bound">γ≤β</a><a id="8455" class="Symbol">)</a> <a id="8457" class="Symbol">→</a> <a id="8459" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="8467" href="NonWellFormed.Ordinal.html#8434" class="Bound">α≤β</a> <a id="8471" href="NonWellFormed.Ordinal.html#8446" class="Bound">β≤γ</a> <a id="8475" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8477" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="8485" href="NonWellFormed.Ordinal.html#8452" class="Bound">γ≤β</a> <a id="8489" href="NonWellFormed.Ordinal.html#8440" class="Bound">β≤α</a> <a id="8493" class="Symbol">}</a>
</pre>
<p>再证一些关于 <code>_≈_</code> 的引理. 由 <code>≈-refl</code> 立即可知 <code>_≡_</code> 蕴含 <code>_≈_</code>.</p>
<pre class="Agda"><a id="≡⇒≈"></a><a id="8559" href="NonWellFormed.Ordinal.html#8559" class="Function">≡⇒≈</a> <a id="8563" class="Symbol">:</a> <a id="8565" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="8569" href="Relation.Binary.Core.html#1263" class="Function Operator">⇒</a> <a id="8571" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a>
<a id="8575" href="NonWellFormed.Ordinal.html#8559" class="Function">≡⇒≈</a> <a id="8579" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8584" class="Symbol">=</a> <a id="8586" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a>
</pre>
<p><code>≤ zero</code> 蕴含 <code>≈ zero</code>, 但要得到 <code>≡ zero</code> 则要求下一章的良构条件. 因为比如非良构的 <code>lim (λ- zero)</code> 外延等于 <code>zero</code>, 但显然不是 <code>zero</code>.</p>
<pre class="Agda"><a id="≤z⇒≈z"></a><a id="8708" href="NonWellFormed.Ordinal.html#8708" class="Function">≤z⇒≈z</a> <a id="8714" class="Symbol">:</a> <a id="8716" class="Symbol">∀</a> <a id="8718" class="Symbol">{</a><a id="8719" href="NonWellFormed.Ordinal.html#8719" class="Bound">α</a><a id="8720" class="Symbol">}</a> <a id="8722" class="Symbol">→</a> <a id="8724" href="NonWellFormed.Ordinal.html#8719" class="Bound">α</a> <a id="8726" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="8728" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a> <a id="8733" class="Symbol">→</a> <a id="8735" href="NonWellFormed.Ordinal.html#8719" class="Bound">α</a> <a id="8737" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8739" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a>
<a id="8744" href="NonWellFormed.Ordinal.html#8708" class="Function">≤z⇒≈z</a> <a id="8750" class="Symbol">{</a><a id="8751" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="8755" class="Symbol">}</a> <a id="8757" class="Symbol">_</a> <a id="8759" class="Symbol">=</a> <a id="8761" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a>
<a id="8768" href="NonWellFormed.Ordinal.html#8708" class="Function">≤z⇒≈z</a> <a id="8774" class="Symbol">{</a><a id="8775" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="8779" href="NonWellFormed.Ordinal.html#8779" class="Bound">α</a><a id="8780" class="Symbol">}</a> <a id="8782" class="Symbol">(</a><a id="8783" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="8786" class="Symbol">{</a><a id="8787" class="Argument">d</a> <a id="8789" class="Symbol">=</a> <a id="8791" class="Symbol">()}</a> <a id="8795" class="Symbol">_)</a>
<a id="8798" href="NonWellFormed.Ordinal.html#8708" class="Function">≤z⇒≈z</a> <a id="8804" class="Symbol">{</a><a id="8805" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="8809" href="NonWellFormed.Ordinal.html#8809" class="Bound">f</a><a id="8810" class="Symbol">}</a> <a id="8812" href="NonWellFormed.Ordinal.html#8812" class="Bound">≤</a> <a id="8814" class="Symbol">=</a> <a id="8816" href="NonWellFormed.Ordinal.html#8812" class="Bound">≤</a> <a id="8818" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8820" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
</pre>
<p>以下三条是 <code>_≈_</code> 版本的 <code>s≤s</code>, <code>s≤s⇒≤</code> 和 <code>≤⇔s≤s</code>.</p>
<pre class="Agda"><a id="s≈s"></a><a id="8879" href="NonWellFormed.Ordinal.html#8879" class="Function">s≈s</a> <a id="8883" class="Symbol">:</a> <a id="8885" class="Symbol">∀</a> <a id="8887" class="Symbol">{</a><a id="8888" href="NonWellFormed.Ordinal.html#8888" class="Bound">α</a> <a id="8890" href="NonWellFormed.Ordinal.html#8890" class="Bound">β</a><a id="8891" class="Symbol">}</a> <a id="8893" class="Symbol">→</a> <a id="8895" href="NonWellFormed.Ordinal.html#8888" class="Bound">α</a> <a id="8897" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8899" href="NonWellFormed.Ordinal.html#8890" class="Bound">β</a> <a id="8901" class="Symbol">→</a> <a id="8903" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="8907" href="NonWellFormed.Ordinal.html#8888" class="Bound">α</a> <a id="8909" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8911" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="8915" href="NonWellFormed.Ordinal.html#8890" class="Bound">β</a>
<a id="8917" href="NonWellFormed.Ordinal.html#8879" class="Function">s≈s</a> <a id="8921" class="Symbol">(</a><a id="8922" href="NonWellFormed.Ordinal.html#8922" class="Bound">α≤β</a> <a id="8926" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8928" href="NonWellFormed.Ordinal.html#8928" class="Bound">β≤α</a><a id="8931" class="Symbol">)</a> <a id="8933" class="Symbol">=</a> <a id="8935" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="8939" href="NonWellFormed.Ordinal.html#8922" class="Bound">α≤β</a> <a id="8943" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8945" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="8949" href="NonWellFormed.Ordinal.html#8928" class="Bound">β≤α</a>

<a id="s≈s⇒≈"></a><a id="8954" href="NonWellFormed.Ordinal.html#8954" class="Function">s≈s⇒≈</a> <a id="8960" class="Symbol">:</a> <a id="8962" class="Symbol">∀</a> <a id="8964" class="Symbol">{</a><a id="8965" href="NonWellFormed.Ordinal.html#8965" class="Bound">α</a> <a id="8967" href="NonWellFormed.Ordinal.html#8967" class="Bound">β</a><a id="8968" class="Symbol">}</a> <a id="8970" class="Symbol">→</a> <a id="8972" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="8976" href="NonWellFormed.Ordinal.html#8965" class="Bound">α</a> <a id="8978" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8980" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="8984" href="NonWellFormed.Ordinal.html#8967" class="Bound">β</a> <a id="8986" class="Symbol">→</a> <a id="8988" href="NonWellFormed.Ordinal.html#8965" class="Bound">α</a> <a id="8990" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="8992" href="NonWellFormed.Ordinal.html#8967" class="Bound">β</a>
<a id="8994" href="NonWellFormed.Ordinal.html#8954" class="Function">s≈s⇒≈</a> <a id="9000" class="Symbol">(</a><a id="9001" href="NonWellFormed.Ordinal.html#9001" class="Bound">sα≤sβ</a> <a id="9007" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9009" href="NonWellFormed.Ordinal.html#9009" class="Bound">sβ≤sα</a><a id="9014" class="Symbol">)</a> <a id="9016" class="Symbol">=</a> <a id="9018" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="9024" href="NonWellFormed.Ordinal.html#9001" class="Bound">sα≤sβ</a> <a id="9030" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9032" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="9038" href="NonWellFormed.Ordinal.html#9009" class="Bound">sβ≤sα</a>

<a id="≈⇔s≈s"></a><a id="9045" href="NonWellFormed.Ordinal.html#9045" class="Function">≈⇔s≈s</a> <a id="9051" class="Symbol">:</a> <a id="9053" class="Symbol">∀</a> <a id="9055" class="Symbol">{</a><a id="9056" href="NonWellFormed.Ordinal.html#9056" class="Bound">α</a> <a id="9058" href="NonWellFormed.Ordinal.html#9058" class="Bound">β</a><a id="9059" class="Symbol">}</a> <a id="9061" class="Symbol">→</a> <a id="9063" href="NonWellFormed.Ordinal.html#9056" class="Bound">α</a> <a id="9065" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="9067" href="NonWellFormed.Ordinal.html#9058" class="Bound">β</a> <a id="9069" href="Function.Equivalence.html#1213" class="Function Operator">⇔</a> <a id="9071" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9075" href="NonWellFormed.Ordinal.html#9056" class="Bound">α</a> <a id="9077" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="9079" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9083" href="NonWellFormed.Ordinal.html#9058" class="Bound">β</a>
<a id="9085" href="NonWellFormed.Ordinal.html#9045" class="Function">≈⇔s≈s</a> <a id="9091" class="Symbol">=</a> <a id="9093" href="NonWellFormed.Ordinal.html#2663" class="Function">mk⇔</a> <a id="9097" href="NonWellFormed.Ordinal.html#8879" class="Function">s≈s</a> <a id="9101" href="NonWellFormed.Ordinal.html#8954" class="Function">s≈s⇒≈</a>
</pre>
<p>如果两个序列逐项相等, 那么它们的极限相等.</p>
<pre class="Agda"><a id="l≈l"></a><a id="9144" href="NonWellFormed.Ordinal.html#9144" class="Function">l≈l</a> <a id="9148" class="Symbol">:</a> <a id="9150" class="Symbol">∀</a> <a id="9152" class="Symbol">{</a><a id="9153" href="NonWellFormed.Ordinal.html#9153" class="Bound">f</a> <a id="9155" href="NonWellFormed.Ordinal.html#9155" class="Bound">g</a><a id="9156" class="Symbol">}</a> <a id="9158" class="Symbol">→</a> <a id="9160" class="Symbol">(∀</a> <a id="9163" class="Symbol">{</a><a id="9164" href="NonWellFormed.Ordinal.html#9164" class="Bound">n</a><a id="9165" class="Symbol">}</a> <a id="9167" class="Symbol">→</a> <a id="9169" href="NonWellFormed.Ordinal.html#9153" class="Bound">f</a> <a id="9171" href="NonWellFormed.Ordinal.html#9164" class="Bound">n</a> <a id="9173" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="9175" href="NonWellFormed.Ordinal.html#9155" class="Bound">g</a> <a id="9177" href="NonWellFormed.Ordinal.html#9164" class="Bound">n</a><a id="9178" class="Symbol">)</a> <a id="9180" class="Symbol">→</a> <a id="9182" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="9186" href="NonWellFormed.Ordinal.html#9153" class="Bound">f</a> <a id="9188" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="9190" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="9194" href="NonWellFormed.Ordinal.html#9155" class="Bound">g</a>
<a id="9196" href="NonWellFormed.Ordinal.html#9144" class="Function">l≈l</a> <a id="9200" href="NonWellFormed.Ordinal.html#9200" class="Bound">ext</a> <a id="9204" class="Symbol">=</a> <a id="9206" href="NonWellFormed.Ordinal.html#6835" class="Function">l≤l</a> <a id="9210" class="Symbol">(</a><a id="9211" href="Function.Base.html#2790" class="Function">λ-</a> <a id="9214" class="Symbol">(</a><a id="9215" href="Data.Product.Base.html#617" class="Field">proj₁</a> <a id="9221" href="NonWellFormed.Ordinal.html#9200" class="Bound">ext</a><a id="9224" class="Symbol">))</a>
        <a id="9235" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9237" href="NonWellFormed.Ordinal.html#6835" class="Function">l≤l</a> <a id="9241" class="Symbol">(</a><a id="9242" href="Function.Base.html#2790" class="Function">λ-</a> <a id="9245" class="Symbol">(</a><a id="9246" href="Data.Product.Base.html#631" class="Field">proj₂</a> <a id="9252" href="NonWellFormed.Ordinal.html#9200" class="Bound">ext</a><a id="9255" class="Symbol">))</a>
</pre>
<p>序列极限与起始项无关.</p>
<pre class="Agda"><a id="l≈ls"></a><a id="9284" href="NonWellFormed.Ordinal.html#9284" class="Function">l≈ls</a> <a id="9289" class="Symbol">:</a> <a id="9291" class="Symbol">∀</a> <a id="9293" class="Symbol">{</a><a id="9294" href="NonWellFormed.Ordinal.html#9294" class="Bound">f</a><a id="9295" class="Symbol">}</a> <a id="9297" class="Symbol">→</a> <a id="9299" href="NonWellFormed.Ordinal.html#9294" class="Bound">f</a> <a id="9301" class="Number">0</a> <a id="9303" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="9305" href="NonWellFormed.Ordinal.html#9294" class="Bound">f</a> <a id="9307" class="Number">1</a> <a id="9309" class="Symbol">→</a> <a id="9311" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="9315" href="NonWellFormed.Ordinal.html#9294" class="Bound">f</a> <a id="9317" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="9319" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="9323" class="Symbol">(</a><a id="9324" href="NonWellFormed.Ordinal.html#9294" class="Bound">f</a> <a id="9326" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="9328" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a><a id="9333" class="Symbol">)</a>
<a id="9335" href="NonWellFormed.Ordinal.html#9284" class="Function">l≈ls</a> <a id="9340" href="NonWellFormed.Ordinal.html#9340" class="Bound">≤</a> <a id="9342" class="Symbol">=</a> <a id="9344" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="9347" class="Symbol">(λ</a> <a id="9350" class="Symbol">{</a> <a id="9352" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">ℕ.zero</a>    <a id="9362" class="Symbol">→</a> <a id="9364" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="9370" href="NonWellFormed.Ordinal.html#9340" class="Bound">≤</a>
               <a id="9387" class="Symbol">;</a> <a id="9389" class="Symbol">(</a><a id="9390" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a> <a id="9396" href="NonWellFormed.Ordinal.html#9396" class="Bound">n</a><a id="9397" class="Symbol">)</a> <a id="9399" class="Symbol">→</a> <a id="9401" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="9407" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a> <a id="9414" class="Symbol">})</a>
       <a id="9424" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9426" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="9429" class="Symbol">λ</a> <a id="9431" href="NonWellFormed.Ordinal.html#9431" class="Bound">n</a> <a id="9433" class="Symbol">→</a> <a id="9435" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="9441" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
</pre>
<h2 id="否命题">否命题</h2>
<p>我们想要引入序数的严格序 <code>_&lt;_</code>, 但其性质的证明依赖于 <code>_≤_</code> 的一些否定式, 我们先证明它们.</p>
<p><strong>引理</strong> 后继不小于等于零.<br />
<strong>证明</strong> 若不然, 可以反演出 ⊥. ∎</p>
<pre class="Agda"><a id="s≰z"></a><a id="9567" href="NonWellFormed.Ordinal.html#9567" class="Function">s≰z</a> <a id="9571" class="Symbol">:</a> <a id="9573" class="Symbol">∀</a> <a id="9575" class="Symbol">{</a><a id="9576" href="NonWellFormed.Ordinal.html#9576" class="Bound">α</a><a id="9577" class="Symbol">}</a> <a id="9579" class="Symbol">→</a> <a id="9581" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9585" href="NonWellFormed.Ordinal.html#9576" class="Bound">α</a> <a id="9587" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">≰</a> <a id="9589" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a>
<a id="9594" href="NonWellFormed.Ordinal.html#9567" class="Function">s≰z</a> <a id="9598" class="Symbol">(</a><a id="9599" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="9602" class="Symbol">{</a><a id="9603" class="Argument">d</a> <a id="9605" class="Symbol">=</a> <a id="9607" href="NonWellFormed.Ordinal.html#9607" class="Bound">⊥</a><a id="9608" class="Symbol">}</a> <a id="9610" href="NonWellFormed.Ordinal.html#9610" class="Bound">≤</a><a id="9611" class="Symbol">)</a> <a id="9613" class="Symbol">=</a> <a id="9615" href="NonWellFormed.Ordinal.html#9607" class="Bound">⊥</a>
</pre>
<p><strong>引理</strong> <code>α</code> 的后继不小于等于 <code>α</code>.<br />
<strong>证明</strong> <code>α</code> 为零的情况上面已证, 为后继或极限的情况用归纳假设可证. ∎</p>
<pre class="Agda"><a id="s≰"></a><a id="9700" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9703" class="Symbol">:</a> <a id="9705" class="Symbol">∀</a> <a id="9707" class="Symbol">{</a><a id="9708" href="NonWellFormed.Ordinal.html#9708" class="Bound">α</a><a id="9709" class="Symbol">}</a> <a id="9711" class="Symbol">→</a> <a id="9713" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9717" href="NonWellFormed.Ordinal.html#9708" class="Bound">α</a> <a id="9719" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">≰</a> <a id="9721" href="NonWellFormed.Ordinal.html#9708" class="Bound">α</a>
<a id="9723" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9726" class="Symbol">{</a><a id="9727" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a><a id="9731" class="Symbol">}</a> <a id="9733" class="Symbol">=</a> <a id="9735" href="NonWellFormed.Ordinal.html#9567" class="Function">s≰z</a>
<a id="9739" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9742" class="Symbol">{</a><a id="9743" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9747" href="NonWellFormed.Ordinal.html#9747" class="Bound">α</a><a id="9748" class="Symbol">}</a> <a id="9750" href="NonWellFormed.Ordinal.html#9750" class="Bound">≤</a> <a id="9752" class="Symbol">=</a> <a id="9754" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9757" class="Symbol">(</a><a id="9758" href="NonWellFormed.Ordinal.html#6548" class="Function">s≤s⇒≤</a> <a id="9764" href="NonWellFormed.Ordinal.html#9750" class="Bound">≤</a><a id="9765" class="Symbol">)</a>
<a id="9767" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9770" class="Symbol">{</a><a id="9771" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="9775" href="NonWellFormed.Ordinal.html#9775" class="Bound">f</a><a id="9776" class="Symbol">}</a> <a id="9778" class="Symbol">(</a><a id="9779" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="9782" class="Symbol">{</a><a id="9783" class="Argument">d</a> <a id="9785" class="Symbol">=</a> <a id="9787" href="NonWellFormed.Ordinal.html#9787" class="Bound">n</a> <a id="9789" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9791" href="NonWellFormed.Ordinal.html#9791" class="Bound">d</a><a id="9792" class="Symbol">}</a> <a id="9794" class="Symbol">(</a><a id="9795" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="9798" href="NonWellFormed.Ordinal.html#9798" class="Bound">f≤</a><a id="9800" class="Symbol">))</a> <a id="9803" class="Symbol">=</a> <a id="9805" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9808" class="Symbol">(</a><a id="9809" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="9812" class="Symbol">(</a><a id="9813" href="NonWellFormed.Ordinal.html#9798" class="Bound">f≤</a> <a id="9816" href="NonWellFormed.Ordinal.html#9787" class="Bound">n</a><a id="9817" class="Symbol">))</a>
</pre>
<p><strong>引理</strong> 如果 <code>α</code> 小于等于 <code>β</code>, 那么 <code>α</code> 的任意前驱不可能大于等于 <code>β</code>.<br />
<strong>证明</strong> 见代码. ∎</p>
<pre class="Agda"><a id="≤⇒∸≱"></a><a id="9899" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="9904" class="Symbol">:</a> <a id="9906" class="Symbol">∀</a> <a id="9908" class="Symbol">{</a><a id="9909" href="NonWellFormed.Ordinal.html#9909" class="Bound">α</a> <a id="9911" href="NonWellFormed.Ordinal.html#9911" class="Bound">β</a> <a id="9913" href="NonWellFormed.Ordinal.html#9913" class="Bound">d</a><a id="9914" class="Symbol">}</a> <a id="9916" class="Symbol">→</a> <a id="9918" href="NonWellFormed.Ordinal.html#9909" class="Bound">α</a> <a id="9920" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="9922" href="NonWellFormed.Ordinal.html#9911" class="Bound">β</a> <a id="9924" class="Symbol">→</a> <a id="9926" href="NonWellFormed.Ordinal.html#9909" class="Bound">α</a> <a id="9928" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="9930" href="NonWellFormed.Ordinal.html#9913" class="Bound">d</a> <a id="9932" href="NonWellFormed.Ordinal.html#4924" class="Function Operator">≱</a> <a id="9934" href="NonWellFormed.Ordinal.html#9911" class="Bound">β</a>
<a id="9936" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="9941" class="Symbol">{</a><a id="9942" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="9946" href="NonWellFormed.Ordinal.html#9946" class="Bound">α</a><a id="9947" class="Symbol">}</a> <a id="9949" class="Symbol">{</a><a id="9950" class="Argument">d</a> <a id="9952" class="Symbol">=</a> <a id="9954" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="9959" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="9961" class="Symbol">}</a> <a id="9963" href="NonWellFormed.Ordinal.html#9963" class="Bound">sα≤β</a>    <a id="9971" href="NonWellFormed.Ordinal.html#9971" class="Bound">β≤α</a>   <a id="9977" class="Symbol">=</a> <a id="9979" href="NonWellFormed.Ordinal.html#9700" class="Function">s≰</a> <a id="9982" class="Symbol">(</a><a id="9983" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="9991" href="NonWellFormed.Ordinal.html#9963" class="Bound">sα≤β</a> <a id="9996" href="NonWellFormed.Ordinal.html#9971" class="Bound">β≤α</a><a id="9999" class="Symbol">)</a>
<a id="10001" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="10006" class="Symbol">{</a><a id="10007" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="10011" href="NonWellFormed.Ordinal.html#10011" class="Bound">α</a><a id="10012" class="Symbol">}</a> <a id="10014" class="Symbol">{</a><a id="10015" class="Argument">d</a> <a id="10017" class="Symbol">=</a> <a id="10019" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="10024" href="NonWellFormed.Ordinal.html#10024" class="Bound">d</a><a id="10025" class="Symbol">}</a>  <a id="10028" href="NonWellFormed.Ordinal.html#10028" class="Bound">sα≤β</a>    <a id="10036" href="NonWellFormed.Ordinal.html#10036" class="Bound">β≤α∸d</a> <a id="10042" class="Symbol">=</a> <a id="10044" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="10049" class="Symbol">(</a><a id="10050" href="NonWellFormed.Ordinal.html#5817" class="Function">s≤⇒≤</a> <a id="10055" href="NonWellFormed.Ordinal.html#10028" class="Bound">sα≤β</a><a id="10059" class="Symbol">)</a> <a id="10061" href="NonWellFormed.Ordinal.html#10036" class="Bound">β≤α∸d</a>
<a id="10067" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="10072" class="Symbol">{</a><a id="10073" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="10077" href="NonWellFormed.Ordinal.html#10077" class="Bound">f</a><a id="10078" class="Symbol">}</a> <a id="10080" class="Symbol">{</a><a id="10081" class="Argument">d</a> <a id="10083" class="Symbol">=</a> <a id="10085" href="NonWellFormed.Ordinal.html#10085" class="Bound">n</a> <a id="10087" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10089" href="NonWellFormed.Ordinal.html#10089" class="Bound">d</a><a id="10090" class="Symbol">}</a>   <a id="10094" class="Symbol">(</a><a id="10095" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="10098" href="NonWellFormed.Ordinal.html#10098" class="Bound">f≤</a><a id="10100" class="Symbol">)</a> <a id="10102" href="NonWellFormed.Ordinal.html#10102" class="Bound">β≤f∸d</a> <a id="10108" class="Symbol">=</a> <a id="10110" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="10115" class="Symbol">(</a><a id="10116" href="NonWellFormed.Ordinal.html#10098" class="Bound">f≤</a> <a id="10119" href="NonWellFormed.Ordinal.html#10085" class="Bound">n</a><a id="10120" class="Symbol">)</a> <a id="10122" href="NonWellFormed.Ordinal.html#10102" class="Bound">β≤f∸d</a>
</pre>
<p><strong>引理</strong> 任何序数都不小于等于自身的任意前驱.<br />
<strong>证明</strong> 这是上一条的特化. ∎</p>
<pre class="Agda"><a id="≰∸"></a><a id="10189" href="NonWellFormed.Ordinal.html#10189" class="Function">≰∸</a> <a id="10192" class="Symbol">:</a> <a id="10194" class="Symbol">∀</a> <a id="10196" class="Symbol">{</a><a id="10197" href="NonWellFormed.Ordinal.html#10197" class="Bound">α</a> <a id="10199" href="NonWellFormed.Ordinal.html#10199" class="Bound">d</a><a id="10200" class="Symbol">}</a> <a id="10202" class="Symbol">→</a> <a id="10204" href="NonWellFormed.Ordinal.html#10197" class="Bound">α</a> <a id="10206" href="NonWellFormed.Ordinal.html#4890" class="Function Operator">≰</a> <a id="10208" href="NonWellFormed.Ordinal.html#10197" class="Bound">α</a> <a id="10210" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="10212" href="NonWellFormed.Ordinal.html#10199" class="Bound">d</a>
<a id="10214" href="NonWellFormed.Ordinal.html#10189" class="Function">≰∸</a> <a id="10217" class="Symbol">=</a> <a id="10219" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="10224" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
</pre>
<h2 id="严格序">严格序</h2>
<p>我们将 <code>α</code> 小于 <code>β</code> 定义为 <code>α</code> 小于等于 <code>β</code> 的某个前驱.</p>
<pre class="Agda"><a id="10292" class="Keyword">infix</a> <a id="10298" class="Number">4</a> <a id="10300" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="10304" href="NonWellFormed.Ordinal.html#10884" class="Function Operator">_&gt;_</a> <a id="10308" href="NonWellFormed.Ordinal.html#10916" class="Function Operator">_≮_</a> <a id="10312" href="NonWellFormed.Ordinal.html#10950" class="Function Operator">_≯_</a>

<a id="_&lt;_"></a><a id="10317" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="10321" class="Symbol">:</a> <a id="10323" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="10327" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="10331" href="Level.html#521" class="Function">0ℓ</a>
<a id="10334" href="NonWellFormed.Ordinal.html#10334" class="Bound">α</a> <a id="10336" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="10338" href="NonWellFormed.Ordinal.html#10338" class="Bound">β</a> <a id="10340" class="Symbol">=</a> <a id="10342" href="Data.Product.html#1094" class="Function">∃[</a> <a id="10345" href="NonWellFormed.Ordinal.html#10345" class="Bound">d</a> <a id="10347" href="Data.Product.html#1094" class="Function">]</a> <a id="10349" href="NonWellFormed.Ordinal.html#10334" class="Bound">α</a> <a id="10351" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="10353" href="NonWellFormed.Ordinal.html#10338" class="Bound">β</a> <a id="10355" href="NonWellFormed.Ordinal.html#4220" class="Function Operator">∸</a> <a id="10357" href="NonWellFormed.Ordinal.html#10345" class="Bound">d</a>
</pre>
<p>注意这里不使用标准库的 <a href="https://agda.github.io/agda-stdlib/Relation.Binary.Construct.NonStrictToStrict.html">NonStrictToStrict</a> 框架把 <code>_&lt;_</code> 定义成 <code>α ≤ β × α ≉ β</code>, 理由有三.</p>
<ol type="1">
<li>在缺少排中律的情况下无法从 <code>α ≤ β × α ≉ β</code> 得到 <code>α ≤ β × α ≱ β</code>.</li>
<li>即使有 <code>α ≱ β</code>, 也无法得到我们的 <code>_&lt;_</code>. 因为在缺少排中律的情况下无法从否定式得到存在性命题.</li>
<li>由我们的 <code>_&lt;_</code> 和前述引理 <code>≤⇒∸≱</code> 可以得到 <code>α ≱ β</code>, 见后文的 <code>&lt;⇒≱</code>.</li>
</ol>
<p>总之, 在构造主义中, 我们的定义严格强于 <code>α ≤ β × α ≉ β</code>. 它使命题的表述更加直接且符合构造主义, 因为不涉及否定式. 此外, <code>α ≤ β</code> 无法分裂成 <code>α &lt; β ⊎ α ≈ β</code>, 因为后者严格强于前者, 不过这种论证并不是必须的. 我们在<a href="Ordinal.Classic.html">独立的一章</a>证明了排中律下两者的等价性.</p>
<p>以下是例行的变体定义.</p>
<pre class="Agda"><a id="_&gt;_"></a><a id="10884" href="NonWellFormed.Ordinal.html#10884" class="Function Operator">_&gt;_</a> <a id="10888" class="Symbol">:</a> <a id="10890" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="10894" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="10898" href="Level.html#521" class="Function">0ℓ</a>
<a id="10901" href="NonWellFormed.Ordinal.html#10901" class="Bound">α</a> <a id="10903" href="NonWellFormed.Ordinal.html#10884" class="Function Operator">&gt;</a> <a id="10905" href="NonWellFormed.Ordinal.html#10905" class="Bound">β</a> <a id="10907" class="Symbol">=</a> <a id="10909" href="NonWellFormed.Ordinal.html#10905" class="Bound">β</a> <a id="10911" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="10913" href="NonWellFormed.Ordinal.html#10901" class="Bound">α</a>

<a id="_≮_"></a><a id="10916" href="NonWellFormed.Ordinal.html#10916" class="Function Operator">_≮_</a> <a id="10920" class="Symbol">:</a> <a id="10922" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="10926" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="10930" href="Level.html#521" class="Function">0ℓ</a>
<a id="10933" href="NonWellFormed.Ordinal.html#10933" class="Bound">α</a> <a id="10935" href="NonWellFormed.Ordinal.html#10916" class="Function Operator">≮</a> <a id="10937" href="NonWellFormed.Ordinal.html#10937" class="Bound">β</a> <a id="10939" class="Symbol">=</a> <a id="10941" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬</a> <a id="10943" href="NonWellFormed.Ordinal.html#10933" class="Bound">α</a> <a id="10945" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="10947" href="NonWellFormed.Ordinal.html#10937" class="Bound">β</a>

<a id="_≯_"></a><a id="10950" href="NonWellFormed.Ordinal.html#10950" class="Function Operator">_≯_</a> <a id="10954" class="Symbol">:</a> <a id="10956" href="Relation.Binary.Core.html#891" class="Function">Rel</a> <a id="10960" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="10964" href="Level.html#521" class="Function">0ℓ</a>
<a id="10967" href="NonWellFormed.Ordinal.html#10967" class="Bound">α</a> <a id="10969" href="NonWellFormed.Ordinal.html#10950" class="Function Operator">≯</a> <a id="10971" href="NonWellFormed.Ordinal.html#10971" class="Bound">β</a> <a id="10973" class="Symbol">=</a> <a id="10975" href="Relation.Nullary.Negation.Core.html#824" class="Function Operator">¬</a> <a id="10977" href="NonWellFormed.Ordinal.html#10971" class="Bound">β</a> <a id="10979" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="10981" href="NonWellFormed.Ordinal.html#10967" class="Bound">α</a>
</pre>
<p>由 <code>_&lt;_</code> 的定义立即可知零小于任意后继, 因为存在 <code>d = inj₁ tt</code> 使得 <code>zero ≤ suc α ∸ d</code>. 类似可证, 任意序数小于自身的后继.</p>
<pre class="Agda"><a id="z&lt;s"></a><a id="11082" href="NonWellFormed.Ordinal.html#11082" class="Function">z&lt;s</a> <a id="11086" class="Symbol">:</a> <a id="11088" class="Symbol">∀</a> <a id="11090" class="Symbol">{</a><a id="11091" href="NonWellFormed.Ordinal.html#11091" class="Bound">α</a><a id="11092" class="Symbol">}</a> <a id="11094" class="Symbol">→</a> <a id="11096" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a> <a id="11101" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="11103" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="11107" href="NonWellFormed.Ordinal.html#11091" class="Bound">α</a>
<a id="11109" href="NonWellFormed.Ordinal.html#11082" class="Function">z&lt;s</a> <a id="11113" class="Symbol">=</a> <a id="11115" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="11120" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="11123" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11125" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>

<a id="&lt;s"></a><a id="11129" href="NonWellFormed.Ordinal.html#11129" class="Function">&lt;s</a> <a id="11132" class="Symbol">:</a> <a id="11134" class="Symbol">∀</a> <a id="11136" class="Symbol">{</a><a id="11137" href="NonWellFormed.Ordinal.html#11137" class="Bound">α</a><a id="11138" class="Symbol">}</a> <a id="11140" class="Symbol">→</a> <a id="11142" href="NonWellFormed.Ordinal.html#11137" class="Bound">α</a> <a id="11144" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="11146" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="11150" href="NonWellFormed.Ordinal.html#11137" class="Bound">α</a>
<a id="11152" href="NonWellFormed.Ordinal.html#11129" class="Function">&lt;s</a> <a id="11155" class="Symbol">=</a> <a id="11157" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="11162" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="11165" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11167" href="NonWellFormed.Ordinal.html#6969" class="Function">≤-refl</a>
</pre>
<p>由上一小节证明的否定式可以证明 <code>_&lt;_</code> 反自反且传递. 其中反自反分两个版本: <code>_≡_</code> 版用 refl 反演后即引理 <code>≰∸</code>; <code>_≈_</code> 版用引理 <code>≤⇒∸≱</code> 不难证明.</p>
<pre class="Agda"><a id="&lt;-irrefl-≡"></a><a id="11281" href="NonWellFormed.Ordinal.html#11281" class="Function">&lt;-irrefl-≡</a> <a id="11292" class="Symbol">:</a> <a id="11294" href="Relation.Binary.Definitions.html#2315" class="Function">Irreflexive</a> <a id="11306" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="11310" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="11314" href="NonWellFormed.Ordinal.html#11281" class="Function">&lt;-irrefl-≡</a> <a id="11325" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11330" class="Symbol">(</a><a id="11331" href="NonWellFormed.Ordinal.html#11331" class="Bound">d</a> <a id="11333" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11335" href="NonWellFormed.Ordinal.html#11335" class="Bound">α≤α∸d</a><a id="11340" class="Symbol">)</a> <a id="11342" class="Symbol">=</a> <a id="11344" href="NonWellFormed.Ordinal.html#10189" class="Function">≰∸</a> <a id="11347" href="NonWellFormed.Ordinal.html#11335" class="Bound">α≤α∸d</a>

<a id="&lt;-irrefl-≈"></a><a id="11354" href="NonWellFormed.Ordinal.html#11354" class="Function">&lt;-irrefl-≈</a> <a id="11365" class="Symbol">:</a> <a id="11367" href="Relation.Binary.Definitions.html#2315" class="Function">Irreflexive</a> <a id="11379" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a> <a id="11383" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="11387" href="NonWellFormed.Ordinal.html#11354" class="Function">&lt;-irrefl-≈</a> <a id="11398" class="Symbol">(</a><a id="11399" href="NonWellFormed.Ordinal.html#11399" class="Bound">α≤β</a> <a id="11403" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11405" href="NonWellFormed.Ordinal.html#11405" class="Bound">β≤α</a><a id="11408" class="Symbol">)</a> <a id="11410" class="Symbol">(</a><a id="11411" href="NonWellFormed.Ordinal.html#11411" class="Bound">d</a> <a id="11413" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11415" href="NonWellFormed.Ordinal.html#11415" class="Bound">α≤β∸d</a><a id="11420" class="Symbol">)</a> <a id="11422" class="Symbol">=</a> <a id="11424" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="11429" href="NonWellFormed.Ordinal.html#11405" class="Bound">β≤α</a> <a id="11433" href="NonWellFormed.Ordinal.html#11415" class="Bound">α≤β∸d</a>
</pre>
<p><code>_&lt;_</code> 的传递性由 <code>_≤_</code> 的传递性而来. 非对称性是反自反和传递性的推论.</p>
<pre class="Agda"><a id="&lt;-trans"></a><a id="11496" href="NonWellFormed.Ordinal.html#11496" class="Function">&lt;-trans</a> <a id="11504" class="Symbol">:</a> <a id="11506" href="Relation.Binary.Definitions.html#1940" class="Function">Transitive</a> <a id="11517" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="11521" href="NonWellFormed.Ordinal.html#11496" class="Function">&lt;-trans</a> <a id="11529" class="Symbol">(</a><a id="11530" href="NonWellFormed.Ordinal.html#11530" class="Bound">d₁</a> <a id="11533" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11535" href="NonWellFormed.Ordinal.html#11535" class="Bound">α≤β∸d₁</a><a id="11541" class="Symbol">)</a> <a id="11543" class="Symbol">(</a><a id="11544" href="NonWellFormed.Ordinal.html#11544" class="Bound">d₂</a> <a id="11547" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11549" href="NonWellFormed.Ordinal.html#11549" class="Bound">β≤γ∸d₂</a><a id="11555" class="Symbol">)</a> <a id="11557" class="Symbol">=</a> <a id="11559" href="NonWellFormed.Ordinal.html#11544" class="Bound">d₂</a> <a id="11562" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11564" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="11572" class="Symbol">(</a><a id="11573" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="11578" href="NonWellFormed.Ordinal.html#11535" class="Bound">α≤β∸d₁</a><a id="11584" class="Symbol">)</a> <a id="11586" href="NonWellFormed.Ordinal.html#11549" class="Bound">β≤γ∸d₂</a>

<a id="&lt;-asym"></a><a id="11594" href="NonWellFormed.Ordinal.html#11594" class="Function">&lt;-asym</a> <a id="11601" class="Symbol">:</a> <a id="11603" href="Relation.Binary.Definitions.html#2427" class="Function">Asymmetric</a> <a id="11614" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="11618" href="NonWellFormed.Ordinal.html#11594" class="Function">&lt;-asym</a> <a id="11625" class="Symbol">=</a> <a id="11627" href="Relation.Binary.Consequences.html#4013" class="Function">trans∧irr⇒asym</a> <a id="11642" class="Symbol">{</a><a id="11643" class="Argument">_≈_</a> <a id="11647" class="Symbol">=</a> <a id="11649" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a><a id="11652" class="Symbol">}</a> <a id="11654" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a> <a id="11661" href="NonWellFormed.Ordinal.html#11496" class="Function">&lt;-trans</a> <a id="11669" href="NonWellFormed.Ordinal.html#11354" class="Function">&lt;-irrefl-≈</a>
</pre>
<p>以上就是我们能证明的最好结果. 在构造主义中我们无法证明 <code>_&lt;_</code> 的线序性, 但这丝毫不影响后续理论 (Veblen 不动点) 的构筑.</p>
<h2 id="与-的相互转化"><code>&lt;</code> 与 <code>≤</code> 的相互转化</h2>
<p>我们顺着 <a href="https://agda.github.io/agda-stdlib/Relation.Binary.Construct.NonStrictToStrict.html">NonStrictToStrict</a> 补上所需引理. 首先, 显然地, <code>_&lt;_</code> 蕴含 <code>_≤_</code>.</p>
<pre class="Agda"><a id="&lt;⇒≤"></a><a id="11929" href="NonWellFormed.Ordinal.html#11929" class="Function">&lt;⇒≤</a> <a id="11933" class="Symbol">:</a> <a id="11935" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="11939" href="Relation.Binary.Core.html#1263" class="Function Operator">⇒</a> <a id="11941" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a>
<a id="11945" href="NonWellFormed.Ordinal.html#11929" class="Function">&lt;⇒≤</a> <a id="11949" class="Symbol">(</a><a id="11950" href="NonWellFormed.Ordinal.html#11950" class="Bound">d</a> <a id="11952" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11954" href="NonWellFormed.Ordinal.html#11954" class="Bound">α≤β∸d</a><a id="11959" class="Symbol">)</a> <a id="11961" class="Symbol">=</a> <a id="11963" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="11968" href="NonWellFormed.Ordinal.html#11954" class="Bound">α≤β∸d</a>
</pre>
<p>然后是否命题的转化, 它们的逆命题依赖于 <code>_≤_</code> 的线序性和 <code>_≈_</code> 的可判定性, 本构筑中都不涉及.</p>
<pre class="Agda"><a id="&lt;⇒≱"></a><a id="12044" href="NonWellFormed.Ordinal.html#12044" class="Function">&lt;⇒≱</a> <a id="12048" class="Symbol">:</a> <a id="12050" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="12054" href="Relation.Binary.Core.html#1263" class="Function Operator">⇒</a> <a id="12056" href="NonWellFormed.Ordinal.html#4924" class="Function Operator">_≱_</a>
<a id="12060" href="NonWellFormed.Ordinal.html#12044" class="Function">&lt;⇒≱</a> <a id="12064" class="Symbol">(</a><a id="12065" href="NonWellFormed.Ordinal.html#12065" class="Bound">d</a> <a id="12067" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12069" href="NonWellFormed.Ordinal.html#12069" class="Bound">α≤β∸d</a><a id="12074" class="Symbol">)</a> <a id="12076" href="NonWellFormed.Ordinal.html#12076" class="Bound">β≤α</a> <a id="12080" class="Symbol">=</a> <a id="12082" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="12087" href="NonWellFormed.Ordinal.html#12076" class="Bound">β≤α</a> <a id="12091" href="NonWellFormed.Ordinal.html#12069" class="Bound">α≤β∸d</a>

<a id="≤⇒≯"></a><a id="12098" href="NonWellFormed.Ordinal.html#12098" class="Function">≤⇒≯</a> <a id="12102" class="Symbol">:</a> <a id="12104" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="12108" href="Relation.Binary.Core.html#1263" class="Function Operator">⇒</a> <a id="12110" href="NonWellFormed.Ordinal.html#10950" class="Function Operator">_≯_</a>
<a id="12114" href="NonWellFormed.Ordinal.html#12098" class="Function">≤⇒≯</a> <a id="12118" href="NonWellFormed.Ordinal.html#12118" class="Bound">α≤β</a> <a id="12122" class="Symbol">(</a><a id="12123" href="NonWellFormed.Ordinal.html#12123" class="Bound">d</a> <a id="12125" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12127" href="NonWellFormed.Ordinal.html#12127" class="Bound">β≤α∸d</a><a id="12132" class="Symbol">)</a> <a id="12134" class="Symbol">=</a> <a id="12136" href="NonWellFormed.Ordinal.html#9899" class="Function">≤⇒∸≱</a> <a id="12141" href="NonWellFormed.Ordinal.html#12118" class="Bound">α≤β</a> <a id="12145" href="NonWellFormed.Ordinal.html#12127" class="Bound">β≤α∸d</a>
</pre>
<p>接着是涉及 <code>suc</code> 的两组等价式.</p>
<pre class="Agda"><a id="&lt;⇒s≤"></a><a id="12185" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="12190" class="Symbol">:</a> <a id="12192" class="Symbol">∀</a> <a id="12194" class="Symbol">{</a><a id="12195" href="NonWellFormed.Ordinal.html#12195" class="Bound">α</a> <a id="12197" href="NonWellFormed.Ordinal.html#12197" class="Bound">β</a><a id="12198" class="Symbol">}</a> <a id="12200" class="Symbol">→</a> <a id="12202" href="NonWellFormed.Ordinal.html#12195" class="Bound">α</a> <a id="12204" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12206" href="NonWellFormed.Ordinal.html#12197" class="Bound">β</a> <a id="12208" class="Symbol">→</a> <a id="12210" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12214" href="NonWellFormed.Ordinal.html#12195" class="Bound">α</a> <a id="12216" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12218" href="NonWellFormed.Ordinal.html#12197" class="Bound">β</a>
<a id="12220" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="12225" class="Symbol">(</a><a id="12226" href="NonWellFormed.Ordinal.html#12226" class="Bound">d</a> <a id="12228" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12230" href="NonWellFormed.Ordinal.html#12230" class="Bound">α≤β∸d</a><a id="12235" class="Symbol">)</a> <a id="12237" class="Symbol">=</a> <a id="12239" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="12242" href="NonWellFormed.Ordinal.html#12230" class="Bound">α≤β∸d</a>

<a id="s≤⇒&lt;"></a><a id="12249" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a> <a id="12254" class="Symbol">:</a> <a id="12256" class="Symbol">∀</a> <a id="12258" class="Symbol">{</a><a id="12259" href="NonWellFormed.Ordinal.html#12259" class="Bound">α</a> <a id="12261" href="NonWellFormed.Ordinal.html#12261" class="Bound">β</a><a id="12262" class="Symbol">}</a> <a id="12264" class="Symbol">→</a> <a id="12266" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12270" href="NonWellFormed.Ordinal.html#12259" class="Bound">α</a> <a id="12272" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12274" href="NonWellFormed.Ordinal.html#12261" class="Bound">β</a> <a id="12276" class="Symbol">→</a> <a id="12278" href="NonWellFormed.Ordinal.html#12259" class="Bound">α</a> <a id="12280" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12282" href="NonWellFormed.Ordinal.html#12261" class="Bound">β</a>
<a id="12284" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a> <a id="12289" class="Symbol">(</a><a id="12290" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">s≤</a> <a id="12293" class="Symbol">{</a><a id="12294" class="Argument">d</a> <a id="12296" class="Symbol">=</a> <a id="12298" href="NonWellFormed.Ordinal.html#12298" class="Bound">d</a><a id="12299" class="Symbol">}</a> <a id="12301" href="NonWellFormed.Ordinal.html#12301" class="Bound">α≤β∸d</a><a id="12306" class="Symbol">)</a> <a id="12308" class="Symbol">=</a> <a id="12310" href="NonWellFormed.Ordinal.html#12298" class="Bound">d</a> <a id="12312" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12314" href="NonWellFormed.Ordinal.html#12301" class="Bound">α≤β∸d</a>

<a id="&lt;⇔s≤"></a><a id="12321" href="NonWellFormed.Ordinal.html#12321" class="Function">&lt;⇔s≤</a> <a id="12326" class="Symbol">:</a> <a id="12328" class="Symbol">∀</a> <a id="12330" class="Symbol">{</a><a id="12331" href="NonWellFormed.Ordinal.html#12331" class="Bound">α</a> <a id="12333" href="NonWellFormed.Ordinal.html#12333" class="Bound">β</a><a id="12334" class="Symbol">}</a> <a id="12336" class="Symbol">→</a> <a id="12338" href="NonWellFormed.Ordinal.html#12331" class="Bound">α</a> <a id="12340" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12342" href="NonWellFormed.Ordinal.html#12333" class="Bound">β</a> <a id="12344" href="Function.Equivalence.html#1213" class="Function Operator">⇔</a> <a id="12346" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12350" href="NonWellFormed.Ordinal.html#12331" class="Bound">α</a> <a id="12352" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12354" href="NonWellFormed.Ordinal.html#12333" class="Bound">β</a>
<a id="12356" href="NonWellFormed.Ordinal.html#12321" class="Function">&lt;⇔s≤</a> <a id="12361" class="Symbol">=</a> <a id="12363" href="NonWellFormed.Ordinal.html#2663" class="Function">mk⇔</a> <a id="12367" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="12372" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a>
</pre>
<pre class="Agda"><a id="≤⇒&lt;s"></a><a id="12390" href="NonWellFormed.Ordinal.html#12390" class="Function">≤⇒&lt;s</a> <a id="12395" class="Symbol">:</a> <a id="12397" class="Symbol">∀</a> <a id="12399" class="Symbol">{</a><a id="12400" href="NonWellFormed.Ordinal.html#12400" class="Bound">α</a> <a id="12402" href="NonWellFormed.Ordinal.html#12402" class="Bound">β</a><a id="12403" class="Symbol">}</a> <a id="12405" class="Symbol">→</a> <a id="12407" href="NonWellFormed.Ordinal.html#12400" class="Bound">α</a> <a id="12409" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12411" href="NonWellFormed.Ordinal.html#12402" class="Bound">β</a> <a id="12413" class="Symbol">→</a> <a id="12415" href="NonWellFormed.Ordinal.html#12400" class="Bound">α</a> <a id="12417" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12419" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12423" href="NonWellFormed.Ordinal.html#12402" class="Bound">β</a>
<a id="12425" href="NonWellFormed.Ordinal.html#12390" class="Function">≤⇒&lt;s</a> <a id="12430" href="NonWellFormed.Ordinal.html#12430" class="Bound">α≤β</a> <a id="12434" class="Symbol">=</a> <a id="12436" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="12441" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12444" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12446" href="NonWellFormed.Ordinal.html#12430" class="Bound">α≤β</a>

<a id="&lt;s⇒≤"></a><a id="12451" href="NonWellFormed.Ordinal.html#12451" class="Function">&lt;s⇒≤</a> <a id="12456" class="Symbol">:</a> <a id="12458" class="Symbol">∀</a> <a id="12460" class="Symbol">{</a><a id="12461" href="NonWellFormed.Ordinal.html#12461" class="Bound">α</a> <a id="12463" href="NonWellFormed.Ordinal.html#12463" class="Bound">β</a><a id="12464" class="Symbol">}</a> <a id="12466" class="Symbol">→</a> <a id="12468" href="NonWellFormed.Ordinal.html#12461" class="Bound">α</a> <a id="12470" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12472" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12476" href="NonWellFormed.Ordinal.html#12463" class="Bound">β</a> <a id="12478" class="Symbol">→</a> <a id="12480" href="NonWellFormed.Ordinal.html#12461" class="Bound">α</a> <a id="12482" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12484" href="NonWellFormed.Ordinal.html#12463" class="Bound">β</a>
<a id="12486" href="NonWellFormed.Ordinal.html#12451" class="Function">&lt;s⇒≤</a> <a id="12491" class="Symbol">(</a><a id="12492" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="12497" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12500" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12502" href="NonWellFormed.Ordinal.html#12502" class="Bound">α≤β</a><a id="12505" class="Symbol">)</a>   <a id="12509" class="Symbol">=</a> <a id="12511" href="NonWellFormed.Ordinal.html#12502" class="Bound">α≤β</a>
<a id="12515" href="NonWellFormed.Ordinal.html#12451" class="Function">&lt;s⇒≤</a> <a id="12520" class="Symbol">(</a><a id="12521" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="12526" href="NonWellFormed.Ordinal.html#12526" class="Bound">d</a>  <a id="12529" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12531" href="NonWellFormed.Ordinal.html#12531" class="Bound">α≤β∸d</a><a id="12536" class="Symbol">)</a> <a id="12538" class="Symbol">=</a> <a id="12540" href="NonWellFormed.Ordinal.html#5102" class="Function">≤∸⇒≤</a> <a id="12545" href="NonWellFormed.Ordinal.html#12531" class="Bound">α≤β∸d</a>

<a id="≤⇔&lt;s"></a><a id="12552" href="NonWellFormed.Ordinal.html#12552" class="Function">≤⇔&lt;s</a> <a id="12557" class="Symbol">:</a> <a id="12559" class="Symbol">∀</a> <a id="12561" class="Symbol">{</a><a id="12562" href="NonWellFormed.Ordinal.html#12562" class="Bound">α</a> <a id="12564" href="NonWellFormed.Ordinal.html#12564" class="Bound">β</a><a id="12565" class="Symbol">}</a> <a id="12567" class="Symbol">→</a> <a id="12569" href="NonWellFormed.Ordinal.html#12562" class="Bound">α</a> <a id="12571" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12573" href="NonWellFormed.Ordinal.html#12564" class="Bound">β</a> <a id="12575" href="Function.Equivalence.html#1213" class="Function Operator">⇔</a> <a id="12577" href="NonWellFormed.Ordinal.html#12562" class="Bound">α</a> <a id="12579" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12581" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12585" href="NonWellFormed.Ordinal.html#12564" class="Bound">β</a>
<a id="12587" href="NonWellFormed.Ordinal.html#12552" class="Function">≤⇔&lt;s</a> <a id="12592" class="Symbol">=</a> <a id="12594" href="NonWellFormed.Ordinal.html#2663" class="Function">mk⇔</a> <a id="12598" href="NonWellFormed.Ordinal.html#12390" class="Function">≤⇒&lt;s</a> <a id="12603" href="NonWellFormed.Ordinal.html#12451" class="Function">&lt;s⇒≤</a>
</pre>
<p>由以上两组等价式改写可得 <code>_&lt;_</code> 版本的 <code>≤⇔s≤s</code>.</p>
<pre class="Agda"><a id="&lt;⇔s&lt;s"></a><a id="12654" href="NonWellFormed.Ordinal.html#12654" class="Function">&lt;⇔s&lt;s</a> <a id="12660" class="Symbol">:</a> <a id="12662" class="Symbol">∀</a> <a id="12664" class="Symbol">{</a><a id="12665" href="NonWellFormed.Ordinal.html#12665" class="Bound">α</a> <a id="12667" href="NonWellFormed.Ordinal.html#12667" class="Bound">β</a><a id="12668" class="Symbol">}</a> <a id="12670" class="Symbol">→</a> <a id="12672" href="NonWellFormed.Ordinal.html#12665" class="Bound">α</a> <a id="12674" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12676" href="NonWellFormed.Ordinal.html#12667" class="Bound">β</a> <a id="12678" href="Function.Equivalence.html#1213" class="Function Operator">⇔</a> <a id="12680" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12684" href="NonWellFormed.Ordinal.html#12665" class="Bound">α</a> <a id="12686" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12688" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12692" href="NonWellFormed.Ordinal.html#12667" class="Bound">β</a>
<a id="12694" href="NonWellFormed.Ordinal.html#12654" class="Function">&lt;⇔s&lt;s</a> <a id="12700" class="Symbol">{</a><a id="12701" href="NonWellFormed.Ordinal.html#12701" class="Bound">α</a><a id="12702" class="Symbol">}</a> <a id="12704" class="Symbol">{</a><a id="12705" href="NonWellFormed.Ordinal.html#12705" class="Bound">β</a><a id="12706" class="Symbol">}</a> <a id="12708" class="Symbol">=</a> <a id="12710" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
  <a id="12718" href="NonWellFormed.Ordinal.html#12701" class="Bound">α</a> <a id="12720" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12722" href="NonWellFormed.Ordinal.html#12705" class="Bound">β</a>         <a id="12732" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="12735" href="NonWellFormed.Ordinal.html#12321" class="Function">&lt;⇔s≤</a> <a id="12740" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
  <a id="12744" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12748" href="NonWellFormed.Ordinal.html#12701" class="Bound">α</a> <a id="12750" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="12752" href="NonWellFormed.Ordinal.html#12705" class="Bound">β</a>     <a id="12758" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="12761" href="NonWellFormed.Ordinal.html#12552" class="Function">≤⇔&lt;s</a> <a id="12766" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
  <a id="12770" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12774" href="NonWellFormed.Ordinal.html#12701" class="Bound">α</a> <a id="12776" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12778" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12782" href="NonWellFormed.Ordinal.html#12705" class="Bound">β</a> <a id="12784" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

<a id="s&lt;s"></a><a id="12787" href="NonWellFormed.Ordinal.html#12787" class="Function">s&lt;s</a> <a id="12791" class="Symbol">:</a> <a id="12793" class="Symbol">∀</a> <a id="12795" class="Symbol">{</a><a id="12796" href="NonWellFormed.Ordinal.html#12796" class="Bound">α</a> <a id="12798" href="NonWellFormed.Ordinal.html#12798" class="Bound">β</a><a id="12799" class="Symbol">}</a> <a id="12801" class="Symbol">→</a> <a id="12803" href="NonWellFormed.Ordinal.html#12796" class="Bound">α</a> <a id="12805" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12807" href="NonWellFormed.Ordinal.html#12798" class="Bound">β</a> <a id="12809" class="Symbol">→</a> <a id="12811" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12815" href="NonWellFormed.Ordinal.html#12796" class="Bound">α</a> <a id="12817" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12819" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12823" href="NonWellFormed.Ordinal.html#12798" class="Bound">β</a>
<a id="12825" href="NonWellFormed.Ordinal.html#12787" class="Function">s&lt;s</a> <a id="12829" class="Symbol">=</a> <a id="12831" href="Function.Equality.html#1073" class="Field Operator">_⟨$⟩_</a> <a id="12837" class="Symbol">(</a><a id="12838" href="Function.Equivalence.html#988" class="Field">Equivalence.to</a> <a id="12853" href="NonWellFormed.Ordinal.html#12654" class="Function">&lt;⇔s&lt;s</a><a id="12858" class="Symbol">)</a>

<a id="s&lt;s⇒&lt;"></a><a id="12861" href="NonWellFormed.Ordinal.html#12861" class="Function">s&lt;s⇒&lt;</a> <a id="12867" class="Symbol">:</a> <a id="12869" class="Symbol">∀</a> <a id="12871" class="Symbol">{</a><a id="12872" href="NonWellFormed.Ordinal.html#12872" class="Bound">α</a> <a id="12874" href="NonWellFormed.Ordinal.html#12874" class="Bound">β</a><a id="12875" class="Symbol">}</a> <a id="12877" class="Symbol">→</a> <a id="12879" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12883" href="NonWellFormed.Ordinal.html#12872" class="Bound">α</a> <a id="12885" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12887" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="12891" href="NonWellFormed.Ordinal.html#12874" class="Bound">β</a> <a id="12893" class="Symbol">→</a> <a id="12895" href="NonWellFormed.Ordinal.html#12872" class="Bound">α</a> <a id="12897" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="12899" href="NonWellFormed.Ordinal.html#12874" class="Bound">β</a>
<a id="12901" href="NonWellFormed.Ordinal.html#12861" class="Function">s&lt;s⇒&lt;</a> <a id="12907" class="Symbol">=</a> <a id="12909" href="Function.Equality.html#1073" class="Field Operator">_⟨$⟩_</a> <a id="12915" class="Symbol">(</a><a id="12916" href="Function.Equivalence.html#1009" class="Field">Equivalence.from</a> <a id="12933" href="NonWellFormed.Ordinal.html#12654" class="Function">&lt;⇔s&lt;s</a><a id="12938" class="Symbol">)</a>
</pre>
<p>由此可得传递性的变体.</p>
<pre class="Agda"><a id="&lt;-≤-trans"></a><a id="12966" href="NonWellFormed.Ordinal.html#12966" class="Function">&lt;-≤-trans</a> <a id="12976" class="Symbol">:</a> <a id="12978" href="Relation.Binary.Definitions.html#1659" class="Function">Trans</a> <a id="12984" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="12988" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="12992" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="12996" href="NonWellFormed.Ordinal.html#12966" class="Function">&lt;-≤-trans</a> <a id="13006" href="NonWellFormed.Ordinal.html#13006" class="Bound">α&lt;β</a> <a id="13010" href="NonWellFormed.Ordinal.html#13010" class="Bound">β≤γ</a> <a id="13014" class="Symbol">=</a> <a id="13016" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a> <a id="13021" class="Symbol">(</a><a id="13022" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="13030" class="Symbol">(</a><a id="13031" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="13036" href="NonWellFormed.Ordinal.html#13006" class="Bound">α&lt;β</a><a id="13039" class="Symbol">)</a> <a id="13041" href="NonWellFormed.Ordinal.html#13010" class="Bound">β≤γ</a><a id="13044" class="Symbol">)</a>

<a id="≤-&lt;-trans"></a><a id="13047" href="NonWellFormed.Ordinal.html#13047" class="Function">≤-&lt;-trans</a> <a id="13057" class="Symbol">:</a> <a id="13059" href="Relation.Binary.Definitions.html#1659" class="Function">Trans</a> <a id="13065" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="13069" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="13073" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="13077" href="NonWellFormed.Ordinal.html#13047" class="Function">≤-&lt;-trans</a> <a id="13087" href="NonWellFormed.Ordinal.html#13087" class="Bound">α≤β</a> <a id="13091" href="NonWellFormed.Ordinal.html#13091" class="Bound">β&lt;γ</a> <a id="13095" class="Symbol">=</a> <a id="13097" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a> <a id="13102" class="Symbol">(</a><a id="13103" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a> <a id="13111" class="Symbol">(</a><a id="13112" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="13116" href="NonWellFormed.Ordinal.html#13087" class="Bound">α≤β</a><a id="13119" class="Symbol">)</a> <a id="13121" class="Symbol">(</a><a id="13122" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="13127" href="NonWellFormed.Ordinal.html#13091" class="Bound">β&lt;γ</a><a id="13130" class="Symbol">))</a>
</pre>
<p>最后是 <code>_&lt;_</code> 版本的 <code>l≤⇒f≤</code> 和 <code>≤f⇒≤l</code>.</p>
<pre class="Agda"><a id="l&lt;⇒f&lt;"></a><a id="13180" href="NonWellFormed.Ordinal.html#13180" class="Function">l&lt;⇒f&lt;</a> <a id="13186" class="Symbol">:</a> <a id="13188" class="Symbol">∀</a> <a id="13190" class="Symbol">{</a><a id="13191" href="NonWellFormed.Ordinal.html#13191" class="Bound">α</a> <a id="13193" href="NonWellFormed.Ordinal.html#13193" class="Bound">f</a> <a id="13195" href="NonWellFormed.Ordinal.html#13195" class="Bound">n</a><a id="13196" class="Symbol">}</a> <a id="13198" class="Symbol">→</a> <a id="13200" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="13204" href="NonWellFormed.Ordinal.html#13193" class="Bound">f</a> <a id="13206" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="13208" href="NonWellFormed.Ordinal.html#13191" class="Bound">α</a> <a id="13210" class="Symbol">→</a> <a id="13212" href="NonWellFormed.Ordinal.html#13193" class="Bound">f</a> <a id="13214" href="NonWellFormed.Ordinal.html#13195" class="Bound">n</a> <a id="13216" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="13218" href="NonWellFormed.Ordinal.html#13191" class="Bound">α</a>
<a id="13220" href="NonWellFormed.Ordinal.html#13180" class="Function">l&lt;⇒f&lt;</a> <a id="13226" class="Symbol">{</a><a id="13227" class="Argument">n</a> <a id="13229" class="Symbol">=</a> <a id="13231" href="NonWellFormed.Ordinal.html#13231" class="Bound">n</a><a id="13232" class="Symbol">}</a> <a id="13234" class="Symbol">(</a><a id="13235" href="NonWellFormed.Ordinal.html#13235" class="Bound">d</a> <a id="13237" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13239" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="13242" href="NonWellFormed.Ordinal.html#13242" class="Bound">g≤</a><a id="13244" class="Symbol">)</a> <a id="13246" class="Symbol">=</a> <a id="13248" href="NonWellFormed.Ordinal.html#13235" class="Bound">d</a> <a id="13250" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13252" href="NonWellFormed.Ordinal.html#13242" class="Bound">g≤</a> <a id="13255" href="NonWellFormed.Ordinal.html#13231" class="Bound">n</a>

<a id="&lt;f⇒&lt;l"></a><a id="13258" href="NonWellFormed.Ordinal.html#13258" class="Function">&lt;f⇒&lt;l</a> <a id="13264" class="Symbol">:</a> <a id="13266" class="Symbol">∀</a> <a id="13268" class="Symbol">{</a><a id="13269" href="NonWellFormed.Ordinal.html#13269" class="Bound">α</a> <a id="13271" href="NonWellFormed.Ordinal.html#13271" class="Bound">f</a> <a id="13273" href="NonWellFormed.Ordinal.html#13273" class="Bound">n</a><a id="13274" class="Symbol">}</a> <a id="13276" class="Symbol">→</a> <a id="13278" href="NonWellFormed.Ordinal.html#13269" class="Bound">α</a> <a id="13280" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="13282" href="NonWellFormed.Ordinal.html#13271" class="Bound">f</a> <a id="13284" href="NonWellFormed.Ordinal.html#13273" class="Bound">n</a> <a id="13286" class="Symbol">→</a> <a id="13288" href="NonWellFormed.Ordinal.html#13269" class="Bound">α</a> <a id="13290" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="13292" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="13296" href="NonWellFormed.Ordinal.html#13271" class="Bound">f</a>
<a id="13298" href="NonWellFormed.Ordinal.html#13258" class="Function">&lt;f⇒&lt;l</a> <a id="13304" href="NonWellFormed.Ordinal.html#13304" class="Bound">α&lt;fn</a> <a id="13309" class="Symbol">=</a> <a id="13311" href="NonWellFormed.Ordinal.html#12249" class="Function">s≤⇒&lt;</a> <a id="13316" class="Symbol">(</a><a id="13317" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="13323" class="Symbol">(</a><a id="13324" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="13329" href="NonWellFormed.Ordinal.html#13304" class="Bound">α&lt;fn</a><a id="13333" class="Symbol">))</a>
</pre>
<h2 id="序结构">序结构</h2>
<p>本小节总结了本章的主要结论. 我们用 <code>_≈_</code> 实例化了序结构模块并证明了 <code>_≤_</code> 是偏序且 <code>_&lt;_</code> 是严格偏序.</p>
<pre class="Agda"><a id="13421" class="Keyword">open</a> <a id="13426" class="Keyword">import</a> <a id="13433" href="Relation.Binary.Structures.html" class="Module">Relation.Binary.Structures</a> <a id="13460" class="Symbol">(</a><a id="13461" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a><a id="13464" class="Symbol">)</a>
  <a id="13468" class="Keyword">using</a> <a id="13474" class="Symbol">(</a><a id="13475" href="Relation.Binary.Structures.html#1545" class="Record">IsEquivalence</a><a id="13488" class="Symbol">;</a> <a id="13490" href="Relation.Binary.Structures.html#2186" class="Record">IsPreorder</a><a id="13500" class="Symbol">;</a> <a id="13502" href="Relation.Binary.Structures.html#3197" class="Record">IsPartialOrder</a><a id="13516" class="Symbol">;</a> <a id="13518" href="Relation.Binary.Structures.html#3973" class="Record">IsStrictPartialOrder</a><a id="13538" class="Symbol">)</a>

<a id="≈-isEquivalence"></a><a id="13541" href="NonWellFormed.Ordinal.html#13541" class="Function">≈-isEquivalence</a> <a id="13557" class="Symbol">:</a> <a id="13559" href="Relation.Binary.Structures.html#1545" class="Record">IsEquivalence</a>
<a id="13573" href="NonWellFormed.Ordinal.html#13541" class="Function">≈-isEquivalence</a> <a id="13589" class="Symbol">=</a> <a id="13591" class="Keyword">record</a>
  <a id="13600" class="Symbol">{</a> <a id="13602" href="Relation.Binary.Structures.html#1591" class="Field">refl</a>  <a id="13608" class="Symbol">=</a> <a id="13610" href="NonWellFormed.Ordinal.html#8284" class="Function">≈-refl</a>
  <a id="13619" class="Symbol">;</a> <a id="13621" href="Relation.Binary.Structures.html#1617" class="Field">sym</a>   <a id="13627" class="Symbol">=</a> <a id="13629" href="NonWellFormed.Ordinal.html#8333" class="Function">≈-sym</a>
  <a id="13637" class="Symbol">;</a> <a id="13639" href="Relation.Binary.Structures.html#1643" class="Field">trans</a> <a id="13645" class="Symbol">=</a> <a id="13647" href="NonWellFormed.Ordinal.html#8394" class="Function">≈-trans</a>
  <a id="13657" class="Symbol">}</a>

<a id="≤-isPreorder"></a><a id="13660" href="NonWellFormed.Ordinal.html#13660" class="Function">≤-isPreorder</a> <a id="13673" class="Symbol">:</a> <a id="13675" href="Relation.Binary.Structures.html#2186" class="Record">IsPreorder</a> <a id="13686" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a>
<a id="13690" href="NonWellFormed.Ordinal.html#13660" class="Function">≤-isPreorder</a> <a id="13703" class="Symbol">=</a> <a id="13705" class="Keyword">record</a>
  <a id="13714" class="Symbol">{</a> <a id="13716" href="Relation.Binary.Structures.html#2251" class="Field">isEquivalence</a> <a id="13730" class="Symbol">=</a> <a id="13732" href="NonWellFormed.Ordinal.html#13541" class="Function">≈-isEquivalence</a>
  <a id="13750" class="Symbol">;</a> <a id="13752" href="Relation.Binary.Structures.html#2354" class="Field">reflexive</a> <a id="13762" class="Symbol">=</a> <a id="13764" href="Data.Product.Base.html#617" class="Field">proj₁</a>
  <a id="13772" class="Symbol">;</a> <a id="13774" href="Relation.Binary.Structures.html#2384" class="Field">trans</a> <a id="13780" class="Symbol">=</a> <a id="13782" href="NonWellFormed.Ordinal.html#7151" class="Function">≤-trans</a>
  <a id="13792" class="Symbol">}</a>

<a id="≤-isPartialOrder"></a><a id="13795" href="NonWellFormed.Ordinal.html#13795" class="Function">≤-isPartialOrder</a> <a id="13812" class="Symbol">:</a> <a id="13814" href="Relation.Binary.Structures.html#3197" class="Record">IsPartialOrder</a> <a id="13829" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a>
<a id="13833" href="NonWellFormed.Ordinal.html#13795" class="Function">≤-isPartialOrder</a> <a id="13850" class="Symbol">=</a> <a id="13852" class="Keyword">record</a>
  <a id="13861" class="Symbol">{</a> <a id="13863" href="Relation.Binary.Structures.html#3266" class="Field">isPreorder</a> <a id="13874" class="Symbol">=</a> <a id="13876" href="NonWellFormed.Ordinal.html#13660" class="Function">≤-isPreorder</a>
  <a id="13891" class="Symbol">;</a> <a id="13893" href="Relation.Binary.Structures.html#3298" class="Field">antisym</a> <a id="13901" class="Symbol">=</a> <a id="13903" class="Symbol">λ</a> <a id="13905" href="NonWellFormed.Ordinal.html#13905" class="Bound">≤</a> <a id="13907" href="NonWellFormed.Ordinal.html#13907" class="Bound">≥</a> <a id="13909" class="Symbol">→</a> <a id="13911" href="NonWellFormed.Ordinal.html#13905" class="Bound">≤</a> <a id="13913" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13915" href="NonWellFormed.Ordinal.html#13907" class="Bound">≥</a>
  <a id="13919" class="Symbol">}</a>

<a id="&lt;-isStrictPartialOrder"></a><a id="13922" href="NonWellFormed.Ordinal.html#13922" class="Function">&lt;-isStrictPartialOrder</a> <a id="13945" class="Symbol">:</a> <a id="13947" href="Relation.Binary.Structures.html#3973" class="Record">IsStrictPartialOrder</a> <a id="13968" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a>
<a id="13972" href="NonWellFormed.Ordinal.html#13922" class="Function">&lt;-isStrictPartialOrder</a> <a id="13995" class="Symbol">=</a> <a id="13997" class="Keyword">record</a>
  <a id="14006" class="Symbol">{</a> <a id="14008" href="Relation.Binary.Structures.html#4048" class="Field">isEquivalence</a> <a id="14022" class="Symbol">=</a> <a id="14024" href="NonWellFormed.Ordinal.html#13541" class="Function">≈-isEquivalence</a>
  <a id="14042" class="Symbol">;</a> <a id="14044" href="Relation.Binary.Structures.html#4082" class="Field">irrefl</a> <a id="14051" class="Symbol">=</a> <a id="14053" href="NonWellFormed.Ordinal.html#11354" class="Function">&lt;-irrefl-≈</a>
  <a id="14066" class="Symbol">;</a> <a id="14068" href="Relation.Binary.Structures.html#4122" class="Field">trans</a> <a id="14074" class="Symbol">=</a> <a id="14076" href="NonWellFormed.Ordinal.html#11496" class="Function">&lt;-trans</a>
  <a id="14086" class="Symbol">;</a> <a id="14088" href="Relation.Binary.Structures.html#4157" class="Field">&lt;-resp-≈</a> <a id="14097" class="Symbol">=</a> <a id="14099" class="Symbol">(λ</a> <a id="14102" class="Symbol">(</a><a id="14103" href="NonWellFormed.Ordinal.html#14103" class="Bound">β≤γ</a> <a id="14107" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14109" class="Symbol">_)</a> <a id="14112" href="NonWellFormed.Ordinal.html#14112" class="Bound">α&lt;β</a> <a id="14116" class="Symbol">→</a> <a id="14118" href="NonWellFormed.Ordinal.html#12966" class="Function">&lt;-≤-trans</a> <a id="14128" href="NonWellFormed.Ordinal.html#14112" class="Bound">α&lt;β</a> <a id="14132" href="NonWellFormed.Ordinal.html#14103" class="Bound">β≤γ</a><a id="14135" class="Symbol">)</a> <a id="14137" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a>
                <a id="14155" class="Symbol">λ</a> <a id="14157" class="Symbol">(_</a> <a id="14160" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14162" href="NonWellFormed.Ordinal.html#14162" class="Bound">α≤β</a><a id="14165" class="Symbol">)</a> <a id="14167" href="NonWellFormed.Ordinal.html#14167" class="Bound">β&lt;γ</a> <a id="14171" class="Symbol">→</a> <a id="14173" href="NonWellFormed.Ordinal.html#13047" class="Function">≤-&lt;-trans</a> <a id="14183" href="NonWellFormed.Ordinal.html#14162" class="Bound">α≤β</a> <a id="14187" href="NonWellFormed.Ordinal.html#14167" class="Bound">β&lt;γ</a>
  <a id="14193" class="Symbol">}</a>
</pre>
<p>由此可得 <code>_≤_</code> 和 <code>_&lt;_</code> 都尊重 <code>_≈_</code>.</p>
<pre class="Agda"><a id="≤-respʳ-≈"></a><a id="14239" href="NonWellFormed.Ordinal.html#14239" class="Function">≤-respʳ-≈</a> <a id="14249" class="Symbol">=</a> <a id="14251" href="Relation.Binary.Structures.html#3431" class="Function">IsPartialOrder.≤-respʳ-≈</a> <a id="14276" href="NonWellFormed.Ordinal.html#13795" class="Function">≤-isPartialOrder</a>
<a id="≤-respˡ-≈"></a><a id="14293" href="NonWellFormed.Ordinal.html#14293" class="Function">≤-respˡ-≈</a> <a id="14303" class="Symbol">=</a> <a id="14305" href="Relation.Binary.Structures.html#3402" class="Function">IsPartialOrder.≤-respˡ-≈</a> <a id="14330" href="NonWellFormed.Ordinal.html#13795" class="Function">≤-isPartialOrder</a>
<a id="≤-resp-≈"></a><a id="14347" href="NonWellFormed.Ordinal.html#14347" class="Function">≤-resp-≈</a> <a id="14356" class="Symbol">=</a> <a id="14358" href="Relation.Binary.Structures.html#3460" class="Function">IsPartialOrder.≤-resp-≈</a> <a id="14382" href="NonWellFormed.Ordinal.html#13795" class="Function">≤-isPartialOrder</a>

<a id="&lt;-respʳ-≈"></a><a id="14400" href="NonWellFormed.Ordinal.html#14400" class="Function">&lt;-respʳ-≈</a> <a id="14410" class="Symbol">=</a> <a id="14412" href="Relation.Binary.Structures.html#4327" class="Function">IsStrictPartialOrder.&lt;-respʳ-≈</a> <a id="14443" href="NonWellFormed.Ordinal.html#13922" class="Function">&lt;-isStrictPartialOrder</a>
<a id="&lt;-respˡ-≈"></a><a id="14466" href="NonWellFormed.Ordinal.html#14466" class="Function">&lt;-respˡ-≈</a> <a id="14476" class="Symbol">=</a> <a id="14478" href="Relation.Binary.Structures.html#4389" class="Function">IsStrictPartialOrder.&lt;-respˡ-≈</a> <a id="14509" href="NonWellFormed.Ordinal.html#13922" class="Function">&lt;-isStrictPartialOrder</a>
<a id="&lt;-resp-≈"></a><a id="14532" href="NonWellFormed.Ordinal.html#14532" class="Function">&lt;-resp-≈</a> <a id="14541" class="Symbol">=</a> <a id="14543" href="Relation.Binary.Structures.html#4157" class="Field">IsStrictPartialOrder.&lt;-resp-≈</a> <a id="14573" href="NonWellFormed.Ordinal.html#13922" class="Function">&lt;-isStrictPartialOrder</a>
</pre>
<p>我们用本章所证明的结论来实例化标准库所提供的涉及序关系和等价关系的推理组合子, 并输出为子模块, 后续章节会大量使用它.</p>
<pre class="Agda"><a id="14671" class="Keyword">module</a> <a id="≤-Reasoning"></a><a id="14678" href="NonWellFormed.Ordinal.html#14678" class="Module">≤-Reasoning</a> <a id="14690" class="Keyword">where</a>
  <a id="14698" class="Keyword">open</a> <a id="14703" class="Keyword">import</a> <a id="14710" href="Relation.Binary.Reasoning.Base.Triple.html" class="Module">Relation.Binary.Reasoning.Base.Triple</a>
    <a id="14752" href="NonWellFormed.Ordinal.html#13660" class="Function">≤-isPreorder</a>
    <a id="14769" href="NonWellFormed.Ordinal.html#11496" class="Function">&lt;-trans</a>
    <a id="14781" href="NonWellFormed.Ordinal.html#14532" class="Function">&lt;-resp-≈</a>
    <a id="14794" href="NonWellFormed.Ordinal.html#11929" class="Function">&lt;⇒≤</a>
    <a id="14802" href="NonWellFormed.Ordinal.html#12966" class="Function">&lt;-≤-trans</a>
    <a id="14816" href="NonWellFormed.Ordinal.html#13047" class="Function">≤-&lt;-trans</a>
    <a id="14830" class="Keyword">public</a>
</pre>
<h2 id="序数广集">序数广集</h2>
<p>由 <code>≈-isEquivalence</code> 可以构造序数广集, 它相当于是 <code>Ord</code> 在 <code>_≈_</code> 上的商集, 合并了传统理论中同一序数在我们这里的多种基本序列表示. 但我们几乎不会使用它, 而是直接使用底层的 <code>Ord</code>.</p>
<pre class="Agda"><a id="14973" class="Keyword">open</a> <a id="14978" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="14994" class="Keyword">using</a> <a id="15000" class="Symbol">(</a><a id="15001" href="Relation.Binary.Bundles.html#1027" class="Record">Setoid</a><a id="15007" class="Symbol">)</a>

<a id="OrdSetoid"></a><a id="15010" href="NonWellFormed.Ordinal.html#15010" class="Function">OrdSetoid</a> <a id="15020" class="Symbol">:</a> <a id="15022" href="Relation.Binary.Bundles.html#1027" class="Record">Setoid</a> <a id="15029" href="Level.html#521" class="Function">0ℓ</a> <a id="15032" href="Level.html#521" class="Function">0ℓ</a>
<a id="15035" href="NonWellFormed.Ordinal.html#15010" class="Function">OrdSetoid</a> <a id="15045" class="Symbol">=</a> <a id="15047" class="Keyword">record</a>
  <a id="15056" class="Symbol">{</a> <a id="15058" href="Relation.Binary.Bundles.html#1090" class="Field">Carrier</a> <a id="15066" class="Symbol">=</a> <a id="15068" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
  <a id="15074" class="Symbol">;</a> <a id="15076" href="Relation.Binary.Bundles.html#1116" class="Field Operator">_≈_</a> <a id="15080" class="Symbol">=</a> <a id="15082" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a>
  <a id="15088" class="Symbol">;</a> <a id="15090" href="Relation.Binary.Bundles.html#1150" class="Field">isEquivalence</a> <a id="15104" class="Symbol">=</a> <a id="15106" href="NonWellFormed.Ordinal.html#13541" class="Function">≈-isEquivalence</a>
  <a id="15124" class="Symbol">}</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
