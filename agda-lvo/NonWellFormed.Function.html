<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(1-3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(1-3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数1-3-序数函数" id="toc-agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
目录: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.html">NonWellFormed.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/NonWellFormed/Function.lagda.md">Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.Function.html">Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<pre class="Agda"><a id="494" class="Symbol">{-#</a> <a id="498" class="Keyword">OPTIONS</a> <a id="506" class="Pragma">--without-K</a> <a id="518" class="Pragma">--safe</a> <a id="525" class="Symbol">#-}</a>
<a id="529" class="Symbol">{-#</a> <a id="533" class="Keyword">OPTIONS</a> <a id="541" class="Pragma">--no-qualified-instances</a> <a id="566" class="Symbol">#-}</a>

<a id="571" class="Keyword">module</a> <a id="578" href="NonWellFormed.Function.html" class="Module">NonWellFormed.Function</a> <a id="601" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="641" class="Keyword">open</a> <a id="646" class="Keyword">import</a> <a id="653" href="NonWellFormed.Ordinal.html" class="Module">NonWellFormed.Ordinal</a>
<a id="675" class="Keyword">open</a> <a id="680" href="NonWellFormed.Ordinal.html#14726" class="Module">NonWellFormed.Ordinal.≤-Reasoning</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="NonWellFormed.WellFormed.html" class="Module">NonWellFormed.WellFormed</a> <a id="751" class="Keyword">using</a> <a id="757" class="Symbol">(</a><a id="758" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a><a id="768" class="Symbol">;</a> <a id="770" href="NonWellFormed.WellFormed.html#5480" class="Function">∃[n]&lt;fn</a><a id="777" class="Symbol">;</a> <a id="779" href="NonWellFormed.WellFormed.html#5222" class="Function">f&lt;l</a><a id="782" class="Symbol">;</a> <a id="784" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a><a id="788" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="898" class="Keyword">open</a> <a id="903" class="Keyword">import</a> <a id="910" href="Data.Product.html" class="Module">Data.Product</a> <a id="923" class="Keyword">using</a> <a id="929" class="Symbol">(</a><a id="930" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="933" class="Symbol">;</a> <a id="935" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="938" class="Symbol">;</a> <a id="940" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="945" class="Symbol">;</a> <a id="947" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="952" class="Symbol">)</a>
<a id="954" class="Keyword">open</a> <a id="959" class="Keyword">import</a> <a id="966" href="Function.html" class="Module">Function</a> <a id="975" class="Keyword">using</a> <a id="981" class="Symbol">(</a><a id="982" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="985" class="Symbol">;</a> <a id="987" href="Function.Base.html#695" class="Function">id</a><a id="989" class="Symbol">;</a> <a id="991" href="Function.Base.html#2781" class="Function">λ-</a><a id="993" class="Symbol">)</a>
<a id="995" class="Keyword">open</a> <a id="1000" class="Keyword">import</a> <a id="1007" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="1023" class="Keyword">using</a> <a id="1029" class="Symbol">(</a><a id="1030" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a><a id="1040" class="Symbol">;</a> <a id="1042" href="Relation.Binary.Definitions.html#4853" class="Function Operator">_Respects_</a><a id="1052" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1118" class="Keyword">private</a> <a id="1126" class="Keyword">variable</a>
  <a id="1137" class="Symbol">{</a><a id="1138" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="1139" class="Symbol">}</a> <a id="1141" class="Symbol">:</a> <a id="1143" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1147" class="Symbol">→</a> <a id="1149" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1249" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1263" class="Symbol">:</a> <a id="1265" class="Symbol">(</a><a id="1266" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1275" class="Symbol">)</a> <a id="1277" class="Symbol">→</a> <a id="1279" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1283" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1297" href="NonWellFormed.Function.html#1297" class="Bound">F</a> <a id="1299" class="Symbol">=</a> <a id="1301" class="Symbol">∀</a> <a id="1303" class="Symbol">{</a><a id="1304" href="NonWellFormed.Function.html#1304" class="Bound">α</a><a id="1305" class="Symbol">}</a> <a id="1307" class="Symbol">→</a> <a id="1309" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="1320" href="NonWellFormed.Function.html#1304" class="Bound">α</a> <a id="1322" class="Symbol">→</a> <a id="1324" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="1335" class="Symbol">(</a><a id="1336" href="NonWellFormed.Function.html#1297" class="Bound">F</a> <a id="1338" href="NonWellFormed.Function.html#1304" class="Bound">α</a><a id="1339" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1369" href="NonWellFormed.Function.html#1369" class="Function">_</a> <a id="1371" class="Symbol">:</a> <a id="1373" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1387" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1391" class="Symbol">_</a> <a id="1393" class="Symbol">=</a> <a id="1395" href="Function.Base.html#695" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1490" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1503" class="Symbol">:</a> <a id="1505" class="Symbol">(</a><a id="1506" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1510" class="Symbol">→</a> <a id="1512" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1515" class="Symbol">)</a> <a id="1517" class="Symbol">→</a> <a id="1519" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1523" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1536" href="NonWellFormed.Function.html#1536" class="Bound">F</a> <a id="1538" class="Symbol">=</a> <a id="1540" class="Symbol">∀</a> <a id="1542" href="NonWellFormed.Function.html#1542" class="Bound">α</a> <a id="1544" class="Symbol">→</a> <a id="1546" href="NonWellFormed.Function.html#1542" class="Bound">α</a> <a id="1548" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">≤</a> <a id="1550" href="NonWellFormed.Function.html#1536" class="Bound">F</a> <a id="1552" href="NonWellFormed.Function.html#1542" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1555" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1568" class="Symbol">:</a> <a id="1570" class="Symbol">(</a><a id="1571" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1575" class="Symbol">→</a> <a id="1577" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1580" class="Symbol">)</a> <a id="1582" class="Symbol">→</a> <a id="1584" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1588" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1601" href="NonWellFormed.Function.html#1601" class="Bound">F</a> <a id="1603" class="Symbol">=</a> <a id="1605" class="Symbol">∀</a> <a id="1607" href="NonWellFormed.Function.html#1607" class="Bound">α</a> <a id="1609" class="Symbol">→</a> <a id="1611" href="NonWellFormed.Function.html#1607" class="Bound">α</a> <a id="1613" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="1615" href="NonWellFormed.Function.html#1601" class="Bound">F</a> <a id="1617" href="NonWellFormed.Function.html#1607" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1649" href="NonWellFormed.Function.html#1649" class="Function">_</a> <a id="1651" class="Symbol">:</a> <a id="1653" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1666" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1670" class="Symbol">_</a> <a id="1672" class="Symbol">=</a> <a id="1674" href="Function.Base.html#2781" class="Function">λ-</a> <a id="1677" href="NonWellFormed.Ordinal.html#7750" class="Function">≤s</a>

<a id="1681" href="NonWellFormed.Function.html#1681" class="Function">_</a> <a id="1683" class="Symbol">:</a> <a id="1685" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1698" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1702" class="Symbol">_</a> <a id="1704" class="Symbol">=</a> <a id="1706" href="Function.Base.html#2781" class="Function">λ-</a> <a id="1709" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1740" href="NonWellFormed.Function.html#1740" class="Function">&lt;⇒≤-incr</a> <a id="1749" class="Symbol">:</a> <a id="1751" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1764" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="1766" class="Symbol">→</a> <a id="1768" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1781" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="1783" href="NonWellFormed.Function.html#1740" class="Function">&lt;⇒≤-incr</a> <a id="1792" href="NonWellFormed.Function.html#1792" class="Bound">&lt;-incr</a> <a id="1799" href="NonWellFormed.Function.html#1799" class="Bound">α</a> <a id="1801" class="Symbol">=</a> <a id="1803" href="NonWellFormed.Ordinal.html#11977" class="Function">&lt;⇒≤</a> <a id="1807" class="Symbol">(</a><a id="1808" href="NonWellFormed.Function.html#1792" class="Bound">&lt;-incr</a> <a id="1815" href="NonWellFormed.Function.html#1799" class="Bound">α</a><a id="1816" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1907" href="NonWellFormed.Function.html#1907" class="Function">zero-increasing</a> <a id="1923" class="Symbol">:</a> <a id="1925" class="Symbol">(</a><a id="1926" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1930" class="Symbol">→</a> <a id="1932" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1935" class="Symbol">)</a> <a id="1937" class="Symbol">→</a> <a id="1939" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1943" href="NonWellFormed.Function.html#1907" class="Function">zero-increasing</a> <a id="1959" href="NonWellFormed.Function.html#1959" class="Bound">F</a> <a id="1961" class="Symbol">=</a> <a id="1963" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a> <a id="1968" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="1970" href="NonWellFormed.Function.html#1959" class="Bound">F</a> <a id="1972" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1978" href="NonWellFormed.Function.html#1978" class="Function">suc-increasing</a> <a id="1993" class="Symbol">:</a> <a id="1995" class="Symbol">(</a><a id="1996" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2000" class="Symbol">→</a> <a id="2002" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2005" class="Symbol">)</a> <a id="2007" class="Symbol">→</a> <a id="2009" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2013" href="NonWellFormed.Function.html#1978" class="Function">suc-increasing</a> <a id="2028" href="NonWellFormed.Function.html#2028" class="Bound">F</a> <a id="2030" class="Symbol">=</a> <a id="2032" class="Symbol">∀</a> <a id="2034" href="NonWellFormed.Function.html#2034" class="Bound">α</a> <a id="2036" class="Symbol">→</a> <a id="2038" class="Symbol">⦃</a> <a id="2040" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="2051" href="NonWellFormed.Function.html#2034" class="Bound">α</a> <a id="2053" class="Symbol">⦄</a> <a id="2055" class="Symbol">→</a> <a id="2057" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2061" href="NonWellFormed.Function.html#2034" class="Bound">α</a> <a id="2063" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="2065" href="NonWellFormed.Function.html#2028" class="Bound">F</a> <a id="2067" class="Symbol">(</a><a id="2068" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2072" href="NonWellFormed.Function.html#2034" class="Bound">α</a><a id="2073" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2130" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="2142" class="Symbol">:</a> <a id="2144" class="Symbol">(</a><a id="2145" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2149" class="Symbol">→</a> <a id="2151" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2154" class="Symbol">)</a> <a id="2156" class="Symbol">→</a> <a id="2158" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2162" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="2174" href="NonWellFormed.Function.html#2174" class="Bound">F</a> <a id="2176" class="Symbol">=</a> <a id="2178" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2189" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">_≤_</a> <a id="2193" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">_≤_</a> <a id="2197" href="NonWellFormed.Function.html#2174" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2200" href="NonWellFormed.Function.html#2200" class="Function">&lt;-monotonic</a> <a id="2212" class="Symbol">:</a> <a id="2214" class="Symbol">(</a><a id="2215" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2219" class="Symbol">→</a> <a id="2221" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2224" class="Symbol">)</a> <a id="2226" class="Symbol">→</a> <a id="2228" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2232" href="NonWellFormed.Function.html#2200" class="Function">&lt;-monotonic</a> <a id="2244" href="NonWellFormed.Function.html#2244" class="Bound">F</a> <a id="2246" class="Symbol">=</a> <a id="2248" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2259" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">_&lt;_</a> <a id="2263" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">_&lt;_</a> <a id="2267" href="NonWellFormed.Function.html#2244" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2299" href="NonWellFormed.Function.html#2299" class="Function">_</a> <a id="2301" class="Symbol">:</a> <a id="2303" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="2315" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="2319" class="Symbol">_</a> <a id="2321" class="Symbol">=</a> <a id="2323" href="NonWellFormed.Ordinal.html#6487" class="Function">s≤s</a>

<a id="2328" href="NonWellFormed.Function.html#2328" class="Function">_</a> <a id="2330" class="Symbol">:</a> <a id="2332" href="NonWellFormed.Function.html#2200" class="Function">&lt;-monotonic</a> <a id="2344" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="2348" class="Symbol">_</a> <a id="2350" class="Symbol">=</a> <a id="2352" href="NonWellFormed.Ordinal.html#12835" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2411" href="NonWellFormed.Function.html#2411" class="Function">suc-monotonic</a> <a id="2425" class="Symbol">:</a> <a id="2427" class="Symbol">(</a><a id="2428" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2432" class="Symbol">→</a> <a id="2434" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2437" class="Symbol">)</a> <a id="2439" class="Symbol">→</a> <a id="2441" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2445" href="NonWellFormed.Function.html#2411" class="Function">suc-monotonic</a> <a id="2459" href="NonWellFormed.Function.html#2459" class="Bound">F</a> <a id="2461" class="Symbol">=</a> <a id="2463" class="Symbol">∀</a> <a id="2465" href="NonWellFormed.Function.html#2465" class="Bound">α</a> <a id="2467" class="Symbol">→</a> <a id="2469" href="NonWellFormed.Function.html#2459" class="Bound">F</a> <a id="2471" href="NonWellFormed.Function.html#2465" class="Bound">α</a> <a id="2473" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="2475" href="NonWellFormed.Function.html#2459" class="Bound">F</a> <a id="2477" class="Symbol">(</a><a id="2478" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2482" href="NonWellFormed.Function.html#2465" class="Bound">α</a><a id="2483" class="Symbol">)</a>

<a id="2486" href="NonWellFormed.Function.html#2486" class="Function">_</a> <a id="2488" class="Symbol">:</a> <a id="2490" href="NonWellFormed.Function.html#2200" class="Function">&lt;-monotonic</a> <a id="2502" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="2504" class="Symbol">→</a> <a id="2506" href="NonWellFormed.Function.html#2411" class="Function">suc-monotonic</a> <a id="2520" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="2522" class="Symbol">_</a> <a id="2524" class="Symbol">=</a> <a id="2526" class="Symbol">λ</a> <a id="2528" href="NonWellFormed.Function.html#2528" class="Bound">&lt;-mono</a> <a id="2535" href="NonWellFormed.Function.html#2535" class="Bound">_</a> <a id="2537" class="Symbol">→</a> <a id="2539" href="NonWellFormed.Function.html#2528" class="Bound">&lt;-mono</a> <a id="2546" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="continuous"></a><a id="2612" href="NonWellFormed.Function.html#2612" class="Function">continuous</a> <a id="2623" class="Symbol">:</a> <a id="2625" class="Symbol">(</a><a id="2626" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2630" class="Symbol">→</a> <a id="2632" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2635" class="Symbol">)</a> <a id="2637" class="Symbol">→</a> <a id="2639" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2643" href="NonWellFormed.Function.html#2612" class="Function">continuous</a> <a id="2654" href="NonWellFormed.Function.html#2654" class="Bound">F</a> <a id="2656" class="Symbol">=</a> <a id="2658" class="Symbol">∀</a> <a id="2660" href="NonWellFormed.Function.html#2660" class="Bound">f</a> <a id="2662" class="Symbol">→</a> <a id="2664" href="NonWellFormed.Function.html#2654" class="Bound">F</a> <a id="2666" class="Symbol">(</a><a id="2667" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="2671" href="NonWellFormed.Function.html#2660" class="Bound">f</a><a id="2672" class="Symbol">)</a> <a id="2674" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">≈</a> <a id="2676" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="2680" class="Symbol">(</a><a id="2681" href="NonWellFormed.Function.html#2654" class="Bound">F</a> <a id="2683" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2685" href="NonWellFormed.Function.html#2660" class="Bound">f</a><a id="2686" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2776" href="NonWellFormed.Function.html#2776" class="Function">normal</a> <a id="2783" class="Symbol">:</a> <a id="2785" class="Symbol">(</a><a id="2786" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2790" class="Symbol">→</a> <a id="2792" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2795" class="Symbol">)</a> <a id="2797" class="Symbol">→</a> <a id="2799" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2803" href="NonWellFormed.Function.html#2776" class="Function">normal</a> <a id="2810" href="NonWellFormed.Function.html#2810" class="Bound">F</a> <a id="2812" class="Symbol">=</a> <a id="2814" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="2826" href="NonWellFormed.Function.html#2810" class="Bound">F</a> <a id="2828" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2830" href="NonWellFormed.Function.html#2200" class="Function">&lt;-monotonic</a> <a id="2842" href="NonWellFormed.Function.html#2810" class="Bound">F</a> <a id="2844" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2846" href="NonWellFormed.Function.html#2612" class="Function">continuous</a> <a id="2857" href="NonWellFormed.Function.html#2810" class="Bound">F</a>
</pre>
<p>我们会在下一小节解释序数嵌入的定义, 现在先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="2979" class="Keyword">module</a> <a id="2986" href="NonWellFormed.Function.html#2986" class="Module">_</a> <a id="2988" class="Symbol">(</a><a id="2989" href="NonWellFormed.Function.html#2989" class="Bound">(_</a> <a id="2992" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2994" href="NonWellFormed.Function.html#2994" class="Bound">&lt;-mono</a> <a id="3001" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3003" href="NonWellFormed.Function.html#3003" class="Bound">ct</a><a id="3005" href="NonWellFormed.Function.html#2989" class="Bound">)</a> <a id="3007" class="Symbol">:</a> <a id="3009" href="NonWellFormed.Function.html#2776" class="Function">normal</a> <a id="3016" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="3017" class="Symbol">)</a> <a id="3019" class="Keyword">where</a>
  <a id="3027" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3041" class="Symbol">:</a> <a id="3043" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="3056" href="NonWellFormed.Function.html#3016" class="Bound">F</a>
  <a id="3060" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3074" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a> <a id="3079" class="Symbol">=</a> <a id="3081" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">  <a id="3234" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3248" class="Symbol">(</a><a id="3249" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3253" href="NonWellFormed.Function.html#3253" class="Bound">α</a><a id="3254" class="Symbol">)</a> <a id="3256" class="Symbol">=</a> <a id="3258" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="3268" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3272" href="NonWellFormed.Function.html#3253" class="Bound">α</a>                 <a id="3290" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3293" href="NonWellFormed.Ordinal.html#6487" class="Function">s≤s</a> <a id="3297" class="Symbol">(</a><a id="3298" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3312" href="NonWellFormed.Function.html#3253" class="Bound">α</a><a id="3313" class="Symbol">)</a> <a id="3315" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3321" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3325" class="Symbol">(</a><a id="3326" href="NonWellFormed.Function.html#3016" class="Bound">F</a> <a id="3328" href="NonWellFormed.Function.html#3253" class="Bound">α</a><a id="3329" class="Symbol">)</a>             <a id="3343" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3346" href="NonWellFormed.Ordinal.html#12233" class="Function">&lt;⇒s≤</a> <a id="3351" class="Symbol">(</a><a id="3352" href="NonWellFormed.Function.html#2994" class="Bound">&lt;-mono</a> <a id="3359" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a><a id="3361" class="Symbol">)</a> <a id="3363" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3369" href="NonWellFormed.Function.html#3016" class="Bound">F</a> <a id="3371" class="Symbol">(</a><a id="3372" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3376" href="NonWellFormed.Function.html#3253" class="Bound">α</a><a id="3377" class="Symbol">)</a>             <a id="3391" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">  <a id="3531" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3545" class="Symbol">(</a><a id="3546" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3550" href="NonWellFormed.Function.html#3550" class="Bound">f</a><a id="3551" class="Symbol">)</a> <a id="3553" class="Symbol">=</a> <a id="3555" href="NonWellFormed.Ordinal.html#4859" class="InductiveConstructor">l≤</a> <a id="3558" class="Symbol">λ</a> <a id="3560" href="NonWellFormed.Function.html#3560" class="Bound">n</a> <a id="3562" class="Symbol">→</a> <a id="3564" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="3574" href="NonWellFormed.Function.html#3550" class="Bound">f</a> <a id="3576" href="NonWellFormed.Function.html#3560" class="Bound">n</a>                   <a id="3596" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3599" href="NonWellFormed.Ordinal.html#6166" class="Function">≤f⇒≤l</a> <a id="3605" class="Symbol">(</a><a id="3606" href="NonWellFormed.Function.html#3027" class="Function">normal⇒≤-incr</a> <a id="3620" class="Symbol">(</a><a id="3621" href="NonWellFormed.Function.html#3550" class="Bound">f</a> <a id="3623" href="NonWellFormed.Function.html#3560" class="Bound">n</a><a id="3624" class="Symbol">))</a> <a id="3627" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3633" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3637" class="Symbol">(</a><a id="3638" href="NonWellFormed.Function.html#3016" class="Bound">F</a> <a id="3640" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="3642" href="NonWellFormed.Function.html#3550" class="Bound">f</a><a id="3643" class="Symbol">)</a>           <a id="3655" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="3659" href="NonWellFormed.Function.html#3003" class="Bound">ct</a> <a id="3662" href="NonWellFormed.Function.html#3550" class="Bound">f</a> <a id="3664" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
    <a id="3670" href="NonWellFormed.Function.html#3016" class="Bound">F</a> <a id="3672" class="Symbol">(</a><a id="3673" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3677" href="NonWellFormed.Function.html#3550" class="Bound">f</a><a id="3678" class="Symbol">)</a>             <a id="3692" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3737" href="NonWellFormed.Function.html#3737" class="Function Operator">_≈ᶠ_</a> <a id="3742" class="Symbol">:</a> <a id="3744" class="Symbol">(</a><a id="3745" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="3749" class="Symbol">→</a> <a id="3751" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="3754" class="Symbol">)</a> <a id="3756" class="Symbol">→</a> <a id="3758" class="Symbol">(</a><a id="3759" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="3763" class="Symbol">→</a> <a id="3765" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="3768" class="Symbol">)</a> <a id="3770" class="Symbol">→</a> <a id="3772" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="3776" href="NonWellFormed.Function.html#3776" class="Bound">F</a> <a id="3778" href="NonWellFormed.Function.html#3737" class="Function Operator">≈ᶠ</a> <a id="3781" href="NonWellFormed.Function.html#3781" class="Bound">G</a> <a id="3783" class="Symbol">=</a> <a id="3785" class="Symbol">∀</a> <a id="3787" class="Symbol">{</a><a id="3788" href="NonWellFormed.Function.html#3788" class="Bound">α</a><a id="3789" class="Symbol">}</a> <a id="3791" class="Symbol">→</a> <a id="3793" href="NonWellFormed.Function.html#3776" class="Bound">F</a> <a id="3795" href="NonWellFormed.Function.html#3788" class="Bound">α</a> <a id="3797" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">≈</a> <a id="3799" href="NonWellFormed.Function.html#3781" class="Bound">G</a> <a id="3801" href="NonWellFormed.Function.html#3788" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3804" href="NonWellFormed.Function.html#3804" class="Function">normal-resp-≈</a> <a id="3818" class="Symbol">:</a> <a id="3820" href="NonWellFormed.Function.html#2776" class="Function">normal</a> <a id="3827" href="Relation.Binary.Definitions.html#4853" class="Function Operator">Respects</a> <a id="3836" href="NonWellFormed.Function.html#3737" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3948" href="NonWellFormed.Function.html#3804" class="Function">normal-resp-≈</a> <a id="3962" class="Symbol">{</a><a id="3963" href="NonWellFormed.Function.html#3963" class="Bound">F</a><a id="3964" class="Symbol">}</a> <a id="3966" class="Symbol">{</a><a id="3967" href="NonWellFormed.Function.html#3967" class="Bound">G</a><a id="3968" class="Symbol">}</a> <a id="3970" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="3974" class="Symbol">(</a><a id="3975" href="NonWellFormed.Function.html#3975" class="Bound">≤-mono</a> <a id="3982" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3984" href="NonWellFormed.Function.html#3984" class="Bound">&lt;-mono</a> <a id="3991" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3993" href="NonWellFormed.Function.html#3993" class="Bound">ct</a><a id="3995" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4094" class="Symbol">=</a> <a id="4096" class="Symbol">(λ</a> <a id="4099" class="Symbol">{</a><a id="4100" href="NonWellFormed.Function.html#4100" class="Bound">α</a><a id="4101" class="Symbol">}</a> <a id="4103" class="Symbol">{</a><a id="4104" href="NonWellFormed.Function.html#4104" class="Bound">β</a><a id="4105" class="Symbol">}</a> <a id="4107" href="NonWellFormed.Function.html#4107" class="Bound">α≤β</a> <a id="4111" class="Symbol">→</a> <a id="4113" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a> <a id="4119" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4121" href="NonWellFormed.Function.html#4100" class="Bound">α</a> <a id="4123" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4127" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4131" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4133" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4135" href="NonWellFormed.Function.html#4100" class="Bound">α</a> <a id="4137" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4140" href="NonWellFormed.Function.html#3975" class="Bound">≤-mono</a> <a id="4147" href="NonWellFormed.Function.html#4107" class="Bound">α≤β</a> <a id="4151" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a> <a id="4153" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4155" href="NonWellFormed.Function.html#4104" class="Bound">β</a> <a id="4157" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4160" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4164" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4166" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4168" href="NonWellFormed.Function.html#4104" class="Bound">β</a> <a id="4170" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4171" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4270" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4272" class="Symbol">(λ</a> <a id="4275" class="Symbol">{</a><a id="4276" href="NonWellFormed.Function.html#4276" class="Bound">α</a><a id="4277" class="Symbol">}</a> <a id="4279" class="Symbol">{</a><a id="4280" href="NonWellFormed.Function.html#4280" class="Bound">β</a><a id="4281" class="Symbol">}</a> <a id="4283" href="NonWellFormed.Function.html#4283" class="Bound">α&lt;β</a> <a id="4287" class="Symbol">→</a> <a id="4289" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a> <a id="4302" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4304" href="NonWellFormed.Function.html#4276" class="Bound">α</a> <a id="4306" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4310" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4314" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4316" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4318" href="NonWellFormed.Function.html#4276" class="Bound">α</a> <a id="4320" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="4323" href="NonWellFormed.Function.html#3984" class="Bound">&lt;-mono</a> <a id="4330" href="NonWellFormed.Function.html#4283" class="Bound">α&lt;β</a> <a id="4334" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a> <a id="4336" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4338" href="NonWellFormed.Function.html#4280" class="Bound">β</a> <a id="4340" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4343" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4347" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4349" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4351" href="NonWellFormed.Function.html#4280" class="Bound">β</a> <a id="4353" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4354" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4400" class="Symbol">(λ</a> <a id="4403" href="NonWellFormed.Function.html#4403" class="Bound">f</a> <a id="4405" class="Symbol">→</a> <a id="4407" href="Relation.Binary.Reasoning.Base.Triple.html#3286" class="Function Operator">begin-equality</a>
      <a id="4428" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4430" class="Symbol">(</a><a id="4431" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4435" href="NonWellFormed.Function.html#4403" class="Bound">f</a><a id="4436" class="Symbol">)</a>   <a id="4440" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4444" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4448" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
      <a id="4456" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4458" class="Symbol">(</a><a id="4459" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4463" href="NonWellFormed.Function.html#4403" class="Bound">f</a><a id="4464" class="Symbol">)</a>   <a id="4468" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4471" href="NonWellFormed.Function.html#3993" class="Bound">ct</a> <a id="4474" href="NonWellFormed.Function.html#4403" class="Bound">f</a> <a id="4476" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4484" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4488" class="Symbol">(</a><a id="4489" href="NonWellFormed.Function.html#3963" class="Bound">F</a> <a id="4491" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4493" href="NonWellFormed.Function.html#4403" class="Bound">f</a><a id="4494" class="Symbol">)</a> <a id="4496" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4499" href="NonWellFormed.Ordinal.html#9192" class="Function">l≈l</a> <a id="4503" href="NonWellFormed.Function.html#3970" class="Bound">ext</a> <a id="4507" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4515" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4519" class="Symbol">(</a><a id="4520" href="NonWellFormed.Function.html#3967" class="Bound">G</a> <a id="4522" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4524" href="NonWellFormed.Function.html#4403" class="Bound">f</a><a id="4525" class="Symbol">)</a> <a id="4527" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4528" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="5029" class="Keyword">open</a> <a id="5034" class="Keyword">import</a> <a id="5041" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="5062" class="Symbol">(</a><a id="5063" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">_≈_</a><a id="5066" class="Symbol">)</a> <a id="5068" class="Symbol">(</a><a id="5069" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">_≈_</a><a id="5072" class="Symbol">)</a> <a id="5074" class="Keyword">using</a> <a id="5080" class="Symbol">(</a><a id="5081" href="Function.Definitions.html#803" class="Function">Congruent</a><a id="5090" class="Symbol">)</a>

<a id="≤-mono⇒cong"></a><a id="5093" href="NonWellFormed.Function.html#5093" class="Function">≤-mono⇒cong</a> <a id="5105" class="Symbol">:</a> <a id="5107" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="5119" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="5121" class="Symbol">→</a> <a id="5123" href="Function.Definitions.html#803" class="Function">Congruent</a> <a id="5133" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="5135" href="NonWellFormed.Function.html#5093" class="Function">≤-mono⇒cong</a> <a id="5147" href="NonWellFormed.Function.html#5147" class="Bound">≤-mono</a> <a id="5154" class="Symbol">=</a> <a id="5156" class="Symbol">λ</a> <a id="5158" class="Symbol">{</a> <a id="5160" class="Symbol">(</a><a id="5161" href="NonWellFormed.Function.html#5161" class="Bound">≤</a> <a id="5163" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5165" href="NonWellFormed.Function.html#5165" class="Bound">≥</a><a id="5166" class="Symbol">)</a> <a id="5168" class="Symbol">→</a> <a id="5170" href="NonWellFormed.Function.html#5147" class="Bound">≤-mono</a> <a id="5177" href="NonWellFormed.Function.html#5161" class="Bound">≤</a> <a id="5179" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5181" href="NonWellFormed.Function.html#5147" class="Bound">≤-mono</a> <a id="5188" href="NonWellFormed.Function.html#5165" class="Bound">≥</a> <a id="5190" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5364" href="NonWellFormed.Function.html#5364" class="Function">wf-&lt;-monotonic</a> <a id="5379" class="Symbol">:</a> <a id="5381" class="Symbol">(</a><a id="5382" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5386" class="Symbol">→</a> <a id="5388" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5391" class="Symbol">)</a> <a id="5393" class="Symbol">→</a> <a id="5395" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5399" href="NonWellFormed.Function.html#5364" class="Function">wf-&lt;-monotonic</a> <a id="5414" href="NonWellFormed.Function.html#5414" class="Bound">F</a> <a id="5416" class="Symbol">=</a> <a id="5418" class="Symbol">∀</a> <a id="5420" class="Symbol">{</a><a id="5421" href="NonWellFormed.Function.html#5421" class="Bound">α</a> <a id="5423" href="NonWellFormed.Function.html#5423" class="Bound">β</a><a id="5424" class="Symbol">}</a> <a id="5426" class="Symbol">→</a> <a id="5428" class="Symbol">⦃</a> <a id="5430" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5441" href="NonWellFormed.Function.html#5421" class="Bound">α</a> <a id="5443" class="Symbol">⦄</a> <a id="5445" class="Symbol">→</a> <a id="5447" class="Symbol">⦃</a> <a id="5449" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5460" href="NonWellFormed.Function.html#5423" class="Bound">β</a> <a id="5462" class="Symbol">⦄</a> <a id="5464" class="Symbol">→</a> <a id="5466" href="NonWellFormed.Function.html#5421" class="Bound">α</a> <a id="5468" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5470" href="NonWellFormed.Function.html#5423" class="Bound">β</a> <a id="5472" class="Symbol">→</a> <a id="5474" href="NonWellFormed.Function.html#5414" class="Bound">F</a> <a id="5476" href="NonWellFormed.Function.html#5421" class="Bound">α</a> <a id="5478" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5480" href="NonWellFormed.Function.html#5414" class="Bound">F</a> <a id="5482" href="NonWellFormed.Function.html#5423" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5485" href="NonWellFormed.Function.html#5485" class="Function">wf-suc-monotonic</a> <a id="5502" class="Symbol">:</a> <a id="5504" class="Symbol">(</a><a id="5505" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5509" class="Symbol">→</a> <a id="5511" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5514" class="Symbol">)</a> <a id="5516" class="Symbol">→</a> <a id="5518" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5522" href="NonWellFormed.Function.html#5485" class="Function">wf-suc-monotonic</a> <a id="5539" href="NonWellFormed.Function.html#5539" class="Bound">F</a> <a id="5541" class="Symbol">=</a> <a id="5543" class="Symbol">∀</a> <a id="5545" href="NonWellFormed.Function.html#5545" class="Bound">α</a> <a id="5547" class="Symbol">→</a> <a id="5549" class="Symbol">⦃</a> <a id="5551" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5562" href="NonWellFormed.Function.html#5545" class="Bound">α</a> <a id="5564" class="Symbol">⦄</a> <a id="5566" class="Symbol">→</a> <a id="5568" href="NonWellFormed.Function.html#5539" class="Bound">F</a> <a id="5570" href="NonWellFormed.Function.html#5545" class="Bound">α</a> <a id="5572" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5574" href="NonWellFormed.Function.html#5539" class="Bound">F</a> <a id="5576" class="Symbol">(</a><a id="5577" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="5581" href="NonWellFormed.Function.html#5545" class="Bound">α</a><a id="5582" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5585" href="NonWellFormed.Function.html#5585" class="Function">wf-normal</a> <a id="5595" class="Symbol">:</a> <a id="5597" class="Symbol">(</a><a id="5598" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5602" class="Symbol">→</a> <a id="5604" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5607" class="Symbol">)</a> <a id="5609" class="Symbol">→</a> <a id="5611" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5615" href="NonWellFormed.Function.html#5585" class="Function">wf-normal</a> <a id="5625" href="NonWellFormed.Function.html#5625" class="Bound">F</a> <a id="5627" class="Symbol">=</a> <a id="5629" href="NonWellFormed.Function.html#2130" class="Function">≤-monotonic</a> <a id="5641" href="NonWellFormed.Function.html#5625" class="Bound">F</a> <a id="5643" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5645" href="NonWellFormed.Function.html#5485" class="Function">wf-suc-monotonic</a> <a id="5662" href="NonWellFormed.Function.html#5625" class="Bound">F</a> <a id="5664" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5666" href="NonWellFormed.Function.html#2612" class="Function">continuous</a> <a id="5677" href="NonWellFormed.Function.html#5625" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="5775" class="Keyword">module</a> <a id="5782" href="NonWellFormed.Function.html#5782" class="Module">_</a> <a id="5784" class="Symbol">(</a><a id="5785" href="NonWellFormed.Function.html#5785" class="Bound">nml</a><a id="5788" class="Symbol">@(</a><a id="5790" href="NonWellFormed.Function.html#5790" class="Bound">≤-mono</a> <a id="5797" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5799" href="NonWellFormed.Function.html#5799" class="Bound">suc-mono</a> <a id="5808" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5810" href="NonWellFormed.Function.html#5810" class="Bound">ct</a><a id="5812" class="Symbol">)</a> <a id="5814" class="Symbol">:</a> <a id="5816" href="NonWellFormed.Function.html#5585" class="Function">wf-normal</a> <a id="5826" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="5827" class="Symbol">)</a> <a id="5829" class="Keyword">where</a>
  <a id="5837" href="NonWellFormed.Function.html#5837" class="Function">wf-nml⇒&lt;-mono</a> <a id="5851" class="Symbol">:</a> <a id="5853" href="NonWellFormed.Function.html#5364" class="Function">wf-&lt;-monotonic</a> <a id="5868" href="NonWellFormed.Function.html#5826" class="Bound">F</a>

  <a id="5873" href="NonWellFormed.Function.html#5837" class="Function">wf-nml⇒&lt;-mono</a> <a id="5887" class="Symbol">{</a><a id="5888" href="NonWellFormed.Function.html#5888" class="Bound">α</a><a id="5889" class="Symbol">}</a> <a id="5891" class="Symbol">{</a><a id="5892" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="5896" href="NonWellFormed.Function.html#5896" class="Bound">β</a><a id="5897" class="Symbol">}</a> <a id="5899" href="NonWellFormed.Function.html#5899" class="Bound">α&lt;s</a> <a id="5903" class="Symbol">=</a> <a id="5905" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="5922" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="5924" href="NonWellFormed.Function.html#5888" class="Bound">α</a>           <a id="5936" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5939" href="NonWellFormed.Function.html#5790" class="Bound">≤-mono</a> <a id="5946" class="Symbol">(</a><a id="5947" href="NonWellFormed.Ordinal.html#12499" class="Function">&lt;s⇒≤</a> <a id="5952" href="NonWellFormed.Function.html#5899" class="Bound">α&lt;s</a><a id="5955" class="Symbol">)</a> <a id="5957" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="5963" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="5965" href="NonWellFormed.Function.html#5896" class="Bound">β</a>           <a id="5977" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="5980" href="NonWellFormed.Function.html#5799" class="Bound">suc-mono</a> <a id="5989" href="NonWellFormed.Function.html#5896" class="Bound">β</a> <a id="5991" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="5997" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="5999" class="Symbol">(</a><a id="6000" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="6004" href="NonWellFormed.Function.html#5896" class="Bound">β</a><a id="6005" class="Symbol">)</a>     <a id="6011" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>

  <a id="6016" href="NonWellFormed.Function.html#5837" class="Function">wf-nml⇒&lt;-mono</a> <a id="6030" class="Symbol">{</a><a id="6031" href="NonWellFormed.Function.html#6031" class="Bound">α</a><a id="6032" class="Symbol">}</a> <a id="6034" class="Symbol">{</a><a id="6035" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6039" href="NonWellFormed.Function.html#6039" class="Bound">f</a><a id="6040" class="Symbol">}</a> <a id="6042" class="Symbol">⦃</a> <a id="6044" class="Symbol">_</a> <a id="6046" class="Symbol">⦄</a> <a id="6048" class="Symbol">⦃</a> <a id="6050" href="NonWellFormed.Function.html#6050" class="Bound">wfn</a> <a id="6054" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6056" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6061" href="NonWellFormed.Function.html#6061" class="Bound">mono</a> <a id="6066" class="Symbol">⦄</a> <a id="6068" href="NonWellFormed.Function.html#6068" class="Bound">α&lt;l</a> <a id="6072" class="Keyword">with</a> <a id="6077" href="NonWellFormed.WellFormed.html#5480" class="Function">∃[n]&lt;fn</a> <a id="6085" class="Symbol">⦃</a> <a id="6087" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6092" href="NonWellFormed.Function.html#6061" class="Bound">mono</a> <a id="6097" class="Symbol">⦄</a> <a id="6099" href="NonWellFormed.Function.html#6068" class="Bound">α&lt;l</a>
  <a id="6105" class="Symbol">...</a> <a id="6109" class="Symbol">|</a> <a id="6111" class="Symbol">(</a><a id="6112" href="NonWellFormed.Function.html#6112" class="Bound">n</a> <a id="6114" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6116" href="NonWellFormed.Function.html#6116" class="Bound">α&lt;fn</a><a id="6120" class="Symbol">)</a> <a id="6122" class="Symbol">=</a> <a id="6124" class="Keyword">let</a> <a id="6128" class="Keyword">instance</a> <a id="6137" href="NonWellFormed.Function.html#6137" class="Bound">wfn</a> <a id="6141" class="Symbol">=</a> <a id="6143" class="Bound">wfn</a> <a id="6147" class="Keyword">in</a> <a id="6150" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="6167" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="6169" class="Bound">α</a>           <a id="6181" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6184" href="NonWellFormed.Function.html#5837" class="Function">wf-nml⇒&lt;-mono</a> <a id="6198" href="NonWellFormed.Function.html#6116" class="Bound">α&lt;fn</a> <a id="6203" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6209" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="6211" class="Symbol">(</a><a id="6212" class="Bound">f</a> <a id="6214" href="NonWellFormed.Function.html#6112" class="Bound">n</a><a id="6215" class="Symbol">)</a>       <a id="6223" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6226" href="NonWellFormed.WellFormed.html#5222" class="Function">f&lt;l</a> <a id="6230" class="Symbol">⦃</a> <a id="6232" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6237" class="Symbol">λ</a> <a id="6239" href="NonWellFormed.Function.html#6239" class="Bound">m&lt;n</a> <a id="6243" class="Symbol">→</a> <a id="6245" href="NonWellFormed.Function.html#5837" class="Function">wf-nml⇒&lt;-mono</a> <a id="6259" class="Symbol">(</a><a id="6260" class="Bound">mono</a> <a id="6265" href="NonWellFormed.Function.html#6239" class="Bound">m&lt;n</a><a id="6268" class="Symbol">)</a> <a id="6270" class="Symbol">⦄</a> <a id="6272" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6278" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6282" class="Symbol">(</a><a id="6283" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="6285" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="6287" class="Bound">f</a><a id="6288" class="Symbol">)</a>   <a id="6292" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="6296" href="NonWellFormed.Function.html#5810" class="Bound">ct</a> <a id="6299" class="Bound">f</a> <a id="6301" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
    <a id="6307" href="NonWellFormed.Function.html#5826" class="Bound">F</a> <a id="6309" class="Symbol">(</a><a id="6310" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6314" class="Bound">f</a><a id="6315" class="Symbol">)</a>     <a id="6321" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
