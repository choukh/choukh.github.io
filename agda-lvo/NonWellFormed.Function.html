<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(1-3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(1-3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数1-3-序数函数" id="toc-agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
目录: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.html">NonWellFormed.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/NonWellFormed/Function.lagda.md">Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.Function.html">Function.html</a><br />
如果你在知乎看到本文: 知乎对Agda语法高亮的支持非常有限, 建议跳转到以上网站阅读</p>
</blockquote>
<pre class="Agda"><a id="494" class="Symbol">{-#</a> <a id="498" class="Keyword">OPTIONS</a> <a id="506" class="Pragma">--without-K</a> <a id="518" class="Pragma">--safe</a> <a id="525" class="Symbol">#-}</a>
<a id="529" class="Symbol">{-#</a> <a id="533" class="Keyword">OPTIONS</a> <a id="541" class="Pragma">--no-qualified-instances</a> <a id="566" class="Symbol">#-}</a>

<a id="571" class="Keyword">module</a> <a id="578" href="NonWellFormed.Function.html" class="Module">NonWellFormed.Function</a> <a id="601" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="641" class="Keyword">open</a> <a id="646" class="Keyword">import</a> <a id="653" href="NonWellFormed.Ordinal.html" class="Module">NonWellFormed.Ordinal</a>
<a id="675" class="Keyword">open</a> <a id="680" href="NonWellFormed.Ordinal.html#14726" class="Module">NonWellFormed.Ordinal.≤-Reasoning</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="NonWellFormed.WellFormed.html" class="Module">NonWellFormed.WellFormed</a> <a id="751" class="Keyword">using</a> <a id="757" class="Symbol">(</a><a id="758" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a><a id="768" class="Symbol">;</a> <a id="770" href="NonWellFormed.WellFormed.html#5530" class="Function">∃[n]&lt;fn</a><a id="777" class="Symbol">;</a> <a id="779" href="NonWellFormed.WellFormed.html#5272" class="Function">f&lt;l</a><a id="782" class="Symbol">;</a> <a id="784" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a><a id="788" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="898" class="Keyword">open</a> <a id="903" class="Keyword">import</a> <a id="910" href="Data.Product.html" class="Module">Data.Product</a> <a id="923" class="Keyword">using</a> <a id="929" class="Symbol">(</a><a id="930" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="933" class="Symbol">;</a> <a id="935" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="938" class="Symbol">;</a> <a id="940" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="945" class="Symbol">;</a> <a id="947" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="952" class="Symbol">)</a>
<a id="954" class="Keyword">open</a> <a id="959" class="Keyword">import</a> <a id="966" href="Function.html" class="Module">Function</a> <a id="975" class="Keyword">using</a> <a id="981" class="Symbol">(</a><a id="982" href="Function.Base.html#1106" class="Function Operator">_∘_</a><a id="985" class="Symbol">;</a> <a id="987" href="Function.Base.html#695" class="Function">id</a><a id="989" class="Symbol">;</a> <a id="991" href="Function.Base.html#2781" class="Function">λ-</a><a id="993" class="Symbol">)</a>
<a id="995" class="Keyword">open</a> <a id="1000" class="Keyword">import</a> <a id="1007" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="1023" class="Keyword">using</a> <a id="1029" class="Symbol">(</a><a id="1030" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a><a id="1040" class="Symbol">;</a> <a id="1042" href="Relation.Binary.Definitions.html#4853" class="Function Operator">_Respects_</a><a id="1052" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1118" class="Keyword">private</a> <a id="1126" class="Keyword">variable</a>
  <a id="1137" class="Symbol">{</a><a id="1138" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="1139" class="Symbol">}</a> <a id="1141" class="Symbol">:</a> <a id="1143" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1147" class="Symbol">→</a> <a id="1149" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1249" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1263" class="Symbol">:</a> <a id="1265" class="Symbol">(</a><a id="1266" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1275" class="Symbol">)</a> <a id="1277" class="Symbol">→</a> <a id="1279" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1283" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1297" href="NonWellFormed.Function.html#1297" class="Bound">F</a> <a id="1299" class="Symbol">=</a> <a id="1301" class="Symbol">∀</a> <a id="1303" class="Symbol">{</a><a id="1304" href="NonWellFormed.Function.html#1304" class="Bound">α</a><a id="1305" class="Symbol">}</a> <a id="1307" class="Symbol">→</a> <a id="1309" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="1320" href="NonWellFormed.Function.html#1304" class="Bound">α</a> <a id="1322" class="Symbol">→</a> <a id="1324" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="1335" class="Symbol">(</a><a id="1336" href="NonWellFormed.Function.html#1297" class="Bound">F</a> <a id="1338" href="NonWellFormed.Function.html#1304" class="Bound">α</a><a id="1339" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1369" href="NonWellFormed.Function.html#1369" class="Function">_</a> <a id="1371" class="Symbol">:</a> <a id="1373" href="NonWellFormed.Function.html#1249" class="Function">wf-preserving</a> <a id="1387" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1391" class="Symbol">_</a> <a id="1393" class="Symbol">=</a> <a id="1395" href="Function.Base.html#695" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1490" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1503" class="Symbol">:</a> <a id="1505" class="Symbol">(</a><a id="1506" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1510" class="Symbol">→</a> <a id="1512" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1515" class="Symbol">)</a> <a id="1517" class="Symbol">→</a> <a id="1519" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1523" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1536" href="NonWellFormed.Function.html#1536" class="Bound">F</a> <a id="1538" class="Symbol">=</a> <a id="1540" class="Symbol">∀</a> <a id="1542" href="NonWellFormed.Function.html#1542" class="Bound">α</a> <a id="1544" class="Symbol">→</a> <a id="1546" href="NonWellFormed.Function.html#1542" class="Bound">α</a> <a id="1548" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">≤</a> <a id="1550" href="NonWellFormed.Function.html#1536" class="Bound">F</a> <a id="1552" href="NonWellFormed.Function.html#1542" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1555" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1568" class="Symbol">:</a> <a id="1570" class="Symbol">(</a><a id="1571" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1575" class="Symbol">→</a> <a id="1577" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1580" class="Symbol">)</a> <a id="1582" class="Symbol">→</a> <a id="1584" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1588" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1601" href="NonWellFormed.Function.html#1601" class="Bound">F</a> <a id="1603" class="Symbol">=</a> <a id="1605" class="Symbol">∀</a> <a id="1607" href="NonWellFormed.Function.html#1607" class="Bound">α</a> <a id="1609" class="Symbol">→</a> <a id="1611" href="NonWellFormed.Function.html#1607" class="Bound">α</a> <a id="1613" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="1615" href="NonWellFormed.Function.html#1601" class="Bound">F</a> <a id="1617" href="NonWellFormed.Function.html#1607" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1649" href="NonWellFormed.Function.html#1649" class="Function">_</a> <a id="1651" class="Symbol">:</a> <a id="1653" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1666" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1670" class="Symbol">_</a> <a id="1672" class="Symbol">=</a> <a id="1674" href="Function.Base.html#2781" class="Function">λ-</a> <a id="1677" href="NonWellFormed.Ordinal.html#7750" class="Function">≤s</a>

<a id="1681" href="NonWellFormed.Function.html#1681" class="Function">_</a> <a id="1683" class="Symbol">:</a> <a id="1685" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1698" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="1702" class="Symbol">_</a> <a id="1704" class="Symbol">=</a> <a id="1706" href="Function.Base.html#2781" class="Function">λ-</a> <a id="1709" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1740" href="NonWellFormed.Function.html#1740" class="Function">&lt;⇒≤-incr</a> <a id="1749" class="Symbol">:</a> <a id="1751" href="NonWellFormed.Function.html#1555" class="Function">&lt;-increasing</a> <a id="1764" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="1766" class="Symbol">→</a> <a id="1768" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="1781" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="1783" href="NonWellFormed.Function.html#1740" class="Function">&lt;⇒≤-incr</a> <a id="1792" class="Symbol">=</a> <a id="1794" class="Symbol">λ</a> <a id="1796" href="NonWellFormed.Function.html#1796" class="Bound">&lt;-incr</a> <a id="1803" href="NonWellFormed.Function.html#1803" class="Bound">α</a> <a id="1805" class="Symbol">→</a> <a id="1807" href="NonWellFormed.Ordinal.html#11977" class="Function">&lt;⇒≤</a> <a id="1811" class="Symbol">(</a><a id="1812" href="NonWellFormed.Function.html#1796" class="Bound">&lt;-incr</a> <a id="1819" href="NonWellFormed.Function.html#1803" class="Bound">α</a><a id="1820" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1911" href="NonWellFormed.Function.html#1911" class="Function">zero-increasing</a> <a id="1927" class="Symbol">:</a> <a id="1929" class="Symbol">(</a><a id="1930" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="1934" class="Symbol">→</a> <a id="1936" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="1939" class="Symbol">)</a> <a id="1941" class="Symbol">→</a> <a id="1943" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1947" href="NonWellFormed.Function.html#1911" class="Function">zero-increasing</a> <a id="1963" href="NonWellFormed.Function.html#1963" class="Bound">F</a> <a id="1965" class="Symbol">=</a> <a id="1967" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a> <a id="1972" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="1974" href="NonWellFormed.Function.html#1963" class="Bound">F</a> <a id="1976" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1982" href="NonWellFormed.Function.html#1982" class="Function">suc-increasing</a> <a id="1997" class="Symbol">:</a> <a id="1999" class="Symbol">(</a><a id="2000" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2004" class="Symbol">→</a> <a id="2006" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2009" class="Symbol">)</a> <a id="2011" class="Symbol">→</a> <a id="2013" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2017" href="NonWellFormed.Function.html#1982" class="Function">suc-increasing</a> <a id="2032" href="NonWellFormed.Function.html#2032" class="Bound">F</a> <a id="2034" class="Symbol">=</a> <a id="2036" class="Symbol">∀</a> <a id="2038" href="NonWellFormed.Function.html#2038" class="Bound">α</a> <a id="2040" class="Symbol">→</a> <a id="2042" class="Symbol">⦃</a> <a id="2044" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="2055" href="NonWellFormed.Function.html#2038" class="Bound">α</a> <a id="2057" class="Symbol">⦄</a> <a id="2059" class="Symbol">→</a> <a id="2061" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2065" href="NonWellFormed.Function.html#2038" class="Bound">α</a> <a id="2067" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="2069" href="NonWellFormed.Function.html#2032" class="Bound">F</a> <a id="2071" class="Symbol">(</a><a id="2072" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2076" href="NonWellFormed.Function.html#2038" class="Bound">α</a><a id="2077" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2134" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="2146" class="Symbol">:</a> <a id="2148" class="Symbol">(</a><a id="2149" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2153" class="Symbol">→</a> <a id="2155" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2158" class="Symbol">)</a> <a id="2160" class="Symbol">→</a> <a id="2162" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2166" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="2178" href="NonWellFormed.Function.html#2178" class="Bound">F</a> <a id="2180" class="Symbol">=</a> <a id="2182" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2193" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">_≤_</a> <a id="2197" href="NonWellFormed.Ordinal.html#4738" class="Datatype Operator">_≤_</a> <a id="2201" href="NonWellFormed.Function.html#2178" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2204" href="NonWellFormed.Function.html#2204" class="Function">&lt;-monotonic</a> <a id="2216" class="Symbol">:</a> <a id="2218" class="Symbol">(</a><a id="2219" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2223" class="Symbol">→</a> <a id="2225" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2228" class="Symbol">)</a> <a id="2230" class="Symbol">→</a> <a id="2232" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2236" href="NonWellFormed.Function.html#2204" class="Function">&lt;-monotonic</a> <a id="2248" href="NonWellFormed.Function.html#2248" class="Bound">F</a> <a id="2250" class="Symbol">=</a> <a id="2252" href="Relation.Binary.Definitions.html#3756" class="Function">Monotonic₁</a> <a id="2263" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">_&lt;_</a> <a id="2267" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">_&lt;_</a> <a id="2271" href="NonWellFormed.Function.html#2248" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2303" href="NonWellFormed.Function.html#2303" class="Function">_</a> <a id="2305" class="Symbol">:</a> <a id="2307" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="2319" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="2323" class="Symbol">_</a> <a id="2325" class="Symbol">=</a> <a id="2327" href="NonWellFormed.Ordinal.html#6487" class="Function">s≤s</a>

<a id="2332" href="NonWellFormed.Function.html#2332" class="Function">_</a> <a id="2334" class="Symbol">:</a> <a id="2336" href="NonWellFormed.Function.html#2204" class="Function">&lt;-monotonic</a> <a id="2348" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a>
<a id="2352" class="Symbol">_</a> <a id="2354" class="Symbol">=</a> <a id="2356" href="NonWellFormed.Ordinal.html#12835" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2415" href="NonWellFormed.Function.html#2415" class="Function">suc-monotonic</a> <a id="2429" class="Symbol">:</a> <a id="2431" class="Symbol">(</a><a id="2432" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2436" class="Symbol">→</a> <a id="2438" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2441" class="Symbol">)</a> <a id="2443" class="Symbol">→</a> <a id="2445" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2449" href="NonWellFormed.Function.html#2415" class="Function">suc-monotonic</a> <a id="2463" href="NonWellFormed.Function.html#2463" class="Bound">F</a> <a id="2465" class="Symbol">=</a> <a id="2467" class="Symbol">∀</a> <a id="2469" href="NonWellFormed.Function.html#2469" class="Bound">α</a> <a id="2471" class="Symbol">→</a> <a id="2473" href="NonWellFormed.Function.html#2463" class="Bound">F</a> <a id="2475" href="NonWellFormed.Function.html#2469" class="Bound">α</a> <a id="2477" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="2479" href="NonWellFormed.Function.html#2463" class="Bound">F</a> <a id="2481" class="Symbol">(</a><a id="2482" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="2486" href="NonWellFormed.Function.html#2469" class="Bound">α</a><a id="2487" class="Symbol">)</a>

<a id="2490" href="NonWellFormed.Function.html#2490" class="Function">_</a> <a id="2492" class="Symbol">:</a> <a id="2494" href="NonWellFormed.Function.html#2204" class="Function">&lt;-monotonic</a> <a id="2506" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="2508" class="Symbol">→</a> <a id="2510" href="NonWellFormed.Function.html#2415" class="Function">suc-monotonic</a> <a id="2524" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="2526" class="Symbol">_</a> <a id="2528" class="Symbol">=</a> <a id="2530" class="Symbol">λ</a> <a id="2532" href="NonWellFormed.Function.html#2532" class="Bound">&lt;-mono</a> <a id="2539" href="NonWellFormed.Function.html#2539" class="Bound">_</a> <a id="2541" class="Symbol">→</a> <a id="2543" href="NonWellFormed.Function.html#2532" class="Bound">&lt;-mono</a> <a id="2550" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="lim-continuous"></a><a id="2616" href="NonWellFormed.Function.html#2616" class="Function">lim-continuous</a> <a id="2631" class="Symbol">:</a> <a id="2633" class="Symbol">(</a><a id="2634" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2638" class="Symbol">→</a> <a id="2640" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2643" class="Symbol">)</a> <a id="2645" class="Symbol">→</a> <a id="2647" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2651" href="NonWellFormed.Function.html#2616" class="Function">lim-continuous</a> <a id="2666" href="NonWellFormed.Function.html#2666" class="Bound">F</a> <a id="2668" class="Symbol">=</a> <a id="2670" class="Symbol">∀</a> <a id="2672" href="NonWellFormed.Function.html#2672" class="Bound">f</a> <a id="2674" class="Symbol">→</a> <a id="2676" href="NonWellFormed.Function.html#2666" class="Bound">F</a> <a id="2678" class="Symbol">(</a><a id="2679" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="2683" href="NonWellFormed.Function.html#2672" class="Bound">f</a><a id="2684" class="Symbol">)</a> <a id="2686" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">≈</a> <a id="2688" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="2692" class="Symbol">(</a><a id="2693" href="NonWellFormed.Function.html#2666" class="Bound">F</a> <a id="2695" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2697" href="NonWellFormed.Function.html#2672" class="Bound">f</a><a id="2698" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2788" href="NonWellFormed.Function.html#2788" class="Function">normal</a> <a id="2795" class="Symbol">:</a> <a id="2797" class="Symbol">(</a><a id="2798" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="2802" class="Symbol">→</a> <a id="2804" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="2807" class="Symbol">)</a> <a id="2809" class="Symbol">→</a> <a id="2811" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2815" href="NonWellFormed.Function.html#2788" class="Function">normal</a> <a id="2822" href="NonWellFormed.Function.html#2822" class="Bound">F</a> <a id="2824" class="Symbol">=</a> <a id="2826" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="2838" href="NonWellFormed.Function.html#2822" class="Bound">F</a> <a id="2840" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2842" href="NonWellFormed.Function.html#2204" class="Function">&lt;-monotonic</a> <a id="2854" href="NonWellFormed.Function.html#2822" class="Bound">F</a> <a id="2856" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2858" href="NonWellFormed.Function.html#2616" class="Function">lim-continuous</a> <a id="2873" href="NonWellFormed.Function.html#2822" class="Bound">F</a>
</pre>
<p>我们会在下一小节解释序数嵌入的定义, 现在先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="2995" class="Keyword">module</a> <a id="3002" href="NonWellFormed.Function.html#3002" class="Module">_</a> <a id="3004" class="Symbol">(</a><a id="3005" href="NonWellFormed.Function.html#3005" class="Bound">nml</a><a id="3008" class="Symbol">@(_</a> <a id="3012" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3014" href="NonWellFormed.Function.html#3014" class="Bound">&lt;-mono</a> <a id="3021" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3023" href="NonWellFormed.Function.html#3023" class="Bound">lim-ct</a><a id="3029" class="Symbol">)</a> <a id="3031" class="Symbol">:</a> <a id="3033" href="NonWellFormed.Function.html#2788" class="Function">normal</a> <a id="3040" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="3041" class="Symbol">)</a> <a id="3043" class="Keyword">where</a>
  <a id="3051" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3065" class="Symbol">:</a> <a id="3067" href="NonWellFormed.Function.html#1490" class="Function">≤-increasing</a> <a id="3080" href="NonWellFormed.Function.html#3040" class="Bound">F</a>
  <a id="3084" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3098" href="NonWellFormed.Ordinal.html#3153" class="InductiveConstructor">zero</a> <a id="3103" class="Symbol">=</a> <a id="3105" href="NonWellFormed.Ordinal.html#4763" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">  <a id="3258" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3272" class="Symbol">(</a><a id="3273" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3277" href="NonWellFormed.Function.html#3277" class="Bound">α</a><a id="3278" class="Symbol">)</a> <a id="3280" class="Symbol">=</a> <a id="3282" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="3292" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3296" href="NonWellFormed.Function.html#3277" class="Bound">α</a>                 <a id="3314" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3317" href="NonWellFormed.Ordinal.html#6487" class="Function">s≤s</a> <a id="3321" class="Symbol">(</a><a id="3322" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3336" href="NonWellFormed.Function.html#3277" class="Bound">α</a><a id="3337" class="Symbol">)</a> <a id="3339" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3345" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3349" class="Symbol">(</a><a id="3350" href="NonWellFormed.Function.html#3040" class="Bound">F</a> <a id="3352" href="NonWellFormed.Function.html#3277" class="Bound">α</a><a id="3353" class="Symbol">)</a>             <a id="3367" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3370" href="NonWellFormed.Ordinal.html#12233" class="Function">&lt;⇒s≤</a> <a id="3375" class="Symbol">(</a><a id="3376" href="NonWellFormed.Function.html#3014" class="Bound">&lt;-mono</a> <a id="3383" href="NonWellFormed.Ordinal.html#11177" class="Function">&lt;s</a><a id="3385" class="Symbol">)</a> <a id="3387" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3393" href="NonWellFormed.Function.html#3040" class="Bound">F</a> <a id="3395" class="Symbol">(</a><a id="3396" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="3400" href="NonWellFormed.Function.html#3277" class="Bound">α</a><a id="3401" class="Symbol">)</a>             <a id="3415" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">  <a id="3555" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3569" class="Symbol">(</a><a id="3570" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3574" href="NonWellFormed.Function.html#3574" class="Bound">f</a><a id="3575" class="Symbol">)</a> <a id="3577" class="Symbol">=</a> <a id="3579" href="NonWellFormed.Ordinal.html#4859" class="InductiveConstructor">l≤</a> <a id="3582" class="Symbol">λ</a> <a id="3584" href="NonWellFormed.Function.html#3584" class="Bound">n</a> <a id="3586" class="Symbol">→</a> <a id="3588" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="3598" href="NonWellFormed.Function.html#3574" class="Bound">f</a> <a id="3600" href="NonWellFormed.Function.html#3584" class="Bound">n</a>                   <a id="3620" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="3623" href="NonWellFormed.Ordinal.html#6166" class="Function">≤f⇒≤l</a> <a id="3629" class="Symbol">(</a><a id="3630" href="NonWellFormed.Function.html#3051" class="Function">normal⇒≤-incr</a> <a id="3644" class="Symbol">(</a><a id="3645" href="NonWellFormed.Function.html#3574" class="Bound">f</a> <a id="3647" href="NonWellFormed.Function.html#3584" class="Bound">n</a><a id="3648" class="Symbol">))</a> <a id="3651" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="3657" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3661" class="Symbol">(</a><a id="3662" href="NonWellFormed.Function.html#3040" class="Bound">F</a> <a id="3664" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="3666" href="NonWellFormed.Function.html#3574" class="Bound">f</a><a id="3667" class="Symbol">)</a>           <a id="3679" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="3683" href="NonWellFormed.Function.html#3023" class="Bound">lim-ct</a> <a id="3690" href="NonWellFormed.Function.html#3574" class="Bound">f</a> <a id="3692" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
    <a id="3698" href="NonWellFormed.Function.html#3040" class="Bound">F</a> <a id="3700" class="Symbol">(</a><a id="3701" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="3705" href="NonWellFormed.Function.html#3574" class="Bound">f</a><a id="3706" class="Symbol">)</a>             <a id="3720" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3765" href="NonWellFormed.Function.html#3765" class="Function Operator">_≈ᶠ_</a> <a id="3770" class="Symbol">:</a> <a id="3772" class="Symbol">(</a><a id="3773" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="3777" class="Symbol">→</a> <a id="3779" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="3782" class="Symbol">)</a> <a id="3784" class="Symbol">→</a> <a id="3786" class="Symbol">(</a><a id="3787" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="3791" class="Symbol">→</a> <a id="3793" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="3796" class="Symbol">)</a> <a id="3798" class="Symbol">→</a> <a id="3800" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="3804" href="NonWellFormed.Function.html#3804" class="Bound">F</a> <a id="3806" href="NonWellFormed.Function.html#3765" class="Function Operator">≈ᶠ</a> <a id="3809" href="NonWellFormed.Function.html#3809" class="Bound">G</a> <a id="3811" class="Symbol">=</a> <a id="3813" class="Symbol">∀</a> <a id="3815" class="Symbol">{</a><a id="3816" href="NonWellFormed.Function.html#3816" class="Bound">α</a><a id="3817" class="Symbol">}</a> <a id="3819" class="Symbol">→</a> <a id="3821" href="NonWellFormed.Function.html#3804" class="Bound">F</a> <a id="3823" href="NonWellFormed.Function.html#3816" class="Bound">α</a> <a id="3825" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">≈</a> <a id="3827" href="NonWellFormed.Function.html#3809" class="Bound">G</a> <a id="3829" href="NonWellFormed.Function.html#3816" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3832" href="NonWellFormed.Function.html#3832" class="Function">normal-resp-≈</a> <a id="3846" class="Symbol">:</a> <a id="3848" href="NonWellFormed.Function.html#2788" class="Function">normal</a> <a id="3855" href="Relation.Binary.Definitions.html#4853" class="Function Operator">Respects</a> <a id="3864" href="NonWellFormed.Function.html#3765" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>lim-ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3980" href="NonWellFormed.Function.html#3832" class="Function">normal-resp-≈</a> <a id="3994" class="Symbol">{</a><a id="3995" href="NonWellFormed.Function.html#3995" class="Bound">F</a><a id="3996" class="Symbol">}</a> <a id="3998" class="Symbol">{</a><a id="3999" href="NonWellFormed.Function.html#3999" class="Bound">G</a><a id="4000" class="Symbol">}</a> <a id="4002" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4006" class="Symbol">(</a><a id="4007" href="NonWellFormed.Function.html#4007" class="Bound">≤-mono</a> <a id="4014" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4016" href="NonWellFormed.Function.html#4016" class="Bound">&lt;-mono</a> <a id="4023" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4025" href="NonWellFormed.Function.html#4025" class="Bound">lim-ct</a><a id="4031" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4130" class="Symbol">=</a> <a id="4132" class="Symbol">(λ</a> <a id="4135" class="Symbol">{</a><a id="4136" href="NonWellFormed.Function.html#4136" class="Bound">α</a><a id="4137" class="Symbol">}</a> <a id="4139" class="Symbol">{</a><a id="4140" href="NonWellFormed.Function.html#4140" class="Bound">β</a><a id="4141" class="Symbol">}</a> <a id="4143" href="NonWellFormed.Function.html#4143" class="Bound">α≤β</a> <a id="4147" class="Symbol">→</a> <a id="4149" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a> <a id="4155" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4157" href="NonWellFormed.Function.html#4136" class="Bound">α</a> <a id="4159" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4163" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4167" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4169" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4171" href="NonWellFormed.Function.html#4136" class="Bound">α</a> <a id="4173" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="4176" href="NonWellFormed.Function.html#4007" class="Bound">≤-mono</a> <a id="4183" href="NonWellFormed.Function.html#4143" class="Bound">α≤β</a> <a id="4187" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a> <a id="4189" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4191" href="NonWellFormed.Function.html#4140" class="Bound">β</a> <a id="4193" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4196" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4200" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4202" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4204" href="NonWellFormed.Function.html#4140" class="Bound">β</a> <a id="4206" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4207" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4306" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4308" class="Symbol">(λ</a> <a id="4311" class="Symbol">{</a><a id="4312" href="NonWellFormed.Function.html#4312" class="Bound">α</a><a id="4313" class="Symbol">}</a> <a id="4315" class="Symbol">{</a><a id="4316" href="NonWellFormed.Function.html#4316" class="Bound">β</a><a id="4317" class="Symbol">}</a> <a id="4319" href="NonWellFormed.Function.html#4319" class="Bound">α&lt;β</a> <a id="4323" class="Symbol">→</a> <a id="4325" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a> <a id="4338" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4340" href="NonWellFormed.Function.html#4312" class="Bound">α</a> <a id="4342" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4346" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4350" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a> <a id="4352" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4354" href="NonWellFormed.Function.html#4312" class="Bound">α</a> <a id="4356" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="4359" href="NonWellFormed.Function.html#4016" class="Bound">&lt;-mono</a> <a id="4366" href="NonWellFormed.Function.html#4319" class="Bound">α&lt;β</a> <a id="4370" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a> <a id="4372" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4374" href="NonWellFormed.Function.html#4316" class="Bound">β</a> <a id="4376" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4379" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4383" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a> <a id="4385" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4387" href="NonWellFormed.Function.html#4316" class="Bound">β</a> <a id="4389" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4390" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4434" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4436" class="Symbol">(λ</a> <a id="4439" href="NonWellFormed.Function.html#4439" class="Bound">f</a> <a id="4441" class="Symbol">→</a> <a id="4443" href="Relation.Binary.Reasoning.Base.Triple.html#3286" class="Function Operator">begin-equality</a>
      <a id="4464" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4466" class="Symbol">(</a><a id="4467" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4471" href="NonWellFormed.Function.html#4439" class="Bound">f</a><a id="4472" class="Symbol">)</a>   <a id="4476" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="4480" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4484" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
      <a id="4492" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4494" class="Symbol">(</a><a id="4495" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4499" href="NonWellFormed.Function.html#4439" class="Bound">f</a><a id="4500" class="Symbol">)</a>   <a id="4504" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4507" href="NonWellFormed.Function.html#4025" class="Bound">lim-ct</a> <a id="4514" href="NonWellFormed.Function.html#4439" class="Bound">f</a> <a id="4516" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4524" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4528" class="Symbol">(</a><a id="4529" href="NonWellFormed.Function.html#3995" class="Bound">F</a> <a id="4531" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4533" href="NonWellFormed.Function.html#4439" class="Bound">f</a><a id="4534" class="Symbol">)</a> <a id="4536" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">≈⟨</a> <a id="4539" href="NonWellFormed.Ordinal.html#9192" class="Function">l≈l</a> <a id="4543" href="NonWellFormed.Function.html#4002" class="Bound">ext</a> <a id="4547" href="Relation.Binary.Reasoning.Base.Triple.html#4035" class="Function">⟩</a>
      <a id="4555" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="4559" class="Symbol">(</a><a id="4560" href="NonWellFormed.Function.html#3999" class="Bound">G</a> <a id="4562" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="4564" href="NonWellFormed.Function.html#4439" class="Bound">f</a><a id="4565" class="Symbol">)</a> <a id="4567" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a><a id="4568" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="5069" class="Keyword">open</a> <a id="5074" class="Keyword">import</a> <a id="5081" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="5102" class="Symbol">(</a><a id="5103" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">_≈_</a><a id="5106" class="Symbol">)</a> <a id="5108" class="Symbol">(</a><a id="5109" href="NonWellFormed.Ordinal.html#8185" class="Function Operator">_≈_</a><a id="5112" class="Symbol">)</a> <a id="5114" class="Keyword">using</a> <a id="5120" class="Symbol">(</a><a id="5121" href="Function.Definitions.html#803" class="Function">Congruent</a><a id="5130" class="Symbol">)</a>

<a id="≤-mono⇒cong"></a><a id="5133" href="NonWellFormed.Function.html#5133" class="Function">≤-mono⇒cong</a> <a id="5145" class="Symbol">:</a> <a id="5147" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="5159" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a> <a id="5161" class="Symbol">→</a> <a id="5163" href="Function.Definitions.html#803" class="Function">Congruent</a> <a id="5173" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a>
<a id="5175" href="NonWellFormed.Function.html#5133" class="Function">≤-mono⇒cong</a> <a id="5187" href="NonWellFormed.Function.html#5187" class="Bound">≤-mono</a> <a id="5194" class="Symbol">=</a> <a id="5196" class="Symbol">λ</a> <a id="5198" class="Symbol">{</a> <a id="5200" class="Symbol">(</a><a id="5201" href="NonWellFormed.Function.html#5201" class="Bound">≤</a> <a id="5203" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5205" href="NonWellFormed.Function.html#5205" class="Bound">≥</a><a id="5206" class="Symbol">)</a> <a id="5208" class="Symbol">→</a> <a id="5210" href="NonWellFormed.Function.html#5187" class="Bound">≤-mono</a> <a id="5217" href="NonWellFormed.Function.html#5201" class="Bound">≤</a> <a id="5219" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5221" href="NonWellFormed.Function.html#5187" class="Bound">≤-mono</a> <a id="5228" href="NonWellFormed.Function.html#5205" class="Bound">≥</a> <a id="5230" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5404" href="NonWellFormed.Function.html#5404" class="Function">wf-&lt;-monotonic</a> <a id="5419" class="Symbol">:</a> <a id="5421" class="Symbol">(</a><a id="5422" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5426" class="Symbol">→</a> <a id="5428" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5431" class="Symbol">)</a> <a id="5433" class="Symbol">→</a> <a id="5435" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5439" href="NonWellFormed.Function.html#5404" class="Function">wf-&lt;-monotonic</a> <a id="5454" href="NonWellFormed.Function.html#5454" class="Bound">F</a> <a id="5456" class="Symbol">=</a> <a id="5458" class="Symbol">∀</a> <a id="5460" class="Symbol">{</a><a id="5461" href="NonWellFormed.Function.html#5461" class="Bound">α</a> <a id="5463" href="NonWellFormed.Function.html#5463" class="Bound">β</a><a id="5464" class="Symbol">}</a> <a id="5466" class="Symbol">→</a> <a id="5468" class="Symbol">⦃</a> <a id="5470" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5481" href="NonWellFormed.Function.html#5461" class="Bound">α</a> <a id="5483" class="Symbol">⦄</a> <a id="5485" class="Symbol">→</a> <a id="5487" class="Symbol">⦃</a> <a id="5489" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5500" href="NonWellFormed.Function.html#5463" class="Bound">β</a> <a id="5502" class="Symbol">⦄</a> <a id="5504" class="Symbol">→</a> <a id="5506" href="NonWellFormed.Function.html#5461" class="Bound">α</a> <a id="5508" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5510" href="NonWellFormed.Function.html#5463" class="Bound">β</a> <a id="5512" class="Symbol">→</a> <a id="5514" href="NonWellFormed.Function.html#5454" class="Bound">F</a> <a id="5516" href="NonWellFormed.Function.html#5461" class="Bound">α</a> <a id="5518" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5520" href="NonWellFormed.Function.html#5454" class="Bound">F</a> <a id="5522" href="NonWellFormed.Function.html#5463" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5525" href="NonWellFormed.Function.html#5525" class="Function">wf-suc-monotonic</a> <a id="5542" class="Symbol">:</a> <a id="5544" class="Symbol">(</a><a id="5545" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5549" class="Symbol">→</a> <a id="5551" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5554" class="Symbol">)</a> <a id="5556" class="Symbol">→</a> <a id="5558" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5562" href="NonWellFormed.Function.html#5525" class="Function">wf-suc-monotonic</a> <a id="5579" href="NonWellFormed.Function.html#5579" class="Bound">F</a> <a id="5581" class="Symbol">=</a> <a id="5583" class="Symbol">∀</a> <a id="5585" href="NonWellFormed.Function.html#5585" class="Bound">α</a> <a id="5587" class="Symbol">→</a> <a id="5589" class="Symbol">⦃</a> <a id="5591" href="NonWellFormed.WellFormed.html#1913" class="Function">WellFormed</a> <a id="5602" href="NonWellFormed.Function.html#5585" class="Bound">α</a> <a id="5604" class="Symbol">⦄</a> <a id="5606" class="Symbol">→</a> <a id="5608" href="NonWellFormed.Function.html#5579" class="Bound">F</a> <a id="5610" href="NonWellFormed.Function.html#5585" class="Bound">α</a> <a id="5612" href="NonWellFormed.Ordinal.html#10365" class="Function Operator">&lt;</a> <a id="5614" href="NonWellFormed.Function.html#5579" class="Bound">F</a> <a id="5616" class="Symbol">(</a><a id="5617" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="5621" href="NonWellFormed.Function.html#5585" class="Bound">α</a><a id="5622" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5625" href="NonWellFormed.Function.html#5625" class="Function">wf-normal</a> <a id="5635" class="Symbol">:</a> <a id="5637" class="Symbol">(</a><a id="5638" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a> <a id="5642" class="Symbol">→</a> <a id="5644" href="NonWellFormed.Ordinal.html#3135" class="Datatype">Ord</a><a id="5647" class="Symbol">)</a> <a id="5649" class="Symbol">→</a> <a id="5651" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5655" href="NonWellFormed.Function.html#5625" class="Function">wf-normal</a> <a id="5665" href="NonWellFormed.Function.html#5665" class="Bound">F</a> <a id="5667" class="Symbol">=</a> <a id="5669" href="NonWellFormed.Function.html#2134" class="Function">≤-monotonic</a> <a id="5681" href="NonWellFormed.Function.html#5665" class="Bound">F</a> <a id="5683" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5685" href="NonWellFormed.Function.html#5525" class="Function">wf-suc-monotonic</a> <a id="5702" href="NonWellFormed.Function.html#5665" class="Bound">F</a> <a id="5704" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="5706" href="NonWellFormed.Function.html#2616" class="Function">lim-continuous</a> <a id="5721" href="NonWellFormed.Function.html#5665" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="5819" class="Keyword">module</a> <a id="5826" href="NonWellFormed.Function.html#5826" class="Module">_</a> <a id="5828" class="Symbol">(</a><a id="5829" href="NonWellFormed.Function.html#5829" class="Bound">nml</a><a id="5832" class="Symbol">@(</a><a id="5834" href="NonWellFormed.Function.html#5834" class="Bound">≤-mono</a> <a id="5841" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5843" href="NonWellFormed.Function.html#5843" class="Bound">suc-mono</a> <a id="5852" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5854" href="NonWellFormed.Function.html#5854" class="Bound">lim-ct</a><a id="5860" class="Symbol">)</a> <a id="5862" class="Symbol">:</a> <a id="5864" href="NonWellFormed.Function.html#5625" class="Function">wf-normal</a> <a id="5874" href="NonWellFormed.Function.html#1138" class="Generalizable">F</a><a id="5875" class="Symbol">)</a> <a id="5877" class="Keyword">where</a>
  <a id="5885" href="NonWellFormed.Function.html#5885" class="Function">wf-nml⇒&lt;-mono</a> <a id="5899" class="Symbol">:</a> <a id="5901" href="NonWellFormed.Function.html#5404" class="Function">wf-&lt;-monotonic</a> <a id="5916" href="NonWellFormed.Function.html#5874" class="Bound">F</a>

  <a id="5921" href="NonWellFormed.Function.html#5885" class="Function">wf-nml⇒&lt;-mono</a> <a id="5935" class="Symbol">{</a><a id="5936" href="NonWellFormed.Function.html#5936" class="Bound">α</a><a id="5937" class="Symbol">}</a> <a id="5939" class="Symbol">{</a><a id="5940" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="5944" href="NonWellFormed.Function.html#5944" class="Bound">β</a><a id="5945" class="Symbol">}</a> <a id="5947" href="NonWellFormed.Function.html#5947" class="Bound">α&lt;s</a> <a id="5951" class="Symbol">=</a> <a id="5953" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="5970" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="5972" href="NonWellFormed.Function.html#5936" class="Bound">α</a>           <a id="5984" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="5987" href="NonWellFormed.Function.html#5834" class="Bound">≤-mono</a> <a id="5994" class="Symbol">(</a><a id="5995" href="NonWellFormed.Ordinal.html#12499" class="Function">&lt;s⇒≤</a> <a id="6000" href="NonWellFormed.Function.html#5947" class="Bound">α&lt;s</a><a id="6003" class="Symbol">)</a> <a id="6005" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a>
    <a id="6011" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6013" href="NonWellFormed.Function.html#5944" class="Bound">β</a>           <a id="6025" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6028" href="NonWellFormed.Function.html#5843" class="Bound">suc-mono</a> <a id="6037" href="NonWellFormed.Function.html#5944" class="Bound">β</a> <a id="6039" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6045" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6047" class="Symbol">(</a><a id="6048" href="NonWellFormed.Ordinal.html#3166" class="InductiveConstructor">suc</a> <a id="6052" href="NonWellFormed.Function.html#5944" class="Bound">β</a><a id="6053" class="Symbol">)</a>     <a id="6059" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>

  <a id="6064" href="NonWellFormed.Function.html#5885" class="Function">wf-nml⇒&lt;-mono</a> <a id="6078" class="Symbol">{</a><a id="6079" href="NonWellFormed.Function.html#6079" class="Bound">α</a><a id="6080" class="Symbol">}</a> <a id="6082" class="Symbol">{</a><a id="6083" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6087" href="NonWellFormed.Function.html#6087" class="Bound">f</a><a id="6088" class="Symbol">}</a> <a id="6090" class="Symbol">⦃</a> <a id="6092" class="Symbol">_</a> <a id="6094" class="Symbol">⦄</a> <a id="6096" class="Symbol">⦃</a> <a id="6098" href="NonWellFormed.Function.html#6098" class="Bound">wfn</a> <a id="6102" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6104" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6109" href="NonWellFormed.Function.html#6109" class="Bound">mono</a> <a id="6114" class="Symbol">⦄</a> <a id="6116" href="NonWellFormed.Function.html#6116" class="Bound">α&lt;l</a> <a id="6120" class="Keyword">with</a> <a id="6125" href="NonWellFormed.WellFormed.html#5530" class="Function">∃[n]&lt;fn</a> <a id="6133" class="Symbol">⦃</a> <a id="6135" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6140" href="NonWellFormed.Function.html#6109" class="Bound">mono</a> <a id="6145" class="Symbol">⦄</a> <a id="6147" href="NonWellFormed.Function.html#6116" class="Bound">α&lt;l</a>
  <a id="6153" class="Symbol">...</a> <a id="6157" class="Symbol">|</a> <a id="6159" class="Symbol">(</a><a id="6160" href="NonWellFormed.Function.html#6160" class="Bound">n</a> <a id="6162" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6164" href="NonWellFormed.Function.html#6164" class="Bound">α&lt;fn</a><a id="6168" class="Symbol">)</a> <a id="6170" class="Symbol">=</a> <a id="6172" class="Keyword">let</a> <a id="6176" class="Keyword">instance</a> <a id="6185" href="NonWellFormed.Function.html#6185" class="Bound">wfn</a> <a id="6189" class="Symbol">=</a> <a id="6191" class="Bound">wfn</a> <a id="6195" class="Keyword">in</a> <a id="6198" href="Relation.Binary.Reasoning.Base.Triple.html#3154" class="Function Operator">begin-strict</a>
    <a id="6215" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6217" class="Bound">α</a>           <a id="6229" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6232" href="NonWellFormed.Function.html#5885" class="Function">wf-nml⇒&lt;-mono</a> <a id="6246" href="NonWellFormed.Function.html#6164" class="Bound">α&lt;fn</a> <a id="6251" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6257" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6259" class="Symbol">(</a><a id="6260" class="Bound">f</a> <a id="6262" href="NonWellFormed.Function.html#6160" class="Bound">n</a><a id="6263" class="Symbol">)</a>       <a id="6271" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">&lt;⟨</a> <a id="6274" href="NonWellFormed.WellFormed.html#5272" class="Function">f&lt;l</a> <a id="6278" class="Symbol">⦃</a> <a id="6280" href="NonWellFormed.WellFormed.html#1705" class="InductiveConstructor">wrap</a> <a id="6285" class="Symbol">λ</a> <a id="6287" href="NonWellFormed.Function.html#6287" class="Bound">m&lt;n</a> <a id="6291" class="Symbol">→</a> <a id="6293" href="NonWellFormed.Function.html#5885" class="Function">wf-nml⇒&lt;-mono</a> <a id="6307" class="Symbol">(</a><a id="6308" class="Bound">mono</a> <a id="6313" href="NonWellFormed.Function.html#6287" class="Bound">m&lt;n</a><a id="6316" class="Symbol">)</a> <a id="6318" class="Symbol">⦄</a> <a id="6320" href="Relation.Binary.Reasoning.Base.Triple.html#3460" class="Function">⟩</a>
    <a id="6326" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6330" class="Symbol">(</a><a id="6331" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6333" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="6335" class="Bound">f</a><a id="6336" class="Symbol">)</a>   <a id="6340" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">≈˘⟨</a> <a id="6344" href="NonWellFormed.Function.html#5854" class="Bound">lim-ct</a> <a id="6351" class="Bound">f</a> <a id="6353" href="Relation.Binary.Reasoning.Base.Triple.html#4358" class="Function">⟩</a>
    <a id="6359" href="NonWellFormed.Function.html#5874" class="Bound">F</a> <a id="6361" class="Symbol">(</a><a id="6362" href="NonWellFormed.Ordinal.html#3185" class="InductiveConstructor">lim</a> <a id="6366" class="Bound">f</a><a id="6367" class="Symbol">)</a>     <a id="6373" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
