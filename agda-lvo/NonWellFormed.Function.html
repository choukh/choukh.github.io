<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(1-3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(1-3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数1-3-序数函数" id="toc-agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数1-3-序数函数">Agda大序数(1-3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
目录: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.html">NonWellFormed.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-lvo/blob/main/src/NonWellFormed/Function.lagda.md">Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-lvo/NonWellFormed.Function.html">Function.html</a></p>
</blockquote>
<pre class="Agda"><a id="446" class="Symbol">{-#</a> <a id="450" class="Keyword">OPTIONS</a> <a id="458" class="Pragma">--without-K</a> <a id="470" class="Pragma">--safe</a> <a id="477" class="Symbol">#-}</a>
<a id="481" class="Symbol">{-#</a> <a id="485" class="Keyword">OPTIONS</a> <a id="493" class="Pragma">--no-qualified-instances</a> <a id="518" class="Symbol">#-}</a>

<a id="523" class="Keyword">module</a> <a id="530" href="NonWellFormed.Function.html" class="Module">NonWellFormed.Function</a> <a id="553" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="593" class="Keyword">open</a> <a id="598" class="Keyword">import</a> <a id="605" href="NonWellFormed.Ordinal.html" class="Module">NonWellFormed.Ordinal</a>
<a id="627" class="Keyword">open</a> <a id="632" href="NonWellFormed.Ordinal.html#14678" class="Module">NonWellFormed.Ordinal.≤-Reasoning</a>
<a id="666" class="Keyword">open</a> <a id="671" class="Keyword">import</a> <a id="678" href="NonWellFormed.WellFormed.html" class="Module">NonWellFormed.WellFormed</a> <a id="703" class="Keyword">using</a> <a id="709" class="Symbol">(</a><a id="710" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a><a id="720" class="Symbol">;</a> <a id="722" href="NonWellFormed.WellFormed.html#5444" class="Function">∃[n]&lt;fn</a><a id="729" class="Symbol">;</a> <a id="731" href="NonWellFormed.WellFormed.html#5186" class="Function">f&lt;l</a><a id="734" class="Symbol">;</a> <a id="736" href="NonWellFormed.WellFormed.html#1669" class="InductiveConstructor">wrap</a><a id="740" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="850" class="Keyword">open</a> <a id="855" class="Keyword">import</a> <a id="862" href="Data.Product.html" class="Module">Data.Product</a> <a id="875" class="Keyword">using</a> <a id="881" class="Symbol">(</a><a id="882" href="Data.Product.Base.html#1118" class="Function Operator">_×_</a><a id="885" class="Symbol">;</a> <a id="887" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="890" class="Symbol">;</a> <a id="892" href="Data.Product.Base.html#617" class="Field">proj₁</a><a id="897" class="Symbol">;</a> <a id="899" href="Data.Product.Base.html#631" class="Field">proj₂</a><a id="904" class="Symbol">)</a>
<a id="906" class="Keyword">open</a> <a id="911" class="Keyword">import</a> <a id="918" href="Function.html" class="Module">Function</a> <a id="927" class="Keyword">using</a> <a id="933" class="Symbol">(</a><a id="934" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="937" class="Symbol">;</a> <a id="939" href="Function.Base.html#704" class="Function">id</a><a id="941" class="Symbol">;</a> <a id="943" href="Function.Base.html#2790" class="Function">λ-</a><a id="945" class="Symbol">)</a>
<a id="947" class="Keyword">open</a> <a id="952" class="Keyword">import</a> <a id="959" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="975" class="Keyword">using</a> <a id="981" class="Symbol">(</a><a id="982" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a><a id="992" class="Symbol">;</a> <a id="994" href="Relation.Binary.Definitions.html#4927" class="Function Operator">_Respects_</a><a id="1004" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1070" class="Keyword">private</a> <a id="1078" class="Keyword">variable</a>
  <a id="1089" class="Symbol">{</a><a id="1090" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a><a id="1091" class="Symbol">}</a> <a id="1093" class="Symbol">:</a> <a id="1095" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1099" class="Symbol">→</a> <a id="1101" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1201" href="NonWellFormed.Function.html#1201" class="Function">wf-preserving</a> <a id="1215" class="Symbol">:</a> <a id="1217" class="Symbol">(</a><a id="1218" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1222" class="Symbol">→</a> <a id="1224" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="1227" class="Symbol">)</a> <a id="1229" class="Symbol">→</a> <a id="1231" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1235" href="NonWellFormed.Function.html#1201" class="Function">wf-preserving</a> <a id="1249" href="NonWellFormed.Function.html#1249" class="Bound">F</a> <a id="1251" class="Symbol">=</a> <a id="1253" class="Symbol">∀</a> <a id="1255" class="Symbol">{</a><a id="1256" href="NonWellFormed.Function.html#1256" class="Bound">α</a><a id="1257" class="Symbol">}</a> <a id="1259" class="Symbol">→</a> <a id="1261" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="1272" href="NonWellFormed.Function.html#1256" class="Bound">α</a> <a id="1274" class="Symbol">→</a> <a id="1276" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="1287" class="Symbol">(</a><a id="1288" href="NonWellFormed.Function.html#1249" class="Bound">F</a> <a id="1290" href="NonWellFormed.Function.html#1256" class="Bound">α</a><a id="1291" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1321" href="NonWellFormed.Function.html#1321" class="Function">_</a> <a id="1323" class="Symbol">:</a> <a id="1325" href="NonWellFormed.Function.html#1201" class="Function">wf-preserving</a> <a id="1339" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>
<a id="1343" class="Symbol">_</a> <a id="1345" class="Symbol">=</a> <a id="1347" href="Function.Base.html#704" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1442" href="NonWellFormed.Function.html#1442" class="Function">≤-increasing</a> <a id="1455" class="Symbol">:</a> <a id="1457" class="Symbol">(</a><a id="1458" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1462" class="Symbol">→</a> <a id="1464" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="1467" class="Symbol">)</a> <a id="1469" class="Symbol">→</a> <a id="1471" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1475" href="NonWellFormed.Function.html#1442" class="Function">≤-increasing</a> <a id="1488" href="NonWellFormed.Function.html#1488" class="Bound">F</a> <a id="1490" class="Symbol">=</a> <a id="1492" class="Symbol">∀</a> <a id="1494" href="NonWellFormed.Function.html#1494" class="Bound">α</a> <a id="1496" class="Symbol">→</a> <a id="1498" href="NonWellFormed.Function.html#1494" class="Bound">α</a> <a id="1500" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">≤</a> <a id="1502" href="NonWellFormed.Function.html#1488" class="Bound">F</a> <a id="1504" href="NonWellFormed.Function.html#1494" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1507" href="NonWellFormed.Function.html#1507" class="Function">&lt;-increasing</a> <a id="1520" class="Symbol">:</a> <a id="1522" class="Symbol">(</a><a id="1523" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1527" class="Symbol">→</a> <a id="1529" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="1532" class="Symbol">)</a> <a id="1534" class="Symbol">→</a> <a id="1536" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1540" href="NonWellFormed.Function.html#1507" class="Function">&lt;-increasing</a> <a id="1553" href="NonWellFormed.Function.html#1553" class="Bound">F</a> <a id="1555" class="Symbol">=</a> <a id="1557" class="Symbol">∀</a> <a id="1559" href="NonWellFormed.Function.html#1559" class="Bound">α</a> <a id="1561" class="Symbol">→</a> <a id="1563" href="NonWellFormed.Function.html#1559" class="Bound">α</a> <a id="1565" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="1567" href="NonWellFormed.Function.html#1553" class="Bound">F</a> <a id="1569" href="NonWellFormed.Function.html#1559" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1601" href="NonWellFormed.Function.html#1601" class="Function">_</a> <a id="1603" class="Symbol">:</a> <a id="1605" href="NonWellFormed.Function.html#1442" class="Function">≤-increasing</a> <a id="1618" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>
<a id="1622" class="Symbol">_</a> <a id="1624" class="Symbol">=</a> <a id="1626" href="Function.Base.html#2790" class="Function">λ-</a> <a id="1629" href="NonWellFormed.Ordinal.html#7702" class="Function">≤s</a>

<a id="1633" href="NonWellFormed.Function.html#1633" class="Function">_</a> <a id="1635" class="Symbol">:</a> <a id="1637" href="NonWellFormed.Function.html#1507" class="Function">&lt;-increasing</a> <a id="1650" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>
<a id="1654" class="Symbol">_</a> <a id="1656" class="Symbol">=</a> <a id="1658" href="Function.Base.html#2790" class="Function">λ-</a> <a id="1661" href="NonWellFormed.Ordinal.html#11129" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1692" href="NonWellFormed.Function.html#1692" class="Function">&lt;⇒≤-incr</a> <a id="1701" class="Symbol">:</a> <a id="1703" href="NonWellFormed.Function.html#1507" class="Function">&lt;-increasing</a> <a id="1716" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a> <a id="1718" class="Symbol">→</a> <a id="1720" href="NonWellFormed.Function.html#1442" class="Function">≤-increasing</a> <a id="1733" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a>
<a id="1735" href="NonWellFormed.Function.html#1692" class="Function">&lt;⇒≤-incr</a> <a id="1744" href="NonWellFormed.Function.html#1744" class="Bound">&lt;-incr</a> <a id="1751" href="NonWellFormed.Function.html#1751" class="Bound">α</a> <a id="1753" class="Symbol">=</a> <a id="1755" href="NonWellFormed.Ordinal.html#11929" class="Function">&lt;⇒≤</a> <a id="1759" class="Symbol">(</a><a id="1760" href="NonWellFormed.Function.html#1744" class="Bound">&lt;-incr</a> <a id="1767" href="NonWellFormed.Function.html#1751" class="Bound">α</a><a id="1768" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1859" href="NonWellFormed.Function.html#1859" class="Function">zero-increasing</a> <a id="1875" class="Symbol">:</a> <a id="1877" class="Symbol">(</a><a id="1878" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1882" class="Symbol">→</a> <a id="1884" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="1887" class="Symbol">)</a> <a id="1889" class="Symbol">→</a> <a id="1891" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1895" href="NonWellFormed.Function.html#1859" class="Function">zero-increasing</a> <a id="1911" href="NonWellFormed.Function.html#1911" class="Bound">F</a> <a id="1913" class="Symbol">=</a> <a id="1915" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a> <a id="1920" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="1922" href="NonWellFormed.Function.html#1911" class="Bound">F</a> <a id="1924" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1930" href="NonWellFormed.Function.html#1930" class="Function">suc-increasing</a> <a id="1945" class="Symbol">:</a> <a id="1947" class="Symbol">(</a><a id="1948" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="1952" class="Symbol">→</a> <a id="1954" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="1957" class="Symbol">)</a> <a id="1959" class="Symbol">→</a> <a id="1961" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1965" href="NonWellFormed.Function.html#1930" class="Function">suc-increasing</a> <a id="1980" href="NonWellFormed.Function.html#1980" class="Bound">F</a> <a id="1982" class="Symbol">=</a> <a id="1984" class="Symbol">∀</a> <a id="1986" href="NonWellFormed.Function.html#1986" class="Bound">α</a> <a id="1988" class="Symbol">→</a> <a id="1990" class="Symbol">⦃</a> <a id="1992" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="2003" href="NonWellFormed.Function.html#1986" class="Bound">α</a> <a id="2005" class="Symbol">⦄</a> <a id="2007" class="Symbol">→</a> <a id="2009" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="2013" href="NonWellFormed.Function.html#1986" class="Bound">α</a> <a id="2015" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="2017" href="NonWellFormed.Function.html#1980" class="Bound">F</a> <a id="2019" class="Symbol">(</a><a id="2020" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="2024" href="NonWellFormed.Function.html#1986" class="Bound">α</a><a id="2025" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2082" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="2094" class="Symbol">:</a> <a id="2096" class="Symbol">(</a><a id="2097" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="2101" class="Symbol">→</a> <a id="2103" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="2106" class="Symbol">)</a> <a id="2108" class="Symbol">→</a> <a id="2110" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2114" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="2126" href="NonWellFormed.Function.html#2126" class="Bound">F</a> <a id="2128" class="Symbol">=</a> <a id="2130" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a> <a id="2141" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="2145" href="NonWellFormed.Ordinal.html#4690" class="Datatype Operator">_≤_</a> <a id="2149" href="NonWellFormed.Function.html#2126" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2152" href="NonWellFormed.Function.html#2152" class="Function">&lt;-monotonic</a> <a id="2164" class="Symbol">:</a> <a id="2166" class="Symbol">(</a><a id="2167" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="2171" class="Symbol">→</a> <a id="2173" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="2176" class="Symbol">)</a> <a id="2178" class="Symbol">→</a> <a id="2180" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2184" href="NonWellFormed.Function.html#2152" class="Function">&lt;-monotonic</a> <a id="2196" href="NonWellFormed.Function.html#2196" class="Bound">F</a> <a id="2198" class="Symbol">=</a> <a id="2200" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a> <a id="2211" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="2215" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">_&lt;_</a> <a id="2219" href="NonWellFormed.Function.html#2196" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2251" href="NonWellFormed.Function.html#2251" class="Function">_</a> <a id="2253" class="Symbol">:</a> <a id="2255" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="2267" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>
<a id="2271" class="Symbol">_</a> <a id="2273" class="Symbol">=</a> <a id="2275" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a>

<a id="2280" href="NonWellFormed.Function.html#2280" class="Function">_</a> <a id="2282" class="Symbol">:</a> <a id="2284" href="NonWellFormed.Function.html#2152" class="Function">&lt;-monotonic</a> <a id="2296" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a>
<a id="2300" class="Symbol">_</a> <a id="2302" class="Symbol">=</a> <a id="2304" href="NonWellFormed.Ordinal.html#12787" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2363" href="NonWellFormed.Function.html#2363" class="Function">suc-monotonic</a> <a id="2377" class="Symbol">:</a> <a id="2379" class="Symbol">(</a><a id="2380" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="2384" class="Symbol">→</a> <a id="2386" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="2389" class="Symbol">)</a> <a id="2391" class="Symbol">→</a> <a id="2393" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2397" href="NonWellFormed.Function.html#2363" class="Function">suc-monotonic</a> <a id="2411" href="NonWellFormed.Function.html#2411" class="Bound">F</a> <a id="2413" class="Symbol">=</a> <a id="2415" class="Symbol">∀</a> <a id="2417" href="NonWellFormed.Function.html#2417" class="Bound">α</a> <a id="2419" class="Symbol">→</a> <a id="2421" href="NonWellFormed.Function.html#2411" class="Bound">F</a> <a id="2423" href="NonWellFormed.Function.html#2417" class="Bound">α</a> <a id="2425" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="2427" href="NonWellFormed.Function.html#2411" class="Bound">F</a> <a id="2429" class="Symbol">(</a><a id="2430" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="2434" href="NonWellFormed.Function.html#2417" class="Bound">α</a><a id="2435" class="Symbol">)</a>

<a id="2438" href="NonWellFormed.Function.html#2438" class="Function">_</a> <a id="2440" class="Symbol">:</a> <a id="2442" href="NonWellFormed.Function.html#2152" class="Function">&lt;-monotonic</a> <a id="2454" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a> <a id="2456" class="Symbol">→</a> <a id="2458" href="NonWellFormed.Function.html#2363" class="Function">suc-monotonic</a> <a id="2472" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a>
<a id="2474" class="Symbol">_</a> <a id="2476" class="Symbol">=</a> <a id="2478" class="Symbol">λ</a> <a id="2480" href="NonWellFormed.Function.html#2480" class="Bound">&lt;-mono</a> <a id="2487" href="NonWellFormed.Function.html#2487" class="Bound">_</a> <a id="2489" class="Symbol">→</a> <a id="2491" href="NonWellFormed.Function.html#2480" class="Bound">&lt;-mono</a> <a id="2498" href="NonWellFormed.Ordinal.html#11129" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="continuous"></a><a id="2564" href="NonWellFormed.Function.html#2564" class="Function">continuous</a> <a id="2575" class="Symbol">:</a> <a id="2577" class="Symbol">(</a><a id="2578" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="2582" class="Symbol">→</a> <a id="2584" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="2587" class="Symbol">)</a> <a id="2589" class="Symbol">→</a> <a id="2591" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2595" href="NonWellFormed.Function.html#2564" class="Function">continuous</a> <a id="2606" href="NonWellFormed.Function.html#2606" class="Bound">F</a> <a id="2608" class="Symbol">=</a> <a id="2610" class="Symbol">∀</a> <a id="2612" href="NonWellFormed.Function.html#2612" class="Bound">f</a> <a id="2614" class="Symbol">→</a> <a id="2616" href="NonWellFormed.Function.html#2606" class="Bound">F</a> <a id="2618" class="Symbol">(</a><a id="2619" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="2623" href="NonWellFormed.Function.html#2612" class="Bound">f</a><a id="2624" class="Symbol">)</a> <a id="2626" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="2628" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="2632" class="Symbol">(</a><a id="2633" href="NonWellFormed.Function.html#2606" class="Bound">F</a> <a id="2635" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2637" href="NonWellFormed.Function.html#2612" class="Bound">f</a><a id="2638" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2728" href="NonWellFormed.Function.html#2728" class="Function">normal</a> <a id="2735" class="Symbol">:</a> <a id="2737" class="Symbol">(</a><a id="2738" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="2742" class="Symbol">→</a> <a id="2744" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="2747" class="Symbol">)</a> <a id="2749" class="Symbol">→</a> <a id="2751" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2755" href="NonWellFormed.Function.html#2728" class="Function">normal</a> <a id="2762" href="NonWellFormed.Function.html#2762" class="Bound">F</a> <a id="2764" class="Symbol">=</a> <a id="2766" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="2778" href="NonWellFormed.Function.html#2762" class="Bound">F</a> <a id="2780" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="2782" href="NonWellFormed.Function.html#2152" class="Function">&lt;-monotonic</a> <a id="2794" href="NonWellFormed.Function.html#2762" class="Bound">F</a> <a id="2796" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="2798" href="NonWellFormed.Function.html#2564" class="Function">continuous</a> <a id="2809" href="NonWellFormed.Function.html#2762" class="Bound">F</a>
</pre>
<p>我们会在下一小节解释序数嵌入的定义, 现在先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="2931" class="Keyword">module</a> <a id="2938" href="NonWellFormed.Function.html#2938" class="Module">_</a> <a id="2940" class="Symbol">(</a><a id="2941" href="NonWellFormed.Function.html#2941" class="Bound">(_</a> <a id="2944" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2946" href="NonWellFormed.Function.html#2946" class="Bound">&lt;-mono</a> <a id="2953" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2955" href="NonWellFormed.Function.html#2955" class="Bound">ct</a><a id="2957" href="NonWellFormed.Function.html#2941" class="Bound">)</a> <a id="2959" class="Symbol">:</a> <a id="2961" href="NonWellFormed.Function.html#2728" class="Function">normal</a> <a id="2968" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a><a id="2969" class="Symbol">)</a> <a id="2971" class="Keyword">where</a>
  <a id="2979" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="2993" class="Symbol">:</a> <a id="2995" href="NonWellFormed.Function.html#1442" class="Function">≤-increasing</a> <a id="3008" href="NonWellFormed.Function.html#2968" class="Bound">F</a>
  <a id="3012" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="3026" href="NonWellFormed.Ordinal.html#3105" class="InductiveConstructor">zero</a> <a id="3031" class="Symbol">=</a> <a id="3033" href="NonWellFormed.Ordinal.html#4715" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">  <a id="3186" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="3200" class="Symbol">(</a><a id="3201" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3205" href="NonWellFormed.Function.html#3205" class="Bound">α</a><a id="3206" class="Symbol">)</a> <a id="3208" class="Symbol">=</a> <a id="3210" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a>
    <a id="3220" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3224" href="NonWellFormed.Function.html#3205" class="Bound">α</a>                 <a id="3242" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3245" href="NonWellFormed.Ordinal.html#6439" class="Function">s≤s</a> <a id="3249" class="Symbol">(</a><a id="3250" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="3264" href="NonWellFormed.Function.html#3205" class="Bound">α</a><a id="3265" class="Symbol">)</a> <a id="3267" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3273" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3277" class="Symbol">(</a><a id="3278" href="NonWellFormed.Function.html#2968" class="Bound">F</a> <a id="3280" href="NonWellFormed.Function.html#3205" class="Bound">α</a><a id="3281" class="Symbol">)</a>             <a id="3295" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3298" href="NonWellFormed.Ordinal.html#12185" class="Function">&lt;⇒s≤</a> <a id="3303" class="Symbol">(</a><a id="3304" href="NonWellFormed.Function.html#2946" class="Bound">&lt;-mono</a> <a id="3311" href="NonWellFormed.Ordinal.html#11129" class="Function">&lt;s</a><a id="3313" class="Symbol">)</a> <a id="3315" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3321" href="NonWellFormed.Function.html#2968" class="Bound">F</a> <a id="3323" class="Symbol">(</a><a id="3324" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="3328" href="NonWellFormed.Function.html#3205" class="Bound">α</a><a id="3329" class="Symbol">)</a>             <a id="3343" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">  <a id="3483" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="3497" class="Symbol">(</a><a id="3498" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3502" href="NonWellFormed.Function.html#3502" class="Bound">f</a><a id="3503" class="Symbol">)</a> <a id="3505" class="Symbol">=</a> <a id="3507" href="NonWellFormed.Ordinal.html#4811" class="InductiveConstructor">l≤</a> <a id="3510" class="Symbol">λ</a> <a id="3512" href="NonWellFormed.Function.html#3512" class="Bound">n</a> <a id="3514" class="Symbol">→</a> <a id="3516" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a>
    <a id="3526" href="NonWellFormed.Function.html#3502" class="Bound">f</a> <a id="3528" href="NonWellFormed.Function.html#3512" class="Bound">n</a>                   <a id="3548" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3551" href="NonWellFormed.Ordinal.html#6118" class="Function">≤f⇒≤l</a> <a id="3557" class="Symbol">(</a><a id="3558" href="NonWellFormed.Function.html#2979" class="Function">normal⇒≤-incr</a> <a id="3572" class="Symbol">(</a><a id="3573" href="NonWellFormed.Function.html#3502" class="Bound">f</a> <a id="3575" href="NonWellFormed.Function.html#3512" class="Bound">n</a><a id="3576" class="Symbol">))</a> <a id="3579" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3585" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3589" class="Symbol">(</a><a id="3590" href="NonWellFormed.Function.html#2968" class="Bound">F</a> <a id="3592" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3594" href="NonWellFormed.Function.html#3502" class="Bound">f</a><a id="3595" class="Symbol">)</a>           <a id="3607" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="3611" href="NonWellFormed.Function.html#2955" class="Bound">ct</a> <a id="3614" href="NonWellFormed.Function.html#3502" class="Bound">f</a> <a id="3616" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
    <a id="3622" href="NonWellFormed.Function.html#2968" class="Bound">F</a> <a id="3624" class="Symbol">(</a><a id="3625" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="3629" href="NonWellFormed.Function.html#3502" class="Bound">f</a><a id="3630" class="Symbol">)</a>             <a id="3644" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3689" href="NonWellFormed.Function.html#3689" class="Function Operator">_≈ᶠ_</a> <a id="3694" class="Symbol">:</a> <a id="3696" class="Symbol">(</a><a id="3697" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="3701" class="Symbol">→</a> <a id="3703" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="3706" class="Symbol">)</a> <a id="3708" class="Symbol">→</a> <a id="3710" class="Symbol">(</a><a id="3711" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="3715" class="Symbol">→</a> <a id="3717" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="3720" class="Symbol">)</a> <a id="3722" class="Symbol">→</a> <a id="3724" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="3728" href="NonWellFormed.Function.html#3728" class="Bound">F</a> <a id="3730" href="NonWellFormed.Function.html#3689" class="Function Operator">≈ᶠ</a> <a id="3733" href="NonWellFormed.Function.html#3733" class="Bound">G</a> <a id="3735" class="Symbol">=</a> <a id="3737" class="Symbol">∀</a> <a id="3739" class="Symbol">{</a><a id="3740" href="NonWellFormed.Function.html#3740" class="Bound">α</a><a id="3741" class="Symbol">}</a> <a id="3743" class="Symbol">→</a> <a id="3745" href="NonWellFormed.Function.html#3728" class="Bound">F</a> <a id="3747" href="NonWellFormed.Function.html#3740" class="Bound">α</a> <a id="3749" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">≈</a> <a id="3751" href="NonWellFormed.Function.html#3733" class="Bound">G</a> <a id="3753" href="NonWellFormed.Function.html#3740" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3756" href="NonWellFormed.Function.html#3756" class="Function">normal-resp-≈</a> <a id="3770" class="Symbol">:</a> <a id="3772" href="NonWellFormed.Function.html#2728" class="Function">normal</a> <a id="3779" href="Relation.Binary.Definitions.html#4927" class="Function Operator">Respects</a> <a id="3788" href="NonWellFormed.Function.html#3689" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3900" href="NonWellFormed.Function.html#3756" class="Function">normal-resp-≈</a> <a id="3914" class="Symbol">{</a><a id="3915" href="NonWellFormed.Function.html#3915" class="Bound">F</a><a id="3916" class="Symbol">}</a> <a id="3918" class="Symbol">{</a><a id="3919" href="NonWellFormed.Function.html#3919" class="Bound">G</a><a id="3920" class="Symbol">}</a> <a id="3922" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="3926" class="Symbol">(</a><a id="3927" href="NonWellFormed.Function.html#3927" class="Bound">≤-mono</a> <a id="3934" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3936" href="NonWellFormed.Function.html#3936" class="Bound">&lt;-mono</a> <a id="3943" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3945" href="NonWellFormed.Function.html#3945" class="Bound">ct</a><a id="3947" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4046" class="Symbol">=</a> <a id="4048" class="Symbol">(λ</a> <a id="4051" class="Symbol">{</a><a id="4052" href="NonWellFormed.Function.html#4052" class="Bound">α</a><a id="4053" class="Symbol">}</a> <a id="4055" class="Symbol">{</a><a id="4056" href="NonWellFormed.Function.html#4056" class="Bound">β</a><a id="4057" class="Symbol">}</a> <a id="4059" href="NonWellFormed.Function.html#4059" class="Bound">α≤β</a> <a id="4063" class="Symbol">→</a> <a id="4065" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a> <a id="4071" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4073" href="NonWellFormed.Function.html#4052" class="Bound">α</a> <a id="4075" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4079" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4083" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a> <a id="4085" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4087" href="NonWellFormed.Function.html#4052" class="Bound">α</a> <a id="4089" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="4092" href="NonWellFormed.Function.html#3927" class="Bound">≤-mono</a> <a id="4099" href="NonWellFormed.Function.html#4059" class="Bound">α≤β</a> <a id="4103" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a> <a id="4105" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4107" href="NonWellFormed.Function.html#4056" class="Bound">β</a> <a id="4109" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4112" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4116" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a> <a id="4118" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4120" href="NonWellFormed.Function.html#4056" class="Bound">β</a> <a id="4122" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4123" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4222" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4224" class="Symbol">(λ</a> <a id="4227" class="Symbol">{</a><a id="4228" href="NonWellFormed.Function.html#4228" class="Bound">α</a><a id="4229" class="Symbol">}</a> <a id="4231" class="Symbol">{</a><a id="4232" href="NonWellFormed.Function.html#4232" class="Bound">β</a><a id="4233" class="Symbol">}</a> <a id="4235" href="NonWellFormed.Function.html#4235" class="Bound">α&lt;β</a> <a id="4239" class="Symbol">→</a> <a id="4241" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a> <a id="4254" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4256" href="NonWellFormed.Function.html#4228" class="Bound">α</a> <a id="4258" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4262" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4266" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a> <a id="4268" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4270" href="NonWellFormed.Function.html#4228" class="Bound">α</a> <a id="4272" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="4275" href="NonWellFormed.Function.html#3936" class="Bound">&lt;-mono</a> <a id="4282" href="NonWellFormed.Function.html#4235" class="Bound">α&lt;β</a> <a id="4286" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a> <a id="4288" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4290" href="NonWellFormed.Function.html#4232" class="Bound">β</a> <a id="4292" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4295" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4299" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a> <a id="4301" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4303" href="NonWellFormed.Function.html#4232" class="Bound">β</a> <a id="4305" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4306" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4350" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4352" class="Symbol">(λ</a> <a id="4355" href="NonWellFormed.Function.html#4355" class="Bound">f</a> <a id="4357" class="Symbol">→</a> <a id="4359" href="Relation.Binary.Reasoning.Base.Triple.html#3305" class="Function Operator">begin-equality</a>
      <a id="4380" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4382" class="Symbol">(</a><a id="4383" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4387" href="NonWellFormed.Function.html#4355" class="Bound">f</a><a id="4388" class="Symbol">)</a>   <a id="4392" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4396" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4400" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
      <a id="4408" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4410" class="Symbol">(</a><a id="4411" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4415" href="NonWellFormed.Function.html#4355" class="Bound">f</a><a id="4416" class="Symbol">)</a>   <a id="4420" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4423" href="NonWellFormed.Function.html#3945" class="Bound">ct</a> <a id="4426" href="NonWellFormed.Function.html#4355" class="Bound">f</a> <a id="4428" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a>
      <a id="4436" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4440" class="Symbol">(</a><a id="4441" href="NonWellFormed.Function.html#3915" class="Bound">F</a> <a id="4443" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4445" href="NonWellFormed.Function.html#4355" class="Bound">f</a><a id="4446" class="Symbol">)</a> <a id="4448" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4451" href="NonWellFormed.Ordinal.html#9144" class="Function">l≈l</a> <a id="4455" href="NonWellFormed.Function.html#3922" class="Bound">ext</a> <a id="4459" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a>
      <a id="4467" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="4471" class="Symbol">(</a><a id="4472" href="NonWellFormed.Function.html#3919" class="Bound">G</a> <a id="4474" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4476" href="NonWellFormed.Function.html#4355" class="Bound">f</a><a id="4477" class="Symbol">)</a> <a id="4479" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4480" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="4981" class="Keyword">open</a> <a id="4986" class="Keyword">import</a> <a id="4993" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="5014" class="Symbol">(</a><a id="5015" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a><a id="5018" class="Symbol">)</a> <a id="5020" class="Symbol">(</a><a id="5021" href="NonWellFormed.Ordinal.html#8137" class="Function Operator">_≈_</a><a id="5024" class="Symbol">)</a> <a id="5026" class="Keyword">using</a> <a id="5032" class="Symbol">(</a><a id="5033" href="Function.Definitions.html#812" class="Function">Congruent</a><a id="5042" class="Symbol">)</a>

<a id="≤-mono⇒cong"></a><a id="5045" href="NonWellFormed.Function.html#5045" class="Function">≤-mono⇒cong</a> <a id="5057" class="Symbol">:</a> <a id="5059" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="5071" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a> <a id="5073" class="Symbol">→</a> <a id="5075" href="Function.Definitions.html#812" class="Function">Congruent</a> <a id="5085" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a>
<a id="5087" href="NonWellFormed.Function.html#5045" class="Function">≤-mono⇒cong</a> <a id="5099" href="NonWellFormed.Function.html#5099" class="Bound">≤-mono</a> <a id="5106" class="Symbol">=</a> <a id="5108" class="Symbol">λ</a> <a id="5110" class="Symbol">{</a> <a id="5112" class="Symbol">(</a><a id="5113" href="NonWellFormed.Function.html#5113" class="Bound">≤</a> <a id="5115" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5117" href="NonWellFormed.Function.html#5117" class="Bound">≥</a><a id="5118" class="Symbol">)</a> <a id="5120" class="Symbol">→</a> <a id="5122" href="NonWellFormed.Function.html#5099" class="Bound">≤-mono</a> <a id="5129" href="NonWellFormed.Function.html#5113" class="Bound">≤</a> <a id="5131" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5133" href="NonWellFormed.Function.html#5099" class="Bound">≤-mono</a> <a id="5140" href="NonWellFormed.Function.html#5117" class="Bound">≥</a> <a id="5142" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5316" href="NonWellFormed.Function.html#5316" class="Function">wf-&lt;-monotonic</a> <a id="5331" class="Symbol">:</a> <a id="5333" class="Symbol">(</a><a id="5334" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="5338" class="Symbol">→</a> <a id="5340" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="5343" class="Symbol">)</a> <a id="5345" class="Symbol">→</a> <a id="5347" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5351" href="NonWellFormed.Function.html#5316" class="Function">wf-&lt;-monotonic</a> <a id="5366" href="NonWellFormed.Function.html#5366" class="Bound">F</a> <a id="5368" class="Symbol">=</a> <a id="5370" class="Symbol">∀</a> <a id="5372" class="Symbol">{</a><a id="5373" href="NonWellFormed.Function.html#5373" class="Bound">α</a> <a id="5375" href="NonWellFormed.Function.html#5375" class="Bound">β</a><a id="5376" class="Symbol">}</a> <a id="5378" class="Symbol">→</a> <a id="5380" class="Symbol">⦃</a> <a id="5382" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="5393" href="NonWellFormed.Function.html#5373" class="Bound">α</a> <a id="5395" class="Symbol">⦄</a> <a id="5397" class="Symbol">→</a> <a id="5399" class="Symbol">⦃</a> <a id="5401" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="5412" href="NonWellFormed.Function.html#5375" class="Bound">β</a> <a id="5414" class="Symbol">⦄</a> <a id="5416" class="Symbol">→</a> <a id="5418" href="NonWellFormed.Function.html#5373" class="Bound">α</a> <a id="5420" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="5422" href="NonWellFormed.Function.html#5375" class="Bound">β</a> <a id="5424" class="Symbol">→</a> <a id="5426" href="NonWellFormed.Function.html#5366" class="Bound">F</a> <a id="5428" href="NonWellFormed.Function.html#5373" class="Bound">α</a> <a id="5430" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="5432" href="NonWellFormed.Function.html#5366" class="Bound">F</a> <a id="5434" href="NonWellFormed.Function.html#5375" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5437" href="NonWellFormed.Function.html#5437" class="Function">wf-suc-monotonic</a> <a id="5454" class="Symbol">:</a> <a id="5456" class="Symbol">(</a><a id="5457" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="5461" class="Symbol">→</a> <a id="5463" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="5466" class="Symbol">)</a> <a id="5468" class="Symbol">→</a> <a id="5470" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5474" href="NonWellFormed.Function.html#5437" class="Function">wf-suc-monotonic</a> <a id="5491" href="NonWellFormed.Function.html#5491" class="Bound">F</a> <a id="5493" class="Symbol">=</a> <a id="5495" class="Symbol">∀</a> <a id="5497" href="NonWellFormed.Function.html#5497" class="Bound">α</a> <a id="5499" class="Symbol">→</a> <a id="5501" class="Symbol">⦃</a> <a id="5503" href="NonWellFormed.WellFormed.html#1877" class="Function">WellFormed</a> <a id="5514" href="NonWellFormed.Function.html#5497" class="Bound">α</a> <a id="5516" class="Symbol">⦄</a> <a id="5518" class="Symbol">→</a> <a id="5520" href="NonWellFormed.Function.html#5491" class="Bound">F</a> <a id="5522" href="NonWellFormed.Function.html#5497" class="Bound">α</a> <a id="5524" href="NonWellFormed.Ordinal.html#10317" class="Function Operator">&lt;</a> <a id="5526" href="NonWellFormed.Function.html#5491" class="Bound">F</a> <a id="5528" class="Symbol">(</a><a id="5529" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5533" href="NonWellFormed.Function.html#5497" class="Bound">α</a><a id="5534" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5537" href="NonWellFormed.Function.html#5537" class="Function">wf-normal</a> <a id="5547" class="Symbol">:</a> <a id="5549" class="Symbol">(</a><a id="5550" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a> <a id="5554" class="Symbol">→</a> <a id="5556" href="NonWellFormed.Ordinal.html#3087" class="Datatype">Ord</a><a id="5559" class="Symbol">)</a> <a id="5561" class="Symbol">→</a> <a id="5563" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5567" href="NonWellFormed.Function.html#5537" class="Function">wf-normal</a> <a id="5577" href="NonWellFormed.Function.html#5577" class="Bound">F</a> <a id="5579" class="Symbol">=</a> <a id="5581" href="NonWellFormed.Function.html#2082" class="Function">≤-monotonic</a> <a id="5593" href="NonWellFormed.Function.html#5577" class="Bound">F</a> <a id="5595" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="5597" href="NonWellFormed.Function.html#5437" class="Function">wf-suc-monotonic</a> <a id="5614" href="NonWellFormed.Function.html#5577" class="Bound">F</a> <a id="5616" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="5618" href="NonWellFormed.Function.html#2564" class="Function">continuous</a> <a id="5629" href="NonWellFormed.Function.html#5577" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="5727" class="Keyword">module</a> <a id="5734" href="NonWellFormed.Function.html#5734" class="Module">_</a> <a id="5736" class="Symbol">(</a><a id="5737" href="NonWellFormed.Function.html#5737" class="Bound">nml</a><a id="5740" class="Symbol">@(</a><a id="5742" href="NonWellFormed.Function.html#5742" class="Bound">≤-mono</a> <a id="5749" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5751" href="NonWellFormed.Function.html#5751" class="Bound">suc-mono</a> <a id="5760" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5762" href="NonWellFormed.Function.html#5762" class="Bound">ct</a><a id="5764" class="Symbol">)</a> <a id="5766" class="Symbol">:</a> <a id="5768" href="NonWellFormed.Function.html#5537" class="Function">wf-normal</a> <a id="5778" href="NonWellFormed.Function.html#1090" class="Generalizable">F</a><a id="5779" class="Symbol">)</a> <a id="5781" class="Keyword">where</a>
  <a id="5789" href="NonWellFormed.Function.html#5789" class="Function">wf-nml⇒&lt;-mono</a> <a id="5803" class="Symbol">:</a> <a id="5805" href="NonWellFormed.Function.html#5316" class="Function">wf-&lt;-monotonic</a> <a id="5820" href="NonWellFormed.Function.html#5778" class="Bound">F</a>

  <a id="5825" href="NonWellFormed.Function.html#5789" class="Function">wf-nml⇒&lt;-mono</a> <a id="5839" class="Symbol">{</a><a id="5840" href="NonWellFormed.Function.html#5840" class="Bound">α</a><a id="5841" class="Symbol">}</a> <a id="5843" class="Symbol">{</a><a id="5844" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5848" href="NonWellFormed.Function.html#5848" class="Bound">β</a><a id="5849" class="Symbol">}</a> <a id="5851" href="NonWellFormed.Function.html#5851" class="Bound">α&lt;s</a> <a id="5855" class="Symbol">=</a> <a id="5857" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a>
    <a id="5874" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="5876" href="NonWellFormed.Function.html#5840" class="Bound">α</a>           <a id="5888" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="5891" href="NonWellFormed.Function.html#5742" class="Bound">≤-mono</a> <a id="5898" class="Symbol">(</a><a id="5899" href="NonWellFormed.Ordinal.html#12451" class="Function">&lt;s⇒≤</a> <a id="5904" href="NonWellFormed.Function.html#5851" class="Bound">α&lt;s</a><a id="5907" class="Symbol">)</a> <a id="5909" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="5915" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="5917" href="NonWellFormed.Function.html#5848" class="Bound">β</a>           <a id="5929" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="5932" href="NonWellFormed.Function.html#5751" class="Bound">suc-mono</a> <a id="5941" href="NonWellFormed.Function.html#5848" class="Bound">β</a> <a id="5943" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="5949" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="5951" class="Symbol">(</a><a id="5952" href="NonWellFormed.Ordinal.html#3118" class="InductiveConstructor">suc</a> <a id="5956" href="NonWellFormed.Function.html#5848" class="Bound">β</a><a id="5957" class="Symbol">)</a>     <a id="5963" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>

  <a id="5968" href="NonWellFormed.Function.html#5789" class="Function">wf-nml⇒&lt;-mono</a> <a id="5982" class="Symbol">{</a><a id="5983" href="NonWellFormed.Function.html#5983" class="Bound">α</a><a id="5984" class="Symbol">}</a> <a id="5986" class="Symbol">{</a><a id="5987" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="5991" href="NonWellFormed.Function.html#5991" class="Bound">f</a><a id="5992" class="Symbol">}</a> <a id="5994" class="Symbol">⦃</a> <a id="5996" class="Symbol">_</a> <a id="5998" class="Symbol">⦄</a> <a id="6000" class="Symbol">⦃</a> <a id="6002" href="NonWellFormed.Function.html#6002" class="Bound">wfn</a> <a id="6006" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6008" href="NonWellFormed.WellFormed.html#1669" class="InductiveConstructor">wrap</a> <a id="6013" href="NonWellFormed.Function.html#6013" class="Bound">mono</a> <a id="6018" class="Symbol">⦄</a> <a id="6020" href="NonWellFormed.Function.html#6020" class="Bound">α&lt;l</a> <a id="6024" class="Keyword">with</a> <a id="6029" href="NonWellFormed.WellFormed.html#5444" class="Function">∃[n]&lt;fn</a> <a id="6037" class="Symbol">⦃</a> <a id="6039" href="NonWellFormed.WellFormed.html#1669" class="InductiveConstructor">wrap</a> <a id="6044" href="NonWellFormed.Function.html#6013" class="Bound">mono</a> <a id="6049" class="Symbol">⦄</a> <a id="6051" href="NonWellFormed.Function.html#6020" class="Bound">α&lt;l</a>
  <a id="6057" class="Symbol">...</a> <a id="6061" class="Symbol">|</a> <a id="6063" class="Symbol">(</a><a id="6064" href="NonWellFormed.Function.html#6064" class="Bound">n</a> <a id="6066" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6068" href="NonWellFormed.Function.html#6068" class="Bound">α&lt;fn</a><a id="6072" class="Symbol">)</a> <a id="6074" class="Symbol">=</a> <a id="6076" class="Keyword">let</a> <a id="6080" class="Keyword">instance</a> <a id="6089" href="NonWellFormed.Function.html#6089" class="Bound">wfn</a> <a id="6093" class="Symbol">=</a> <a id="6095" class="Bound">wfn</a> <a id="6099" class="Keyword">in</a> <a id="6102" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a>
    <a id="6119" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="6121" class="Bound">α</a>           <a id="6133" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="6136" href="NonWellFormed.Function.html#5789" class="Function">wf-nml⇒&lt;-mono</a> <a id="6150" href="NonWellFormed.Function.html#6068" class="Bound">α&lt;fn</a> <a id="6155" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="6161" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="6163" class="Symbol">(</a><a id="6164" class="Bound">f</a> <a id="6166" href="NonWellFormed.Function.html#6064" class="Bound">n</a><a id="6167" class="Symbol">)</a>       <a id="6175" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="6178" href="NonWellFormed.WellFormed.html#5186" class="Function">f&lt;l</a> <a id="6182" class="Symbol">⦃</a> <a id="6184" href="NonWellFormed.WellFormed.html#1669" class="InductiveConstructor">wrap</a> <a id="6189" class="Symbol">λ</a> <a id="6191" href="NonWellFormed.Function.html#6191" class="Bound">m&lt;n</a> <a id="6195" class="Symbol">→</a> <a id="6197" href="NonWellFormed.Function.html#5789" class="Function">wf-nml⇒&lt;-mono</a> <a id="6211" class="Symbol">(</a><a id="6212" class="Bound">mono</a> <a id="6217" href="NonWellFormed.Function.html#6191" class="Bound">m&lt;n</a><a id="6220" class="Symbol">)</a> <a id="6222" class="Symbol">⦄</a> <a id="6224" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="6230" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6234" class="Symbol">(</a><a id="6235" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="6237" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="6239" class="Bound">f</a><a id="6240" class="Symbol">)</a>   <a id="6244" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="6248" href="NonWellFormed.Function.html#5762" class="Bound">ct</a> <a id="6251" class="Bound">f</a> <a id="6253" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
    <a id="6259" href="NonWellFormed.Function.html#5778" class="Bound">F</a> <a id="6261" class="Symbol">(</a><a id="6262" href="NonWellFormed.Ordinal.html#3137" class="InductiveConstructor">lim</a> <a id="6266" class="Bound">f</a><a id="6267" class="Symbol">)</a>     <a id="6273" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
