<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda大序数(3) 序数函数</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda大序数(3) 序数函数</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda大序数3-序数函数" id="toc-agda大序数3-序数函数">Agda大序数(3) 序数函数</a>
  <ul>
  <li><a href="#前置" id="toc-前置">前置</a></li>
  <li><a href="#序数函数的性质" id="toc-序数函数的性质">序数函数的性质</a></li>
  <li><a href="#序数嵌入" id="toc-序数嵌入">序数嵌入</a></li>
  <li><a href="#与传统定义的等价性" id="toc-与传统定义的等价性">与传统定义的等价性</a>
  <ul>
  <li><a href="#单调" id="toc-单调">≤-单调</a></li>
  <li><a href="#单调-1" id="toc-单调-1">&lt;-单调</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda大序数3-序数函数">Agda大序数(3) 序数函数</h1>
<blockquote>
<p>交流Q群: 893531731<br />
目录: <a href="https://choukh.github.io/agda-veblen/NonWellFormed.html">NonWellFormed.html</a><br />
本文源码: <a href="https://github.com/choukh/agda-veblen/blob/main/src/NonWellFormed/Function.lagda.md">Function.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-veblen/NonWellFormed.Function.html">Function.html</a></p>
</blockquote>
<pre class="Agda"><a id="442" class="Symbol">{-#</a> <a id="446" class="Keyword">OPTIONS</a> <a id="454" class="Pragma">--without-K</a> <a id="466" class="Pragma">--safe</a> <a id="473" class="Symbol">#-}</a>
<a id="477" class="Symbol">{-#</a> <a id="481" class="Keyword">OPTIONS</a> <a id="489" class="Pragma">--no-qualified-instances</a> <a id="514" class="Symbol">#-}</a>

<a id="519" class="Keyword">module</a> <a id="526" href="NonWellFormed.Function.html" class="Module">NonWellFormed.Function</a> <a id="549" class="Keyword">where</a>
</pre>
<h2 id="前置">前置</h2>
<p>本章在内容上延续前两章.</p>
<pre class="Agda"><a id="589" class="Keyword">open</a> <a id="594" class="Keyword">import</a> <a id="601" href="NonWellFormed.Ordinal.html" class="Module">NonWellFormed.Ordinal</a>
<a id="623" class="Keyword">open</a> <a id="628" href="NonWellFormed.Ordinal.html#14674" class="Module">NonWellFormed.Ordinal.≤-Reasoning</a>
<a id="662" class="Keyword">open</a> <a id="667" class="Keyword">import</a> <a id="674" href="NonWellFormed.WellFormed.html" class="Module">NonWellFormed.WellFormed</a> <a id="699" class="Keyword">using</a> <a id="705" class="Symbol">(</a><a id="706" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a><a id="716" class="Symbol">;</a> <a id="718" href="NonWellFormed.WellFormed.html#5440" class="Function">∃[n]&lt;fn</a><a id="725" class="Symbol">;</a> <a id="727" href="NonWellFormed.WellFormed.html#5182" class="Function">f&lt;l</a><a id="730" class="Symbol">;</a> <a id="732" href="NonWellFormed.WellFormed.html#1665" class="InductiveConstructor">wrap</a><a id="736" class="Symbol">)</a>
</pre>
<p>标准库依赖除了乘积类型之外, 我们还将使用函数复合 <code>_∘_</code>, 恒等函数 <code>id</code>, 函数的单调性 <code>Monotonic₁</code>, 以及函数<strong>尊重</strong>二元关系 <code>_Respects_</code>.</p>
<pre class="Agda"><a id="846" class="Keyword">open</a> <a id="851" class="Keyword">import</a> <a id="858" href="Data.Product.html" class="Module">Data.Product</a> <a id="871" class="Keyword">using</a> <a id="877" class="Symbol">(</a><a id="878" href="Data.Product.Base.html#1118" class="Function Operator">_×_</a><a id="881" class="Symbol">;</a> <a id="883" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="886" class="Symbol">;</a> <a id="888" href="Data.Product.Base.html#617" class="Field">proj₁</a><a id="893" class="Symbol">;</a> <a id="895" href="Data.Product.Base.html#631" class="Field">proj₂</a><a id="900" class="Symbol">)</a>
<a id="902" class="Keyword">open</a> <a id="907" class="Keyword">import</a> <a id="914" href="Function.html" class="Module">Function</a> <a id="923" class="Keyword">using</a> <a id="929" class="Symbol">(</a><a id="930" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="933" class="Symbol">;</a> <a id="935" href="Function.Base.html#704" class="Function">id</a><a id="937" class="Symbol">;</a> <a id="939" href="Function.Base.html#2790" class="Function">λ-</a><a id="941" class="Symbol">)</a>
<a id="943" class="Keyword">open</a> <a id="948" class="Keyword">import</a> <a id="955" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="971" class="Keyword">using</a> <a id="977" class="Symbol">(</a><a id="978" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a><a id="988" class="Symbol">;</a> <a id="990" href="Relation.Binary.Definitions.html#4927" class="Function Operator">_Respects_</a><a id="1000" class="Symbol">)</a>
</pre>
<h2 id="序数函数的性质">序数函数的性质</h2>
<p>我们称 F : Ord → Ord 为序数函数, 它是我们的主要研究对象.</p>
<pre class="Agda"><a id="1066" class="Keyword">private</a> <a id="1074" class="Keyword">variable</a>
  <a id="1085" class="Symbol">{</a><a id="1086" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a><a id="1087" class="Symbol">}</a> <a id="1089" class="Symbol">:</a> <a id="1091" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1095" class="Symbol">→</a> <a id="1097" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a>
</pre>
<p>本章统一列出了我们将要考虑的序数函数的性质. 首先, 由上一章的良构谓词, 我们可以谈论<strong>保良构</strong>的函数. 我们会证明我们构造出的每一个序数函数都是保良构的.</p>
<pre class="Agda"><a id="wf-preserving"></a><a id="1197" href="NonWellFormed.Function.html#1197" class="Function">wf-preserving</a> <a id="1211" class="Symbol">:</a> <a id="1213" class="Symbol">(</a><a id="1214" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1218" class="Symbol">→</a> <a id="1220" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="1223" class="Symbol">)</a> <a id="1225" class="Symbol">→</a> <a id="1227" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1231" href="NonWellFormed.Function.html#1197" class="Function">wf-preserving</a> <a id="1245" href="NonWellFormed.Function.html#1245" class="Bound">F</a> <a id="1247" class="Symbol">=</a> <a id="1249" class="Symbol">∀</a> <a id="1251" class="Symbol">{</a><a id="1252" href="NonWellFormed.Function.html#1252" class="Bound">α</a><a id="1253" class="Symbol">}</a> <a id="1255" class="Symbol">→</a> <a id="1257" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="1268" href="NonWellFormed.Function.html#1252" class="Bound">α</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="1283" class="Symbol">(</a><a id="1284" href="NonWellFormed.Function.html#1245" class="Bound">F</a> <a id="1286" href="NonWellFormed.Function.html#1252" class="Bound">α</a><a id="1287" class="Symbol">)</a>
</pre>
<p>显然 <code>suc</code> 保良构.</p>
<pre class="Agda"><a id="1317" href="NonWellFormed.Function.html#1317" class="Function">_</a> <a id="1319" class="Symbol">:</a> <a id="1321" href="NonWellFormed.Function.html#1197" class="Function">wf-preserving</a> <a id="1335" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a>
<a id="1339" class="Symbol">_</a> <a id="1341" class="Symbol">=</a> <a id="1343" href="Function.Base.html#704" class="Function">id</a>
</pre>
<p>以下两条称为 F 的增长性. <code>α ≤ F α</code> 称为<strong>弱增长</strong>, <code>α &lt; F α</code> 称为<strong>强增长</strong>. 弱增长在有些书中又被称为<em>非无穷降链</em>.</p>
<pre class="Agda"><a id="≤-increasing"></a><a id="1438" href="NonWellFormed.Function.html#1438" class="Function">≤-increasing</a> <a id="1451" class="Symbol">:</a> <a id="1453" class="Symbol">(</a><a id="1454" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1458" class="Symbol">→</a> <a id="1460" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="1463" class="Symbol">)</a> <a id="1465" class="Symbol">→</a> <a id="1467" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1471" href="NonWellFormed.Function.html#1438" class="Function">≤-increasing</a> <a id="1484" href="NonWellFormed.Function.html#1484" class="Bound">F</a> <a id="1486" class="Symbol">=</a> <a id="1488" class="Symbol">∀</a> <a id="1490" href="NonWellFormed.Function.html#1490" class="Bound">α</a> <a id="1492" class="Symbol">→</a> <a id="1494" href="NonWellFormed.Function.html#1490" class="Bound">α</a> <a id="1496" href="NonWellFormed.Ordinal.html#4686" class="Datatype Operator">≤</a> <a id="1498" href="NonWellFormed.Function.html#1484" class="Bound">F</a> <a id="1500" href="NonWellFormed.Function.html#1490" class="Bound">α</a>

<a id="&lt;-increasing"></a><a id="1503" href="NonWellFormed.Function.html#1503" class="Function">&lt;-increasing</a> <a id="1516" class="Symbol">:</a> <a id="1518" class="Symbol">(</a><a id="1519" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1523" class="Symbol">→</a> <a id="1525" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="1528" class="Symbol">)</a> <a id="1530" class="Symbol">→</a> <a id="1532" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1536" href="NonWellFormed.Function.html#1503" class="Function">&lt;-increasing</a> <a id="1549" href="NonWellFormed.Function.html#1549" class="Bound">F</a> <a id="1551" class="Symbol">=</a> <a id="1553" class="Symbol">∀</a> <a id="1555" href="NonWellFormed.Function.html#1555" class="Bound">α</a> <a id="1557" class="Symbol">→</a> <a id="1559" href="NonWellFormed.Function.html#1555" class="Bound">α</a> <a id="1561" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="1563" href="NonWellFormed.Function.html#1549" class="Bound">F</a> <a id="1565" href="NonWellFormed.Function.html#1555" class="Bound">α</a>
</pre>
<p>显然 <code>suc</code> 满足增长性.</p>
<pre class="Agda"><a id="1597" href="NonWellFormed.Function.html#1597" class="Function">_</a> <a id="1599" class="Symbol">:</a> <a id="1601" href="NonWellFormed.Function.html#1438" class="Function">≤-increasing</a> <a id="1614" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a>
<a id="1618" class="Symbol">_</a> <a id="1620" class="Symbol">=</a> <a id="1622" href="Function.Base.html#2790" class="Function">λ-</a> <a id="1625" href="NonWellFormed.Ordinal.html#7698" class="Function">≤s</a>

<a id="1629" href="NonWellFormed.Function.html#1629" class="Function">_</a> <a id="1631" class="Symbol">:</a> <a id="1633" href="NonWellFormed.Function.html#1503" class="Function">&lt;-increasing</a> <a id="1646" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a>
<a id="1650" class="Symbol">_</a> <a id="1652" class="Symbol">=</a> <a id="1654" href="Function.Base.html#2790" class="Function">λ-</a> <a id="1657" href="NonWellFormed.Ordinal.html#11125" class="Function">&lt;s</a>
</pre>
<p>显然, 强增长蕴含弱增长.</p>
<pre class="Agda"><a id="&lt;⇒≤-incr"></a><a id="1688" href="NonWellFormed.Function.html#1688" class="Function">&lt;⇒≤-incr</a> <a id="1697" class="Symbol">:</a> <a id="1699" href="NonWellFormed.Function.html#1503" class="Function">&lt;-increasing</a> <a id="1712" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a> <a id="1714" class="Symbol">→</a> <a id="1716" href="NonWellFormed.Function.html#1438" class="Function">≤-increasing</a> <a id="1729" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a>
<a id="1731" href="NonWellFormed.Function.html#1688" class="Function">&lt;⇒≤-incr</a> <a id="1740" href="NonWellFormed.Function.html#1740" class="Bound">&lt;-incr</a> <a id="1747" href="NonWellFormed.Function.html#1747" class="Bound">α</a> <a id="1749" class="Symbol">=</a> <a id="1751" href="NonWellFormed.Ordinal.html#11925" class="Function">&lt;⇒≤</a> <a id="1755" class="Symbol">(</a><a id="1756" href="NonWellFormed.Function.html#1740" class="Bound">&lt;-incr</a> <a id="1763" href="NonWellFormed.Function.html#1747" class="Bound">α</a><a id="1764" class="Symbol">)</a>
</pre>
<p>下面是两种特殊的增长性, 分别叫做<strong>零处增长</strong>和<strong>良构后继处增长</strong>. 在 Veblen 不动点理论中要用到它们. 显然, 强增长蕴含这两者.</p>
<pre class="Agda"><a id="zero-increasing"></a><a id="1855" href="NonWellFormed.Function.html#1855" class="Function">zero-increasing</a> <a id="1871" class="Symbol">:</a> <a id="1873" class="Symbol">(</a><a id="1874" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="1883" class="Symbol">)</a> <a id="1885" class="Symbol">→</a> <a id="1887" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1891" href="NonWellFormed.Function.html#1855" class="Function">zero-increasing</a> <a id="1907" href="NonWellFormed.Function.html#1907" class="Bound">F</a> <a id="1909" class="Symbol">=</a> <a id="1911" href="NonWellFormed.Ordinal.html#3101" class="InductiveConstructor">zero</a> <a id="1916" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="1918" href="NonWellFormed.Function.html#1907" class="Bound">F</a> <a id="1920" href="NonWellFormed.Ordinal.html#3101" class="InductiveConstructor">zero</a>

<a id="suc-increasing"></a><a id="1926" href="NonWellFormed.Function.html#1926" class="Function">suc-increasing</a> <a id="1941" class="Symbol">:</a> <a id="1943" class="Symbol">(</a><a id="1944" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="1948" class="Symbol">→</a> <a id="1950" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="1953" class="Symbol">)</a> <a id="1955" class="Symbol">→</a> <a id="1957" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="1961" href="NonWellFormed.Function.html#1926" class="Function">suc-increasing</a> <a id="1976" href="NonWellFormed.Function.html#1976" class="Bound">F</a> <a id="1978" class="Symbol">=</a> <a id="1980" class="Symbol">∀</a> <a id="1982" href="NonWellFormed.Function.html#1982" class="Bound">α</a> <a id="1984" class="Symbol">→</a> <a id="1986" class="Symbol">⦃</a> <a id="1988" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="1999" href="NonWellFormed.Function.html#1982" class="Bound">α</a> <a id="2001" class="Symbol">⦄</a> <a id="2003" class="Symbol">→</a> <a id="2005" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="2009" href="NonWellFormed.Function.html#1982" class="Bound">α</a> <a id="2011" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="2013" href="NonWellFormed.Function.html#1976" class="Bound">F</a> <a id="2015" class="Symbol">(</a><a id="2016" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="2020" href="NonWellFormed.Function.html#1982" class="Bound">α</a><a id="2021" class="Symbol">)</a>
</pre>
<p>以下两条称为 F 的单调性, 分别叫做 <strong>≤-单调</strong> 和 <strong>&lt;-单调</strong>.</p>
<pre class="Agda"><a id="≤-monotonic"></a><a id="2078" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="2090" class="Symbol">:</a> <a id="2092" class="Symbol">(</a><a id="2093" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="2097" class="Symbol">→</a> <a id="2099" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="2102" class="Symbol">)</a> <a id="2104" class="Symbol">→</a> <a id="2106" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2110" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="2122" href="NonWellFormed.Function.html#2122" class="Bound">F</a> <a id="2124" class="Symbol">=</a> <a id="2126" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a> <a id="2137" href="NonWellFormed.Ordinal.html#4686" class="Datatype Operator">_≤_</a> <a id="2141" href="NonWellFormed.Ordinal.html#4686" class="Datatype Operator">_≤_</a> <a id="2145" href="NonWellFormed.Function.html#2122" class="Bound">F</a>

<a id="&lt;-monotonic"></a><a id="2148" href="NonWellFormed.Function.html#2148" class="Function">&lt;-monotonic</a> <a id="2160" class="Symbol">:</a> <a id="2162" class="Symbol">(</a><a id="2163" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="2167" class="Symbol">→</a> <a id="2169" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="2172" class="Symbol">)</a> <a id="2174" class="Symbol">→</a> <a id="2176" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2180" href="NonWellFormed.Function.html#2148" class="Function">&lt;-monotonic</a> <a id="2192" href="NonWellFormed.Function.html#2192" class="Bound">F</a> <a id="2194" class="Symbol">=</a> <a id="2196" href="Relation.Binary.Definitions.html#3830" class="Function">Monotonic₁</a> <a id="2207" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">_&lt;_</a> <a id="2211" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">_&lt;_</a> <a id="2215" href="NonWellFormed.Function.html#2192" class="Bound">F</a>
</pre>
<p>显然 <code>suc</code> 满足单调性.</p>
<pre class="Agda"><a id="2247" href="NonWellFormed.Function.html#2247" class="Function">_</a> <a id="2249" class="Symbol">:</a> <a id="2251" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="2263" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a>
<a id="2267" class="Symbol">_</a> <a id="2269" class="Symbol">=</a> <a id="2271" href="NonWellFormed.Ordinal.html#6435" class="Function">s≤s</a>

<a id="2276" href="NonWellFormed.Function.html#2276" class="Function">_</a> <a id="2278" class="Symbol">:</a> <a id="2280" href="NonWellFormed.Function.html#2148" class="Function">&lt;-monotonic</a> <a id="2292" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a>
<a id="2296" class="Symbol">_</a> <a id="2298" class="Symbol">=</a> <a id="2300" href="NonWellFormed.Ordinal.html#12783" class="Function">s&lt;s</a>
</pre>
<p>下面是一种特殊的单调性, 称为<strong>后继单调</strong>. 显然, &lt;-单调蕴含后继单调.</p>
<pre class="Agda"><a id="suc-monotonic"></a><a id="2359" href="NonWellFormed.Function.html#2359" class="Function">suc-monotonic</a> <a id="2373" class="Symbol">:</a> <a id="2375" class="Symbol">(</a><a id="2376" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="2380" class="Symbol">→</a> <a id="2382" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="2385" class="Symbol">)</a> <a id="2387" class="Symbol">→</a> <a id="2389" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2393" href="NonWellFormed.Function.html#2359" class="Function">suc-monotonic</a> <a id="2407" href="NonWellFormed.Function.html#2407" class="Bound">F</a> <a id="2409" class="Symbol">=</a> <a id="2411" class="Symbol">∀</a> <a id="2413" href="NonWellFormed.Function.html#2413" class="Bound">α</a> <a id="2415" class="Symbol">→</a> <a id="2417" href="NonWellFormed.Function.html#2407" class="Bound">F</a> <a id="2419" href="NonWellFormed.Function.html#2413" class="Bound">α</a> <a id="2421" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="2423" href="NonWellFormed.Function.html#2407" class="Bound">F</a> <a id="2425" class="Symbol">(</a><a id="2426" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="2430" href="NonWellFormed.Function.html#2413" class="Bound">α</a><a id="2431" class="Symbol">)</a>

<a id="2434" href="NonWellFormed.Function.html#2434" class="Function">_</a> <a id="2436" class="Symbol">:</a> <a id="2438" href="NonWellFormed.Function.html#2148" class="Function">&lt;-monotonic</a> <a id="2450" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a> <a id="2452" class="Symbol">→</a> <a id="2454" href="NonWellFormed.Function.html#2359" class="Function">suc-monotonic</a> <a id="2468" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a>
<a id="2470" class="Symbol">_</a> <a id="2472" class="Symbol">=</a> <a id="2474" class="Symbol">λ</a> <a id="2476" href="NonWellFormed.Function.html#2476" class="Bound">&lt;-mono</a> <a id="2483" href="NonWellFormed.Function.html#2483" class="Bound">_</a> <a id="2485" class="Symbol">→</a> <a id="2487" href="NonWellFormed.Function.html#2476" class="Bound">&lt;-mono</a> <a id="2494" href="NonWellFormed.Ordinal.html#11125" class="Function">&lt;s</a>
</pre>
<p>如果可以交换 <code>F</code> 和 <code>lim</code> 的顺序, 我们就说 <code>F</code> <strong>极限连续</strong>, 简称连续.</p>
<pre class="Agda"><a id="continuous"></a><a id="2560" href="NonWellFormed.Function.html#2560" class="Function">continuous</a> <a id="2571" class="Symbol">:</a> <a id="2573" class="Symbol">(</a><a id="2574" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="2578" class="Symbol">→</a> <a id="2580" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="2583" class="Symbol">)</a> <a id="2585" class="Symbol">→</a> <a id="2587" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2591" href="NonWellFormed.Function.html#2560" class="Function">continuous</a> <a id="2602" href="NonWellFormed.Function.html#2602" class="Bound">F</a> <a id="2604" class="Symbol">=</a> <a id="2606" class="Symbol">∀</a> <a id="2608" href="NonWellFormed.Function.html#2608" class="Bound">f</a> <a id="2610" class="Symbol">→</a> <a id="2612" href="NonWellFormed.Function.html#2602" class="Bound">F</a> <a id="2614" class="Symbol">(</a><a id="2615" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="2619" href="NonWellFormed.Function.html#2608" class="Bound">f</a><a id="2620" class="Symbol">)</a> <a id="2622" href="NonWellFormed.Ordinal.html#8133" class="Function Operator">≈</a> <a id="2624" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="2628" class="Symbol">(</a><a id="2629" href="NonWellFormed.Function.html#2602" class="Bound">F</a> <a id="2631" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2633" href="NonWellFormed.Function.html#2608" class="Bound">f</a><a id="2634" class="Symbol">)</a>
</pre>
<h2 id="序数嵌入">序数嵌入</h2>
<p>我们在后续章节主要研究<strong>序数嵌入</strong> (normal function), 它定义为 ≤-单调 且 &lt;-单调且连续的序数函数.</p>
<pre class="Agda"><a id="normal"></a><a id="2724" href="NonWellFormed.Function.html#2724" class="Function">normal</a> <a id="2731" class="Symbol">:</a> <a id="2733" class="Symbol">(</a><a id="2734" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="2738" class="Symbol">→</a> <a id="2740" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="2743" class="Symbol">)</a> <a id="2745" class="Symbol">→</a> <a id="2747" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="2751" href="NonWellFormed.Function.html#2724" class="Function">normal</a> <a id="2758" href="NonWellFormed.Function.html#2758" class="Bound">F</a> <a id="2760" class="Symbol">=</a> <a id="2762" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="2774" href="NonWellFormed.Function.html#2758" class="Bound">F</a> <a id="2776" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="2778" href="NonWellFormed.Function.html#2148" class="Function">&lt;-monotonic</a> <a id="2790" href="NonWellFormed.Function.html#2758" class="Bound">F</a> <a id="2792" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="2794" href="NonWellFormed.Function.html#2560" class="Function">continuous</a> <a id="2805" href="NonWellFormed.Function.html#2758" class="Bound">F</a>
</pre>
<p>我们会在下一小节解释序数嵌入的定义, 现在先来看一些结论.</p>
<p><strong>引理</strong> 序数嵌入蕴含非无穷降链.<br />
<strong>证明</strong> 即证对序数嵌入 <code>F</code> 有 <code>α ≤ F α</code>. 讨论 <code>α</code>.</p>
<ul>
<li>零的情况显然成立.</li>
</ul>
<pre class="Agda"><a id="2927" class="Keyword">module</a> <a id="2934" href="NonWellFormed.Function.html#2934" class="Module">_</a> <a id="2936" class="Symbol">(</a><a id="2937" href="NonWellFormed.Function.html#2937" class="Bound">(_</a> <a id="2940" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2942" href="NonWellFormed.Function.html#2942" class="Bound">&lt;-mono</a> <a id="2949" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2951" href="NonWellFormed.Function.html#2951" class="Bound">ct</a><a id="2953" href="NonWellFormed.Function.html#2937" class="Bound">)</a> <a id="2955" class="Symbol">:</a> <a id="2957" href="NonWellFormed.Function.html#2724" class="Function">normal</a> <a id="2964" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a><a id="2965" class="Symbol">)</a> <a id="2967" class="Keyword">where</a>
  <a id="2975" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="2989" class="Symbol">:</a> <a id="2991" href="NonWellFormed.Function.html#1438" class="Function">≤-increasing</a> <a id="3004" href="NonWellFormed.Function.html#2964" class="Bound">F</a>
  <a id="3008" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="3022" href="NonWellFormed.Ordinal.html#3101" class="InductiveConstructor">zero</a> <a id="3027" class="Symbol">=</a> <a id="3029" href="NonWellFormed.Ordinal.html#4711" class="InductiveConstructor">z≤</a>
</pre>
<ul>
<li>后继的情况, 首先由归纳假设 <code>α ≤ F α</code> 有 <code>suc α ≤ suc (F α)</code>. 又由后继单调 <code>F α &lt; F (suc α)</code> 有 <code>suc (F α) ≤ F (suc α)</code>. 结合两者由传递性即得 <code>suc α ≤ F (suc α)</code>.</li>
</ul>
<pre class="Agda">  <a id="3182" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="3196" class="Symbol">(</a><a id="3197" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="3201" href="NonWellFormed.Function.html#3201" class="Bound">α</a><a id="3202" class="Symbol">)</a> <a id="3204" class="Symbol">=</a> <a id="3206" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a>
    <a id="3216" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="3220" href="NonWellFormed.Function.html#3201" class="Bound">α</a>                 <a id="3238" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3241" href="NonWellFormed.Ordinal.html#6435" class="Function">s≤s</a> <a id="3245" class="Symbol">(</a><a id="3246" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="3260" href="NonWellFormed.Function.html#3201" class="Bound">α</a><a id="3261" class="Symbol">)</a> <a id="3263" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3269" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="3273" class="Symbol">(</a><a id="3274" href="NonWellFormed.Function.html#2964" class="Bound">F</a> <a id="3276" href="NonWellFormed.Function.html#3201" class="Bound">α</a><a id="3277" class="Symbol">)</a>             <a id="3291" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3294" href="NonWellFormed.Ordinal.html#12181" class="Function">&lt;⇒s≤</a> <a id="3299" class="Symbol">(</a><a id="3300" href="NonWellFormed.Function.html#2942" class="Bound">&lt;-mono</a> <a id="3307" href="NonWellFormed.Ordinal.html#11125" class="Function">&lt;s</a><a id="3309" class="Symbol">)</a> <a id="3311" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3317" href="NonWellFormed.Function.html#2964" class="Bound">F</a> <a id="3319" class="Symbol">(</a><a id="3320" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="3324" href="NonWellFormed.Function.html#3201" class="Bound">α</a><a id="3325" class="Symbol">)</a>             <a id="3339" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<ul>
<li>极限的情况, 即证 <code>f n ≤ F (lim f)</code>. 由连续性, <code>F (lim f) ≈ lim (F ∘ f)</code>. 只需证 <code>f n ≤ lim (F ∘ f)</code>, 只需证 <code>f n ≤ (F ∘ f) n</code>, 此即归纳假设. ∎</li>
</ul>
<pre class="Agda">  <a id="3479" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="3493" class="Symbol">(</a><a id="3494" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="3498" href="NonWellFormed.Function.html#3498" class="Bound">f</a><a id="3499" class="Symbol">)</a> <a id="3501" class="Symbol">=</a> <a id="3503" href="NonWellFormed.Ordinal.html#4807" class="InductiveConstructor">l≤</a> <a id="3506" class="Symbol">λ</a> <a id="3508" href="NonWellFormed.Function.html#3508" class="Bound">n</a> <a id="3510" class="Symbol">→</a> <a id="3512" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a>
    <a id="3522" href="NonWellFormed.Function.html#3498" class="Bound">f</a> <a id="3524" href="NonWellFormed.Function.html#3508" class="Bound">n</a>                   <a id="3544" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="3547" href="NonWellFormed.Ordinal.html#6114" class="Function">≤f⇒≤l</a> <a id="3553" class="Symbol">(</a><a id="3554" href="NonWellFormed.Function.html#2975" class="Function">normal⇒≤-incr</a> <a id="3568" class="Symbol">(</a><a id="3569" href="NonWellFormed.Function.html#3498" class="Bound">f</a> <a id="3571" href="NonWellFormed.Function.html#3508" class="Bound">n</a><a id="3572" class="Symbol">))</a> <a id="3575" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="3581" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="3585" class="Symbol">(</a><a id="3586" href="NonWellFormed.Function.html#2964" class="Bound">F</a> <a id="3588" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3590" href="NonWellFormed.Function.html#3498" class="Bound">f</a><a id="3591" class="Symbol">)</a>           <a id="3603" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="3607" href="NonWellFormed.Function.html#2951" class="Bound">ct</a> <a id="3610" href="NonWellFormed.Function.html#3498" class="Bound">f</a> <a id="3612" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
    <a id="3618" href="NonWellFormed.Function.html#2964" class="Bound">F</a> <a id="3620" class="Symbol">(</a><a id="3621" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="3625" href="NonWellFormed.Function.html#3498" class="Bound">f</a><a id="3626" class="Symbol">)</a>             <a id="3640" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<p><strong>引理</strong> 序数嵌入<strong>尊重</strong>序数函数的外延等价性.</p>
<pre class="Agda"><a id="_≈ᶠ_"></a><a id="3685" href="NonWellFormed.Function.html#3685" class="Function Operator">_≈ᶠ_</a> <a id="3690" class="Symbol">:</a> <a id="3692" class="Symbol">(</a><a id="3693" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="3697" class="Symbol">→</a> <a id="3699" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="3702" class="Symbol">)</a> <a id="3704" class="Symbol">→</a> <a id="3706" class="Symbol">(</a><a id="3707" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="3711" class="Symbol">→</a> <a id="3713" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="3716" class="Symbol">)</a> <a id="3718" class="Symbol">→</a> <a id="3720" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="3724" href="NonWellFormed.Function.html#3724" class="Bound">F</a> <a id="3726" href="NonWellFormed.Function.html#3685" class="Function Operator">≈ᶠ</a> <a id="3729" href="NonWellFormed.Function.html#3729" class="Bound">G</a> <a id="3731" class="Symbol">=</a> <a id="3733" class="Symbol">∀</a> <a id="3735" class="Symbol">{</a><a id="3736" href="NonWellFormed.Function.html#3736" class="Bound">α</a><a id="3737" class="Symbol">}</a> <a id="3739" class="Symbol">→</a> <a id="3741" href="NonWellFormed.Function.html#3724" class="Bound">F</a> <a id="3743" href="NonWellFormed.Function.html#3736" class="Bound">α</a> <a id="3745" href="NonWellFormed.Ordinal.html#8133" class="Function Operator">≈</a> <a id="3747" href="NonWellFormed.Function.html#3729" class="Bound">G</a> <a id="3749" href="NonWellFormed.Function.html#3736" class="Bound">α</a>

<a id="normal-resp-≈"></a><a id="3752" href="NonWellFormed.Function.html#3752" class="Function">normal-resp-≈</a> <a id="3766" class="Symbol">:</a> <a id="3768" href="NonWellFormed.Function.html#2724" class="Function">normal</a> <a id="3775" href="Relation.Binary.Definitions.html#4927" class="Function Operator">Respects</a> <a id="3784" href="NonWellFormed.Function.html#3685" class="Function Operator">_≈ᶠ_</a>
</pre>
<p><strong>证明</strong> 我们有 <code>F</code> 和 <code>G</code> 的外延等价 <code>ext</code>, <code>F</code> 的 ≤-单调 <code>≤-mono</code>, &lt;-单调 <code>&lt;-mono</code> 和连续 <code>ct</code>, 要证 <code>G</code> 是序数嵌入.</p>
<pre class="Agda"><a id="3896" href="NonWellFormed.Function.html#3752" class="Function">normal-resp-≈</a> <a id="3910" class="Symbol">{</a><a id="3911" href="NonWellFormed.Function.html#3911" class="Bound">F</a><a id="3912" class="Symbol">}</a> <a id="3914" class="Symbol">{</a><a id="3915" href="NonWellFormed.Function.html#3915" class="Bound">G</a><a id="3916" class="Symbol">}</a> <a id="3918" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="3922" class="Symbol">(</a><a id="3923" href="NonWellFormed.Function.html#3923" class="Bound">≤-mono</a> <a id="3930" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3932" href="NonWellFormed.Function.html#3932" class="Bound">&lt;-mono</a> <a id="3939" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3941" href="NonWellFormed.Function.html#3941" class="Bound">ct</a><a id="3943" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> ≤-单调. 对 <code>α ≤ β</code>, 由 <code>≤-mono</code> 有 <code>F α ≤ F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α ≤ G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4042" class="Symbol">=</a> <a id="4044" class="Symbol">(λ</a> <a id="4047" class="Symbol">{</a><a id="4048" href="NonWellFormed.Function.html#4048" class="Bound">α</a><a id="4049" class="Symbol">}</a> <a id="4051" class="Symbol">{</a><a id="4052" href="NonWellFormed.Function.html#4052" class="Bound">β</a><a id="4053" class="Symbol">}</a> <a id="4055" href="NonWellFormed.Function.html#4055" class="Bound">α≤β</a> <a id="4059" class="Symbol">→</a> <a id="4061" href="Relation.Binary.Reasoning.Base.Triple.html#3029" class="Function Operator">begin</a> <a id="4067" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4069" href="NonWellFormed.Function.html#4048" class="Bound">α</a> <a id="4071" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4075" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4079" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a> <a id="4081" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4083" href="NonWellFormed.Function.html#4048" class="Bound">α</a> <a id="4085" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="4088" href="NonWellFormed.Function.html#3923" class="Bound">≤-mono</a> <a id="4095" href="NonWellFormed.Function.html#4055" class="Bound">α≤β</a> <a id="4099" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a> <a id="4101" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4103" href="NonWellFormed.Function.html#4052" class="Bound">β</a> <a id="4105" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4108" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4112" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a> <a id="4114" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4116" href="NonWellFormed.Function.html#4052" class="Bound">β</a> <a id="4118" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4119" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> &lt;-单调. 对 <code>α &lt; β</code>, 由 <code>&lt;-mono</code> 有 <code>F α &lt; F β</code>, 两边都用 <code>ext</code> 改写即得 <code>G α &lt; G β</code>.</li>
</ul>
<pre class="Agda">  <a id="4218" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4220" class="Symbol">(λ</a> <a id="4223" class="Symbol">{</a><a id="4224" href="NonWellFormed.Function.html#4224" class="Bound">α</a><a id="4225" class="Symbol">}</a> <a id="4227" class="Symbol">{</a><a id="4228" href="NonWellFormed.Function.html#4228" class="Bound">β</a><a id="4229" class="Symbol">}</a> <a id="4231" href="NonWellFormed.Function.html#4231" class="Bound">α&lt;β</a> <a id="4235" class="Symbol">→</a> <a id="4237" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a> <a id="4250" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4252" href="NonWellFormed.Function.html#4224" class="Bound">α</a> <a id="4254" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4258" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4262" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a> <a id="4264" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4266" href="NonWellFormed.Function.html#4224" class="Bound">α</a> <a id="4268" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="4271" href="NonWellFormed.Function.html#3932" class="Bound">&lt;-mono</a> <a id="4278" href="NonWellFormed.Function.html#4231" class="Bound">α&lt;β</a> <a id="4282" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a> <a id="4284" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4286" href="NonWellFormed.Function.html#4228" class="Bound">β</a> <a id="4288" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4291" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4295" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a> <a id="4297" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4299" href="NonWellFormed.Function.html#4228" class="Bound">β</a> <a id="4301" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4302" class="Symbol">)</a>
</pre>
<ul>
<li>需证 <code>G</code> 连续. 以下改写链是自明的. ∎</li>
</ul>
<pre class="Agda">  <a id="4346" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4348" class="Symbol">(λ</a> <a id="4351" href="NonWellFormed.Function.html#4351" class="Bound">f</a> <a id="4353" class="Symbol">→</a> <a id="4355" href="Relation.Binary.Reasoning.Base.Triple.html#3305" class="Function Operator">begin-equality</a>
      <a id="4376" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4378" class="Symbol">(</a><a id="4379" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="4383" href="NonWellFormed.Function.html#4351" class="Bound">f</a><a id="4384" class="Symbol">)</a>   <a id="4388" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="4392" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4396" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
      <a id="4404" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4406" class="Symbol">(</a><a id="4407" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="4411" href="NonWellFormed.Function.html#4351" class="Bound">f</a><a id="4412" class="Symbol">)</a>   <a id="4416" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4419" href="NonWellFormed.Function.html#3941" class="Bound">ct</a> <a id="4422" href="NonWellFormed.Function.html#4351" class="Bound">f</a> <a id="4424" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a>
      <a id="4432" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="4436" class="Symbol">(</a><a id="4437" href="NonWellFormed.Function.html#3911" class="Bound">F</a> <a id="4439" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4441" href="NonWellFormed.Function.html#4351" class="Bound">f</a><a id="4442" class="Symbol">)</a> <a id="4444" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">≈⟨</a> <a id="4447" href="NonWellFormed.Ordinal.html#9140" class="Function">l≈l</a> <a id="4451" href="NonWellFormed.Function.html#3918" class="Bound">ext</a> <a id="4455" href="Relation.Binary.Reasoning.Base.Triple.html#4054" class="Function">⟩</a>
      <a id="4463" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="4467" class="Symbol">(</a><a id="4468" href="NonWellFormed.Function.html#3915" class="Bound">G</a> <a id="4470" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4472" href="NonWellFormed.Function.html#4351" class="Bound">f</a><a id="4473" class="Symbol">)</a> <a id="4475" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a><a id="4476" class="Symbol">)</a>
</pre>
<h2 id="与传统定义的等价性">与传统定义的等价性</h2>
<p>在传统文献中序数嵌入定义为后继单调且极限连续的序数函数. 两种定义对比如下.</p>
<table>
<thead>
<tr class="header">
<th>本构筑</th>
<th>传统</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>≤-单调</td>
<td>-</td>
</tr>
<tr class="even">
<td>&lt;-单调</td>
<td>后继单调</td>
</tr>
<tr class="odd">
<td>极限连续</td>
<td>极限连续</td>
</tr>
</tbody>
</table>
<p>第三点是一样的, 我们分别解释前两点.</p>
<h3 id="单调">≤-单调</h3>
<p>传统数学中 &lt;-单调 蕴含 ≤-单调, 该论证依赖以下两点.</p>
<ol type="1">
<li>“≤” 到 “&lt; 或 =” 的分裂, 而在本构筑中实现这一点需要排中律, 如<a href="Ordinal.Classic.html">独立的一章</a>所述.</li>
<li>“=” 的合同性 (congruence), 即对任意 F 有 x = y 蕴含 F x = F y, 而本构筑的 <code>_≈_</code> 并不具有.</li>
</ol>
<p>因此在本构筑中 &lt;-单调 与 ≤-单调 是相互独立的, 这就解释了 ≤-单调的不可替代性. 至于其必要性, 上面第2点也已经可以看出来了. 因为我们只关心对 <code>_≈_</code> 合同的 (congruent) 函数, 而 ≤-单调蕴含这一点.</p>
<pre class="Agda"><a id="4977" class="Keyword">open</a> <a id="4982" class="Keyword">import</a> <a id="4989" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="5010" class="Symbol">(</a><a id="5011" href="NonWellFormed.Ordinal.html#8133" class="Function Operator">_≈_</a><a id="5014" class="Symbol">)</a> <a id="5016" class="Symbol">(</a><a id="5017" href="NonWellFormed.Ordinal.html#8133" class="Function Operator">_≈_</a><a id="5020" class="Symbol">)</a> <a id="5022" class="Keyword">using</a> <a id="5028" class="Symbol">(</a><a id="5029" href="Function.Definitions.html#812" class="Function">Congruent</a><a id="5038" class="Symbol">)</a>

<a id="≤-mono⇒cong"></a><a id="5041" href="NonWellFormed.Function.html#5041" class="Function">≤-mono⇒cong</a> <a id="5053" class="Symbol">:</a> <a id="5055" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="5067" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a> <a id="5069" class="Symbol">→</a> <a id="5071" href="Function.Definitions.html#812" class="Function">Congruent</a> <a id="5081" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a>
<a id="5083" href="NonWellFormed.Function.html#5041" class="Function">≤-mono⇒cong</a> <a id="5095" href="NonWellFormed.Function.html#5095" class="Bound">≤-mono</a> <a id="5102" class="Symbol">=</a> <a id="5104" class="Symbol">λ</a> <a id="5106" class="Symbol">{</a> <a id="5108" class="Symbol">(</a><a id="5109" href="NonWellFormed.Function.html#5109" class="Bound">≤</a> <a id="5111" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5113" href="NonWellFormed.Function.html#5113" class="Bound">≥</a><a id="5114" class="Symbol">)</a> <a id="5116" class="Symbol">→</a> <a id="5118" href="NonWellFormed.Function.html#5095" class="Bound">≤-mono</a> <a id="5125" href="NonWellFormed.Function.html#5109" class="Bound">≤</a> <a id="5127" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5129" href="NonWellFormed.Function.html#5095" class="Bound">≤-mono</a> <a id="5136" href="NonWellFormed.Function.html#5113" class="Bound">≥</a> <a id="5138" class="Symbol">}</a>
</pre>
<p>从根本上可以说, ≤-单调的必要性来源于本构筑所依赖的类型论基础的构造主义性和内涵性.</p>
<h3 id="单调-1">&lt;-单调</h3>
<p>我们用 &lt;-单调取代后继单调是为了省去良构条件. 若不然, 需要将相关性质都限制成良构版如下<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">_ 当然我们也可以用一个 record 类型封装良构条件, 但还是没有上面的处理简单.<br />
<br />
</span></span>.</p>
<pre class="Agda"><a id="wf-&lt;-monotonic"></a><a id="5312" href="NonWellFormed.Function.html#5312" class="Function">wf-&lt;-monotonic</a> <a id="5327" class="Symbol">:</a> <a id="5329" class="Symbol">(</a><a id="5330" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="5334" class="Symbol">→</a> <a id="5336" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="5339" class="Symbol">)</a> <a id="5341" class="Symbol">→</a> <a id="5343" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5347" href="NonWellFormed.Function.html#5312" class="Function">wf-&lt;-monotonic</a> <a id="5362" href="NonWellFormed.Function.html#5362" class="Bound">F</a> <a id="5364" class="Symbol">=</a> <a id="5366" class="Symbol">∀</a> <a id="5368" class="Symbol">{</a><a id="5369" href="NonWellFormed.Function.html#5369" class="Bound">α</a> <a id="5371" href="NonWellFormed.Function.html#5371" class="Bound">β</a><a id="5372" class="Symbol">}</a> <a id="5374" class="Symbol">→</a> <a id="5376" class="Symbol">⦃</a> <a id="5378" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="5389" href="NonWellFormed.Function.html#5369" class="Bound">α</a> <a id="5391" class="Symbol">⦄</a> <a id="5393" class="Symbol">→</a> <a id="5395" class="Symbol">⦃</a> <a id="5397" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="5408" href="NonWellFormed.Function.html#5371" class="Bound">β</a> <a id="5410" class="Symbol">⦄</a> <a id="5412" class="Symbol">→</a> <a id="5414" href="NonWellFormed.Function.html#5369" class="Bound">α</a> <a id="5416" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="5418" href="NonWellFormed.Function.html#5371" class="Bound">β</a> <a id="5420" class="Symbol">→</a> <a id="5422" href="NonWellFormed.Function.html#5362" class="Bound">F</a> <a id="5424" href="NonWellFormed.Function.html#5369" class="Bound">α</a> <a id="5426" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="5428" href="NonWellFormed.Function.html#5362" class="Bound">F</a> <a id="5430" href="NonWellFormed.Function.html#5371" class="Bound">β</a>

<a id="wf-suc-monotonic"></a><a id="5433" href="NonWellFormed.Function.html#5433" class="Function">wf-suc-monotonic</a> <a id="5450" class="Symbol">:</a> <a id="5452" class="Symbol">(</a><a id="5453" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="5457" class="Symbol">→</a> <a id="5459" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="5462" class="Symbol">)</a> <a id="5464" class="Symbol">→</a> <a id="5466" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5470" href="NonWellFormed.Function.html#5433" class="Function">wf-suc-monotonic</a> <a id="5487" href="NonWellFormed.Function.html#5487" class="Bound">F</a> <a id="5489" class="Symbol">=</a> <a id="5491" class="Symbol">∀</a> <a id="5493" href="NonWellFormed.Function.html#5493" class="Bound">α</a> <a id="5495" class="Symbol">→</a> <a id="5497" class="Symbol">⦃</a> <a id="5499" href="NonWellFormed.WellFormed.html#1873" class="Function">WellFormed</a> <a id="5510" href="NonWellFormed.Function.html#5493" class="Bound">α</a> <a id="5512" class="Symbol">⦄</a> <a id="5514" class="Symbol">→</a> <a id="5516" href="NonWellFormed.Function.html#5487" class="Bound">F</a> <a id="5518" href="NonWellFormed.Function.html#5493" class="Bound">α</a> <a id="5520" href="NonWellFormed.Ordinal.html#10313" class="Function Operator">&lt;</a> <a id="5522" href="NonWellFormed.Function.html#5487" class="Bound">F</a> <a id="5524" class="Symbol">(</a><a id="5525" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="5529" href="NonWellFormed.Function.html#5493" class="Bound">α</a><a id="5530" class="Symbol">)</a>

<a id="wf-normal"></a><a id="5533" href="NonWellFormed.Function.html#5533" class="Function">wf-normal</a> <a id="5543" class="Symbol">:</a> <a id="5545" class="Symbol">(</a><a id="5546" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a> <a id="5550" class="Symbol">→</a> <a id="5552" href="NonWellFormed.Ordinal.html#3083" class="Datatype">Ord</a><a id="5555" class="Symbol">)</a> <a id="5557" class="Symbol">→</a> <a id="5559" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="5563" href="NonWellFormed.Function.html#5533" class="Function">wf-normal</a> <a id="5573" href="NonWellFormed.Function.html#5573" class="Bound">F</a> <a id="5575" class="Symbol">=</a> <a id="5577" href="NonWellFormed.Function.html#2078" class="Function">≤-monotonic</a> <a id="5589" href="NonWellFormed.Function.html#5573" class="Bound">F</a> <a id="5591" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="5593" href="NonWellFormed.Function.html#5433" class="Function">wf-suc-monotonic</a> <a id="5610" href="NonWellFormed.Function.html#5573" class="Bound">F</a> <a id="5612" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="5614" href="NonWellFormed.Function.html#2560" class="Function">continuous</a> <a id="5625" href="NonWellFormed.Function.html#5573" class="Bound">F</a>
</pre>
<p><strong>事实</strong> 用 <code>wf-suc-monotonic</code> 取代 <code>&lt;-monotonic</code> 定义的 <code>wf-normal</code> 蕴含 <code>wf-&lt;-monotonic</code>.</p>
<pre class="Agda"><a id="5723" class="Keyword">module</a> <a id="5730" href="NonWellFormed.Function.html#5730" class="Module">_</a> <a id="5732" class="Symbol">(</a><a id="5733" href="NonWellFormed.Function.html#5733" class="Bound">nml</a><a id="5736" class="Symbol">@(</a><a id="5738" href="NonWellFormed.Function.html#5738" class="Bound">≤-mono</a> <a id="5745" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5747" href="NonWellFormed.Function.html#5747" class="Bound">suc-mono</a> <a id="5756" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5758" href="NonWellFormed.Function.html#5758" class="Bound">ct</a><a id="5760" class="Symbol">)</a> <a id="5762" class="Symbol">:</a> <a id="5764" href="NonWellFormed.Function.html#5533" class="Function">wf-normal</a> <a id="5774" href="NonWellFormed.Function.html#1086" class="Generalizable">F</a><a id="5775" class="Symbol">)</a> <a id="5777" class="Keyword">where</a>
  <a id="5785" href="NonWellFormed.Function.html#5785" class="Function">wf-nml⇒&lt;-mono</a> <a id="5799" class="Symbol">:</a> <a id="5801" href="NonWellFormed.Function.html#5312" class="Function">wf-&lt;-monotonic</a> <a id="5816" href="NonWellFormed.Function.html#5774" class="Bound">F</a>

  <a id="5821" href="NonWellFormed.Function.html#5785" class="Function">wf-nml⇒&lt;-mono</a> <a id="5835" class="Symbol">{</a><a id="5836" href="NonWellFormed.Function.html#5836" class="Bound">α</a><a id="5837" class="Symbol">}</a> <a id="5839" class="Symbol">{</a><a id="5840" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="5844" href="NonWellFormed.Function.html#5844" class="Bound">β</a><a id="5845" class="Symbol">}</a> <a id="5847" href="NonWellFormed.Function.html#5847" class="Bound">α&lt;s</a> <a id="5851" class="Symbol">=</a> <a id="5853" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a>
    <a id="5870" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="5872" href="NonWellFormed.Function.html#5836" class="Bound">α</a>           <a id="5884" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">≤⟨</a> <a id="5887" href="NonWellFormed.Function.html#5738" class="Bound">≤-mono</a> <a id="5894" class="Symbol">(</a><a id="5895" href="NonWellFormed.Ordinal.html#12447" class="Function">&lt;s⇒≤</a> <a id="5900" href="NonWellFormed.Function.html#5847" class="Bound">α&lt;s</a><a id="5903" class="Symbol">)</a> <a id="5905" href="Relation.Binary.Reasoning.Base.Triple.html#3764" class="Function">⟩</a>
    <a id="5911" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="5913" href="NonWellFormed.Function.html#5844" class="Bound">β</a>           <a id="5925" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="5928" href="NonWellFormed.Function.html#5747" class="Bound">suc-mono</a> <a id="5937" href="NonWellFormed.Function.html#5844" class="Bound">β</a> <a id="5939" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="5945" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="5947" class="Symbol">(</a><a id="5948" href="NonWellFormed.Ordinal.html#3114" class="InductiveConstructor">suc</a> <a id="5952" href="NonWellFormed.Function.html#5844" class="Bound">β</a><a id="5953" class="Symbol">)</a>     <a id="5959" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>

  <a id="5964" href="NonWellFormed.Function.html#5785" class="Function">wf-nml⇒&lt;-mono</a> <a id="5978" class="Symbol">{</a><a id="5979" href="NonWellFormed.Function.html#5979" class="Bound">α</a><a id="5980" class="Symbol">}</a> <a id="5982" class="Symbol">{</a><a id="5983" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="5987" href="NonWellFormed.Function.html#5987" class="Bound">f</a><a id="5988" class="Symbol">}</a> <a id="5990" class="Symbol">⦃</a> <a id="5992" class="Symbol">_</a> <a id="5994" class="Symbol">⦄</a> <a id="5996" class="Symbol">⦃</a> <a id="5998" href="NonWellFormed.Function.html#5998" class="Bound">wfn</a> <a id="6002" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6004" href="NonWellFormed.WellFormed.html#1665" class="InductiveConstructor">wrap</a> <a id="6009" href="NonWellFormed.Function.html#6009" class="Bound">mono</a> <a id="6014" class="Symbol">⦄</a> <a id="6016" href="NonWellFormed.Function.html#6016" class="Bound">α&lt;l</a> <a id="6020" class="Keyword">with</a> <a id="6025" href="NonWellFormed.WellFormed.html#5440" class="Function">∃[n]&lt;fn</a> <a id="6033" class="Symbol">⦃</a> <a id="6035" href="NonWellFormed.WellFormed.html#1665" class="InductiveConstructor">wrap</a> <a id="6040" href="NonWellFormed.Function.html#6009" class="Bound">mono</a> <a id="6045" class="Symbol">⦄</a> <a id="6047" href="NonWellFormed.Function.html#6016" class="Bound">α&lt;l</a>
  <a id="6053" class="Symbol">...</a> <a id="6057" class="Symbol">|</a> <a id="6059" class="Symbol">(</a><a id="6060" href="NonWellFormed.Function.html#6060" class="Bound">n</a> <a id="6062" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6064" href="NonWellFormed.Function.html#6064" class="Bound">α&lt;fn</a><a id="6068" class="Symbol">)</a> <a id="6070" class="Symbol">=</a> <a id="6072" class="Keyword">let</a> <a id="6076" class="Keyword">instance</a> <a id="6085" href="NonWellFormed.Function.html#6085" class="Bound">wfn</a> <a id="6089" class="Symbol">=</a> <a id="6091" class="Bound">wfn</a> <a id="6095" class="Keyword">in</a> <a id="6098" href="Relation.Binary.Reasoning.Base.Triple.html#3173" class="Function Operator">begin-strict</a>
    <a id="6115" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="6117" class="Bound">α</a>           <a id="6129" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="6132" href="NonWellFormed.Function.html#5785" class="Function">wf-nml⇒&lt;-mono</a> <a id="6146" href="NonWellFormed.Function.html#6064" class="Bound">α&lt;fn</a> <a id="6151" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="6157" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="6159" class="Symbol">(</a><a id="6160" class="Bound">f</a> <a id="6162" href="NonWellFormed.Function.html#6060" class="Bound">n</a><a id="6163" class="Symbol">)</a>       <a id="6171" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">&lt;⟨</a> <a id="6174" href="NonWellFormed.WellFormed.html#5182" class="Function">f&lt;l</a> <a id="6178" class="Symbol">⦃</a> <a id="6180" href="NonWellFormed.WellFormed.html#1665" class="InductiveConstructor">wrap</a> <a id="6185" class="Symbol">λ</a> <a id="6187" href="NonWellFormed.Function.html#6187" class="Bound">m&lt;n</a> <a id="6191" class="Symbol">→</a> <a id="6193" href="NonWellFormed.Function.html#5785" class="Function">wf-nml⇒&lt;-mono</a> <a id="6207" class="Symbol">(</a><a id="6208" class="Bound">mono</a> <a id="6213" href="NonWellFormed.Function.html#6187" class="Bound">m&lt;n</a><a id="6216" class="Symbol">)</a> <a id="6218" class="Symbol">⦄</a> <a id="6220" href="Relation.Binary.Reasoning.Base.Triple.html#3479" class="Function">⟩</a>
    <a id="6226" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="6230" class="Symbol">(</a><a id="6231" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="6233" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="6235" class="Bound">f</a><a id="6236" class="Symbol">)</a>   <a id="6240" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">≈˘⟨</a> <a id="6244" href="NonWellFormed.Function.html#5758" class="Bound">ct</a> <a id="6247" class="Bound">f</a> <a id="6249" href="Relation.Binary.Reasoning.Base.Triple.html#4377" class="Function">⟩</a>
    <a id="6255" href="NonWellFormed.Function.html#5774" class="Bound">F</a> <a id="6257" class="Symbol">(</a><a id="6258" href="NonWellFormed.Ordinal.html#3133" class="InductiveConstructor">lim</a> <a id="6262" class="Bound">f</a><a id="6263" class="Symbol">)</a>     <a id="6269" href="Relation.Binary.Reasoning.Base.Triple.html#5138" class="Function Operator">∎</a>
</pre>
<p>也就是说, 限定在良构序数的情况下<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">_ 且忽略上一小节所述由构造主义和内涵类型论所造成的微妙区别<br />
<br />
</span></span>, 传统定义蕴含我们的定义. 另一方面, 显然地, 由 <code>&lt;-monotonic</code> 蕴含 <code>suc-monotonic</code>, 我们的定义也蕴含传统定义. 这就说明了两者的等价性.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
