<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>公理化结构集合论 (3 元素)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">公理化结构集合论 (3 元素)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#公理化结构集合论-3-元素" id="toc-公理化结构集合论-3-元素">公理化结构集合论 (3 元素)</a></li>
  </ul>
</nav>

<main>
<h1 id="公理化结构集合论-3-元素">公理化结构集合论 (3 元素)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/ETCS/blob/main/src/Basic/Membership.lagda.md">Membership.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/ETCS/Basic.Membership.html">Membership.html</a></p>
</blockquote>
<p>我们知道, 质料集合论 (material set theory), 如 ZFC 等, 以命题性的全局成员关系 (membership) <span class="math inline">\in</span> 为原始概念. 而这里讲的结构集合论 ETCS, 其成员关系从作为原始概念的函数箭头 <code>→̇</code> 导出, 并且不是一个可以讨论真假的命题.</p>
<p>回顾第一篇<a href="https://zhuanlan.zhihu.com/p/5630540119">公理化结构集合论 (1 公理)</a>: 公理2承诺终集 (terminal set) 存在, 我们把它记作 <code>１</code>, 而 <code>１</code> 到 <code>X</code> 的函数则称为 <code>X</code> 的元素. 本篇将说明这一公理和定义的合理性.</p>
<pre class="Agda"><a id="645" class="Keyword">open</a> <a id="650" class="Keyword">import</a> <a id="657" href="Axiom.html" class="Module">Axiom</a>
<a id="663" class="Keyword">module</a> <a id="670" href="Basic.Membership.html" class="Module">Basic.Membership</a> <a id="687" class="Symbol">(</a><a id="688" href="Basic.Membership.html#688" class="Bound">ℳ</a> <a id="690" class="Symbol">:</a> <a id="692" href="Axiom.html#12349" class="Record">ETCS</a><a id="696" class="Symbol">)</a> <a id="698" class="Keyword">where</a>
<a id="704" class="Keyword">open</a> <a id="709" href="Axiom.html#12349" class="Module">ETCS</a> <a id="714" href="Basic.Membership.html#688" class="Bound">ℳ</a>

<a id="717" class="Keyword">open</a> <a id="722" class="Keyword">import</a> <a id="729" href="Basic.Isomorphism.html" class="Module">Basic.Isomorphism</a> <a id="747" href="Basic.Membership.html#688" class="Bound">ℳ</a>
<a id="749" class="Keyword">open</a> <a id="754" class="Keyword">import</a> <a id="761" href="Function.html" class="Module">Function</a> <a id="770" class="Keyword">using</a> <a id="776" class="Symbol">(</a><a id="777" href="Function.Base.html#1974" class="Function Operator">_$_</a><a id="780" class="Symbol">)</a>
<a id="782" class="Keyword">open</a> <a id="787" class="Keyword">import</a> <a id="794" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="811" class="Keyword">using</a> <a id="817" class="Symbol">(</a><a id="818" href="Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="820" class="Symbol">)</a>
</pre>
<p><strong>引理 2.3.7</strong> 元素的定义与公理1「相容」.</p>
<ul>
<li>恒等函数的良定性: <code>id</code> 作用于任意元素都等于该元素自身.</li>
<li>复合运算的良定性: <span class="math inline">(g ∘ f)( x ) = g ( f ( x ) )</span>.</li>
</ul>
<p><strong>(证明)</strong> 由公理1和元素的定义即得. □</p>
<pre class="Agda"><a id="969" class="Comment">-- Lemma 2.3.7</a>
<a id="id-wellDefined"></a><a id="984" href="Basic.Membership.html#984" class="Function">id-wellDefined</a> <a id="999" class="Symbol">:</a> <a id="1001" href="Axiom.html#4174" class="Function">∀[</a> <a id="1004" href="Basic.Membership.html#1004" class="Bound">x</a> <a id="1006" href="Axiom.html#4174" class="Function">∈</a> <a id="1008" href="Axiom.html#3021" class="Generalizable">X</a> <a id="1010" href="Axiom.html#4174" class="Function">]</a> <a id="1012" href="Axiom.html#1800" class="Function">id</a> <a id="1015" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="1017" href="Basic.Membership.html#1004" class="Bound">x</a> <a id="1019" href="Axiom.html#4842" class="Function Operator">⦆</a> <a id="1021" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1023" href="Basic.Membership.html#1004" class="Bound">x</a>
<a id="1025" href="Basic.Membership.html#984" class="Function">id-wellDefined</a> <a id="1040" href="Basic.Membership.html#1040" class="Bound">x</a> <a id="1042" class="Symbol">=</a> <a id="1044" href="Axiom.html#3299" class="Function">AxIdˡ</a>

<a id="∘-wellDefined"></a><a id="1051" href="Basic.Membership.html#1051" class="Function">∘-wellDefined</a> <a id="1065" class="Symbol">:</a> <a id="1067" href="Axiom.html#4174" class="Function">∀[</a> <a id="1070" href="Basic.Membership.html#1070" class="Bound">x</a> <a id="1072" href="Axiom.html#4174" class="Function">∈</a> <a id="1074" href="Axiom.html#3021" class="Generalizable">X</a> <a id="1076" href="Axiom.html#4174" class="Function">]</a> <a id="1078" class="Symbol">(</a><a id="1079" href="Axiom.html#3046" class="Generalizable">g</a> <a id="1081" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1083" href="Axiom.html#3044" class="Generalizable">f</a><a id="1084" class="Symbol">)</a> <a id="1086" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="1088" href="Basic.Membership.html#1070" class="Bound">x</a> <a id="1090" href="Axiom.html#4842" class="Function Operator">⦆</a> <a id="1092" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1094" href="Axiom.html#3046" class="Generalizable">g</a> <a id="1096" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="1098" href="Axiom.html#3044" class="Generalizable">f</a> <a id="1100" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="1102" href="Basic.Membership.html#1070" class="Bound">x</a> <a id="1104" href="Axiom.html#4842" class="Function Operator">⦆</a> <a id="1106" href="Axiom.html#4842" class="Function Operator">⦆</a>
<a id="1108" href="Basic.Membership.html#1051" class="Function">∘-wellDefined</a> <a id="1122" class="Symbol">_</a> <a id="1124" class="Symbol">=</a> <a id="1126" href="Axiom.html#3259" class="Function">AxAss</a>
</pre>
<p><strong>引理 2.3.3</strong> 终集在同构意义下不变: 与终集同构的集合也是终集.<br />
<strong>(证明)</strong> 假设 <code>T</code> 是终集且 <code>T ≅ T″</code>, 给定集合 <code>X</code>. 要证 <code>T′</code> 是终极, 只要证存在唯一的函数 <code>T′ →̇ X</code>.</p>
<p>存在性: 由于 <code>T</code> 是终集, 有唯一的函数 <code>X →̇ T</code>, 记作 <code>f</code>. <code>j ∘ f : T′ →̇ X</code> 就是所需函数, 其中 <code>j : T →̇ T′</code> 是假设的同构.</p>
<p>唯一性: 设 <code>f′ g′ : T′ →̇ X</code>. 由于 <code>X →̇ T</code> 唯一, 所以 <span class="math inline">j^{-1} ∘ f&#39; = j^{-1} ∘ g&#39;</span>, 所以</p>
<p><span class="math display">
\begin{aligned}
f&#39; &amp;= j ∘ (j^{-1} ∘ f&#39;) \\
&amp;= j ∘ (j^{-1} ∘ g&#39;) \\
&amp;= g&#39; \quad \square
\end {aligned}
</span></p>
<pre class="Agda"><a id="1544" class="Comment">-- Lemma 2.3.3</a>
<a id="isoInvariant-isTerminal"></a><a id="1559" href="Basic.Membership.html#1559" class="Function">isoInvariant-isTerminal</a> <a id="1583" class="Symbol">:</a> <a id="1585" href="Basic.Isomorphism.html#4270" class="Function Operator">isoInvariant⟨</a> <a id="1599" href="Axiom.html#3532" class="Function">TerminalCommuter</a> <a id="1616" href="Basic.Isomorphism.html#4270" class="Function Operator">⟩</a> <a id="1618" href="Axiom.html#3609" class="Function">isTerminal</a>
<a id="1629" href="Basic.Membership.html#1559" class="Function">isoInvariant-isTerminal</a> <a id="1653" class="Symbol">{</a><a id="1654" class="Argument">a</a> <a id="1656" class="Symbol">=</a> <a id="1658" href="Basic.Membership.html#1658" class="Bound">T</a><a id="1659" class="Symbol">}</a> <a id="1661" class="Symbol">{</a><a id="1662" class="Argument">b</a> <a id="1664" class="Symbol">=</a> <a id="1666" href="Basic.Membership.html#1666" class="Bound">T′</a><a id="1668" class="Symbol">}</a> <a id="1670" href="Basic.Membership.html#1670" class="Bound">j</a> <a id="1672" class="Symbol">(</a><a id="1673" href="Basic.Membership.html#1673" class="Bound">j⁻¹</a> <a id="1677" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1679" href="Basic.Membership.html#1679" class="Bound">jj⁻¹</a> <a id="1684" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1686" class="Symbol">_)</a> <a id="1689" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="1692" href="Basic.Membership.html#1692" class="Bound">tml</a> <a id="1696" href="Basic.Membership.html#1696" class="Bound">X</a> <a id="1698" class="Symbol">=</a>
  <a id="1702" class="Keyword">let</a> <a id="1706" class="Symbol">(</a><a id="1707" href="Basic.Membership.html#1707" class="Bound">f</a> <a id="1709" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1711" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1713" class="Symbol">)</a> <a id="1715" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1717" href="Basic.Membership.html#1717" class="Bound">f!</a> <a id="1720" class="Symbol">=</a> <a id="1722" href="Basic.Membership.html#1692" class="Bound">tml</a> <a id="1726" href="Basic.Membership.html#1696" class="Bound">X</a> <a id="1728" class="Keyword">in</a>
  <a id="1733" class="Symbol">(</a><a id="1734" href="Basic.Membership.html#1670" class="Bound">j</a> <a id="1736" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1738" href="Basic.Membership.html#1707" class="Bound">f</a> <a id="1740" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1742" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1744" class="Symbol">)</a> <a id="1746" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1748" class="Symbol">λ</a> <a id="1750" class="Symbol">{</a><a id="1751" href="Basic.Membership.html#1751" class="Bound">f′</a> <a id="1754" href="Basic.Membership.html#1754" class="Bound">g′</a><a id="1756" class="Symbol">}</a> <a id="1758" href="Basic.Membership.html#1758" class="Bound">_</a> <a id="1760" href="Basic.Membership.html#1760" class="Bound">_</a> <a id="1762" class="Symbol">→</a> <a id="1764" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="1774" href="Basic.Membership.html#1751" class="Bound">f′</a>                      <a id="1798" href="Relation.Binary.Reasoning.Syntax.html#11539" class="Function">≡˘⟨</a> <a id="1802" href="Basic.Isomorphism.html#780" class="Function">AssIdˡ</a> <a id="1809" href="Basic.Membership.html#1679" class="Bound">jj⁻¹</a> <a id="1814" href="Relation.Binary.Reasoning.Syntax.html#11539" class="Function">⟩</a>
    <a id="1820" href="Basic.Membership.html#1670" class="Bound">j</a> <a id="1822" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1824" class="Symbol">(</a><a id="1825" href="Basic.Membership.html#1673" class="Bound">j⁻¹</a> <a id="1829" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1831" href="Basic.Membership.html#1751" class="Bound">f′</a><a id="1833" class="Symbol">)</a>          <a id="1844" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="1847" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1852" class="Symbol">(</a><a id="1853" href="Basic.Membership.html#1670" class="Bound">j</a> <a id="1855" href="Axiom.html#1707" class="Function Operator">∘_</a><a id="1857" class="Symbol">)</a> <a id="1859" class="Symbol">(</a><a id="1860" href="Basic.Membership.html#1717" class="Bound">f!</a> <a id="1863" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="1866" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1868" class="Symbol">)</a> <a id="1870" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="1876" href="Basic.Membership.html#1670" class="Bound">j</a> <a id="1878" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1880" class="Symbol">(</a><a id="1881" href="Basic.Membership.html#1673" class="Bound">j⁻¹</a> <a id="1885" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="1887" href="Basic.Membership.html#1754" class="Bound">g′</a><a id="1889" class="Symbol">)</a>          <a id="1900" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="1903" href="Basic.Isomorphism.html#780" class="Function">AssIdˡ</a> <a id="1910" href="Basic.Membership.html#1679" class="Bound">jj⁻¹</a> <a id="1915" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="1921" href="Basic.Membership.html#1754" class="Bound">g′</a>                      <a id="1945" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="1947" class="Keyword">where</a> <a id="1953" class="Keyword">open</a> <a id="1958" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre>
<p><strong>引理 2.3.4</strong> 终集在同构意义下唯一: 任意两个终集存在唯一同构.<br />
<strong>(证明)</strong> 令 <code>T</code> <code>T′</code> 是终集, 由终集的定义, 存在 <code>f : T →̇ T′</code> 与 <code>f′ : T′ →̇ T</code>. 且由终集的定义, 某终集到其自身的函数 <code>id</code> 也是唯一的, 所以 <code>f ∘ f′ ≡ id</code> 且 <code>f′ ∘ f ≡ id</code>. 因此 <code>f</code> 是 <code>T</code> 与 <code>T′</code> 的同构. 其唯一性由终集的定义即得. □</p>
<pre class="Agda"><a id="2200" class="Comment">-- Lemma 2.3.4</a>
<a id="isoUnique-isTerminal"></a><a id="2215" href="Basic.Membership.html#2215" class="Function">isoUnique-isTerminal</a> <a id="2236" class="Symbol">:</a> <a id="2238" href="Basic.Isomorphism.html#4663" class="Function Operator">isoUnique⟨</a> <a id="2249" href="Axiom.html#3532" class="Function">TerminalCommuter</a> <a id="2266" href="Basic.Isomorphism.html#4663" class="Function Operator">⟩</a> <a id="2268" href="Axiom.html#3609" class="Function">isTerminal</a>
<a id="2279" href="Basic.Membership.html#2215" class="Function">isoUnique-isTerminal</a> <a id="2300" href="Basic.Membership.html#2300" class="Bound">a</a><a id="2301" class="Symbol">@{</a><a id="2303" href="Basic.Membership.html#2303" class="Bound">T</a> <a id="2305" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2307" class="Symbol">_}</a> <a id="2310" href="Basic.Membership.html#2310" class="Bound">b</a><a id="2311" class="Symbol">@{</a><a id="2313" href="Basic.Membership.html#2313" class="Bound">T′</a> <a id="2316" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2318" class="Symbol">_}</a> <a id="2321" href="Basic.Membership.html#2321" class="Bound">ta</a> <a id="2324" href="Basic.Membership.html#2324" class="Bound">tb</a> <a id="2327" class="Symbol">=</a>
  <a id="2331" class="Keyword">let</a> <a id="2335" href="Basic.Membership.html#2335" class="Bound">f</a> <a id="2337" class="Symbol">:</a> <a id="2339" href="Basic.Membership.html#2303" class="Bound">T</a> <a id="2341" href="Axiom.html#1677" class="Function Operator">→̇</a> <a id="2344" href="Basic.Membership.html#2313" class="Bound">T′</a>
      <a id="2353" href="Basic.Membership.html#2335" class="Bound">f</a> <a id="2355" class="Symbol">=</a> <a id="2357" href="Basic.Membership.html#2324" class="Bound">tb</a> <a id="2360" href="Basic.Membership.html#2300" class="Bound">a</a> <a id="2362" class="Symbol">.</a><a id="2363" href="Axiom.html#949" class="Field">fst</a> <a id="2367" class="Symbol">.</a><a id="2368" href="Axiom.html#949" class="Field">fst</a>
      <a id="2378" href="Basic.Membership.html#2378" class="Bound">f′</a> <a id="2381" class="Symbol">:</a> <a id="2383" href="Basic.Membership.html#2313" class="Bound">T′</a> <a id="2386" href="Axiom.html#1677" class="Function Operator">→̇</a> <a id="2389" href="Basic.Membership.html#2303" class="Bound">T</a>
      <a id="2397" href="Basic.Membership.html#2378" class="Bound">f′</a> <a id="2400" class="Symbol">=</a> <a id="2402" href="Basic.Membership.html#2321" class="Bound">ta</a> <a id="2405" href="Basic.Membership.html#2310" class="Bound">b</a> <a id="2407" class="Symbol">.</a><a id="2408" href="Axiom.html#949" class="Field">fst</a> <a id="2412" class="Symbol">.</a><a id="2413" href="Axiom.html#949" class="Field">fst</a>
      <a id="2423" href="Basic.Membership.html#2423" class="Bound">ff′</a> <a id="2427" class="Symbol">:</a> <a id="2429" href="Basic.Membership.html#2335" class="Bound">f</a> <a id="2431" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="2433" href="Basic.Membership.html#2378" class="Bound">f′</a> <a id="2436" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2438" href="Axiom.html#1800" class="Function">id</a>
      <a id="2447" href="Basic.Membership.html#2423" class="Bound">ff′</a> <a id="2451" class="Symbol">=</a> <a id="2453" href="Basic.Membership.html#2324" class="Bound">tb</a> <a id="2456" href="Basic.Membership.html#2310" class="Bound">b</a> <a id="2458" class="Symbol">.</a><a id="2459" href="Axiom.html#963" class="Field">snd</a> <a id="2463" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="2466" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
      <a id="2475" href="Basic.Membership.html#2475" class="Bound">f′f</a> <a id="2479" class="Symbol">:</a> <a id="2481" href="Basic.Membership.html#2378" class="Bound">f′</a> <a id="2484" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="2486" href="Basic.Membership.html#2335" class="Bound">f</a> <a id="2488" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2490" href="Axiom.html#1800" class="Function">id</a>
      <a id="2499" href="Basic.Membership.html#2475" class="Bound">f′f</a> <a id="2503" class="Symbol">=</a> <a id="2505" href="Basic.Membership.html#2321" class="Bound">ta</a> <a id="2508" href="Basic.Membership.html#2300" class="Bound">a</a> <a id="2510" class="Symbol">.</a><a id="2511" href="Axiom.html#963" class="Field">snd</a> <a id="2515" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="2518" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
      <a id="2527" href="Basic.Membership.html#2527" class="Bound">f≡g</a> <a id="2531" class="Symbol">:</a> <a id="2533" class="Symbol">{</a><a id="2534" href="Basic.Membership.html#2534" class="Bound">f</a> <a id="2536" href="Basic.Membership.html#2536" class="Bound">g</a> <a id="2538" class="Symbol">:</a> <a id="2540" href="Basic.Membership.html#2303" class="Bound">T</a> <a id="2542" href="Axiom.html#1677" class="Function Operator">→̇</a> <a id="2545" href="Basic.Membership.html#2313" class="Bound">T′</a><a id="2547" class="Symbol">}</a> <a id="2549" class="Symbol">→</a> <a id="2551" href="Basic.Membership.html#2534" class="Bound">f</a> <a id="2553" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2555" href="Basic.Membership.html#2536" class="Bound">g</a>
      <a id="2563" href="Basic.Membership.html#2527" class="Bound">f≡g</a> <a id="2567" class="Symbol">=</a> <a id="2569" href="Basic.Membership.html#2324" class="Bound">tb</a> <a id="2572" href="Basic.Membership.html#2300" class="Bound">a</a> <a id="2574" class="Symbol">.</a><a id="2575" href="Axiom.html#963" class="Field">snd</a> <a id="2579" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="2582" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
  <a id="2587" class="Keyword">in</a> <a id="2590" href="Basic.Membership.html#2335" class="Bound">f</a> <a id="2592" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2594" class="Symbol">(</a><a id="2595" href="Basic.Membership.html#2378" class="Bound">f′</a> <a id="2598" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2600" href="Basic.Membership.html#2423" class="Bound">ff′</a> <a id="2604" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2606" href="Basic.Membership.html#2475" class="Bound">f′f</a><a id="2609" class="Symbol">)</a> <a id="2611" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2613" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="2616" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2618" class="Symbol">λ</a> <a id="2620" href="Basic.Membership.html#2620" class="Bound">_</a> <a id="2622" href="Basic.Membership.html#2622" class="Bound">_</a> <a id="2624" class="Symbol">→</a> <a id="2626" href="Basic.Membership.html#2527" class="Bound">f≡g</a>
</pre>
<p>我们把到终集的唯一函数记作 <code>!</code>, 特别地, 终集的元素记作 <code>*</code>.</p>
<pre class="Agda"><a id="!⟨_⟩"></a><a id="2681" href="Basic.Membership.html#2681" class="Function Operator">!⟨_⟩</a> <a id="2686" class="Symbol">:</a> <a id="2688" class="Symbol">(</a><a id="2689" href="Basic.Membership.html#2689" class="Bound">X</a> <a id="2691" class="Symbol">:</a> <a id="2693" href="Axiom.html#1662" class="Function">CSet</a><a id="2697" class="Symbol">)</a> <a id="2699" class="Symbol">→</a> <a id="2701" href="Basic.Membership.html#2689" class="Bound">X</a> <a id="2703" href="Axiom.html#1677" class="Function Operator">→̇</a> <a id="2706" href="Axiom.html#3965" class="Function">１</a>
<a id="2708" href="Basic.Membership.html#2681" class="Function Operator">!⟨</a> <a id="2711" href="Basic.Membership.html#2711" class="Bound">X</a> <a id="2713" href="Basic.Membership.html#2681" class="Function Operator">⟩</a> <a id="2715" class="Symbol">=</a> <a id="2717" href="Axiom.html#3751" class="Function">AxTml</a> <a id="2723" class="Symbol">.</a><a id="2724" href="Axiom.html#963" class="Field">snd</a> <a id="2728" class="Symbol">(</a><a id="2729" href="Basic.Membership.html#2711" class="Bound">X</a> <a id="2731" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2733" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="2735" class="Symbol">)</a> <a id="2737" class="Symbol">.</a><a id="2738" href="Axiom.html#949" class="Field">fst</a> <a id="2742" class="Symbol">.</a><a id="2743" href="Axiom.html#949" class="Field">fst</a>

<a id="!"></a><a id="2748" href="Basic.Membership.html#2748" class="Function">!</a> <a id="2750" class="Symbol">:</a> <a id="2752" href="Axiom.html#3021" class="Generalizable">X</a> <a id="2754" href="Axiom.html#1677" class="Function Operator">→̇</a> <a id="2757" href="Axiom.html#3965" class="Function">１</a>
<a id="2759" href="Basic.Membership.html#2748" class="Function">!</a> <a id="2761" class="Symbol">{</a><a id="2762" href="Basic.Membership.html#2762" class="Bound">X</a><a id="2763" class="Symbol">}</a> <a id="2765" class="Symbol">=</a> <a id="2767" href="Basic.Membership.html#2681" class="Function Operator">!⟨</a> <a id="2770" href="Basic.Membership.html#2762" class="Bound">X</a> <a id="2772" href="Basic.Membership.html#2681" class="Function Operator">⟩</a>

<a id="*"></a><a id="2775" href="Basic.Membership.html#2775" class="Function">*</a> <a id="2777" class="Symbol">:</a> <a id="2779" href="Axiom.html#4136" class="Function">Elm</a> <a id="2783" href="Axiom.html#3965" class="Function">１</a>
<a id="2785" href="Basic.Membership.html#2775" class="Function">*</a> <a id="2787" class="Symbol">=</a> <a id="2789" href="Basic.Membership.html#2748" class="Function">!</a>
</pre>
<p><strong>例 2.5.2</strong> <code>１</code> 不是空集.</p>
<pre class="Agda"><a id="2827" class="Comment">-- Example 2.5.2</a>
<a id="2844" href="Basic.Membership.html#2844" class="Function">_</a> <a id="2846" class="Symbol">:</a> <a id="2848" href="Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="2850" href="Axiom.html#5192" class="Function">empty</a> <a id="2856" href="Axiom.html#3965" class="Function">１</a>
<a id="2858" class="Symbol">_</a> <a id="2860" class="Symbol">=</a> <a id="2862" class="Symbol">λ</a> <a id="2864" href="Basic.Membership.html#2864" class="Bound">p</a> <a id="2866" class="Symbol">→</a> <a id="2868" href="Basic.Membership.html#2864" class="Bound">p</a> <a id="2870" href="Basic.Membership.html#2775" class="Function">*</a>
</pre>
<p>我们说一个集合 <code>X</code> 是单集, 记作 <code>isSingleton X</code>, 当且仅当存在 <code>Elm X</code> 且对任意 <code>x y : Elm X</code> 有 <code>x ≡ y</code>. 显然, <code>１</code> 是单集.</p>
<pre class="Agda"><a id="isSingleton"></a><a id="2981" href="Basic.Membership.html#2981" class="Function">isSingleton</a> <a id="2993" class="Symbol">:</a> <a id="2995" href="Axiom.html#1662" class="Function">CSet</a> <a id="3000" class="Symbol">→</a> <a id="3002" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="3006" href="Basic.Membership.html#2981" class="Function">isSingleton</a> <a id="3018" href="Basic.Membership.html#3018" class="Bound">X</a> <a id="3020" class="Symbol">=</a> <a id="3022" href="Axiom.html#4136" class="Function">Elm</a> <a id="3026" href="Basic.Membership.html#3018" class="Bound">X</a> <a id="3028" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="3030" class="Symbol">∀</a> <a id="3032" class="Symbol">{</a><a id="3033" href="Basic.Membership.html#3033" class="Bound">x</a> <a id="3035" href="Basic.Membership.html#3035" class="Bound">y</a> <a id="3037" class="Symbol">:</a> <a id="3039" href="Axiom.html#4136" class="Function">Elm</a> <a id="3043" href="Basic.Membership.html#3018" class="Bound">X</a><a id="3044" class="Symbol">}</a> <a id="3046" class="Symbol">→</a> <a id="3048" href="Basic.Membership.html#3033" class="Bound">x</a> <a id="3050" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3052" href="Basic.Membership.html#3035" class="Bound">y</a>

<a id="isSingleton-１"></a><a id="3055" href="Basic.Membership.html#3055" class="Function">isSingleton-１</a> <a id="3069" class="Symbol">:</a> <a id="3071" href="Basic.Membership.html#2981" class="Function">isSingleton</a> <a id="3083" href="Axiom.html#3965" class="Function">１</a>
<a id="3085" href="Basic.Membership.html#3055" class="Function">isSingleton-１</a> <a id="3099" class="Symbol">=</a> <a id="3101" href="Basic.Membership.html#2775" class="Function">*</a> <a id="3103" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3105" href="Axiom.html#3751" class="Function">AxTml</a> <a id="3111" class="Symbol">.</a><a id="3112" href="Axiom.html#963" class="Field">snd</a> <a id="3116" class="Symbol">(</a><a id="3117" href="Axiom.html#3965" class="Function">１</a> <a id="3119" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3121" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3123" class="Symbol">)</a> <a id="3125" class="Symbol">.</a><a id="3126" href="Axiom.html#963" class="Field">snd</a> <a id="3130" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="3133" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
</pre>
<p><strong>引理 2.4.1</strong> 终集是单集, 反之亦然.<br />
<strong>(证明)</strong> 左到右显然成立. 右到左, 给定单集 <code>X</code>, 将其唯一元素记作 <code>x</code>. 由引理 2.3.3, 我们证 <code>X</code> 与 <code>１</code> 同构即可. 我们有 <code>x : １ →̇ X</code> 和 <code>! : １ →̇ X</code>, 只需证它们互逆. 由终集的定义可得 <code>! ∘ x ≡ id</code>. 最后用公理3证 <code>x ∘ ! ≡ id</code>, 即证对任意 <code>y ∈ X</code> 有 <code>(x ∘ !) ⦅ y ⦆ ≡ id ⦅ y ⦆</code>. 由公理1, 左边等于 <code>x</code>, 右边等于 <code>y</code>. 由于 <code>x</code> 唯一, 所以 <code>x ≡ y</code>. □</p>
<pre class="Agda"><a id="3438" class="Comment">-- Lemma 2.4.1</a>
<a id="isTerminal→isSingleton"></a><a id="3453" href="Basic.Membership.html#3453" class="Function">isTerminal→isSingleton</a> <a id="3476" class="Symbol">:</a> <a id="3478" href="Axiom.html#3609" class="Function">isTerminal</a> <a id="3489" class="Symbol">(</a><a id="3490" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3492" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3494" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3496" class="Symbol">)</a> <a id="3498" class="Symbol">→</a> <a id="3500" href="Basic.Membership.html#2981" class="Function">isSingleton</a> <a id="3512" href="Axiom.html#3021" class="Generalizable">X</a>
<a id="3514" href="Basic.Membership.html#3453" class="Function">isTerminal→isSingleton</a> <a id="3537" href="Basic.Membership.html#3537" class="Bound">tml</a> <a id="3541" class="Symbol">=</a> <a id="3543" href="Basic.Membership.html#3537" class="Bound">tml</a> <a id="3547" class="Symbol">(</a><a id="3548" href="Axiom.html#3965" class="Function">１</a> <a id="3550" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3552" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3554" class="Symbol">)</a> <a id="3556" class="Symbol">.</a><a id="3557" href="Axiom.html#949" class="Field">fst</a> <a id="3561" class="Symbol">.</a><a id="3562" href="Axiom.html#949" class="Field">fst</a> <a id="3566" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3568" href="Basic.Membership.html#3537" class="Bound">tml</a> <a id="3572" class="Symbol">(</a><a id="3573" href="Axiom.html#3965" class="Function">１</a> <a id="3575" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3577" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3579" class="Symbol">)</a> <a id="3581" class="Symbol">.</a><a id="3582" href="Axiom.html#963" class="Field">snd</a> <a id="3586" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="3589" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

<a id="isSingleton→isTerminal"></a><a id="3593" href="Basic.Membership.html#3593" class="Function">isSingleton→isTerminal</a> <a id="3616" class="Symbol">:</a> <a id="3618" href="Basic.Membership.html#2981" class="Function">isSingleton</a> <a id="3630" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3632" class="Symbol">→</a> <a id="3634" href="Axiom.html#3609" class="Function">isTerminal</a> <a id="3645" class="Symbol">(</a><a id="3646" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3648" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3650" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3652" class="Symbol">)</a>
<a id="3654" href="Basic.Membership.html#3593" class="Function">isSingleton→isTerminal</a> <a id="3677" class="Symbol">(</a><a id="3678" href="Basic.Membership.html#3678" class="Bound">x</a> <a id="3680" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3682" href="Basic.Membership.html#3682" class="Bound">x!</a><a id="3684" class="Symbol">)</a> <a id="3686" class="Symbol">=</a> <a id="3688" href="Basic.Membership.html#1559" class="Function">isoInvariant-isTerminal</a>
  <a id="3714" href="Basic.Membership.html#3678" class="Bound">x</a> <a id="3716" class="Symbol">(</a><a id="3717" href="Basic.Membership.html#2748" class="Function">!</a> <a id="3719" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3721" href="Axiom.html#5046" class="Function">AxFunExt</a> <a id="3730" href="Basic.Membership.html#3832" class="Function">q</a> <a id="3732" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3734" href="Basic.Membership.html#3763" class="Function">p</a><a id="3735" class="Symbol">)</a> <a id="3737" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="3740" class="Symbol">(</a><a id="3741" href="Axiom.html#3751" class="Function">AxTml</a> <a id="3747" class="Symbol">.</a><a id="3748" href="Axiom.html#963" class="Field">snd</a><a id="3751" class="Symbol">)</a> <a id="3753" class="Keyword">where</a>
    <a id="3763" href="Basic.Membership.html#3763" class="Function">p</a> <a id="3765" class="Symbol">:</a> <a id="3767" class="Symbol">{</a><a id="3768" href="Basic.Membership.html#3768" class="Bound">x</a> <a id="3770" href="Basic.Membership.html#3770" class="Bound">y</a> <a id="3772" class="Symbol">:</a> <a id="3774" href="Axiom.html#4136" class="Function">Elm</a> <a id="3778" href="Axiom.html#3965" class="Function">１</a><a id="3779" class="Symbol">}</a> <a id="3781" class="Symbol">→</a> <a id="3783" href="Basic.Membership.html#3768" class="Bound">x</a> <a id="3785" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3787" href="Basic.Membership.html#3770" class="Bound">y</a>
    <a id="3793" href="Basic.Membership.html#3763" class="Function">p</a> <a id="3795" class="Symbol">=</a> <a id="3797" href="Axiom.html#3751" class="Function">AxTml</a> <a id="3803" class="Symbol">.</a><a id="3804" href="Axiom.html#963" class="Field">snd</a> <a id="3808" class="Symbol">(</a><a id="3809" href="Axiom.html#3965" class="Function">１</a> <a id="3811" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3813" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="3815" class="Symbol">)</a> <a id="3817" class="Symbol">.</a><a id="3818" href="Axiom.html#963" class="Field">snd</a> <a id="3822" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="3825" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
    <a id="3832" href="Basic.Membership.html#3832" class="Function">q</a> <a id="3834" class="Symbol">=</a> <a id="3836" class="Symbol">λ</a> <a id="3838" href="Basic.Membership.html#3838" class="Bound">y</a> <a id="3840" class="Symbol">→</a>         <a id="3850" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
      <a id="3862" class="Symbol">(</a><a id="3863" href="Basic.Membership.html#3678" class="Bound">x</a> <a id="3865" href="Axiom.html#1707" class="Function Operator">∘</a> <a id="3867" href="Basic.Membership.html#2748" class="Function">!</a><a id="3868" class="Symbol">)</a> <a id="3870" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="3872" href="Basic.Membership.html#3838" class="Bound">y</a> <a id="3874" href="Axiom.html#4842" class="Function Operator">⦆</a>   <a id="3878" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3881" href="Basic.Isomorphism.html#1054" class="Function">AssIdʳ</a> <a id="3888" href="Basic.Membership.html#3763" class="Function">p</a> <a id="3890" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
      <a id="3898" href="Basic.Membership.html#3678" class="Bound">x</a>               <a id="3914" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3917" href="Basic.Membership.html#3682" class="Bound">x!</a> <a id="3920" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
      <a id="3928" href="Basic.Membership.html#3838" class="Bound">y</a>               <a id="3944" href="Relation.Binary.Reasoning.Syntax.html#11539" class="Function">≡˘⟨</a> <a id="3948" href="Axiom.html#3299" class="Function">AxIdˡ</a> <a id="3954" href="Relation.Binary.Reasoning.Syntax.html#11539" class="Function">⟩</a>
      <a id="3962" href="Axiom.html#1800" class="Function">id</a> <a id="3965" href="Axiom.html#4842" class="Function Operator">⦅</a> <a id="3967" href="Basic.Membership.html#3838" class="Bound">y</a> <a id="3969" href="Axiom.html#4842" class="Function Operator">⦆</a>        <a id="3978" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a> <a id="3980" class="Keyword">where</a> <a id="3986" class="Keyword">open</a> <a id="3991" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
