<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>公理化结构集合论 (1 公理)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">公理化结构集合论 (1 公理)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#公理化结构集合论-1-公理" id="toc-公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#原始概念" id="toc-原始概念">原始概念</a></li>
  <li><a href="#公理" id="toc-公理">公理</a></li>
  <li><a href="#总结" id="toc-总结">总结</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/ETCS/blob/main/src/Axiom.lagda.md">Axiom.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/ETCS/Axiom.html">Axiom.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是对 Tom Leinster 在爱丁堡大学教授的本科课程「公理化结构集合论（ETCS）」<a href="https://www.maths.ed.ac.uk/~tl/ast/ast.pdf">讲义</a>（以下简称「讲义」）的 Agda 形式化. 我们的符号选取和定义表述基本上遵循讲义, 而定理编号与讲义完全一致, 但由于 Agda 的特性而稍微调整了顺序. 注意我们讲的是一种可以作为数学基础的集合论而不是范畴论, 虽然借用了一些范畴论的术语和思想, 但不需要先掌握范畴论.</p>
<p>我们采用原味 Agda 加 stdlib 标准库, 这是我们的元语言, 而 ETCS 将是我们的对象语言. 由于两层语言的高度相似性, 它们的符号/命名冲突我们主要采用如下两种方式解决.</p>
<ol type="1">
<li>如果一个符号已经用于元语言 (如 <code>→</code>), 则在上面加点表示对象语言的相应概念 (如 <code>→̇</code>).</li>
<li>如果一个符号优先用于对象语言 (如 <code>id</code>), 则在后面加上 <code>⒨</code> 表示元语言的相应概念 (如 <code>id⒨</code>).</li>
</ol>
<pre class="Agda"><a id="773" class="Keyword">module</a> <a id="780" href="Axiom.html" class="Module">Axiom</a> <a id="786" class="Keyword">where</a>

<a id="793" class="Keyword">open</a> <a id="798" class="Keyword">import</a> <a id="805" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="816" class="Keyword">public</a> <a id="823" class="Keyword">using</a> <a id="829" class="Symbol">(</a><a id="830" href="Data.Empty.html#914" class="Function">⊥</a><a id="831" class="Symbol">)</a>
<a id="833" class="Keyword">open</a> <a id="838" class="Keyword">import</a> <a id="845" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="855" class="Keyword">public</a> <a id="862" class="Keyword">using</a> <a id="868" class="Symbol">(</a><a id="869" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="870" class="Symbol">;</a> <a id="872" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="874" class="Symbol">)</a>
<a id="876" class="Keyword">open</a> <a id="881" class="Keyword">import</a> <a id="888" href="Data.Product.html" class="Module">Data.Product</a> <a id="901" class="Keyword">public</a> <a id="908" class="Keyword">using</a> <a id="914" class="Symbol">(</a><a id="915" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="916" class="Symbol">;</a> <a id="918" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="921" class="Symbol">;</a> <a id="923" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="926" class="Symbol">)</a>
  <a id="930" class="Keyword">renaming</a> <a id="939" class="Symbol">(</a><a id="940" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="946" class="Symbol">to</a> <a id="949" class="Field">fst</a><a id="952" class="Symbol">;</a> <a id="954" href="Data.Product.Base.html#650" class="Field">proj₂</a> <a id="960" class="Symbol">to</a> <a id="963" class="Field">snd</a><a id="966" class="Symbol">)</a>
<a id="968" class="Keyword">open</a> <a id="973" class="Keyword">import</a> <a id="980" href="Function.html" class="Module">Function</a> <a id="989" class="Keyword">public</a> <a id="996" class="Keyword">using</a> <a id="1002" class="Symbol">(</a><a id="1003" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="1011" class="Symbol">)</a> <a id="1013" class="Keyword">renaming</a> <a id="1022" class="Symbol">(</a><a id="1023" href="Function.Base.html#704" class="Function">id</a> <a id="1026" class="Symbol">to</a> <a id="1029" class="Function">id⒨</a><a id="1032" class="Symbol">)</a>
<a id="1034" class="Keyword">open</a> <a id="1039" class="Keyword">import</a> <a id="1046" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1084" class="Keyword">public</a>
</pre>
<p>本文是系列的第一篇, 我们引入 ETCS 的10条公理. 为了表述公理, 首先需要引入 ETCS 的原始概念, 讲义中称它们为资料 (the data), 有的地方也称之为原语 (primitives) , 语言 (language) 或签名 (signature).</p>
<h2 id="原始概念">原始概念</h2>
<p>形式地, 我们的公理将在如下原始概念上展开表述.</p>
<ul>
<li>一些称为集合的东西, 这样的集合 <code>X</code> 记作 <code>X : CSet</code>, 其中 C 来自范畴 (category).</li>
<li>对每个集合 <code>X</code> 和 <code>Y</code>, 一些称为「<code>X</code> 到 <code>Y</code> 的函数」的东西, 这样的函数 <code>f</code> 记作 <code>f : X →̇ Y</code>.</li>
<li>对每个集合 <code>X</code>, <code>Y</code> 和 <code>Z</code>, 一个称为「复合」的运算, 将每个 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋值为一个函数 <code>g ∘ f : X →̇ Z</code>.</li>
<li>对每个集合 <code>X</code>, 一个称为「恒等函数」的东西, 记作 <code>id⟨ X ⟩ : X →̇ X</code>, <code>X</code> 可以从上下文推断出来时简记作 <code>id</code>.</li>
</ul>
<pre class="Agda"><a id="1577" class="Comment">-- 2.1 The data</a>
<a id="1593" class="Keyword">record</a> <a id="Data"></a><a id="1600" href="Axiom.html#1600" class="Record">Data</a> <a id="1605" class="Symbol">:</a> <a id="1607" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="1612" class="Keyword">where</a>
  <a id="1620" class="Keyword">infixl</a> <a id="1627" class="Number">10</a> <a id="1630" href="Axiom.html#1677" class="Field Operator">_→̇_</a>
  <a id="1637" class="Keyword">infix</a> <a id="1643" class="Number">10</a> <a id="1646" href="Axiom.html#1707" class="Field Operator">_∘_</a>
  <a id="1652" class="Keyword">field</a>
    <a id="Data.CSet"></a><a id="1662" href="Axiom.html#1662" class="Field">CSet</a> <a id="1667" class="Symbol">:</a> <a id="1669" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._→̇_"></a><a id="1677" href="Axiom.html#1677" class="Field Operator">_→̇_</a> <a id="1682" class="Symbol">:</a> <a id="1684" class="Symbol">(</a><a id="1685" href="Axiom.html#1685" class="Bound">X</a> <a id="1687" href="Axiom.html#1687" class="Bound">Y</a> <a id="1689" class="Symbol">:</a> <a id="1691" href="Axiom.html#1662" class="Field">CSet</a><a id="1695" class="Symbol">)</a> <a id="1697" class="Symbol">→</a> <a id="1699" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._∘_"></a><a id="1707" href="Axiom.html#1707" class="Field Operator">_∘_</a> <a id="1711" class="Symbol">:</a> <a id="1713" class="Symbol">{</a><a id="1714" href="Axiom.html#1714" class="Bound">X</a> <a id="1716" href="Axiom.html#1716" class="Bound">Y</a> <a id="1718" href="Axiom.html#1718" class="Bound">Z</a> <a id="1720" class="Symbol">:</a> <a id="1722" href="Axiom.html#1662" class="Field">CSet</a><a id="1726" class="Symbol">}</a> <a id="1728" class="Symbol">(</a><a id="1729" href="Axiom.html#1729" class="Bound">g</a> <a id="1731" class="Symbol">:</a> <a id="1733" href="Axiom.html#1716" class="Bound">Y</a> <a id="1735" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1738" href="Axiom.html#1718" class="Bound">Z</a><a id="1739" class="Symbol">)</a> <a id="1741" class="Symbol">(</a><a id="1742" href="Axiom.html#1742" class="Bound">f</a> <a id="1744" class="Symbol">:</a> <a id="1746" href="Axiom.html#1714" class="Bound">X</a> <a id="1748" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1751" href="Axiom.html#1716" class="Bound">Y</a><a id="1752" class="Symbol">)</a> <a id="1754" class="Symbol">→</a> <a id="1756" class="Symbol">(</a><a id="1757" href="Axiom.html#1714" class="Bound">X</a> <a id="1759" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1762" href="Axiom.html#1718" class="Bound">Z</a><a id="1763" class="Symbol">)</a>
    <a id="Data.id⟨_⟩"></a><a id="1769" href="Axiom.html#1769" class="Field Operator">id⟨_⟩</a> <a id="1775" class="Symbol">:</a> <a id="1777" class="Symbol">(</a><a id="1778" href="Axiom.html#1778" class="Bound">X</a> <a id="1780" class="Symbol">:</a> <a id="1782" href="Axiom.html#1662" class="Field">CSet</a><a id="1786" class="Symbol">)</a> <a id="1788" class="Symbol">→</a> <a id="1790" href="Axiom.html#1778" class="Bound">X</a> <a id="1792" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1795" href="Axiom.html#1778" class="Bound">X</a>

  <a id="Data.id"></a><a id="1800" href="Axiom.html#1800" class="Function">id</a> <a id="1803" class="Symbol">:</a> <a id="1805" class="Symbol">{</a><a id="1806" href="Axiom.html#1806" class="Bound">X</a> <a id="1808" class="Symbol">:</a> <a id="1810" href="Axiom.html#1662" class="Field">CSet</a><a id="1814" class="Symbol">}</a> <a id="1816" class="Symbol">→</a> <a id="1818" href="Axiom.html#1806" class="Bound">X</a> <a id="1820" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1823" href="Axiom.html#1806" class="Bound">X</a>
  <a id="1827" href="Axiom.html#1800" class="Function">id</a> <a id="1830" class="Symbol">{</a><a id="1831" href="Axiom.html#1831" class="Bound">X</a><a id="1832" class="Symbol">}</a> <a id="1834" class="Symbol">=</a> <a id="1836" href="Axiom.html#1769" class="Field Operator">id⟨</a> <a id="1840" href="Axiom.html#1831" class="Bound">X</a> <a id="1842" href="Axiom.html#1769" class="Field Operator">⟩</a>
</pre>
<p>我们会形式化讲义中没有编号的定义和命题, 这些内容我们编号为负数.</p>
<p><strong>定义 -1.1</strong> 我们把关于集合的性质称为箭头模式 <code>Arrow</code>. 给定这样的性质 <code>A : Arrow</code>, 如果某集合 <code>X</code> 满足 <code>A</code>, 我们就把 <code>a : A X</code> 称为集合 <code>X</code> 的一套 <code>A</code>-箭头.</p>
<pre class="Agda">  <a id="Data.Arrow"></a><a id="2008" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2014" class="Symbol">:</a> <a id="2016" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2023" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2029" class="Symbol">=</a> <a id="2031" href="Axiom.html#1662" class="Field">CSet</a> <a id="2036" class="Symbol">→</a> <a id="2038" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.2</strong> 给定箭头模式 <code>A</code>, 由以下资料组成的东西称为 <code>A</code>-图式 (diagram), 记作 <code>Diagram A</code>.</p>
<ul>
<li>一个集合 <code>X</code></li>
<li><code>X</code> 的一套 <code>A</code>-箭头</li>
</ul>
<p>其中 <code>X</code> 叫做图式的底集 (underlying set).</p>
<pre class="Agda">  <a id="Data.Diagram"></a><a id="2192" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2200" class="Symbol">:</a> <a id="2202" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2208" class="Symbol">→</a> <a id="2210" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2216" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2224" class="Symbol">=</a> <a id="2226" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2228" href="Axiom.html#1662" class="Field">CSet</a>
</pre>
<p><strong>定义 -1.3</strong> 给定箭头模式 <code>A</code>, 我们把关于两个 <code>A</code>-图式以及它们的底集间映射 <code>j</code> 的性质称为 <code>A</code>-交换模式, 记作 <code>Commuter A</code>. 对任意两个 <code>A</code>-图式 <code>a</code> <code>b</code> 以及它们的底集间映射 <code>j</code>, 如果它们满足一个 <code>A</code>-交换模式 <code>C : Commuter A</code>, 我们就称它们 <code>C</code>-交换, 记作 <code>C a b j</code>.</p>
<pre class="Agda">  <a id="Data.Commuter"></a><a id="2437" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2446" class="Symbol">:</a> <a id="2448" class="Symbol">(</a><a id="2449" href="Axiom.html#2449" class="Bound">A</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="Axiom.html#2008" class="Function">Arrow</a><a id="2458" class="Symbol">)</a> <a id="2460" class="Symbol">→</a> <a id="2462" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2469" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2478" href="Axiom.html#2478" class="Bound">A</a> <a id="2480" class="Symbol">=</a> <a id="2482" class="Symbol">(</a><a id="2483" href="Axiom.html#2483" class="Bound">(</a><a id="2484" href="Axiom.html#2484" class="Bound">X</a> <a id="2486" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2488" href="Axiom.html#2483" class="Bound">_)</a> <a id="2491" href="Axiom.html#2491" class="Bound">(</a><a id="2492" href="Axiom.html#2492" class="Bound">Y</a> <a id="2494" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2496" href="Axiom.html#2491" class="Bound">_)</a> <a id="2499" class="Symbol">:</a> <a id="2501" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2509" href="Axiom.html#2478" class="Bound">A</a><a id="2510" class="Symbol">)</a> <a id="2512" class="Symbol">(</a><a id="2513" href="Axiom.html#2513" class="Bound">j</a> <a id="2515" class="Symbol">:</a> <a id="2517" href="Axiom.html#2484" class="Bound">X</a> <a id="2519" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="2522" href="Axiom.html#2492" class="Bound">Y</a><a id="2523" class="Symbol">)</a> <a id="2525" class="Symbol">→</a> <a id="2527" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.4</strong> 给定一个 <code>A</code>-交换模式 <code>C</code> 和一个 <code>A</code>-图式 <code>b</code>, 我们称 <code>b</code> 满足 <code>C</code>-泛性质, 当且仅当对任意 <code>A</code>-图式 <code>a</code>, 存在唯一的底集间映射 <code>j</code> 使得 <code>a</code> <code>b</code> <code>j</code> 满足 <code>C</code>-交换.</p>
<pre class="Agda">  <a id="Data.unique"></a><a id="2674" href="Axiom.html#2674" class="Function">unique</a> <a id="2681" class="Symbol">:</a> <a id="2683" class="Symbol">{</a><a id="2684" href="Axiom.html#2684" class="Bound">A</a> <a id="2686" class="Symbol">:</a> <a id="2688" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2691" class="Symbol">}</a> <a id="2693" class="Symbol">(</a><a id="2694" href="Axiom.html#2694" class="Bound">P</a> <a id="2696" class="Symbol">:</a> <a id="2698" href="Axiom.html#2684" class="Bound">A</a> <a id="2700" class="Symbol">→</a> <a id="2702" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2705" class="Symbol">)</a> <a id="2707" class="Symbol">→</a> <a id="2709" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2715" href="Axiom.html#2674" class="Function">unique</a> <a id="2722" href="Axiom.html#2722" class="Bound">P</a> <a id="2724" class="Symbol">=</a> <a id="2726" class="Symbol">∀</a> <a id="2728" class="Symbol">{</a><a id="2729" href="Axiom.html#2729" class="Bound">a</a> <a id="2731" href="Axiom.html#2731" class="Bound">b</a><a id="2732" class="Symbol">}</a> <a id="2734" class="Symbol">→</a> <a id="2736" href="Axiom.html#2722" class="Bound">P</a> <a id="2738" href="Axiom.html#2729" class="Bound">a</a> <a id="2740" class="Symbol">→</a> <a id="2742" href="Axiom.html#2722" class="Bound">P</a> <a id="2744" href="Axiom.html#2731" class="Bound">b</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="Axiom.html#2729" class="Bound">a</a> <a id="2750" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2752" href="Axiom.html#2731" class="Bound">b</a>

  <a id="Data.universal"></a><a id="2757" href="Axiom.html#2757" class="Function">universal</a> <a id="2767" class="Symbol">:</a> <a id="2769" class="Symbol">{</a><a id="2770" href="Axiom.html#2770" class="Bound">A</a> <a id="2772" class="Symbol">:</a> <a id="2774" href="Axiom.html#2008" class="Function">Arrow</a><a id="2779" class="Symbol">}</a> <a id="2781" class="Symbol">→</a> <a id="2783" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2792" href="Axiom.html#2770" class="Bound">A</a> <a id="2794" class="Symbol">→</a> <a id="2796" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2804" href="Axiom.html#2770" class="Bound">A</a> <a id="2806" class="Symbol">→</a> <a id="2808" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2814" href="Axiom.html#2757" class="Function">universal</a> <a id="2824" class="Symbol">{</a><a id="2825" href="Axiom.html#2825" class="Bound">A</a><a id="2826" class="Symbol">}</a> <a id="2828" href="Axiom.html#2828" class="Bound">C</a> <a id="2830" href="Axiom.html#2830" class="Bound">b</a><a id="2831" class="Symbol">@(</a><a id="2833" href="Axiom.html#2833" class="Bound">Y</a> <a id="2835" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2837" class="Symbol">_)</a> <a id="2840" class="Symbol">=</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Axiom.html#2843" class="Bound">a</a><a id="2844" class="Symbol">@(</a><a id="2846" href="Axiom.html#2846" class="Bound">X</a> <a id="2848" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2850" class="Symbol">_)</a> <a id="2853" class="Symbol">:</a> <a id="2855" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2863" href="Axiom.html#2825" class="Bound">A</a><a id="2864" class="Symbol">)</a> <a id="2866" class="Symbol">→</a>
    <a id="2872" class="Symbol">(</a><a id="2873" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2875" class="Symbol">(</a><a id="2876" href="Axiom.html#2846" class="Bound">X</a> <a id="2878" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="2881" href="Axiom.html#2833" class="Bound">Y</a><a id="2882" class="Symbol">)</a> <a id="2884" class="Symbol">λ</a> <a id="2886" href="Axiom.html#2886" class="Bound">j</a> <a id="2888" class="Symbol">→</a> <a id="2890" href="Axiom.html#2828" class="Bound">C</a> <a id="2892" href="Axiom.html#2843" class="Bound">a</a> <a id="2894" href="Axiom.html#2830" class="Bound">b</a> <a id="2896" href="Axiom.html#2886" class="Bound">j</a><a id="2897" class="Symbol">)</a> <a id="2899" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2901" href="Axiom.html#2674" class="Function">unique</a> <a id="2908" class="Symbol">(</a><a id="2909" href="Axiom.html#2828" class="Bound">C</a> <a id="2911" href="Axiom.html#2843" class="Bound">a</a> <a id="2913" href="Axiom.html#2830" class="Bound">b</a><a id="2914" class="Symbol">)</a>
</pre>
<p>我们约定用 <code>A</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code> <code>X′</code> <code>Y′</code> 表示集合, 用 <code>f</code> <code>g</code> <code>h</code> <code>f′</code> <code>g′</code> 表示函数.</p>
<pre class="Agda">  <a id="3004" class="Keyword">variable</a>
    <a id="3017" href="Axiom.html#3017" class="Generalizable">A</a> <a id="3019" href="Axiom.html#3019" class="Generalizable">W</a> <a id="3021" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3023" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="3025" href="Axiom.html#3025" class="Generalizable">Z</a> <a id="3027" href="Axiom.html#3027" class="Generalizable">X′</a> <a id="3030" href="Axiom.html#3030" class="Generalizable">Y′</a> <a id="3033" class="Symbol">:</a> <a id="3035" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="3044" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3046" href="Axiom.html#3046" class="Generalizable">g</a> <a id="3048" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3050" href="Axiom.html#3050" class="Generalizable">f′</a> <a id="3053" href="Axiom.html#3053" class="Generalizable">g′</a> <a id="3056" class="Symbol">:</a> <a id="3058" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3060" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="3063" href="Axiom.html#3023" class="Generalizable">Y</a>
</pre>
<h2 id="公理">公理</h2>
<p>我们现在可以引入 ETCS 的10条公理.</p>
<pre class="Agda">  <a id="3110" class="Keyword">record</a> <a id="Data.Axiom"></a><a id="3117" href="Axiom.html#3117" class="Record">Axiom</a> <a id="3123" class="Symbol">:</a> <a id="3125" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3129" class="Keyword">where</a>
</pre>
<p><strong>公理 1 (范畴)</strong> 以下三个命题成立.</p>
<ol type="1">
<li>复合运算满足结合律.</li>
<li>恒等函数是复合运算的左单位元.</li>
<li>恒等函数是复合运算的右单位元.</li>
</ol>
<pre class="Agda">    <a id="3230" class="Keyword">field</a>
      <a id="3242" class="Comment">-- Axiom 1</a>
      <a id="3259" href="Axiom.html#3259" class="Field">AxAss</a> <a id="3265" class="Symbol">:</a> <a id="3267" class="Symbol">(</a><a id="3268" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3270" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3272" href="Axiom.html#3046" class="Generalizable">g</a><a id="3273" class="Symbol">)</a> <a id="3275" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3277" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3279" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3281" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3283" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Axiom.html#3046" class="Generalizable">g</a> <a id="3288" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3290" href="Axiom.html#3044" class="Generalizable">f</a><a id="3291" class="Symbol">)</a>
      <a id="3299" href="Axiom.html#3299" class="Field">AxIdˡ</a> <a id="3305" class="Symbol">:</a> <a id="3307" href="Axiom.html#1800" class="Function">id</a> <a id="3310" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3312" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3314" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3316" href="Axiom.html#3044" class="Generalizable">f</a>
      <a id="3324" href="Axiom.html#3324" class="Field">AxIdʳ</a> <a id="3330" class="Symbol">:</a> <a id="3332" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3334" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3336" href="Axiom.html#1800" class="Function">id</a> <a id="3339" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3341" href="Axiom.html#3044" class="Generalizable">f</a>
</pre>
<p><strong>定义 2.3.1</strong> 我们说一个集合 <code>T</code> 是终集合, 当且仅当对任意集合 <code>X</code>, 存在唯一的 <code>j : X →̇ T</code>. 注意终集合的图式没有箭头, 只有一个集合, 且终集合的交换模式是恒真.</p>
<pre class="Agda">    <a id="3463" class="Comment">-- Definition 2.3.1</a>
    <a id="3487" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3496" class="Symbol">:</a> <a id="3498" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="3508" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3517" class="Symbol">=</a> <a id="3519" class="Symbol">λ</a> <a id="3521" href="Axiom.html#3521" class="Bound">_</a> <a id="3523" class="Symbol">→</a> <a id="3525" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3532" href="Axiom.html#3532" class="Bound">TerminalCommuter</a> <a id="3549" class="Symbol">:</a> <a id="3551" href="Axiom.html#2437" class="Function">Commuter</a> <a id="3560" href="Axiom.html#3487" class="Bound">Terminal</a>
    <a id="3573" href="Axiom.html#3532" class="Bound">TerminalCommuter</a> <a id="3590" class="Symbol">=</a> <a id="3592" class="Symbol">λ</a> <a id="3594" href="Axiom.html#3594" class="Bound">_</a> <a id="3596" href="Axiom.html#3596" class="Bound">_</a> <a id="3598" href="Axiom.html#3598" class="Bound">_</a> <a id="3600" class="Symbol">→</a> <a id="3602" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3609" href="Axiom.html#3609" class="Bound">isTerminal</a> <a id="3620" class="Symbol">:</a> <a id="3622" href="Axiom.html#2192" class="Function">Diagram</a> <a id="3630" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3639" class="Symbol">→</a> <a id="3641" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="3649" href="Axiom.html#3609" class="Bound">isTerminal</a> <a id="3660" class="Symbol">=</a> <a id="3662" href="Axiom.html#2757" class="Function">universal</a> <a id="3672" href="Axiom.html#3532" class="Bound">TerminalCommuter</a>
</pre>
<p><strong>公理 2 (终集)</strong> 存在一个终集合.</p>
<pre class="Agda">    <a id="3730" class="Comment">-- Axiom 2</a>
    <a id="3745" class="Keyword">field</a> <a id="3751" href="Axiom.html#3751" class="Field">AxTml</a> <a id="3757" class="Symbol">:</a> <a id="3759" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="3761" class="Symbol">(</a><a id="3762" href="Axiom.html#2192" class="Function">Diagram</a> <a id="3770" href="Axiom.html#3487" class="Bound">Terminal</a><a id="3778" class="Symbol">)</a> <a id="3780" href="Axiom.html#3609" class="Bound">isTerminal</a>
</pre>
<p>我们将在后篇证明这样的终集合是唯一的. 实际上, 我们会证明所有用泛性质框定的集合都是唯一的. 所以定义了一种泛性质就唯一定义了一种集合, 所以我们后面会直接说「定义某种集合的泛性质」, 这应该理解为就是在「定义某种集合」.</p>
<p>我们把公理2承诺的集合记作 <code>１</code>, 因为它里面只有一个元素, 这会在下一章证明.</p>
<pre class="Agda">    <a id="3965" href="Axiom.html#3965" class="Bound">１</a> <a id="3967" class="Symbol">:</a> <a id="3969" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="3978" href="Axiom.html#3965" class="Bound">１</a> <a id="3980" class="Symbol">=</a> <a id="3982" href="Axiom.html#3751" class="Field">AxTml</a> <a id="3988" class="Symbol">.</a><a id="3989" href="Axiom.html#949" class="Field">fst</a> <a id="3993" class="Symbol">.</a><a id="3994" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p><strong>定义 2.3.6</strong> 给定集合 <code>X</code>, 我们把 <code>１</code> 到 <code>X</code> 的函数称为 <code>X</code> 的元素, 其类型记作 <code>Elm X</code>. 我们将 <code>x : Elm X</code> 简记为 <code>x ∈ X</code>.</p>
<pre class="Agda">    <a id="4112" class="Comment">-- Definition 2.3.6</a>
    <a id="4136" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4140" class="Symbol">:</a> <a id="4142" href="Axiom.html#1662" class="Field">CSet</a> <a id="4147" class="Symbol">→</a> <a id="4149" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4157" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4161" class="Symbol">=</a> <a id="4163" href="Axiom.html#3965" class="Bound">１</a> <a id="4165" href="Axiom.html#1677" class="Field Operator">→̇_</a>

    <a id="4174" href="Axiom.html#4174" class="Bound">∀[∈]-syntax</a> <a id="4186" class="Symbol">:</a> <a id="4188" class="Symbol">(</a><a id="4189" href="Axiom.html#4189" class="Bound">X</a> <a id="4191" class="Symbol">:</a> <a id="4193" href="Axiom.html#1662" class="Field">CSet</a><a id="4197" class="Symbol">)</a> <a id="4199" class="Symbol">(</a><a id="4200" href="Axiom.html#4200" class="Bound">P</a> <a id="4202" class="Symbol">:</a> <a id="4204" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4208" href="Axiom.html#4189" class="Bound">X</a> <a id="4210" class="Symbol">→</a> <a id="4212" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4215" class="Symbol">)</a> <a id="4217" class="Symbol">→</a> <a id="4219" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4227" href="Axiom.html#4174" class="Bound">∀[∈]-syntax</a> <a id="4239" href="Axiom.html#4239" class="Bound">X</a> <a id="4241" href="Axiom.html#4241" class="Bound">P</a> <a id="4243" class="Symbol">=</a> <a id="4245" class="Symbol">(</a><a id="4246" href="Axiom.html#4246" class="Bound">x</a> <a id="4248" class="Symbol">:</a> <a id="4250" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4254" href="Axiom.html#4239" class="Bound">X</a><a id="4255" class="Symbol">)</a> <a id="4257" class="Symbol">→</a> <a id="4259" href="Axiom.html#4241" class="Bound">P</a> <a id="4261" href="Axiom.html#4246" class="Bound">x</a>

    <a id="4268" class="Keyword">infix</a> <a id="4274" class="Number">3</a> <a id="4276" href="Axiom.html#4174" class="Function">∀[∈]-syntax</a>
    <a id="4292" class="Keyword">syntax</a> <a id="4299" href="Axiom.html#4174" class="Function">∀[∈]-syntax</a> <a id="4311" class="Bound">X</a> <a id="4313" class="Symbol">(λ</a> <a id="4316" class="Bound">x</a> <a id="4318" class="Symbol">→</a> <a id="4320" class="Bound">A</a><a id="4321" class="Symbol">)</a> <a id="4323" class="Symbol">=</a> <a id="4325" class="Function">∀[</a> <a id="4328" class="Bound">x</a> <a id="4330" class="Function">∈</a> <a id="4332" class="Bound">X</a> <a id="4334" class="Function">]</a> <a id="4336" class="Bound">A</a>

    <a id="4343" href="Axiom.html#4343" class="Bound">∃[∈]-syntax</a> <a id="4355" class="Symbol">:</a> <a id="4357" class="Symbol">(</a><a id="4358" href="Axiom.html#4358" class="Bound">X</a> <a id="4360" class="Symbol">:</a> <a id="4362" href="Axiom.html#1662" class="Field">CSet</a><a id="4366" class="Symbol">)</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Axiom.html#4369" class="Bound">P</a> <a id="4371" class="Symbol">:</a> <a id="4373" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4377" href="Axiom.html#4358" class="Bound">X</a> <a id="4379" class="Symbol">→</a> <a id="4381" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4384" class="Symbol">)</a> <a id="4386" class="Symbol">→</a> <a id="4388" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4396" href="Axiom.html#4343" class="Bound">∃[∈]-syntax</a> <a id="4408" href="Axiom.html#4408" class="Bound">X</a> <a id="4410" href="Axiom.html#4410" class="Bound">P</a> <a id="4412" class="Symbol">=</a> <a id="4414" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="4416" class="Symbol">(</a><a id="4417" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4421" href="Axiom.html#4408" class="Bound">X</a><a id="4422" class="Symbol">)</a> <a id="4424" href="Axiom.html#4410" class="Bound">P</a>

    <a id="4431" class="Keyword">infix</a> <a id="4437" class="Number">3</a> <a id="4439" href="Axiom.html#4343" class="Function">∃[∈]-syntax</a>
    <a id="4455" class="Keyword">syntax</a> <a id="4462" href="Axiom.html#4343" class="Function">∃[∈]-syntax</a> <a id="4474" class="Bound">X</a> <a id="4476" class="Symbol">(λ</a> <a id="4479" class="Bound">x</a> <a id="4481" class="Symbol">→</a> <a id="4483" class="Bound">A</a><a id="4484" class="Symbol">)</a> <a id="4486" class="Symbol">=</a> <a id="4488" class="Function">∃[</a> <a id="4491" class="Bound">x</a> <a id="4493" class="Function">∈</a> <a id="4495" class="Bound">X</a> <a id="4497" class="Function">]</a> <a id="4499" class="Bound">A</a>
</pre>
<p><strong>注意</strong> <code>x ∈ X</code> 是一个声明而不是可以讨论真假的命题, 这一点与质料集合论 (ZFC等) 不同. 就像我们说「任意/存在集合 <code>X</code>, 怎么怎么样」一样, 这里不存在 「<code>X</code> 是不是集合」的问题, 我们也只能说「任意/存在元素 <code>x ∈ X</code>, 怎么怎么样」, 而不存在 「<code>x</code> 是不是 <code>X</code> 的元素」的问题.</p>
<p>给定函数 <code>f : X →̇ Y</code> 和一个元素 <code>x ∈ X</code>, 我们把复合函数 <code>f ∘ x</code> 记作 <code>f ⦅ x ⦆</code>.</p>
<pre class="Agda">    <a id="4748" class="Keyword">infix</a> <a id="4754" class="Number">15</a> <a id="4757" href="Axiom.html#4766" class="Function Operator">_⦅_⦆</a>
    <a id="4766" href="Axiom.html#4766" class="Bound Operator">_⦅_⦆</a> <a id="4771" class="Symbol">:</a> <a id="4773" class="Symbol">(</a><a id="4774" href="Axiom.html#4774" class="Bound">f</a> <a id="4776" class="Symbol">:</a> <a id="4778" href="Axiom.html#3021" class="Generalizable">X</a> <a id="4780" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="4783" href="Axiom.html#3023" class="Generalizable">Y</a><a id="4784" class="Symbol">)</a> <a id="4786" class="Symbol">→</a> <a id="4788" href="Axiom.html#4174" class="Bound">∀[</a> <a id="4791" href="Axiom.html#4791" class="Bound">x</a> <a id="4793" href="Axiom.html#4174" class="Bound">∈</a> <a id="4795" href="Axiom.html#3021" class="Generalizable">X</a> <a id="4797" href="Axiom.html#4174" class="Bound">]</a> <a id="4799" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4803" href="Axiom.html#3023" class="Generalizable">Y</a>
    <a id="4809" href="Axiom.html#4809" class="Bound">f</a> <a id="4811" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="4813" href="Axiom.html#4813" class="Bound">x</a> <a id="4815" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="4817" class="Symbol">=</a> <a id="4819" href="Axiom.html#4809" class="Bound">f</a> <a id="4821" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="4823" href="Axiom.html#4813" class="Bound">x</a>
</pre>
<p><strong>公理 3 (函数外延)</strong> 对任意集合 <code>X Y : CSet</code> 以及函数 <code>f g : X →̇ Y</code>, 如果对任意 <code>x ∈ X</code> 都有 <code>f ⦅ x ⦆ ≡ g ⦅ x ⦆</code>, 那么 <code>f ≡ g</code>.</p>
<pre class="Agda">    <a id="4949" class="Comment">-- Axiom 3</a>
    <a id="4964" class="Keyword">field</a> <a id="4970" href="Axiom.html#4970" class="Field">AxFunExt</a> <a id="4979" class="Symbol">:</a> <a id="4981" class="Symbol">(</a><a id="4982" href="Axiom.html#4174" class="Bound">∀[</a> <a id="4985" href="Axiom.html#4985" class="Bound">x</a> <a id="4987" href="Axiom.html#4174" class="Bound">∈</a> <a id="4989" href="Axiom.html#3021" class="Generalizable">X</a> <a id="4991" href="Axiom.html#4174" class="Bound">]</a> <a id="4993" href="Axiom.html#3044" class="Generalizable">f</a> <a id="4995" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="4997" href="Axiom.html#4985" class="Bound">x</a> <a id="4999" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="5001" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5003" href="Axiom.html#3046" class="Generalizable">g</a> <a id="5005" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="5007" href="Axiom.html#4985" class="Bound">x</a> <a id="5009" href="Axiom.html#4766" class="Bound Operator">⦆</a><a id="5010" class="Symbol">)</a> <a id="5012" class="Symbol">→</a> <a id="5014" href="Axiom.html#3044" class="Generalizable">f</a> <a id="5016" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5018" href="Axiom.html#3046" class="Generalizable">g</a>
</pre>
<p><strong>定义 2.5.1</strong> 我们称一个集合 <code>X</code> 为空集, 当且仅当对任意 <code>x ∈ X</code> 都有 <code>⊥</code>.</p>
<pre class="Agda">    <a id="5092" class="Comment">-- Definition 2.5.1</a>
    <a id="5116" href="Axiom.html#5116" class="Bound">empty</a> <a id="5122" class="Symbol">:</a> <a id="5124" href="Axiom.html#1662" class="Field">CSet</a> <a id="5129" class="Symbol">→</a> <a id="5131" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5139" href="Axiom.html#5116" class="Bound">empty</a> <a id="5145" href="Axiom.html#5145" class="Bound">X</a> <a id="5147" class="Symbol">=</a> <a id="5149" href="Axiom.html#4174" class="Bound">∀[</a> <a id="5152" href="Axiom.html#5152" class="Bound">x</a> <a id="5154" href="Axiom.html#4174" class="Bound">∈</a> <a id="5156" href="Axiom.html#5145" class="Bound">X</a> <a id="5158" href="Axiom.html#4174" class="Bound">]</a> <a id="5160" href="Data.Empty.html#914" class="Function">⊥</a>
</pre>
<p><strong>公理 4 (空集)</strong> 存在一个空集.</p>
<pre class="Agda">    <a id="5202" class="Comment">-- Axiom 4</a>
    <a id="5217" class="Keyword">field</a> <a id="5223" href="Axiom.html#5223" class="Field">AxEmpty</a> <a id="5231" class="Symbol">:</a> <a id="5233" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="5235" href="Axiom.html#1662" class="Field">CSet</a> <a id="5240" href="Axiom.html#5116" class="Bound">empty</a>
</pre>
<p><strong>定义 2.6.2</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的积的泛性质.</p>
<p>第一步, 定义积图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>P</code></li>
<li>一个函数 <code>p : P →̇ X</code></li>
<li>一个函数 <code>q : P →̇ Y</code></li>
</ul>
<p>于是一个积图式具有如下形式</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-7e2a8ae22d3645250a1f82970ba78df1.png" alt="积图式" />
<figcaption aria-hidden="true">积图式</figcaption>
</figure>
<p>我们将这样的积图式简记作 <code>(P , p , q)</code>.</p>
<p>第二步, 定义积图式的交换: 我们说两个积图式 <code>(A , f , g)</code> 和 <code>(P , p , q)</code> 以及底集间映射 <code>h : A →̇ P</code> 交换, 当且仅当 <code>p ∘ h ≡ f</code> 且 <code>q ∘ h ≡ g</code>.</p>
<p>第三步, 定义积的泛性质: 我们说一个积图式 <code>(P , p , q)</code> 满足积的泛性质, 当且仅当对任意积图式 <code>(A , f , g)</code>, 存在唯一的底集间映射 <code>h : A →̇ P</code> 使得它们交换.</p>
<pre class="Agda">    <a id="5725" class="Comment">-- Definition 2.6.2</a>
    <a id="5749" href="Axiom.html#5749" class="Bound">Product</a> <a id="5757" class="Symbol">:</a> <a id="5759" class="Symbol">(</a><a id="5760" href="Axiom.html#5760" class="Bound">X</a> <a id="5762" href="Axiom.html#5762" class="Bound">Y</a> <a id="5764" class="Symbol">:</a> <a id="5766" href="Axiom.html#1662" class="Field">CSet</a><a id="5770" class="Symbol">)</a> <a id="5772" class="Symbol">→</a> <a id="5774" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="5784" href="Axiom.html#5749" class="Bound">Product</a> <a id="5792" href="Axiom.html#5792" class="Bound">X</a> <a id="5794" href="Axiom.html#5794" class="Bound">Y</a> <a id="5796" class="Symbol">=</a> <a id="5798" class="Symbol">λ</a> <a id="5800" href="Axiom.html#5800" class="Bound">P</a> <a id="5802" class="Symbol">→</a> <a id="5804" href="Axiom.html#5800" class="Bound">P</a> <a id="5806" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="5809" href="Axiom.html#5792" class="Bound">X</a> <a id="5811" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5813" href="Axiom.html#5800" class="Bound">P</a> <a id="5815" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="5818" href="Axiom.html#5794" class="Bound">Y</a>

    <a id="5825" href="Axiom.html#5825" class="Bound">ProductCommuter</a> <a id="5841" class="Symbol">:</a> <a id="5843" href="Axiom.html#2437" class="Function">Commuter</a> <a id="5852" class="Symbol">(</a><a id="5853" href="Axiom.html#5749" class="Bound">Product</a> <a id="5861" href="Axiom.html#3021" class="Generalizable">X</a> <a id="5863" href="Axiom.html#3023" class="Generalizable">Y</a><a id="5864" class="Symbol">)</a>
    <a id="5870" href="Axiom.html#5825" class="Bound">ProductCommuter</a> <a id="5886" class="Symbol">=</a> <a id="5888" class="Symbol">λ</a> <a id="5890" class="Symbol">(</a><a id="5891" href="Axiom.html#5891" class="Bound">A</a> <a id="5893" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5895" href="Axiom.html#5895" class="Bound">f</a> <a id="5897" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5899" href="Axiom.html#5899" class="Bound">g</a><a id="5900" class="Symbol">)</a> <a id="5902" class="Symbol">(</a><a id="5903" href="Axiom.html#5903" class="Bound">P</a> <a id="5905" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5907" href="Axiom.html#5907" class="Bound">p</a> <a id="5909" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5911" href="Axiom.html#5911" class="Bound">q</a><a id="5912" class="Symbol">)</a> <a id="5914" href="Axiom.html#5914" class="Bound">h</a> <a id="5916" class="Symbol">→</a> <a id="5918" href="Axiom.html#5907" class="Bound">p</a> <a id="5920" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="5922" href="Axiom.html#5914" class="Bound">h</a> <a id="5924" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5926" href="Axiom.html#5895" class="Bound">f</a> <a id="5928" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5930" href="Axiom.html#5911" class="Bound">q</a> <a id="5932" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="5934" href="Axiom.html#5914" class="Bound">h</a> <a id="5936" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5938" href="Axiom.html#5899" class="Bound">g</a>

    <a id="5945" href="Axiom.html#5945" class="Bound">isProduct</a> <a id="5955" class="Symbol">:</a> <a id="5957" href="Axiom.html#2192" class="Function">Diagram</a> <a id="5965" class="Symbol">(</a><a id="5966" href="Axiom.html#5749" class="Bound">Product</a> <a id="5974" href="Axiom.html#3021" class="Generalizable">X</a> <a id="5976" href="Axiom.html#3023" class="Generalizable">Y</a><a id="5977" class="Symbol">)</a> <a id="5979" class="Symbol">→</a> <a id="5981" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5989" href="Axiom.html#5945" class="Bound">isProduct</a> <a id="5999" class="Symbol">=</a> <a id="6001" href="Axiom.html#2757" class="Function">universal</a> <a id="6011" href="Axiom.html#5825" class="Bound">ProductCommuter</a>
</pre>
<p><strong>公理 5 (积)</strong> 对任意集合 <code>X Y : CSet</code>, 存在积图式满足积的泛性质.</p>
<pre class="Agda">    <a id="6092" class="Comment">-- Axiom 5</a>
    <a id="6107" class="Keyword">field</a> <a id="6113" href="Axiom.html#6113" class="Field">AxProd</a> <a id="6120" class="Symbol">:</a> <a id="6122" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="6124" class="Symbol">(</a><a id="6125" href="Axiom.html#2192" class="Function">Diagram</a> <a id="6133" class="Symbol">(</a><a id="6134" href="Axiom.html#5749" class="Bound">Product</a> <a id="6142" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6144" href="Axiom.html#3023" class="Generalizable">Y</a><a id="6145" class="Symbol">))</a> <a id="6148" href="Axiom.html#5945" class="Bound">isProduct</a>
</pre>
<p>给定集合 <code>X Y : CSet</code>, 我们把公理5所承诺的积图式的底集称为 <code>X</code> 和 <code>Y</code> 的积, 记作 <code>X ×̇ Y</code>.</p>
<pre class="Agda">    <a id="6241" class="Keyword">infixr</a> <a id="6248" class="Number">15</a> <a id="6251" href="Axiom.html#6260" class="Function Operator">_×̇_</a>
    <a id="6260" href="Axiom.html#6260" class="Bound Operator">_×̇_</a> <a id="6265" class="Symbol">:</a> <a id="6267" href="Axiom.html#1662" class="Field">CSet</a> <a id="6272" class="Symbol">→</a> <a id="6274" href="Axiom.html#1662" class="Field">CSet</a> <a id="6279" class="Symbol">→</a> <a id="6281" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="6290" href="Axiom.html#6290" class="Bound">X</a> <a id="6292" href="Axiom.html#6260" class="Bound Operator">×̇</a> <a id="6295" href="Axiom.html#6295" class="Bound">Y</a> <a id="6297" class="Symbol">=</a> <a id="6299" href="Axiom.html#6113" class="Field">AxProd</a> <a id="6306" class="Symbol">{</a><a id="6307" href="Axiom.html#6290" class="Bound">X</a><a id="6308" class="Symbol">}</a> <a id="6310" class="Symbol">{</a><a id="6311" href="Axiom.html#6295" class="Bound">Y</a><a id="6312" class="Symbol">}</a> <a id="6314" class="Symbol">.</a><a id="6315" href="Axiom.html#949" class="Field">fst</a> <a id="6319" class="Symbol">.</a><a id="6320" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p>给定集合 <code>X Y A : CSet</code> 和函数 <code>f : A →̇ X</code> <code>g : A →̇ Y</code>, 公理5承诺了积图示 <code>(A , f , g)</code> 到积图示 <code>(X ×̇ Y , p , q)</code> 的底集间唯一映射, 我们记作 <code>f ,̇ g : A →̇ X ×̇ Y</code>. 如下图所示, 其中虚线表示唯一. 特别地, 当 <code>A ≡ １</code> 时, <code>f</code> 是 <code>X</code> 的元素, <code>g</code> 是 <code>Y</code> 的元素, <code>f ,̇ g</code> 是 <code>X ×̇ Y</code> 的元素.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2cfcd05207f77e2d965658d158731767.png" alt="积的元素" />
<figcaption aria-hidden="true">积的元素</figcaption>
</figure>
<pre class="Agda">    <a id="6646" class="Keyword">infixr</a> <a id="6653" class="Number">5</a> <a id="6655" href="Axiom.html#6664" class="Function Operator">_,̇_</a>
    <a id="6664" href="Axiom.html#6664" class="Bound Operator">_,̇_</a> <a id="6669" class="Symbol">:</a> <a id="6671" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6673" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6676" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6678" class="Symbol">→</a> <a id="6680" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6682" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6685" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="6687" class="Symbol">→</a> <a id="6689" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6691" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6694" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6696" href="Axiom.html#6260" class="Bound Operator">×̇</a> <a id="6699" href="Axiom.html#3023" class="Generalizable">Y</a>
    <a id="6705" href="Axiom.html#6705" class="Bound">f</a> <a id="6707" href="Axiom.html#6664" class="Bound Operator">,̇</a> <a id="6710" href="Axiom.html#6710" class="Bound">g</a> <a id="6712" class="Symbol">=</a> <a id="6714" href="Axiom.html#6113" class="Field">AxProd</a> <a id="6721" class="Symbol">.</a><a id="6722" href="Axiom.html#963" class="Field">snd</a> <a id="6726" class="Symbol">(_</a> <a id="6729" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6731" href="Axiom.html#6705" class="Bound">f</a> <a id="6733" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6735" href="Axiom.html#6710" class="Bound">g</a><a id="6736" class="Symbol">)</a> <a id="6738" class="Symbol">.</a><a id="6739" href="Axiom.html#949" class="Field">fst</a> <a id="6743" class="Symbol">.</a><a id="6744" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p><strong>定义 2.7.3</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的函数集 (简称幂) 的泛性质.</p>
<p>第一步, 定义幂图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>F</code></li>
<li>一个函数 <code>e : F ×̇ X →̇ Y</code></li>
</ul>
<p>简记作 <code>(F , e)</code>.</p>
<p>第二步, 定义幂图式的交换: 我们说两个幂图式 <code>(A , q)</code> 和 <code>(F , e)</code> 以及底集间映射 <code>q̅ : A →̇ F</code> 交换, 当且仅当对任意 <code>a ∈ A</code> 和 <code>x ∈ X</code> 都有 <code>q ⦅ a ,̇ x ⦆ ≡ e ⦅ q̅ ⦅ a ⦆ ,̇ x ⦆</code>.</p>
<p>第三步, 定义幂的泛性质: 我们说一个幂图式 <code>(F , e)</code> 满足幂的泛性质, 当且仅当对任意幂图式 <code>(A , q)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ F</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2874a6ccdc996e99f8027e4b11e2383d.png" alt="幂的泛性质" />
<figcaption aria-hidden="true">幂的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="7216" class="Comment">-- Definition 2.7.3</a>
    <a id="7240" href="Axiom.html#7240" class="Bound">FuncSet</a> <a id="7248" class="Symbol">:</a> <a id="7250" class="Symbol">(</a><a id="7251" href="Axiom.html#7251" class="Bound">X</a> <a id="7253" href="Axiom.html#7253" class="Bound">Y</a> <a id="7255" class="Symbol">:</a> <a id="7257" href="Axiom.html#1662" class="Field">CSet</a><a id="7261" class="Symbol">)</a> <a id="7263" class="Symbol">→</a> <a id="7265" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="7275" href="Axiom.html#7240" class="Bound">FuncSet</a> <a id="7283" href="Axiom.html#7283" class="Bound">X</a> <a id="7285" href="Axiom.html#7285" class="Bound">Y</a> <a id="7287" class="Symbol">=</a> <a id="7289" class="Symbol">λ</a> <a id="7291" href="Axiom.html#7291" class="Bound">F</a> <a id="7293" class="Symbol">→</a> <a id="7295" href="Axiom.html#7291" class="Bound">F</a> <a id="7297" href="Axiom.html#6260" class="Bound Operator">×̇</a> <a id="7300" href="Axiom.html#7283" class="Bound">X</a> <a id="7302" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="7305" href="Axiom.html#7285" class="Bound">Y</a>

    <a id="7312" href="Axiom.html#7312" class="Bound">FuncSetCommuter</a> <a id="7328" class="Symbol">:</a> <a id="7330" href="Axiom.html#2437" class="Function">Commuter</a> <a id="7339" class="Symbol">(</a><a id="7340" href="Axiom.html#7240" class="Bound">FuncSet</a> <a id="7348" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7350" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7351" class="Symbol">)</a>
    <a id="7357" href="Axiom.html#7312" class="Bound">FuncSetCommuter</a> <a id="7373" class="Symbol">{</a><a id="7374" href="Axiom.html#7374" class="Bound">X</a><a id="7375" class="Symbol">}</a> <a id="7377" class="Symbol">=</a> <a id="7379" class="Symbol">λ</a> <a id="7381" class="Symbol">(</a><a id="7382" href="Axiom.html#7382" class="Bound">A</a> <a id="7384" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7386" href="Axiom.html#7386" class="Bound">q</a><a id="7387" class="Symbol">)</a> <a id="7389" class="Symbol">(</a><a id="7390" href="Axiom.html#7390" class="Bound">F</a> <a id="7392" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7394" href="Axiom.html#7394" class="Bound">e</a><a id="7395" class="Symbol">)</a> <a id="7397" href="Axiom.html#7397" class="Bound">q̅</a> <a id="7400" class="Symbol">→</a>
      <a id="7408" href="Axiom.html#4174" class="Bound">∀[</a> <a id="7411" href="Axiom.html#7411" class="Bound">a</a> <a id="7413" href="Axiom.html#4174" class="Bound">∈</a> <a id="7415" href="Axiom.html#7382" class="Bound">A</a> <a id="7417" href="Axiom.html#4174" class="Bound">]</a> <a id="7419" href="Axiom.html#4174" class="Bound">∀[</a> <a id="7422" href="Axiom.html#7422" class="Bound">x</a> <a id="7424" href="Axiom.html#4174" class="Bound">∈</a> <a id="7426" href="Axiom.html#7374" class="Bound">X</a> <a id="7428" href="Axiom.html#4174" class="Bound">]</a> <a id="7430" href="Axiom.html#7386" class="Bound">q</a> <a id="7432" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="7434" href="Axiom.html#7411" class="Bound">a</a> <a id="7436" href="Axiom.html#6664" class="Bound Operator">,̇</a> <a id="7439" href="Axiom.html#7422" class="Bound">x</a> <a id="7441" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="7443" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7445" href="Axiom.html#7394" class="Bound">e</a> <a id="7447" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="7449" href="Axiom.html#7397" class="Bound">q̅</a> <a id="7452" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="7454" href="Axiom.html#7411" class="Bound">a</a> <a id="7456" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="7458" href="Axiom.html#6664" class="Bound Operator">,̇</a> <a id="7461" href="Axiom.html#7422" class="Bound">x</a> <a id="7463" href="Axiom.html#4766" class="Bound Operator">⦆</a>

    <a id="7470" href="Axiom.html#7470" class="Bound">isFuncSet</a> <a id="7480" class="Symbol">:</a> <a id="7482" href="Axiom.html#2192" class="Function">Diagram</a> <a id="7490" class="Symbol">(</a><a id="7491" href="Axiom.html#7240" class="Bound">FuncSet</a> <a id="7499" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7501" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7502" class="Symbol">)</a> <a id="7504" class="Symbol">→</a> <a id="7506" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="7514" href="Axiom.html#7470" class="Bound">isFuncSet</a> <a id="7524" class="Symbol">=</a> <a id="7526" href="Axiom.html#2757" class="Function">universal</a> <a id="7536" href="Axiom.html#7312" class="Bound">FuncSetCommuter</a>
</pre>
<p><strong>公理 6 (幂)</strong> 对任意集合 <code>X Y : CSet</code>, 存在幂图式满足幂的泛性质.</p>
<pre class="Agda">    <a id="7617" class="Comment">-- Axiom 6</a>
    <a id="7632" class="Keyword">field</a> <a id="7638" href="Axiom.html#7638" class="Field">AxFuncSet</a> <a id="7648" class="Symbol">:</a> <a id="7650" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="7652" class="Symbol">(</a><a id="7653" href="Axiom.html#2192" class="Function">Diagram</a> <a id="7661" class="Symbol">(</a><a id="7662" href="Axiom.html#7240" class="Bound">FuncSet</a> <a id="7670" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7672" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7673" class="Symbol">))</a> <a id="7676" href="Axiom.html#7470" class="Bound">isFuncSet</a>
</pre>
<p><strong>定义 3.1.4</strong> 给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 我们按以下四步定义关于 <code>f</code> 和 <code>y</code> 的纤维的泛性质.</p>
<p>第零步, 定义什么叫纤维: 我们说一个集合 <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维, 记作 <code>U withInclusion i isFibreOf f over y</code>, 当且仅当对任意 <code>u ∈ U</code> 都有 <code>f ⦅ i ⦅ u ⦆ ⦆ ≡ y</code>, 也就是下图交换. 由于这样的 <code>U</code> 一般又记作 <span class="math inline">f^{-1}(y)</span>, 图中用此记法.</p>
<p>第一步, 定义纤维图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>U</code></li>
<li>一个函数 <code>i : U →̇ X</code></li>
<li>一个证明: <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维</li>
</ul>
<p>简记作 <code>(U , i , fiu)</code>.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-bcacd8638c0c142fb4422fe291b632f7.png" alt="纤维图式" />
<figcaption aria-hidden="true">纤维图式</figcaption>
</figure>
<p>第二步, 定义纤维图式的交换: 我们说两个纤维图式 <code>(A , q , fqa)</code> 和 <code>(U , i , fiu)</code> 以及底集间映射 <code>q̅ : A →̇ U</code> 交换, 当且仅当 <code>q ≡ i ∘ q̅</code>.</p>
<p>第三步, 定义纤维的泛性质: 我们说一个纤维图式 <code>(U , i , fiu)</code> 满足纤维的泛性质, 当且仅当对任意纤维图式 <code>(A , q , fqa)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ U</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-0f5d1b447ca9b15abfd4df13ad044223.png" alt="纤维的泛性质" />
<figcaption aria-hidden="true">纤维的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="8479" class="Comment">-- Definition 3.1.4</a>
    <a id="8503" href="Axiom.html#8503" class="Bound Operator">_withInclusion_isFibreOf_over_</a> <a id="8534" class="Symbol">:</a> <a id="8536" class="Symbol">(</a><a id="8537" href="Axiom.html#8537" class="Bound">U</a> <a id="8539" class="Symbol">:</a> <a id="8541" href="Axiom.html#1662" class="Field">CSet</a><a id="8545" class="Symbol">)</a> <a id="8547" class="Symbol">(</a><a id="8548" href="Axiom.html#8548" class="Bound">i</a> <a id="8550" class="Symbol">:</a> <a id="8552" href="Axiom.html#8537" class="Bound">U</a> <a id="8554" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8557" href="Axiom.html#3021" class="Generalizable">X</a><a id="8558" class="Symbol">)</a> <a id="8560" class="Symbol">(</a><a id="8561" href="Axiom.html#8561" class="Bound">f</a> <a id="8563" class="Symbol">:</a> <a id="8565" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8567" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8570" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8571" class="Symbol">)</a> <a id="8573" class="Symbol">(</a><a id="8574" href="Axiom.html#8574" class="Bound">y</a> <a id="8576" class="Symbol">:</a> <a id="8578" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8582" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8583" class="Symbol">)</a> <a id="8585" class="Symbol">→</a> <a id="8587" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8595" href="Axiom.html#8595" class="Bound">U</a> <a id="8597" href="Axiom.html#8503" class="Bound Operator">withInclusion</a> <a id="8611" href="Axiom.html#8611" class="Bound">i</a> <a id="8613" href="Axiom.html#8503" class="Bound Operator">isFibreOf</a> <a id="8623" href="Axiom.html#8623" class="Bound">f</a> <a id="8625" href="Axiom.html#8503" class="Bound Operator">over</a> <a id="8630" href="Axiom.html#8630" class="Bound">y</a> <a id="8632" class="Symbol">=</a> <a id="8634" href="Axiom.html#4174" class="Bound">∀[</a> <a id="8637" href="Axiom.html#8637" class="Bound">u</a> <a id="8639" href="Axiom.html#4174" class="Bound">∈</a> <a id="8641" class="Symbol">_</a> <a id="8643" href="Axiom.html#4174" class="Bound">]</a> <a id="8645" href="Axiom.html#8623" class="Bound">f</a> <a id="8647" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="8649" href="Axiom.html#8611" class="Bound">i</a> <a id="8651" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="8653" href="Axiom.html#8637" class="Bound">u</a> <a id="8655" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="8657" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="8659" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8661" href="Axiom.html#8630" class="Bound">y</a>

    <a id="8668" href="Axiom.html#8668" class="Bound">Fibre</a> <a id="8674" class="Symbol">:</a> <a id="8676" class="Symbol">(</a><a id="8677" href="Axiom.html#8677" class="Bound">f</a> <a id="8679" class="Symbol">:</a> <a id="8681" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8683" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8686" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8687" class="Symbol">)</a> <a id="8689" class="Symbol">(</a><a id="8690" href="Axiom.html#8690" class="Bound">y</a> <a id="8692" class="Symbol">:</a> <a id="8694" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8698" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8699" class="Symbol">)</a> <a id="8701" class="Symbol">→</a> <a id="8703" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="8713" href="Axiom.html#8668" class="Bound">Fibre</a> <a id="8719" class="Symbol">{</a><a id="8720" href="Axiom.html#8720" class="Bound">X</a><a id="8721" class="Symbol">}</a> <a id="8723" href="Axiom.html#8723" class="Bound">f</a> <a id="8725" href="Axiom.html#8725" class="Bound">y</a> <a id="8727" class="Symbol">=</a> <a id="8729" class="Symbol">λ</a> <a id="8731" href="Axiom.html#8731" class="Bound">U</a> <a id="8733" class="Symbol">→</a> <a id="8735" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="8737" class="Symbol">(</a><a id="8738" href="Axiom.html#8731" class="Bound">U</a> <a id="8740" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8743" href="Axiom.html#8720" class="Bound">X</a><a id="8744" class="Symbol">)</a> <a id="8746" class="Symbol">λ</a> <a id="8748" href="Axiom.html#8748" class="Bound">i</a> <a id="8750" class="Symbol">→</a> <a id="8752" href="Axiom.html#8731" class="Bound">U</a> <a id="8754" href="Axiom.html#8503" class="Bound Operator">withInclusion</a> <a id="8768" href="Axiom.html#8748" class="Bound">i</a> <a id="8770" href="Axiom.html#8503" class="Bound Operator">isFibreOf</a> <a id="8780" href="Axiom.html#8723" class="Bound">f</a> <a id="8782" href="Axiom.html#8503" class="Bound Operator">over</a> <a id="8787" href="Axiom.html#8725" class="Bound">y</a>

    <a id="8794" href="Axiom.html#8794" class="Bound">FibreCommuter</a> <a id="8808" class="Symbol">:</a> <a id="8810" class="Symbol">{</a><a id="8811" href="Axiom.html#8811" class="Bound">f</a> <a id="8813" class="Symbol">:</a> <a id="8815" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8817" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8820" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8821" class="Symbol">}</a> <a id="8823" class="Symbol">{</a><a id="8824" href="Axiom.html#8824" class="Bound">y</a> <a id="8826" class="Symbol">:</a> <a id="8828" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8832" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8833" class="Symbol">}</a> <a id="8835" class="Symbol">→</a> <a id="8837" href="Axiom.html#2437" class="Function">Commuter</a> <a id="8846" class="Symbol">(</a><a id="8847" href="Axiom.html#8668" class="Bound">Fibre</a> <a id="8853" href="Axiom.html#8811" class="Bound">f</a> <a id="8855" href="Axiom.html#8824" class="Bound">y</a><a id="8856" class="Symbol">)</a>
    <a id="8862" href="Axiom.html#8794" class="Bound">FibreCommuter</a> <a id="8876" class="Symbol">=</a> <a id="8878" class="Symbol">λ</a> <a id="8880" class="Symbol">(</a><a id="8881" href="Axiom.html#8881" class="Bound">A</a> <a id="8883" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8885" href="Axiom.html#8885" class="Bound">q</a> <a id="8887" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8889" href="Axiom.html#8889" class="Bound">fqa</a><a id="8892" class="Symbol">)</a> <a id="8894" class="Symbol">(</a><a id="8895" href="Axiom.html#8895" class="Bound">U</a> <a id="8897" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8899" href="Axiom.html#8899" class="Bound">i</a> <a id="8901" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8903" href="Axiom.html#8903" class="Bound">fiu</a><a id="8906" class="Symbol">)</a> <a id="8908" href="Axiom.html#8908" class="Bound">q̅</a> <a id="8911" class="Symbol">→</a> <a id="8913" href="Axiom.html#8885" class="Bound">q</a> <a id="8915" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8917" href="Axiom.html#8899" class="Bound">i</a> <a id="8919" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="8921" href="Axiom.html#8908" class="Bound">q̅</a>

    <a id="8929" href="Axiom.html#8929" class="Bound">isFibre</a> <a id="8937" class="Symbol">:</a> <a id="8939" class="Symbol">{</a><a id="8940" href="Axiom.html#8940" class="Bound">f</a> <a id="8942" class="Symbol">:</a> <a id="8944" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8946" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8949" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8950" class="Symbol">}</a> <a id="8952" class="Symbol">{</a><a id="8953" href="Axiom.html#8953" class="Bound">y</a> <a id="8955" class="Symbol">:</a> <a id="8957" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8961" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8962" class="Symbol">}</a> <a id="8964" class="Symbol">→</a> <a id="8966" href="Axiom.html#2192" class="Function">Diagram</a> <a id="8974" class="Symbol">(</a><a id="8975" href="Axiom.html#8668" class="Bound">Fibre</a> <a id="8981" href="Axiom.html#8940" class="Bound">f</a> <a id="8983" href="Axiom.html#8953" class="Bound">y</a><a id="8984" class="Symbol">)</a> <a id="8986" class="Symbol">→</a> <a id="8988" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8996" href="Axiom.html#8929" class="Bound">isFibre</a> <a id="9004" class="Symbol">=</a> <a id="9006" href="Axiom.html#2757" class="Function">universal</a> <a id="9016" href="Axiom.html#8794" class="Bound">FibreCommuter</a>
</pre>
<p><strong>公理 7 (纤维)</strong> 对任意 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在纤维图式满足纤维的泛性质.</p>
<pre class="Agda">    <a id="9108" class="Comment">-- Axiom 7</a>
    <a id="9123" class="Keyword">field</a> <a id="9129" href="Axiom.html#9129" class="Field">AxFibre</a> <a id="9137" class="Symbol">:</a> <a id="9139" class="Symbol">{</a><a id="9140" href="Axiom.html#9140" class="Bound">f</a> <a id="9142" class="Symbol">:</a> <a id="9144" href="Axiom.html#3021" class="Generalizable">X</a> <a id="9146" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="9149" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9150" class="Symbol">}</a> <a id="9152" class="Symbol">{</a><a id="9153" href="Axiom.html#9153" class="Bound">y</a> <a id="9155" class="Symbol">:</a> <a id="9157" href="Axiom.html#4136" class="Bound">Elm</a> <a id="9161" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9162" class="Symbol">}</a> <a id="9164" class="Symbol">→</a> <a id="9166" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9168" class="Symbol">(</a><a id="9169" href="Axiom.html#2192" class="Function">Diagram</a> <a id="9177" class="Symbol">(</a><a id="9178" href="Axiom.html#8668" class="Bound">Fibre</a> <a id="9184" href="Axiom.html#9140" class="Bound">f</a> <a id="9186" href="Axiom.html#9153" class="Bound">y</a><a id="9187" class="Symbol">))</a> <a id="9190" href="Axiom.html#8929" class="Bound">isFibre</a>
</pre>
<p><strong>定义 3.2.1</strong> 我们按以下三步定义子集分类器的泛性质.</p>
<p>第一步, 我们定义子集分类器图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>Ω</code></li>
<li>一个集合 <code>T</code></li>
<li>一个函数 <code>t : T →̇ Ω</code></li>
</ul>
<p>简记作 <code>(Ω , T , t)</code>.</p>
<p>第二步, 定义子集分类器图式的交换: 我们说两个子集分类器图式 <code>(A , X , i)</code> 和 <code>(Ω , T , t)</code> 以及底集间映射 <code>χ : A →̇ Ω</code> 交换, 当且仅当如果 <code>T ≡ １</code>, 那么 <code>X</code> 配合上 <code>i</code> 是 <code>χ</code> 在 <code>t</code> 上的纤维.</p>
<p>第三步, 定义子集分类器的泛性质: 我们说一个子集分类器图式 <code>(Ω , T , t)</code> 满足子集分类器的泛性质, 当且仅当对任意子集分类器图式 <code>(A , X , i)</code>, 存在唯一的底集间映射 <code>χ : A →̇ Ω</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-f1f7a1eec3df674886ffa5161566c82b.png" alt="子集分类器的泛性质" />
<figcaption aria-hidden="true">子集分类器的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="9679" class="Comment">-- Definition 3.2.1</a>
    <a id="9703" href="Axiom.html#9703" class="Bound">SubCls</a> <a id="9710" class="Symbol">:</a> <a id="9712" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="9722" href="Axiom.html#9703" class="Bound">SubCls</a> <a id="9729" class="Symbol">=</a> <a id="9731" class="Symbol">λ</a> <a id="9733" href="Axiom.html#9733" class="Bound">Ω</a> <a id="9735" class="Symbol">→</a> <a id="9737" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9739" href="Axiom.html#1662" class="Field">CSet</a> <a id="9744" class="Symbol">λ</a> <a id="9746" href="Axiom.html#9746" class="Bound">T</a> <a id="9748" class="Symbol">→</a> <a id="9750" href="Axiom.html#9746" class="Bound">T</a> <a id="9752" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="9755" href="Axiom.html#9733" class="Bound">Ω</a>

    <a id="9762" href="Axiom.html#9762" class="Bound">SubClsCommuter</a> <a id="9777" class="Symbol">:</a> <a id="9779" href="Axiom.html#2437" class="Function">Commuter</a> <a id="9788" href="Axiom.html#9703" class="Bound">SubCls</a>
    <a id="9799" href="Axiom.html#9762" class="Bound">SubClsCommuter</a> <a id="9814" class="Symbol">=</a> <a id="9816" class="Symbol">λ</a> <a id="9818" class="Symbol">(</a><a id="9819" href="Axiom.html#9819" class="Bound">A</a> <a id="9821" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9823" href="Axiom.html#9823" class="Bound">X</a> <a id="9825" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9827" href="Axiom.html#9827" class="Bound">i</a><a id="9828" class="Symbol">)</a> <a id="9830" class="Symbol">(</a><a id="9831" href="Axiom.html#9831" class="Bound">Ω</a> <a id="9833" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9835" href="Axiom.html#9835" class="Bound">T</a> <a id="9837" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9839" href="Axiom.html#9839" class="Bound">t</a><a id="9840" class="Symbol">)</a> <a id="9842" href="Axiom.html#9842" class="Bound">χ</a> <a id="9844" class="Symbol">→</a> <a id="9846" class="Symbol">(</a><a id="9847" href="Axiom.html#9847" class="Bound">eq</a> <a id="9850" class="Symbol">:</a> <a id="9852" href="Axiom.html#9835" class="Bound">T</a> <a id="9854" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9856" href="Axiom.html#3965" class="Bound">１</a><a id="9857" class="Symbol">)</a> <a id="9859" class="Symbol">→</a>
      <a id="9867" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="9872" href="Axiom.html#9847" class="Bound">eq</a> <a id="9875" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="9878" class="Symbol">λ</a> <a id="9880" class="Symbol">{</a> <a id="9882" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9887" class="Symbol">→</a> <a id="9889" href="Axiom.html#9823" class="Bound">X</a> <a id="9891" href="Axiom.html#8503" class="Bound Operator">withInclusion</a> <a id="9905" href="Axiom.html#9827" class="Bound">i</a> <a id="9907" href="Axiom.html#8503" class="Bound Operator">isFibreOf</a> <a id="9917" href="Axiom.html#9842" class="Bound">χ</a> <a id="9919" href="Axiom.html#8503" class="Bound Operator">over</a> <a id="9924" href="Axiom.html#9839" class="Bound">t</a> <a id="9926" class="Symbol">}</a>

    <a id="9933" href="Axiom.html#9933" class="Bound">isSubCls</a> <a id="9942" class="Symbol">:</a> <a id="9944" href="Axiom.html#2192" class="Function">Diagram</a> <a id="9952" href="Axiom.html#9703" class="Bound">SubCls</a> <a id="9959" class="Symbol">→</a> <a id="9961" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="9969" href="Axiom.html#9933" class="Bound">isSubCls</a> <a id="9978" class="Symbol">=</a> <a id="9980" href="Axiom.html#2757" class="Function">universal</a> <a id="9990" href="Axiom.html#9762" class="Bound">SubClsCommuter</a>
</pre>
<p><strong>公理 8 (子集)</strong> 存在一个子集分类器图式 <code>(Ω , １ , t)</code> 满足子集分类器的泛性质.</p>
<pre class="Agda">    <a id="10076" class="Comment">-- Axiom 8</a>
    <a id="10091" class="Keyword">field</a> <a id="10097" href="Axiom.html#10097" class="Field">AxSubCls</a> <a id="10106" class="Symbol">:</a> <a id="10108" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10110" class="Symbol">(</a><a id="10111" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10119" href="Axiom.html#9703" class="Bound">SubCls</a><a id="10125" class="Symbol">)</a> <a id="10127" class="Symbol">λ</a> <a id="10129" href="Axiom.html#10129" class="Bound">d</a><a id="10130" class="Symbol">@(_</a> <a id="10134" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10136" href="Axiom.html#10136" class="Bound">T</a> <a id="10138" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10140" class="Symbol">_)</a> <a id="10143" class="Symbol">→</a> <a id="10145" href="Axiom.html#10136" class="Bound">T</a> <a id="10147" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10149" href="Axiom.html#3965" class="Bound">１</a> <a id="10151" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10153" href="Axiom.html#9933" class="Bound">isSubCls</a> <a id="10162" href="Axiom.html#10129" class="Bound">d</a>
</pre>
<p><strong>定义 3.3.2</strong> 我们按以下三步定义自然数集的泛性质.</p>
<p>第一步, 定义自然数图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>N</code></li>
<li>一个元素 <code>z ∈ N</code></li>
<li>一个函数 <code>σ : N →̇ N</code></li>
</ul>
<p>第二步, 定义自然数图式的交换: 我们说两个自然数图式 <code>(N , z , σ)</code> 和 <code>(X , a , r)</code> 以及底集间映射 <code>x : N →̇ X</code> 交换, 当且仅当对任意 <code>n ∈ N</code> 都有 <code>x ⦅ z ⦆ ≡ a</code> 且 <code>x ⦅ σ ⦅ n ⦆ ⦆ ≡ r ⦅ x ⦅ n ⦆ ⦆</code>.</p>
<p>第三步, 定义自然数的泛性质: 我们说一个自然数图式 <code>(N , z , σ)</code> 满足自然数的泛性质, 当且仅当对任意自然数图式 <code>(X , a , r)</code>, 存在唯一的底集间映射 <code>x : N →̇ X</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-a643f6546c3ea362bb62336c01d46535.png" alt="自然数的泛性质" />
<figcaption aria-hidden="true">自然数的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="10629" class="Comment">-- Definition 3.3.2</a>
    <a id="10653" href="Axiom.html#10653" class="Bound">Nat</a> <a id="10657" class="Symbol">:</a> <a id="10659" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="10669" href="Axiom.html#10653" class="Bound">Nat</a> <a id="10673" class="Symbol">=</a> <a id="10675" class="Symbol">λ</a> <a id="10677" href="Axiom.html#10677" class="Bound">N</a> <a id="10679" class="Symbol">→</a> <a id="10681" href="Axiom.html#4136" class="Bound">Elm</a> <a id="10685" href="Axiom.html#10677" class="Bound">N</a> <a id="10687" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10689" href="Axiom.html#10677" class="Bound">N</a> <a id="10691" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="10694" href="Axiom.html#10677" class="Bound">N</a>

    <a id="10701" href="Axiom.html#10701" class="Bound">NatCommuter</a> <a id="10713" class="Symbol">:</a> <a id="10715" href="Axiom.html#2437" class="Function">Commuter</a> <a id="10724" href="Axiom.html#10653" class="Bound">Nat</a>
    <a id="10732" href="Axiom.html#10701" class="Bound">NatCommuter</a> <a id="10744" class="Symbol">=</a> <a id="10746" class="Symbol">λ</a> <a id="10748" class="Symbol">(</a><a id="10749" href="Axiom.html#10749" class="Bound">N</a> <a id="10751" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10753" href="Axiom.html#10753" class="Bound">z</a> <a id="10755" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10757" href="Axiom.html#10757" class="Bound">σ</a><a id="10758" class="Symbol">)</a> <a id="10760" class="Symbol">(</a><a id="10761" href="Axiom.html#10761" class="Bound">X</a> <a id="10763" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10765" href="Axiom.html#10765" class="Bound">a</a> <a id="10767" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10769" href="Axiom.html#10769" class="Bound">r</a><a id="10770" class="Symbol">)</a> <a id="10772" href="Axiom.html#10772" class="Bound">x</a> <a id="10774" class="Symbol">→</a>
      <a id="10782" href="Axiom.html#4174" class="Bound">∀[</a> <a id="10785" href="Axiom.html#10785" class="Bound">n</a> <a id="10787" href="Axiom.html#4174" class="Bound">∈</a> <a id="10789" href="Axiom.html#10749" class="Bound">N</a> <a id="10791" href="Axiom.html#4174" class="Bound">]</a> <a id="10793" class="Symbol">(</a><a id="10794" href="Axiom.html#10772" class="Bound">x</a> <a id="10796" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="10798" href="Axiom.html#10753" class="Bound">z</a> <a id="10800" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="10802" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10804" href="Axiom.html#10765" class="Bound">a</a> <a id="10806" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10808" href="Axiom.html#10772" class="Bound">x</a> <a id="10810" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="10812" href="Axiom.html#10757" class="Bound">σ</a> <a id="10814" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="10816" href="Axiom.html#10785" class="Bound">n</a> <a id="10818" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="10820" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="10822" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10824" href="Axiom.html#10769" class="Bound">r</a> <a id="10826" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="10828" href="Axiom.html#10772" class="Bound">x</a> <a id="10830" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="10832" href="Axiom.html#10785" class="Bound">n</a> <a id="10834" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="10836" href="Axiom.html#4766" class="Bound Operator">⦆</a><a id="10837" class="Symbol">)</a>

    <a id="10844" href="Axiom.html#10844" class="Bound">isNat</a> <a id="10850" class="Symbol">:</a> <a id="10852" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10860" href="Axiom.html#10653" class="Bound">Nat</a> <a id="10864" class="Symbol">→</a> <a id="10866" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="10874" href="Axiom.html#10844" class="Bound">isNat</a> <a id="10880" class="Symbol">=</a> <a id="10882" href="Axiom.html#2757" class="Function">universal</a> <a id="10892" href="Axiom.html#10701" class="Bound">NatCommuter</a>
</pre>
<p><strong>公理 9 (自然数)</strong> 存在一个自然数图式满足自然数的泛性质.</p>
<pre class="Agda">    <a id="10957" class="Comment">-- Axiom 9</a>
    <a id="10972" class="Keyword">field</a> <a id="10978" href="Axiom.html#10978" class="Field">AxNat</a> <a id="10984" class="Symbol">:</a> <a id="10986" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10988" class="Symbol">(</a><a id="10989" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10997" href="Axiom.html#10653" class="Bound">Nat</a><a id="11000" class="Symbol">)</a> <a id="11002" href="Axiom.html#10844" class="Bound">isNat</a>
</pre>
<p><strong>定义 3.1.8 ii</strong> 给定函数 <code>f : X →̇ Y</code>, 我们称 <code>f</code> 是满射, 当且仅当对任意 <code>y ∈ Y</code> 都存在 <code>x ∈ X</code> 使得 <code>f ⦅ x ⦆ ≡ y</code>.</p>
<pre class="Agda">    <a id="11120" class="Comment">-- Definition 3.1.8 ii</a>
    <a id="11147" href="Axiom.html#11147" class="Bound">surjective</a> <a id="11158" class="Symbol">:</a> <a id="11160" class="Symbol">(</a><a id="11161" href="Axiom.html#11161" class="Bound">f</a> <a id="11163" class="Symbol">:</a> <a id="11165" href="Axiom.html#3021" class="Generalizable">X</a> <a id="11167" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11170" href="Axiom.html#3023" class="Generalizable">Y</a><a id="11171" class="Symbol">)</a> <a id="11173" class="Symbol">→</a> <a id="11175" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11183" href="Axiom.html#11147" class="Bound">surjective</a> <a id="11194" class="Symbol">{</a><a id="11195" href="Axiom.html#11195" class="Bound">X</a><a id="11196" class="Symbol">}</a> <a id="11198" class="Symbol">{</a><a id="11199" href="Axiom.html#11199" class="Bound">Y</a><a id="11200" class="Symbol">}</a> <a id="11202" href="Axiom.html#11202" class="Bound">f</a> <a id="11204" class="Symbol">=</a> <a id="11206" href="Axiom.html#4174" class="Bound">∀[</a> <a id="11209" href="Axiom.html#11209" class="Bound">y</a> <a id="11211" href="Axiom.html#4174" class="Bound">∈</a> <a id="11213" href="Axiom.html#11199" class="Bound">Y</a> <a id="11215" href="Axiom.html#4174" class="Bound">]</a> <a id="11217" href="Axiom.html#4343" class="Bound">∃[</a> <a id="11220" href="Axiom.html#11220" class="Bound">x</a> <a id="11222" href="Axiom.html#4343" class="Bound">∈</a> <a id="11224" href="Axiom.html#11195" class="Bound">X</a> <a id="11226" href="Axiom.html#4343" class="Bound">]</a> <a id="11228" href="Axiom.html#11202" class="Bound">f</a> <a id="11230" href="Axiom.html#4766" class="Bound Operator">⦅</a> <a id="11232" href="Axiom.html#11220" class="Bound">x</a> <a id="11234" href="Axiom.html#4766" class="Bound Operator">⦆</a> <a id="11236" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11238" href="Axiom.html#11209" class="Bound">y</a>
</pre>
<p><strong>定义 3.4.1</strong> 给定函数 <code>f : X →̇ Y</code> 和 <code>i : Y →̇ X</code>, 我们称 <code>i</code> 是 <code>f</code> 的截面, 当且仅当 <code>f ∘ i ≡ id</code>.</p>
<pre class="Agda">    <a id="11343" class="Comment">-- Definition 3.4.1</a>
    <a id="11367" href="Axiom.html#11367" class="Bound">section</a> <a id="11375" class="Symbol">:</a> <a id="11377" class="Symbol">(</a><a id="11378" href="Axiom.html#11378" class="Bound">f</a> <a id="11380" class="Symbol">:</a> <a id="11382" href="Axiom.html#3021" class="Generalizable">X</a> <a id="11384" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11387" href="Axiom.html#3023" class="Generalizable">Y</a><a id="11388" class="Symbol">)</a> <a id="11390" class="Symbol">(</a><a id="11391" href="Axiom.html#11391" class="Bound">i</a> <a id="11393" class="Symbol">:</a> <a id="11395" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="11397" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11400" href="Axiom.html#3021" class="Generalizable">X</a><a id="11401" class="Symbol">)</a> <a id="11403" class="Symbol">→</a> <a id="11405" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11413" href="Axiom.html#11367" class="Bound">section</a> <a id="11421" href="Axiom.html#11421" class="Bound">f</a> <a id="11423" href="Axiom.html#11423" class="Bound">i</a> <a id="11425" class="Symbol">=</a> <a id="11427" href="Axiom.html#11421" class="Bound">f</a> <a id="11429" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="11431" href="Axiom.html#11423" class="Bound">i</a> <a id="11433" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11435" href="Axiom.html#1800" class="Function">id</a>
</pre>
<p><strong>公理 10 (选择)</strong> 如果 <code>f : X →̇ Y</code> 是满射, 那么存在 <code>f</code> 的一个截面 <code>i : Y →̇ X</code>.</p>
<pre class="Agda">    <a id="11521" class="Comment">-- Axiom 10</a>
    <a id="11537" class="Keyword">field</a> <a id="11543" href="Axiom.html#11543" class="Field">AxChoice</a> <a id="11552" class="Symbol">:</a> <a id="11554" href="Axiom.html#11147" class="Bound">surjective</a> <a id="11565" href="Axiom.html#3044" class="Generalizable">f</a> <a id="11567" class="Symbol">→</a> <a id="11569" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11571" class="Symbol">(</a><a id="11572" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="11574" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11577" href="Axiom.html#3021" class="Generalizable">X</a><a id="11578" class="Symbol">)</a> <a id="11580" class="Symbol">(</a><a id="11581" href="Axiom.html#11367" class="Bound">section</a> <a id="11589" href="Axiom.html#3044" class="Generalizable">f</a><a id="11590" class="Symbol">)</a>
</pre>
<h2 id="总结">总结</h2>
<p>以下是对公理化的总结. 我们的公理适用于以下资料：</p>
<ul>
<li>一些称为集合的东西;</li>
<li>对于每个集合 <code>X</code> 和集合 <code>Y</code>, 一些称为从 <code>X</code> 到 <code>Y</code> 的函数, 我们用 <code>f : X →̇ Y</code> 表示从 <code>X</code> 到 <code>Y</code> 的函数 <code>f</code>;</li>
<li>对于每个集合 <code>X</code>, 集合 <code>Y</code> 和集合 <code>X</code>, 一个称为复合的运算, 将每对函数 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋予一个函数 <code>f ∘ g : X →̇ Z</code>;</li>
<li>对于每个集合 <code>X</code>， 一个函数 <code>id : X →̇ X</code>, 称为 <code>X</code> 的恒等函数.</li>
</ul>
<p>公理：</p>
<ol type="1">
<li>函数的复合满足结合律, 并且恒等函数起到恒等作用.</li>
<li>存在一个终集.</li>
<li>函数外延性成立.</li>
<li>存在一个空集.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 和 <code>Y</code> 的积.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 到 <code>Y</code> 的函数集.</li>
<li>给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在 <code>f</code> 在 <code>y</code> 上的纤维.</li>
<li>存在一个子集分类器.</li>
<li>存在一个自然数系统.</li>
<li>每个满射都有一个截面.</li>
</ol>
<p>公理 3, 4 和 7 都涉及到元素, 它定义为定义域为终集 <code>１</code> 的函数. 公理 2 以及 5–9 都涉及到泛性质, 并且所有这些公理唯一地刻画了涉及的集合 (在同构意义上), 这将在接下来的几篇中证明.</p>
<p>为了方便后面引用, 我们将以上资料和公理统称为 <code>ETCS</code> 理论.</p>
<pre class="Agda"><a id="12266" class="Keyword">record</a> <a id="ETCS"></a><a id="12273" href="Axiom.html#12273" class="Record">ETCS</a> <a id="12278" class="Symbol">:</a> <a id="12280" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="12285" class="Keyword">where</a>
  <a id="12293" class="Keyword">field</a>
    <a id="ETCS.etcs"></a><a id="12303" href="Axiom.html#12303" class="Field">etcs</a> <a id="12308" class="Symbol">:</a> <a id="12310" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="12312" href="Axiom.html#1600" class="Record">Data</a> <a id="12317" href="Axiom.html#3117" class="Record">Data.Axiom</a>
  <a id="12330" class="Keyword">open</a> <a id="12335" href="Axiom.html#1600" class="Module">Data</a> <a id="12340" class="Symbol">(</a><a id="12341" href="Axiom.html#12303" class="Field">etcs</a> <a id="12346" class="Symbol">.</a><a id="12347" href="Axiom.html#949" class="Field">fst</a><a id="12350" class="Symbol">)</a> <a id="12352" class="Keyword">public</a>
  <a id="12361" class="Keyword">open</a> <a id="12366" href="Axiom.html#3117" class="Module">Data.Axiom</a> <a id="12377" class="Symbol">(</a><a id="12378" href="Axiom.html#12303" class="Field">etcs</a> <a id="12383" class="Symbol">.</a><a id="12384" href="Axiom.html#963" class="Field">snd</a><a id="12387" class="Symbol">)</a> <a id="12389" class="Keyword">public</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
