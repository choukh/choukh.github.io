<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>公理化结构集合论 (1 公理)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">公理化结构集合论 (1 公理)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#公理化结构集合论-1-公理" id="toc-公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#原始概念" id="toc-原始概念">原始概念</a></li>
  <li><a href="#公理" id="toc-公理">公理</a></li>
  <li><a href="#总结" id="toc-总结">总结</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/ETCS/blob/main/src/Axiom.lagda.md">Axiom.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/ETCS/Axiom.html">Axiom.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是对 Tom Leinster 在爱丁堡大学教授的本科课程「公理化结构集合论（ETCS）」讲义（以下简称「讲义」）的 Agda 形式化. 我们的符号选取和定义表述基本上遵循讲义, 而定理编号与讲义完全一致, 但由于 Agda 的特性而稍微调整了顺序. 注意我们讲的是一种可以作为数学基础的集合论而不是范畴论, 虽然借用了一些范畴论的术语和思想, 但不需要先掌握范畴论.</p>
<p>我们采用原味 Agda 加 stdlib 标准库, 这是我们的元语言, 而 ETCS 将是我们的对象语言. 由于两层语言的高度相似性, 它们的符号/命名冲突我们主要采用如下两种方式解决.</p>
<ol type="1">
<li>如果一个符号已经用于元语言 (如 <code>→</code>), 则在上面加点表示对象语言的相应概念 (如 <code>→̇</code>).</li>
<li>如果一个符号优先用于对象语言 (如 <code>id</code>), 则在后面加上 <code>⒨</code> 表示元语言的相应概念 (如 <code>id⒨</code>).</li>
</ol>
<pre class="Agda"><a id="727" class="Keyword">module</a> <a id="734" href="Axiom.html" class="Module">Axiom</a> <a id="740" class="Keyword">where</a>

<a id="747" class="Keyword">open</a> <a id="752" class="Keyword">import</a> <a id="759" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="770" class="Keyword">public</a> <a id="777" class="Keyword">using</a> <a id="783" class="Symbol">(</a><a id="784" href="Data.Empty.html#914" class="Function">⊥</a><a id="785" class="Symbol">)</a>
<a id="787" class="Keyword">open</a> <a id="792" class="Keyword">import</a> <a id="799" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="809" class="Keyword">public</a> <a id="816" class="Keyword">using</a> <a id="822" class="Symbol">(</a><a id="823" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="824" class="Symbol">;</a> <a id="826" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="828" class="Symbol">)</a>
<a id="830" class="Keyword">open</a> <a id="835" class="Keyword">import</a> <a id="842" href="Data.Product.html" class="Module">Data.Product</a> <a id="855" class="Keyword">public</a> <a id="862" class="Keyword">using</a> <a id="868" class="Symbol">(</a><a id="869" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="870" class="Symbol">;</a> <a id="872" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="875" class="Symbol">;</a> <a id="877" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="880" class="Symbol">)</a>
  <a id="884" class="Keyword">renaming</a> <a id="893" class="Symbol">(</a><a id="894" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="900" class="Symbol">to</a> <a id="903" class="Field">fst</a><a id="906" class="Symbol">;</a> <a id="908" href="Data.Product.Base.html#650" class="Field">proj₂</a> <a id="914" class="Symbol">to</a> <a id="917" class="Field">snd</a><a id="920" class="Symbol">)</a>
<a id="922" class="Keyword">open</a> <a id="927" class="Keyword">import</a> <a id="934" href="Function.html" class="Module">Function</a> <a id="943" class="Keyword">public</a> <a id="950" class="Keyword">using</a> <a id="956" class="Symbol">(</a><a id="957" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="965" class="Symbol">)</a> <a id="967" class="Keyword">renaming</a> <a id="976" class="Symbol">(</a><a id="977" href="Function.Base.html#704" class="Function">id</a> <a id="980" class="Symbol">to</a> <a id="983" class="Function">id⒨</a><a id="986" class="Symbol">)</a>
<a id="988" class="Keyword">open</a> <a id="993" class="Keyword">import</a> <a id="1000" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1038" class="Keyword">public</a>
</pre>
<p>本文是系列的第一篇, 我们引入 ETCS 的10条公理. 为了表示公理, 首先需要引入 ETCS 的原始概念, 讲义中称它们为资料 (the data), 有的地方也称之为原语 (primitives) , 语言 (language) 或签名 (signature).</p>
<h2 id="原始概念">原始概念</h2>
<p>形式地, 我们的公理将在如下原始概念上展开表述.</p>
<ul>
<li>一些称为集合的东西, 这样的集合 <code>X</code> 记作 <code>X : CSet</code>, 其中 C 来自范畴 (category).</li>
<li>对每个集合 <code>X</code> 和 <code>Y</code>, 一些称为「<code>X</code> 到 <code>Y</code> 的函数」的东西, 这样的函数 <code>f</code> 记作 <code>f : X →̇ Y</code>.</li>
<li>对每个集合 <code>X</code>, <code>Y</code> 和 <code>Z</code>, 一个称为「复合」的运算, 将每个 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋值为一个函数 <code>g ∘ f : X →̇ Z</code>.</li>
<li>对每个集合 <code>X</code>, 一个称为「恒等函数」的东西, 记作 <code>id⟨ X ⟩ : X →̇ X</code>, <code>X</code> 可以从上下文推断出来时简记作 <code>id</code>.</li>
</ul>
<pre class="Agda"><a id="1531" class="Comment">-- 2.1 The data</a>
<a id="1547" class="Keyword">record</a> <a id="Data"></a><a id="1554" href="Axiom.html#1554" class="Record">Data</a> <a id="1559" class="Symbol">:</a> <a id="1561" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="1566" class="Keyword">where</a>
  <a id="1574" class="Keyword">infixl</a> <a id="1581" class="Number">10</a> <a id="1584" href="Axiom.html#1631" class="Field Operator">_→̇_</a>
  <a id="1591" class="Keyword">infix</a> <a id="1597" class="Number">10</a> <a id="1600" href="Axiom.html#1661" class="Field Operator">_∘_</a>
  <a id="1606" class="Keyword">field</a>
    <a id="Data.CSet"></a><a id="1616" href="Axiom.html#1616" class="Field">CSet</a> <a id="1621" class="Symbol">:</a> <a id="1623" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._→̇_"></a><a id="1631" href="Axiom.html#1631" class="Field Operator">_→̇_</a> <a id="1636" class="Symbol">:</a> <a id="1638" class="Symbol">(</a><a id="1639" href="Axiom.html#1639" class="Bound">X</a> <a id="1641" href="Axiom.html#1641" class="Bound">Y</a> <a id="1643" class="Symbol">:</a> <a id="1645" href="Axiom.html#1616" class="Field">CSet</a><a id="1649" class="Symbol">)</a> <a id="1651" class="Symbol">→</a> <a id="1653" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._∘_"></a><a id="1661" href="Axiom.html#1661" class="Field Operator">_∘_</a> <a id="1665" class="Symbol">:</a> <a id="1667" class="Symbol">{</a><a id="1668" href="Axiom.html#1668" class="Bound">X</a> <a id="1670" href="Axiom.html#1670" class="Bound">Y</a> <a id="1672" href="Axiom.html#1672" class="Bound">Z</a> <a id="1674" class="Symbol">:</a> <a id="1676" href="Axiom.html#1616" class="Field">CSet</a><a id="1680" class="Symbol">}</a> <a id="1682" class="Symbol">(</a><a id="1683" href="Axiom.html#1683" class="Bound">g</a> <a id="1685" class="Symbol">:</a> <a id="1687" href="Axiom.html#1670" class="Bound">Y</a> <a id="1689" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1692" href="Axiom.html#1672" class="Bound">Z</a><a id="1693" class="Symbol">)</a> <a id="1695" class="Symbol">(</a><a id="1696" href="Axiom.html#1696" class="Bound">f</a> <a id="1698" class="Symbol">:</a> <a id="1700" href="Axiom.html#1668" class="Bound">X</a> <a id="1702" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1705" href="Axiom.html#1670" class="Bound">Y</a><a id="1706" class="Symbol">)</a> <a id="1708" class="Symbol">→</a> <a id="1710" class="Symbol">(</a><a id="1711" href="Axiom.html#1668" class="Bound">X</a> <a id="1713" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1716" href="Axiom.html#1672" class="Bound">Z</a><a id="1717" class="Symbol">)</a>
    <a id="Data.id⟨_⟩"></a><a id="1723" href="Axiom.html#1723" class="Field Operator">id⟨_⟩</a> <a id="1729" class="Symbol">:</a> <a id="1731" class="Symbol">(</a><a id="1732" href="Axiom.html#1732" class="Bound">X</a> <a id="1734" class="Symbol">:</a> <a id="1736" href="Axiom.html#1616" class="Field">CSet</a><a id="1740" class="Symbol">)</a> <a id="1742" class="Symbol">→</a> <a id="1744" href="Axiom.html#1732" class="Bound">X</a> <a id="1746" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1749" href="Axiom.html#1732" class="Bound">X</a>

  <a id="Data.id"></a><a id="1754" href="Axiom.html#1754" class="Function">id</a> <a id="1757" class="Symbol">:</a> <a id="1759" class="Symbol">{</a><a id="1760" href="Axiom.html#1760" class="Bound">X</a> <a id="1762" class="Symbol">:</a> <a id="1764" href="Axiom.html#1616" class="Field">CSet</a><a id="1768" class="Symbol">}</a> <a id="1770" class="Symbol">→</a> <a id="1772" href="Axiom.html#1760" class="Bound">X</a> <a id="1774" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1777" href="Axiom.html#1760" class="Bound">X</a>
  <a id="1781" href="Axiom.html#1754" class="Function">id</a> <a id="1784" class="Symbol">{</a><a id="1785" href="Axiom.html#1785" class="Bound">X</a><a id="1786" class="Symbol">}</a> <a id="1788" class="Symbol">=</a> <a id="1790" href="Axiom.html#1723" class="Field Operator">id⟨</a> <a id="1794" href="Axiom.html#1785" class="Bound">X</a> <a id="1796" href="Axiom.html#1723" class="Field Operator">⟩</a>
</pre>
<p>我们会形式化讲义中没有编号的概念, 这些概念我们编号为 -1.</p>
<p><strong>定义 -1.1</strong> 我们把关于集合的性质称为箭头模式 <code>Arrow</code>. 给定这样的性质 <code>A : Arrow</code>, 如果某集合 <code>X</code> 满足 <code>A</code>, 我们就把 <code>a : A X</code> 称为集合 <code>X</code> 的一套 <code>A</code>-箭头.</p>
<pre class="Agda">  <a id="Data.Arrow"></a><a id="1960" href="Axiom.html#1960" class="Function">Arrow</a> <a id="1966" class="Symbol">:</a> <a id="1968" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="1975" href="Axiom.html#1960" class="Function">Arrow</a> <a id="1981" class="Symbol">=</a> <a id="1983" href="Axiom.html#1616" class="Field">CSet</a> <a id="1988" class="Symbol">→</a> <a id="1990" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.2</strong> 给定箭头模式 <code>A</code>, 由以下资料组成的东西称为 <code>A</code>-图式 (diagram), 记作 <code>Diagram A</code>.</p>
<ul>
<li>一个集合 <code>X</code></li>
<li><code>X</code> 的一套 <code>A</code>-箭头</li>
</ul>
<p>其中 <code>X</code> 叫做图式的底集 (underlying set).</p>
<pre class="Agda">  <a id="Data.Diagram"></a><a id="2144" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2152" class="Symbol">:</a> <a id="2154" href="Axiom.html#1960" class="Function">Arrow</a> <a id="2160" class="Symbol">→</a> <a id="2162" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2168" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2176" class="Symbol">=</a> <a id="2178" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2180" href="Axiom.html#1616" class="Field">CSet</a>
</pre>
<p><strong>定义 -1.3</strong> 给定箭头模式 <code>A</code>, 我们把关于两个 <code>A</code>-图式以及它们的底集间映射 <code>j</code> 的性质称为 <code>A</code>-交换模式, 记作 <code>Commuter A</code>. 对任意两个 <code>A</code>-图式 <code>a</code> <code>b</code> 以及它们的底集间映射 <code>j</code>, 如果它们满足一个 <code>A</code>-交换模式 <code>C : Commuter A</code>, 我们就称它们 <code>C</code>-交换, 记作 <code>C a b j</code>.</p>
<pre class="Agda">  <a id="Data.Commuter"></a><a id="2389" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2398" class="Symbol">:</a> <a id="2400" class="Symbol">(</a><a id="2401" href="Axiom.html#2401" class="Bound">A</a> <a id="2403" class="Symbol">:</a> <a id="2405" href="Axiom.html#1960" class="Function">Arrow</a><a id="2410" class="Symbol">)</a> <a id="2412" class="Symbol">→</a> <a id="2414" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2421" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2430" href="Axiom.html#2430" class="Bound">A</a> <a id="2432" class="Symbol">=</a> <a id="2434" class="Symbol">(</a><a id="2435" href="Axiom.html#2435" class="Bound">(</a><a id="2436" href="Axiom.html#2436" class="Bound">X</a> <a id="2438" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2440" href="Axiom.html#2435" class="Bound">_)</a> <a id="2443" href="Axiom.html#2443" class="Bound">(</a><a id="2444" href="Axiom.html#2444" class="Bound">Y</a> <a id="2446" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2448" href="Axiom.html#2443" class="Bound">_)</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2461" href="Axiom.html#2430" class="Bound">A</a><a id="2462" class="Symbol">)</a> <a id="2464" class="Symbol">(</a><a id="2465" href="Axiom.html#2465" class="Bound">j</a> <a id="2467" class="Symbol">:</a> <a id="2469" href="Axiom.html#2436" class="Bound">X</a> <a id="2471" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="2474" href="Axiom.html#2444" class="Bound">Y</a><a id="2475" class="Symbol">)</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.4</strong> 给定一个 <code>A</code>-交换模式 <code>C</code> 和一个 <code>A</code>-图式 <code>b</code>, 我们称 <code>b</code> 满足 <code>C</code>-泛性质, 当且仅当对任意 <code>A</code>-图式 <code>a</code>, 存在唯一的底集间映射 <code>j</code> 使得 <code>a</code> <code>b</code> <code>j</code> 满足 <code>C</code>-交换.</p>
<pre class="Agda">  <a id="Data.unique"></a><a id="2626" href="Axiom.html#2626" class="Function">unique</a> <a id="2633" class="Symbol">:</a> <a id="2635" class="Symbol">{</a><a id="2636" href="Axiom.html#2636" class="Bound">A</a> <a id="2638" class="Symbol">:</a> <a id="2640" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2643" class="Symbol">}</a> <a id="2645" class="Symbol">(</a><a id="2646" href="Axiom.html#2646" class="Bound">P</a> <a id="2648" class="Symbol">:</a> <a id="2650" href="Axiom.html#2636" class="Bound">A</a> <a id="2652" class="Symbol">→</a> <a id="2654" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2657" class="Symbol">)</a> <a id="2659" class="Symbol">→</a> <a id="2661" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2667" href="Axiom.html#2626" class="Function">unique</a> <a id="2674" href="Axiom.html#2674" class="Bound">P</a> <a id="2676" class="Symbol">=</a> <a id="2678" class="Symbol">∀</a> <a id="2680" class="Symbol">{</a><a id="2681" href="Axiom.html#2681" class="Bound">a</a> <a id="2683" href="Axiom.html#2683" class="Bound">b</a><a id="2684" class="Symbol">}</a> <a id="2686" class="Symbol">→</a> <a id="2688" href="Axiom.html#2674" class="Bound">P</a> <a id="2690" href="Axiom.html#2681" class="Bound">a</a> <a id="2692" class="Symbol">→</a> <a id="2694" href="Axiom.html#2674" class="Bound">P</a> <a id="2696" href="Axiom.html#2683" class="Bound">b</a> <a id="2698" class="Symbol">→</a> <a id="2700" href="Axiom.html#2681" class="Bound">a</a> <a id="2702" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2704" href="Axiom.html#2683" class="Bound">b</a>

  <a id="Data.universal"></a><a id="2709" href="Axiom.html#2709" class="Function">universal</a> <a id="2719" class="Symbol">:</a> <a id="2721" class="Symbol">{</a><a id="2722" href="Axiom.html#2722" class="Bound">A</a> <a id="2724" class="Symbol">:</a> <a id="2726" href="Axiom.html#1960" class="Function">Arrow</a><a id="2731" class="Symbol">}</a> <a id="2733" class="Symbol">→</a> <a id="2735" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2744" href="Axiom.html#2722" class="Bound">A</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2756" href="Axiom.html#2722" class="Bound">A</a> <a id="2758" class="Symbol">→</a> <a id="2760" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2766" href="Axiom.html#2709" class="Function">universal</a> <a id="2776" class="Symbol">{</a><a id="2777" href="Axiom.html#2777" class="Bound">A</a><a id="2778" class="Symbol">}</a> <a id="2780" href="Axiom.html#2780" class="Bound">C</a> <a id="2782" href="Axiom.html#2782" class="Bound">b</a><a id="2783" class="Symbol">@(</a><a id="2785" href="Axiom.html#2785" class="Bound">Y</a> <a id="2787" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2789" class="Symbol">_)</a> <a id="2792" class="Symbol">=</a> <a id="2794" class="Symbol">(</a><a id="2795" href="Axiom.html#2795" class="Bound">a</a><a id="2796" class="Symbol">@(</a><a id="2798" href="Axiom.html#2798" class="Bound">X</a> <a id="2800" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2802" class="Symbol">_)</a> <a id="2805" class="Symbol">:</a> <a id="2807" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2815" href="Axiom.html#2777" class="Bound">A</a><a id="2816" class="Symbol">)</a> <a id="2818" class="Symbol">→</a>
    <a id="2824" class="Symbol">(</a><a id="2825" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2827" class="Symbol">(</a><a id="2828" href="Axiom.html#2798" class="Bound">X</a> <a id="2830" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="2833" href="Axiom.html#2785" class="Bound">Y</a><a id="2834" class="Symbol">)</a> <a id="2836" class="Symbol">λ</a> <a id="2838" href="Axiom.html#2838" class="Bound">j</a> <a id="2840" class="Symbol">→</a> <a id="2842" href="Axiom.html#2780" class="Bound">C</a> <a id="2844" href="Axiom.html#2795" class="Bound">a</a> <a id="2846" href="Axiom.html#2782" class="Bound">b</a> <a id="2848" href="Axiom.html#2838" class="Bound">j</a><a id="2849" class="Symbol">)</a> <a id="2851" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2853" href="Axiom.html#2626" class="Function">unique</a> <a id="2860" class="Symbol">(</a><a id="2861" href="Axiom.html#2780" class="Bound">C</a> <a id="2863" href="Axiom.html#2795" class="Bound">a</a> <a id="2865" href="Axiom.html#2782" class="Bound">b</a><a id="2866" class="Symbol">)</a>
</pre>
<p>我们约定用 <code>A</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code> <code>X′</code> <code>Y′</code> 表示集合, 用 <code>f</code> <code>g</code> <code>h</code> <code>f′</code> <code>g′</code> 表示函数.</p>
<pre class="Agda">  <a id="2956" class="Keyword">variable</a>
    <a id="2969" href="Axiom.html#2969" class="Generalizable">A</a> <a id="2971" href="Axiom.html#2971" class="Generalizable">W</a> <a id="2973" href="Axiom.html#2973" class="Generalizable">X</a> <a id="2975" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="2977" href="Axiom.html#2977" class="Generalizable">Z</a> <a id="2979" href="Axiom.html#2979" class="Generalizable">X′</a> <a id="2982" href="Axiom.html#2982" class="Generalizable">Y′</a> <a id="2985" class="Symbol">:</a> <a id="2987" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="2996" href="Axiom.html#2996" class="Generalizable">f</a> <a id="2998" href="Axiom.html#2998" class="Generalizable">g</a> <a id="3000" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3002" href="Axiom.html#3002" class="Generalizable">f′</a> <a id="3005" href="Axiom.html#3005" class="Generalizable">g′</a> <a id="3008" class="Symbol">:</a> <a id="3010" href="Axiom.html#2973" class="Generalizable">X</a> <a id="3012" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="3015" href="Axiom.html#2975" class="Generalizable">Y</a>
</pre>
<h2 id="公理">公理</h2>
<p>我们现在可以引入 ETCS 的10条公理.</p>
<pre class="Agda">  <a id="3062" class="Keyword">record</a> <a id="Data.Axiom"></a><a id="3069" href="Axiom.html#3069" class="Record">Axiom</a> <a id="3075" class="Symbol">:</a> <a id="3077" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3081" class="Keyword">where</a>
</pre>
<p><strong>公理 1 (范畴)</strong> 以下三个命题成立.</p>
<ol type="1">
<li>复合运算满足结合律.</li>
<li>恒等函数是复合运算的左单位元.</li>
<li>恒等函数是复合运算的右单位元.</li>
</ol>
<pre class="Agda">    <a id="3182" class="Keyword">field</a>
      <a id="3194" class="Comment">-- Axiom 1</a>
      <a id="3211" href="Axiom.html#3211" class="Field">AxAss</a> <a id="3217" class="Symbol">:</a> <a id="3219" class="Symbol">(</a><a id="3220" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3222" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3224" href="Axiom.html#2998" class="Generalizable">g</a><a id="3225" class="Symbol">)</a> <a id="3227" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3229" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3231" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3233" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3235" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3237" class="Symbol">(</a><a id="3238" href="Axiom.html#2998" class="Generalizable">g</a> <a id="3240" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3242" href="Axiom.html#2996" class="Generalizable">f</a><a id="3243" class="Symbol">)</a>
      <a id="3251" href="Axiom.html#3251" class="Field">AxIdˡ</a> <a id="3257" class="Symbol">:</a> <a id="3259" href="Axiom.html#1754" class="Function">id</a> <a id="3262" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3264" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3266" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3268" href="Axiom.html#2996" class="Generalizable">f</a>
      <a id="3276" href="Axiom.html#3276" class="Field">AxIdʳ</a> <a id="3282" class="Symbol">:</a> <a id="3284" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3286" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3288" href="Axiom.html#1754" class="Function">id</a> <a id="3291" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3293" href="Axiom.html#2996" class="Generalizable">f</a>
</pre>
<p><strong>定义 2.3.1</strong> 我们说一个集合 <code>T</code> 是终集合, 当且仅当对任意集合 <code>X</code>, 存在唯一的 <code>j : X →̇ T</code>. 注意终集合的图式没有箭头, 只有一个集合, 且终集合的交换模式是恒真.</p>
<pre class="Agda">    <a id="3415" class="Comment">-- Definition 2.3.1</a>
    <a id="3439" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3448" class="Symbol">:</a> <a id="3450" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="3460" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3469" class="Symbol">=</a> <a id="3471" class="Symbol">λ</a> <a id="3473" href="Axiom.html#3473" class="Bound">_</a> <a id="3475" class="Symbol">→</a> <a id="3477" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3484" href="Axiom.html#3484" class="Bound">TerminalCommuter</a> <a id="3501" class="Symbol">:</a> <a id="3503" href="Axiom.html#2389" class="Function">Commuter</a> <a id="3512" href="Axiom.html#3439" class="Bound">Terminal</a>
    <a id="3525" href="Axiom.html#3484" class="Bound">TerminalCommuter</a> <a id="3542" class="Symbol">=</a> <a id="3544" class="Symbol">λ</a> <a id="3546" href="Axiom.html#3546" class="Bound">_</a> <a id="3548" href="Axiom.html#3548" class="Bound">_</a> <a id="3550" href="Axiom.html#3550" class="Bound">_</a> <a id="3552" class="Symbol">→</a> <a id="3554" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3561" href="Axiom.html#3561" class="Bound">isTerminal</a> <a id="3572" class="Symbol">:</a> <a id="3574" href="Axiom.html#2144" class="Function">Diagram</a> <a id="3582" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3591" class="Symbol">→</a> <a id="3593" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="3601" href="Axiom.html#3561" class="Bound">isTerminal</a> <a id="3612" class="Symbol">=</a> <a id="3614" href="Axiom.html#2709" class="Function">universal</a> <a id="3624" href="Axiom.html#3484" class="Bound">TerminalCommuter</a>
</pre>
<p><strong>公理 2 (终集)</strong> 存在一个终集合.</p>
<pre class="Agda">    <a id="3682" class="Comment">-- Axiom 2</a>
    <a id="3697" class="Keyword">field</a> <a id="3703" href="Axiom.html#3703" class="Field">AxTml</a> <a id="3709" class="Symbol">:</a> <a id="3711" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="3713" class="Symbol">(</a><a id="3714" href="Axiom.html#2144" class="Function">Diagram</a> <a id="3722" href="Axiom.html#3439" class="Bound">Terminal</a><a id="3730" class="Symbol">)</a> <a id="3732" href="Axiom.html#3561" class="Bound">isTerminal</a>
</pre>
<p>我们将在后篇证明这样的终集合是唯一的. 实际上, 我们会证明所有用泛性质框定的集合都是唯一的. 所以定义了一种泛性质就唯一定义了一种集合, 所以我们后面会直接说「定义某种集合的泛性质」, 这应该理解为就是在「定义某种集合」.</p>
<p>我们把公理2承诺的集合记作 <code>１</code>, 因为它里面只有一个元素, 这会在下一章证明.</p>
<pre class="Agda">    <a id="3917" href="Axiom.html#3917" class="Bound">１</a> <a id="3919" class="Symbol">:</a> <a id="3921" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="3930" href="Axiom.html#3917" class="Bound">１</a> <a id="3932" class="Symbol">=</a> <a id="3934" href="Axiom.html#3703" class="Field">AxTml</a> <a id="3940" class="Symbol">.</a><a id="3941" href="Axiom.html#903" class="Field">fst</a> <a id="3945" class="Symbol">.</a><a id="3946" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p><strong>定义 2.3.6</strong> 给定集合 <code>X</code>, 我们把 <code>１</code> 到 <code>X</code> 的函数称为 <code>X</code> 的元素, 其类型记作 <code>Elm X</code>. 我们将 <code>x : Elm X</code> 简记为 <code>x ∈ X</code>.</p>
<pre class="Agda">    <a id="4064" class="Comment">-- Definition 2.3.6</a>
    <a id="4088" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4092" class="Symbol">:</a> <a id="4094" href="Axiom.html#1616" class="Field">CSet</a> <a id="4099" class="Symbol">→</a> <a id="4101" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4109" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4113" class="Symbol">=</a> <a id="4115" href="Axiom.html#3917" class="Bound">１</a> <a id="4117" href="Axiom.html#1631" class="Field Operator">→̇_</a>

    <a id="4126" href="Axiom.html#4126" class="Bound">∀[∈]-syntax</a> <a id="4138" class="Symbol">:</a> <a id="4140" class="Symbol">(</a><a id="4141" href="Axiom.html#4141" class="Bound">X</a> <a id="4143" class="Symbol">:</a> <a id="4145" href="Axiom.html#1616" class="Field">CSet</a><a id="4149" class="Symbol">)</a> <a id="4151" class="Symbol">(</a><a id="4152" href="Axiom.html#4152" class="Bound">P</a> <a id="4154" class="Symbol">:</a> <a id="4156" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4160" href="Axiom.html#4141" class="Bound">X</a> <a id="4162" class="Symbol">→</a> <a id="4164" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4167" class="Symbol">)</a> <a id="4169" class="Symbol">→</a> <a id="4171" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4179" href="Axiom.html#4126" class="Bound">∀[∈]-syntax</a> <a id="4191" href="Axiom.html#4191" class="Bound">X</a> <a id="4193" href="Axiom.html#4193" class="Bound">P</a> <a id="4195" class="Symbol">=</a> <a id="4197" class="Symbol">(</a><a id="4198" href="Axiom.html#4198" class="Bound">x</a> <a id="4200" class="Symbol">:</a> <a id="4202" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4206" href="Axiom.html#4191" class="Bound">X</a><a id="4207" class="Symbol">)</a> <a id="4209" class="Symbol">→</a> <a id="4211" href="Axiom.html#4193" class="Bound">P</a> <a id="4213" href="Axiom.html#4198" class="Bound">x</a>

    <a id="4220" class="Keyword">infix</a> <a id="4226" class="Number">3</a> <a id="4228" href="Axiom.html#4126" class="Function">∀[∈]-syntax</a>
    <a id="4244" class="Keyword">syntax</a> <a id="4251" href="Axiom.html#4126" class="Function">∀[∈]-syntax</a> <a id="4263" class="Bound">X</a> <a id="4265" class="Symbol">(λ</a> <a id="4268" class="Bound">x</a> <a id="4270" class="Symbol">→</a> <a id="4272" class="Bound">A</a><a id="4273" class="Symbol">)</a> <a id="4275" class="Symbol">=</a> <a id="4277" class="Function">∀[</a> <a id="4280" class="Bound">x</a> <a id="4282" class="Function">∈</a> <a id="4284" class="Bound">X</a> <a id="4286" class="Function">]</a> <a id="4288" class="Bound">A</a>

    <a id="4295" href="Axiom.html#4295" class="Bound">∃[∈]-syntax</a> <a id="4307" class="Symbol">:</a> <a id="4309" class="Symbol">(</a><a id="4310" href="Axiom.html#4310" class="Bound">X</a> <a id="4312" class="Symbol">:</a> <a id="4314" href="Axiom.html#1616" class="Field">CSet</a><a id="4318" class="Symbol">)</a> <a id="4320" class="Symbol">(</a><a id="4321" href="Axiom.html#4321" class="Bound">P</a> <a id="4323" class="Symbol">:</a> <a id="4325" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4329" href="Axiom.html#4310" class="Bound">X</a> <a id="4331" class="Symbol">→</a> <a id="4333" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4336" class="Symbol">)</a> <a id="4338" class="Symbol">→</a> <a id="4340" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4348" href="Axiom.html#4295" class="Bound">∃[∈]-syntax</a> <a id="4360" href="Axiom.html#4360" class="Bound">X</a> <a id="4362" href="Axiom.html#4362" class="Bound">P</a> <a id="4364" class="Symbol">=</a> <a id="4366" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4373" href="Axiom.html#4360" class="Bound">X</a><a id="4374" class="Symbol">)</a> <a id="4376" href="Axiom.html#4362" class="Bound">P</a>

    <a id="4383" class="Keyword">infix</a> <a id="4389" class="Number">3</a> <a id="4391" href="Axiom.html#4295" class="Function">∃[∈]-syntax</a>
    <a id="4407" class="Keyword">syntax</a> <a id="4414" href="Axiom.html#4295" class="Function">∃[∈]-syntax</a> <a id="4426" class="Bound">X</a> <a id="4428" class="Symbol">(λ</a> <a id="4431" class="Bound">x</a> <a id="4433" class="Symbol">→</a> <a id="4435" class="Bound">A</a><a id="4436" class="Symbol">)</a> <a id="4438" class="Symbol">=</a> <a id="4440" class="Function">∃[</a> <a id="4443" class="Bound">x</a> <a id="4445" class="Function">∈</a> <a id="4447" class="Bound">X</a> <a id="4449" class="Function">]</a> <a id="4451" class="Bound">A</a>
</pre>
<p><strong>注意</strong> <code>x ∈ X</code> 是一个声明而不是可以讨论真假的命题, 这一点与质料集合论 (ZFC等) 不同. 就像我们说「任意/存在集合 <code>X</code>, 怎么怎么样」一样, 这里不存在 「<code>X</code> 是不是集合」的问题, 我们也只能说「任意/存在元素 <code>x ∈ X</code>, 怎么怎么样」, 而不存在 「<code>x</code> 是不是 <code>X</code> 的元素」的问题.</p>
<p>给定函数 <code>f : X →̇ Y</code> 和一个元素 <code>x ∈ X</code>, 我们把复合函数 <code>f ∘ x</code> 记作 <code>f ⦅ x ⦆</code>.</p>
<pre class="Agda">    <a id="4700" class="Keyword">infix</a> <a id="4706" class="Number">15</a> <a id="4709" href="Axiom.html#4718" class="Function Operator">_⦅_⦆</a>
    <a id="4718" href="Axiom.html#4718" class="Bound Operator">_⦅_⦆</a> <a id="4723" class="Symbol">:</a> <a id="4725" class="Symbol">(</a><a id="4726" href="Axiom.html#4726" class="Bound">f</a> <a id="4728" class="Symbol">:</a> <a id="4730" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4732" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="4735" href="Axiom.html#2975" class="Generalizable">Y</a><a id="4736" class="Symbol">)</a> <a id="4738" class="Symbol">→</a> <a id="4740" href="Axiom.html#4126" class="Bound">∀[</a> <a id="4743" href="Axiom.html#4743" class="Bound">x</a> <a id="4745" href="Axiom.html#4126" class="Bound">∈</a> <a id="4747" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4749" href="Axiom.html#4126" class="Bound">]</a> <a id="4751" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4755" href="Axiom.html#2975" class="Generalizable">Y</a>
    <a id="4761" href="Axiom.html#4761" class="Bound">f</a> <a id="4763" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4765" href="Axiom.html#4765" class="Bound">x</a> <a id="4767" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="4769" class="Symbol">=</a> <a id="4771" href="Axiom.html#4761" class="Bound">f</a> <a id="4773" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="4775" href="Axiom.html#4765" class="Bound">x</a>
</pre>
<p><strong>公理 3 (函数外延)</strong> 对任意集合 <code>X Y : CSet</code> 以及函数 <code>f g : X →̇ Y</code>, 如果对任意 <code>x ∈ X</code> 都有 <code>f ⦅ x ⦆ ≡ g ⦅ x ⦆</code>, 那么 <code>f ≡ g</code>.</p>
<pre class="Agda">    <a id="4901" class="Comment">-- Axiom 3</a>
    <a id="4916" class="Keyword">field</a> <a id="4922" href="Axiom.html#4922" class="Field">AxFunExt</a> <a id="4931" class="Symbol">:</a> <a id="4933" class="Symbol">(</a><a id="4934" href="Axiom.html#4126" class="Bound">∀[</a> <a id="4937" href="Axiom.html#4937" class="Bound">x</a> <a id="4939" href="Axiom.html#4126" class="Bound">∈</a> <a id="4941" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4943" href="Axiom.html#4126" class="Bound">]</a> <a id="4945" href="Axiom.html#2996" class="Generalizable">f</a> <a id="4947" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4949" href="Axiom.html#4937" class="Bound">x</a> <a id="4951" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="4953" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4955" href="Axiom.html#2998" class="Generalizable">g</a> <a id="4957" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4959" href="Axiom.html#4937" class="Bound">x</a> <a id="4961" href="Axiom.html#4718" class="Bound Operator">⦆</a><a id="4962" class="Symbol">)</a> <a id="4964" class="Symbol">→</a> <a id="4966" href="Axiom.html#2996" class="Generalizable">f</a> <a id="4968" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4970" href="Axiom.html#2998" class="Generalizable">g</a>
</pre>
<p><strong>定义 2.5.1</strong> 我们称一个集合 <code>X</code> 为空集, 当且仅当对任意 <code>x ∈ X</code> 都有 <code>⊥</code>.</p>
<pre class="Agda">    <a id="5044" class="Comment">-- Definition 2.5.1</a>
    <a id="5068" href="Axiom.html#5068" class="Bound">empty</a> <a id="5074" class="Symbol">:</a> <a id="5076" href="Axiom.html#1616" class="Field">CSet</a> <a id="5081" class="Symbol">→</a> <a id="5083" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5091" href="Axiom.html#5068" class="Bound">empty</a> <a id="5097" href="Axiom.html#5097" class="Bound">X</a> <a id="5099" class="Symbol">=</a> <a id="5101" href="Axiom.html#4126" class="Bound">∀[</a> <a id="5104" href="Axiom.html#5104" class="Bound">x</a> <a id="5106" href="Axiom.html#4126" class="Bound">∈</a> <a id="5108" href="Axiom.html#5097" class="Bound">X</a> <a id="5110" href="Axiom.html#4126" class="Bound">]</a> <a id="5112" href="Data.Empty.html#914" class="Function">⊥</a>
</pre>
<p><strong>公理 4 (空集)</strong> 存在一个空集.</p>
<pre class="Agda">    <a id="5154" class="Comment">-- Axiom 4</a>
    <a id="5169" class="Keyword">field</a> <a id="5175" href="Axiom.html#5175" class="Field">AxEmpty</a> <a id="5183" class="Symbol">:</a> <a id="5185" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="5187" href="Axiom.html#1616" class="Field">CSet</a> <a id="5192" href="Axiom.html#5068" class="Bound">empty</a>
</pre>
<p><strong>定义 2.6.2</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的积的泛性质.</p>
<p>第一步, 定义积图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>P</code></li>
<li>一个函数 <code>p : P →̇ X</code></li>
<li>一个函数 <code>q : P →̇ Y</code></li>
</ul>
<p>于是一个积图式具有如下形式</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-4102e695eae0d63c5a11e9aef1af1ee5.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<p>我们将这样的积图式简记作 <code>(P , p , q)</code>.</p>
<p>第二步, 定义积图式的交换: 我们说两个积图式 <code>(A , f , g)</code> 和 <code>(P , p , q)</code> 以及底集间映射 <code>h : A →̇ P</code> 交换, 当且仅当 <code>p ∘ h ≡ f</code> 且 <code>q ∘ h ≡ g</code>.</p>
<p>第三步, 定义积的泛性质: 我们说一个积图式 <code>(P , p , q)</code> 满足积的泛性质, 当且仅当对任意积图式 <code>(A , f , g)</code>, 存在唯一的底集间映射 <code>h : A →̇ P</code> 使得它们交换.</p>
<pre class="Agda">    <a id="5679" class="Comment">-- Definition 2.6.2</a>
    <a id="5703" href="Axiom.html#5703" class="Bound">Product</a> <a id="5711" class="Symbol">:</a> <a id="5713" class="Symbol">(</a><a id="5714" href="Axiom.html#5714" class="Bound">X</a> <a id="5716" href="Axiom.html#5716" class="Bound">Y</a> <a id="5718" class="Symbol">:</a> <a id="5720" href="Axiom.html#1616" class="Field">CSet</a><a id="5724" class="Symbol">)</a> <a id="5726" class="Symbol">→</a> <a id="5728" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="5738" href="Axiom.html#5703" class="Bound">Product</a> <a id="5746" href="Axiom.html#5746" class="Bound">X</a> <a id="5748" href="Axiom.html#5748" class="Bound">Y</a> <a id="5750" class="Symbol">=</a> <a id="5752" class="Symbol">λ</a> <a id="5754" href="Axiom.html#5754" class="Bound">P</a> <a id="5756" class="Symbol">→</a> <a id="5758" href="Axiom.html#5754" class="Bound">P</a> <a id="5760" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="5763" href="Axiom.html#5746" class="Bound">X</a> <a id="5765" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5767" href="Axiom.html#5754" class="Bound">P</a> <a id="5769" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="5772" href="Axiom.html#5748" class="Bound">Y</a>

    <a id="5779" href="Axiom.html#5779" class="Bound">ProductCommuter</a> <a id="5795" class="Symbol">:</a> <a id="5797" href="Axiom.html#2389" class="Function">Commuter</a> <a id="5806" class="Symbol">(</a><a id="5807" href="Axiom.html#5703" class="Bound">Product</a> <a id="5815" href="Axiom.html#2973" class="Generalizable">X</a> <a id="5817" href="Axiom.html#2975" class="Generalizable">Y</a><a id="5818" class="Symbol">)</a>
    <a id="5824" href="Axiom.html#5779" class="Bound">ProductCommuter</a> <a id="5840" class="Symbol">=</a> <a id="5842" class="Symbol">λ</a> <a id="5844" class="Symbol">(</a><a id="5845" href="Axiom.html#5845" class="Bound">A</a> <a id="5847" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5849" href="Axiom.html#5849" class="Bound">f</a> <a id="5851" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5853" href="Axiom.html#5853" class="Bound">g</a><a id="5854" class="Symbol">)</a> <a id="5856" class="Symbol">(</a><a id="5857" href="Axiom.html#5857" class="Bound">P</a> <a id="5859" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5861" href="Axiom.html#5861" class="Bound">p</a> <a id="5863" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5865" href="Axiom.html#5865" class="Bound">q</a><a id="5866" class="Symbol">)</a> <a id="5868" href="Axiom.html#5868" class="Bound">h</a> <a id="5870" class="Symbol">→</a> <a id="5872" href="Axiom.html#5861" class="Bound">p</a> <a id="5874" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="5876" href="Axiom.html#5868" class="Bound">h</a> <a id="5878" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5880" href="Axiom.html#5849" class="Bound">f</a> <a id="5882" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5884" href="Axiom.html#5865" class="Bound">q</a> <a id="5886" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="5888" href="Axiom.html#5868" class="Bound">h</a> <a id="5890" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5892" href="Axiom.html#5853" class="Bound">g</a>

    <a id="5899" href="Axiom.html#5899" class="Bound">isProduct</a> <a id="5909" class="Symbol">:</a> <a id="5911" href="Axiom.html#2144" class="Function">Diagram</a> <a id="5919" class="Symbol">(</a><a id="5920" href="Axiom.html#5703" class="Bound">Product</a> <a id="5928" href="Axiom.html#2973" class="Generalizable">X</a> <a id="5930" href="Axiom.html#2975" class="Generalizable">Y</a><a id="5931" class="Symbol">)</a> <a id="5933" class="Symbol">→</a> <a id="5935" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5943" href="Axiom.html#5899" class="Bound">isProduct</a> <a id="5953" class="Symbol">=</a> <a id="5955" href="Axiom.html#2709" class="Function">universal</a> <a id="5965" href="Axiom.html#5779" class="Bound">ProductCommuter</a>
</pre>
<p><strong>公理 5 (积)</strong> 对任意集合 <code>X Y : CSet</code>, 存在积图式满足积的泛性质.</p>
<pre class="Agda">    <a id="6046" class="Comment">-- Axiom 5</a>
    <a id="6061" class="Keyword">field</a> <a id="6067" href="Axiom.html#6067" class="Field">AxProd</a> <a id="6074" class="Symbol">:</a> <a id="6076" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="6078" class="Symbol">(</a><a id="6079" href="Axiom.html#2144" class="Function">Diagram</a> <a id="6087" class="Symbol">(</a><a id="6088" href="Axiom.html#5703" class="Bound">Product</a> <a id="6096" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6098" href="Axiom.html#2975" class="Generalizable">Y</a><a id="6099" class="Symbol">))</a> <a id="6102" href="Axiom.html#5899" class="Bound">isProduct</a>
</pre>
<p>给定集合 <code>X Y : CSet</code>, 我们把公理5所承诺的积图式的底集称为 <code>X</code> 和 <code>Y</code> 的积, 记作 <code>X ×̇ Y</code>.</p>
<pre class="Agda">    <a id="6195" class="Keyword">infixr</a> <a id="6202" class="Number">15</a> <a id="6205" href="Axiom.html#6214" class="Function Operator">_×̇_</a>
    <a id="6214" href="Axiom.html#6214" class="Bound Operator">_×̇_</a> <a id="6219" class="Symbol">:</a> <a id="6221" href="Axiom.html#1616" class="Field">CSet</a> <a id="6226" class="Symbol">→</a> <a id="6228" href="Axiom.html#1616" class="Field">CSet</a> <a id="6233" class="Symbol">→</a> <a id="6235" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="6244" href="Axiom.html#6244" class="Bound">X</a> <a id="6246" href="Axiom.html#6214" class="Bound Operator">×̇</a> <a id="6249" href="Axiom.html#6249" class="Bound">Y</a> <a id="6251" class="Symbol">=</a> <a id="6253" href="Axiom.html#6067" class="Field">AxProd</a> <a id="6260" class="Symbol">{</a><a id="6261" href="Axiom.html#6244" class="Bound">X</a><a id="6262" class="Symbol">}</a> <a id="6264" class="Symbol">{</a><a id="6265" href="Axiom.html#6249" class="Bound">Y</a><a id="6266" class="Symbol">}</a> <a id="6268" class="Symbol">.</a><a id="6269" href="Axiom.html#903" class="Field">fst</a> <a id="6273" class="Symbol">.</a><a id="6274" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p>给定集合 <code>X Y A : CSet</code> 和函数 <code>f : A →̇ X</code> <code>g : A →̇ Y</code>, 公理5承诺了积图示 <code>(A , f , g)</code> 到积图示 <code>(X ×̇ Y , p , q)</code> 的底集间唯一映射, 我们记作 <code>f ,̇ g : A →̇ X ×̇ Y</code>. 如下图所示, 其中虚线表示唯一. 特别地, 当 <code>A ≡ １</code> 时, <code>f</code> 是 <code>X</code> 的元素, <code>g</code> 是 <code>Y</code> 的元素, <code>f ,̇ g</code> 是 <code>X ×̇ Y</code> 的元素.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2d6538eb4972f971f7a6362c7763612f.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<pre class="Agda">    <a id="6601" class="Keyword">infixr</a> <a id="6608" class="Number">5</a> <a id="6610" href="Axiom.html#6619" class="Function Operator">_,̇_</a>
    <a id="6619" href="Axiom.html#6619" class="Bound Operator">_,̇_</a> <a id="6624" class="Symbol">:</a> <a id="6626" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6628" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6631" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6633" class="Symbol">→</a> <a id="6635" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6637" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6640" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="6642" class="Symbol">→</a> <a id="6644" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6646" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6649" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6651" href="Axiom.html#6214" class="Bound Operator">×̇</a> <a id="6654" href="Axiom.html#2975" class="Generalizable">Y</a>
    <a id="6660" href="Axiom.html#6660" class="Bound">f</a> <a id="6662" href="Axiom.html#6619" class="Bound Operator">,̇</a> <a id="6665" href="Axiom.html#6665" class="Bound">g</a> <a id="6667" class="Symbol">=</a> <a id="6669" href="Axiom.html#6067" class="Field">AxProd</a> <a id="6676" class="Symbol">.</a><a id="6677" href="Axiom.html#917" class="Field">snd</a> <a id="6681" class="Symbol">(_</a> <a id="6684" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6686" href="Axiom.html#6660" class="Bound">f</a> <a id="6688" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6690" href="Axiom.html#6665" class="Bound">g</a><a id="6691" class="Symbol">)</a> <a id="6693" class="Symbol">.</a><a id="6694" href="Axiom.html#903" class="Field">fst</a> <a id="6698" class="Symbol">.</a><a id="6699" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p><strong>定义 2.7.3</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的函数集 (简称幂) 的泛性质.</p>
<p>第一步, 定义幂图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>F</code></li>
<li>一个函数 <code>e : F ×̇ X →̇ Y</code></li>
</ul>
<p>简记作 <code>(F , e)</code>.</p>
<p>第二步, 定义幂图式的交换: 我们说两个幂图式 <code>(A , q)</code> 和 <code>(F , e)</code> 以及底集间映射 <code>q̅ : A →̇ F</code> 交换, 当且仅当对任意 <code>a ∈ A</code> 和 <code>x ∈ X</code> 都有 <code>q ⦅ a ,̇ x ⦆ ≡ e ⦅ q̅ ⦅ a ⦆ ,̇ x ⦆</code>.</p>
<p>第三步, 定义幂的泛性质: 我们说一个幂图式 <code>(F , e)</code> 满足幂的泛性质, 当且仅当对任意幂图式 <code>(A , q)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ F</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-687dfd1332dea8dea293646f54c437c1.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<pre class="Agda">    <a id="7171" class="Comment">-- Definition 2.7.3</a>
    <a id="7195" href="Axiom.html#7195" class="Bound">FuncSet</a> <a id="7203" class="Symbol">:</a> <a id="7205" class="Symbol">(</a><a id="7206" href="Axiom.html#7206" class="Bound">X</a> <a id="7208" href="Axiom.html#7208" class="Bound">Y</a> <a id="7210" class="Symbol">:</a> <a id="7212" href="Axiom.html#1616" class="Field">CSet</a><a id="7216" class="Symbol">)</a> <a id="7218" class="Symbol">→</a> <a id="7220" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="7230" href="Axiom.html#7195" class="Bound">FuncSet</a> <a id="7238" href="Axiom.html#7238" class="Bound">X</a> <a id="7240" href="Axiom.html#7240" class="Bound">Y</a> <a id="7242" class="Symbol">=</a> <a id="7244" class="Symbol">λ</a> <a id="7246" href="Axiom.html#7246" class="Bound">F</a> <a id="7248" class="Symbol">→</a> <a id="7250" href="Axiom.html#7246" class="Bound">F</a> <a id="7252" href="Axiom.html#6214" class="Bound Operator">×̇</a> <a id="7255" href="Axiom.html#7238" class="Bound">X</a> <a id="7257" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="7260" href="Axiom.html#7240" class="Bound">Y</a>

    <a id="7267" href="Axiom.html#7267" class="Bound">FuncSetCommuter</a> <a id="7283" class="Symbol">:</a> <a id="7285" href="Axiom.html#2389" class="Function">Commuter</a> <a id="7294" class="Symbol">(</a><a id="7295" href="Axiom.html#7195" class="Bound">FuncSet</a> <a id="7303" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7305" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7306" class="Symbol">)</a>
    <a id="7312" href="Axiom.html#7267" class="Bound">FuncSetCommuter</a> <a id="7328" class="Symbol">{</a><a id="7329" href="Axiom.html#7329" class="Bound">X</a><a id="7330" class="Symbol">}</a> <a id="7332" class="Symbol">=</a> <a id="7334" class="Symbol">λ</a> <a id="7336" class="Symbol">(</a><a id="7337" href="Axiom.html#7337" class="Bound">A</a> <a id="7339" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7341" href="Axiom.html#7341" class="Bound">q</a><a id="7342" class="Symbol">)</a> <a id="7344" class="Symbol">(</a><a id="7345" href="Axiom.html#7345" class="Bound">F</a> <a id="7347" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7349" href="Axiom.html#7349" class="Bound">e</a><a id="7350" class="Symbol">)</a> <a id="7352" href="Axiom.html#7352" class="Bound">q̅</a> <a id="7355" class="Symbol">→</a>
      <a id="7363" href="Axiom.html#4126" class="Bound">∀[</a> <a id="7366" href="Axiom.html#7366" class="Bound">a</a> <a id="7368" href="Axiom.html#4126" class="Bound">∈</a> <a id="7370" href="Axiom.html#7337" class="Bound">A</a> <a id="7372" href="Axiom.html#4126" class="Bound">]</a> <a id="7374" href="Axiom.html#4126" class="Bound">∀[</a> <a id="7377" href="Axiom.html#7377" class="Bound">x</a> <a id="7379" href="Axiom.html#4126" class="Bound">∈</a> <a id="7381" href="Axiom.html#7329" class="Bound">X</a> <a id="7383" href="Axiom.html#4126" class="Bound">]</a> <a id="7385" href="Axiom.html#7341" class="Bound">q</a> <a id="7387" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7389" href="Axiom.html#7366" class="Bound">a</a> <a id="7391" href="Axiom.html#6619" class="Bound Operator">,̇</a> <a id="7394" href="Axiom.html#7377" class="Bound">x</a> <a id="7396" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="7398" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7400" href="Axiom.html#7349" class="Bound">e</a> <a id="7402" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7404" href="Axiom.html#7352" class="Bound">q̅</a> <a id="7407" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7409" href="Axiom.html#7366" class="Bound">a</a> <a id="7411" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="7413" href="Axiom.html#6619" class="Bound Operator">,̇</a> <a id="7416" href="Axiom.html#7377" class="Bound">x</a> <a id="7418" href="Axiom.html#4718" class="Bound Operator">⦆</a>

    <a id="7425" href="Axiom.html#7425" class="Bound">isFuncSet</a> <a id="7435" class="Symbol">:</a> <a id="7437" href="Axiom.html#2144" class="Function">Diagram</a> <a id="7445" class="Symbol">(</a><a id="7446" href="Axiom.html#7195" class="Bound">FuncSet</a> <a id="7454" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7456" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7457" class="Symbol">)</a> <a id="7459" class="Symbol">→</a> <a id="7461" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="7469" href="Axiom.html#7425" class="Bound">isFuncSet</a> <a id="7479" class="Symbol">=</a> <a id="7481" href="Axiom.html#2709" class="Function">universal</a> <a id="7491" href="Axiom.html#7267" class="Bound">FuncSetCommuter</a>
</pre>
<p><strong>公理 6 (幂)</strong> 对任意集合 <code>X Y : CSet</code>, 存在幂图式满足幂的泛性质.</p>
<pre class="Agda">    <a id="7572" class="Comment">-- Axiom 6</a>
    <a id="7587" class="Keyword">field</a> <a id="7593" href="Axiom.html#7593" class="Field">AxFuncSet</a> <a id="7603" class="Symbol">:</a> <a id="7605" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="7607" class="Symbol">(</a><a id="7608" href="Axiom.html#2144" class="Function">Diagram</a> <a id="7616" class="Symbol">(</a><a id="7617" href="Axiom.html#7195" class="Bound">FuncSet</a> <a id="7625" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7627" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7628" class="Symbol">))</a> <a id="7631" href="Axiom.html#7425" class="Bound">isFuncSet</a>
</pre>
<p><strong>定义 3.1.4</strong> 给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 我们按以下四步定义关于 <code>f</code> 和 <code>y</code> 的纤维的泛性质.</p>
<p>第零步, 定义什么叫纤维: 我们说一个集合 <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维, 记作 <code>U withInclusion i isFibreOf f over y</code>, 当且仅当对任意 <code>u ∈ U</code> 都有 <code>f ⦅ i ⦅ u ⦆ ⦆ ≡ y</code>, 也就是下图交换. 由于这样的 <code>U</code> 一般又记作 <span class="math inline">f^{-1}(y)</span>, 图中用此记法.</p>
<p>第一步, 定义纤维图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>U</code></li>
<li>一个函数 <code>i : U →̇ X</code></li>
<li>一个证明: <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维</li>
</ul>
<p>简记作 <code>(U , i , fiu)</code>.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-e279d11dcaed857517f4f8edc2cdd1d2.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<p>第二步, 定义纤维图式的交换: 我们说两个纤维图式 <code>(A , q , fqa)</code> 和 <code>(U , i , fiu)</code> 以及底集间映射 <code>q̅ : A →̇ U</code> 交换, 当且仅当 <code>q ≡ i ∘ q̅</code>.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-a5bf2b3be3ab0027b8d64bfad76b274b.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<p>第三步, 定义纤维的泛性质: 我们说一个纤维图式 <code>(U , i , fiu)</code> 满足纤维的泛性质, 当且仅当对任意纤维图式 <code>(A , q , fqa)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ U</code> 使得它们交换.</p>
<pre class="Agda">    <a id="8434" class="Comment">-- Definition 3.1.4</a>
    <a id="8458" href="Axiom.html#8458" class="Bound Operator">_withInclusion_isFibreOf_over_</a> <a id="8489" class="Symbol">:</a> <a id="8491" class="Symbol">(</a><a id="8492" href="Axiom.html#8492" class="Bound">U</a> <a id="8494" class="Symbol">:</a> <a id="8496" href="Axiom.html#1616" class="Field">CSet</a><a id="8500" class="Symbol">)</a> <a id="8502" class="Symbol">(</a><a id="8503" href="Axiom.html#8503" class="Bound">i</a> <a id="8505" class="Symbol">:</a> <a id="8507" href="Axiom.html#8492" class="Bound">U</a> <a id="8509" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8512" href="Axiom.html#2973" class="Generalizable">X</a><a id="8513" class="Symbol">)</a> <a id="8515" class="Symbol">(</a><a id="8516" href="Axiom.html#8516" class="Bound">f</a> <a id="8518" class="Symbol">:</a> <a id="8520" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8522" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8525" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8526" class="Symbol">)</a> <a id="8528" class="Symbol">(</a><a id="8529" href="Axiom.html#8529" class="Bound">y</a> <a id="8531" class="Symbol">:</a> <a id="8533" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8537" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8538" class="Symbol">)</a> <a id="8540" class="Symbol">→</a> <a id="8542" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8550" href="Axiom.html#8550" class="Bound">U</a> <a id="8552" href="Axiom.html#8458" class="Bound Operator">withInclusion</a> <a id="8566" href="Axiom.html#8566" class="Bound">i</a> <a id="8568" href="Axiom.html#8458" class="Bound Operator">isFibreOf</a> <a id="8578" href="Axiom.html#8578" class="Bound">f</a> <a id="8580" href="Axiom.html#8458" class="Bound Operator">over</a> <a id="8585" href="Axiom.html#8585" class="Bound">y</a> <a id="8587" class="Symbol">=</a> <a id="8589" href="Axiom.html#4126" class="Bound">∀[</a> <a id="8592" href="Axiom.html#8592" class="Bound">u</a> <a id="8594" href="Axiom.html#4126" class="Bound">∈</a> <a id="8596" class="Symbol">_</a> <a id="8598" href="Axiom.html#4126" class="Bound">]</a> <a id="8600" href="Axiom.html#8578" class="Bound">f</a> <a id="8602" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="8604" href="Axiom.html#8566" class="Bound">i</a> <a id="8606" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="8608" href="Axiom.html#8592" class="Bound">u</a> <a id="8610" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="8612" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="8614" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8616" href="Axiom.html#8585" class="Bound">y</a>

    <a id="8623" href="Axiom.html#8623" class="Bound">Fibre</a> <a id="8629" class="Symbol">:</a> <a id="8631" class="Symbol">(</a><a id="8632" href="Axiom.html#8632" class="Bound">f</a> <a id="8634" class="Symbol">:</a> <a id="8636" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8638" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8641" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8642" class="Symbol">)</a> <a id="8644" class="Symbol">(</a><a id="8645" href="Axiom.html#8645" class="Bound">y</a> <a id="8647" class="Symbol">:</a> <a id="8649" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8653" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8654" class="Symbol">)</a> <a id="8656" class="Symbol">→</a> <a id="8658" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="8668" href="Axiom.html#8623" class="Bound">Fibre</a> <a id="8674" class="Symbol">{</a><a id="8675" href="Axiom.html#8675" class="Bound">X</a><a id="8676" class="Symbol">}</a> <a id="8678" href="Axiom.html#8678" class="Bound">f</a> <a id="8680" href="Axiom.html#8680" class="Bound">y</a> <a id="8682" class="Symbol">=</a> <a id="8684" class="Symbol">λ</a> <a id="8686" href="Axiom.html#8686" class="Bound">U</a> <a id="8688" class="Symbol">→</a> <a id="8690" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="8692" class="Symbol">(</a><a id="8693" href="Axiom.html#8686" class="Bound">U</a> <a id="8695" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8698" href="Axiom.html#8675" class="Bound">X</a><a id="8699" class="Symbol">)</a> <a id="8701" class="Symbol">λ</a> <a id="8703" href="Axiom.html#8703" class="Bound">i</a> <a id="8705" class="Symbol">→</a> <a id="8707" href="Axiom.html#8686" class="Bound">U</a> <a id="8709" href="Axiom.html#8458" class="Bound Operator">withInclusion</a> <a id="8723" href="Axiom.html#8703" class="Bound">i</a> <a id="8725" href="Axiom.html#8458" class="Bound Operator">isFibreOf</a> <a id="8735" href="Axiom.html#8678" class="Bound">f</a> <a id="8737" href="Axiom.html#8458" class="Bound Operator">over</a> <a id="8742" href="Axiom.html#8680" class="Bound">y</a>

    <a id="8749" href="Axiom.html#8749" class="Bound">FibreCommuter</a> <a id="8763" class="Symbol">:</a> <a id="8765" class="Symbol">{</a><a id="8766" href="Axiom.html#8766" class="Bound">f</a> <a id="8768" class="Symbol">:</a> <a id="8770" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8772" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8775" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8776" class="Symbol">}</a> <a id="8778" class="Symbol">{</a><a id="8779" href="Axiom.html#8779" class="Bound">y</a> <a id="8781" class="Symbol">:</a> <a id="8783" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8787" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8788" class="Symbol">}</a> <a id="8790" class="Symbol">→</a> <a id="8792" href="Axiom.html#2389" class="Function">Commuter</a> <a id="8801" class="Symbol">(</a><a id="8802" href="Axiom.html#8623" class="Bound">Fibre</a> <a id="8808" href="Axiom.html#8766" class="Bound">f</a> <a id="8810" href="Axiom.html#8779" class="Bound">y</a><a id="8811" class="Symbol">)</a>
    <a id="8817" href="Axiom.html#8749" class="Bound">FibreCommuter</a> <a id="8831" class="Symbol">=</a> <a id="8833" class="Symbol">λ</a> <a id="8835" class="Symbol">(</a><a id="8836" href="Axiom.html#8836" class="Bound">A</a> <a id="8838" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8840" href="Axiom.html#8840" class="Bound">q</a> <a id="8842" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8844" href="Axiom.html#8844" class="Bound">fqa</a><a id="8847" class="Symbol">)</a> <a id="8849" class="Symbol">(</a><a id="8850" href="Axiom.html#8850" class="Bound">U</a> <a id="8852" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8854" href="Axiom.html#8854" class="Bound">i</a> <a id="8856" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8858" href="Axiom.html#8858" class="Bound">fiu</a><a id="8861" class="Symbol">)</a> <a id="8863" href="Axiom.html#8863" class="Bound">q̅</a> <a id="8866" class="Symbol">→</a> <a id="8868" href="Axiom.html#8840" class="Bound">q</a> <a id="8870" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8872" href="Axiom.html#8854" class="Bound">i</a> <a id="8874" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="8876" href="Axiom.html#8863" class="Bound">q̅</a>

    <a id="8884" href="Axiom.html#8884" class="Bound">isFibre</a> <a id="8892" class="Symbol">:</a> <a id="8894" class="Symbol">{</a><a id="8895" href="Axiom.html#8895" class="Bound">f</a> <a id="8897" class="Symbol">:</a> <a id="8899" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8901" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8904" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8905" class="Symbol">}</a> <a id="8907" class="Symbol">{</a><a id="8908" href="Axiom.html#8908" class="Bound">y</a> <a id="8910" class="Symbol">:</a> <a id="8912" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8916" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8917" class="Symbol">}</a> <a id="8919" class="Symbol">→</a> <a id="8921" href="Axiom.html#2144" class="Function">Diagram</a> <a id="8929" class="Symbol">(</a><a id="8930" href="Axiom.html#8623" class="Bound">Fibre</a> <a id="8936" href="Axiom.html#8895" class="Bound">f</a> <a id="8938" href="Axiom.html#8908" class="Bound">y</a><a id="8939" class="Symbol">)</a> <a id="8941" class="Symbol">→</a> <a id="8943" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8951" href="Axiom.html#8884" class="Bound">isFibre</a> <a id="8959" class="Symbol">=</a> <a id="8961" href="Axiom.html#2709" class="Function">universal</a> <a id="8971" href="Axiom.html#8749" class="Bound">FibreCommuter</a>
</pre>
<p><strong>公理 7 (纤维)</strong> 对任意 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在纤维图式满足纤维的泛性质.</p>
<pre class="Agda">    <a id="9063" class="Comment">-- Axiom 7</a>
    <a id="9078" class="Keyword">field</a> <a id="9084" href="Axiom.html#9084" class="Field">AxFibre</a> <a id="9092" class="Symbol">:</a> <a id="9094" class="Symbol">{</a><a id="9095" href="Axiom.html#9095" class="Bound">f</a> <a id="9097" class="Symbol">:</a> <a id="9099" href="Axiom.html#2973" class="Generalizable">X</a> <a id="9101" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="9104" href="Axiom.html#2975" class="Generalizable">Y</a><a id="9105" class="Symbol">}</a> <a id="9107" class="Symbol">{</a><a id="9108" href="Axiom.html#9108" class="Bound">y</a> <a id="9110" class="Symbol">:</a> <a id="9112" href="Axiom.html#4088" class="Bound">Elm</a> <a id="9116" href="Axiom.html#2975" class="Generalizable">Y</a><a id="9117" class="Symbol">}</a> <a id="9119" class="Symbol">→</a> <a id="9121" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9123" class="Symbol">(</a><a id="9124" href="Axiom.html#2144" class="Function">Diagram</a> <a id="9132" class="Symbol">(</a><a id="9133" href="Axiom.html#8623" class="Bound">Fibre</a> <a id="9139" href="Axiom.html#9095" class="Bound">f</a> <a id="9141" href="Axiom.html#9108" class="Bound">y</a><a id="9142" class="Symbol">))</a> <a id="9145" href="Axiom.html#8884" class="Bound">isFibre</a>
</pre>
<p><strong>定义 3.2.1</strong> 我们按以下三步定义子集分类器的泛性质.</p>
<p>第一步, 我们定义子集分类器图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>Ω</code></li>
<li>一个集合 <code>T</code></li>
<li>一个函数 <code>t : T →̇ Ω</code></li>
</ul>
<p>简记作 <code>(Ω , T , t)</code>.</p>
<p>第二步, 定义子集分类器图式的交换: 我们说两个子集分类器图式 <code>(A , X , i)</code> 和 <code>(Ω , T , t)</code> 以及底集间映射 <code>χ : A →̇ Ω</code> 交换, 当且仅当如果 <code>T ≡ １</code>, 那么 <code>X</code> 配合上 <code>i</code> 是 <code>χ</code> 在 <code>t</code> 上的纤维.</p>
<p>第三步, 定义子集分类器的泛性质: 我们说一个子集分类器图式 <code>(Ω , T , t)</code> 满足子集分类器的泛性质, 当且仅当对任意子集分类器图式 <code>(A , X , i)</code>, 存在唯一的底集间映射 <code>χ : A →̇ Ω</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-4a23a3be42899b6e8ce7187429bfb81e.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<pre class="Agda">    <a id="9630" class="Comment">-- Definition 3.2.1</a>
    <a id="9654" href="Axiom.html#9654" class="Bound">SubCls</a> <a id="9661" class="Symbol">:</a> <a id="9663" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="9673" href="Axiom.html#9654" class="Bound">SubCls</a> <a id="9680" class="Symbol">=</a> <a id="9682" class="Symbol">λ</a> <a id="9684" href="Axiom.html#9684" class="Bound">Ω</a> <a id="9686" class="Symbol">→</a> <a id="9688" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9690" href="Axiom.html#1616" class="Field">CSet</a> <a id="9695" class="Symbol">λ</a> <a id="9697" href="Axiom.html#9697" class="Bound">T</a> <a id="9699" class="Symbol">→</a> <a id="9701" href="Axiom.html#9697" class="Bound">T</a> <a id="9703" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="9706" href="Axiom.html#9684" class="Bound">Ω</a>

    <a id="9713" href="Axiom.html#9713" class="Bound">SubClsCommuter</a> <a id="9728" class="Symbol">:</a> <a id="9730" href="Axiom.html#2389" class="Function">Commuter</a> <a id="9739" href="Axiom.html#9654" class="Bound">SubCls</a>
    <a id="9750" href="Axiom.html#9713" class="Bound">SubClsCommuter</a> <a id="9765" class="Symbol">=</a> <a id="9767" class="Symbol">λ</a> <a id="9769" class="Symbol">(</a><a id="9770" href="Axiom.html#9770" class="Bound">A</a> <a id="9772" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9774" href="Axiom.html#9774" class="Bound">X</a> <a id="9776" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9778" href="Axiom.html#9778" class="Bound">i</a><a id="9779" class="Symbol">)</a> <a id="9781" class="Symbol">(</a><a id="9782" href="Axiom.html#9782" class="Bound">Ω</a> <a id="9784" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9786" href="Axiom.html#9786" class="Bound">T</a> <a id="9788" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9790" href="Axiom.html#9790" class="Bound">t</a><a id="9791" class="Symbol">)</a> <a id="9793" href="Axiom.html#9793" class="Bound">χ</a> <a id="9795" class="Symbol">→</a> <a id="9797" class="Symbol">(</a><a id="9798" href="Axiom.html#9798" class="Bound">eq</a> <a id="9801" class="Symbol">:</a> <a id="9803" href="Axiom.html#9786" class="Bound">T</a> <a id="9805" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9807" href="Axiom.html#3917" class="Bound">１</a><a id="9808" class="Symbol">)</a> <a id="9810" class="Symbol">→</a>
      <a id="9818" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="9823" href="Axiom.html#9798" class="Bound">eq</a> <a id="9826" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="9829" class="Symbol">λ</a> <a id="9831" class="Symbol">{</a> <a id="9833" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9838" class="Symbol">→</a> <a id="9840" href="Axiom.html#9774" class="Bound">X</a> <a id="9842" href="Axiom.html#8458" class="Bound Operator">withInclusion</a> <a id="9856" href="Axiom.html#9778" class="Bound">i</a> <a id="9858" href="Axiom.html#8458" class="Bound Operator">isFibreOf</a> <a id="9868" href="Axiom.html#9793" class="Bound">χ</a> <a id="9870" href="Axiom.html#8458" class="Bound Operator">over</a> <a id="9875" href="Axiom.html#9790" class="Bound">t</a> <a id="9877" class="Symbol">}</a>

    <a id="9884" href="Axiom.html#9884" class="Bound">isSubCls</a> <a id="9893" class="Symbol">:</a> <a id="9895" href="Axiom.html#2144" class="Function">Diagram</a> <a id="9903" href="Axiom.html#9654" class="Bound">SubCls</a> <a id="9910" class="Symbol">→</a> <a id="9912" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="9920" href="Axiom.html#9884" class="Bound">isSubCls</a> <a id="9929" class="Symbol">=</a> <a id="9931" href="Axiom.html#2709" class="Function">universal</a> <a id="9941" href="Axiom.html#9713" class="Bound">SubClsCommuter</a>
</pre>
<p><strong>公理 8 (子集)</strong> 存在一个子集分类器图式 <code>(Ω , １ , t)</code> 满足子集分类器的泛性质.</p>
<pre class="Agda">    <a id="10027" class="Comment">-- Axiom 8</a>
    <a id="10042" class="Keyword">field</a> <a id="10048" href="Axiom.html#10048" class="Field">AxSubCls</a> <a id="10057" class="Symbol">:</a> <a id="10059" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10061" class="Symbol">(</a><a id="10062" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10070" href="Axiom.html#9654" class="Bound">SubCls</a><a id="10076" class="Symbol">)</a> <a id="10078" class="Symbol">λ</a> <a id="10080" href="Axiom.html#10080" class="Bound">d</a><a id="10081" class="Symbol">@(_</a> <a id="10085" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10087" href="Axiom.html#10087" class="Bound">T</a> <a id="10089" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10091" class="Symbol">_)</a> <a id="10094" class="Symbol">→</a> <a id="10096" href="Axiom.html#10087" class="Bound">T</a> <a id="10098" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10100" href="Axiom.html#3917" class="Bound">１</a> <a id="10102" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10104" href="Axiom.html#9884" class="Bound">isSubCls</a> <a id="10113" href="Axiom.html#10080" class="Bound">d</a>
</pre>
<p><strong>定义 3.3.2</strong> 我们按以下三步定义自然数集的泛性质.</p>
<p>第一步, 定义自然数图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>N</code></li>
<li>一个元素 <code>z ∈ N</code></li>
<li>一个函数 <code>σ : N →̇ N</code></li>
</ul>
<p>第二步, 定义自然数图式的交换: 我们说两个自然数图式 <code>(N , z , σ)</code> 和 <code>(X , a , r)</code> 以及底集间映射 <code>x : N →̇ X</code> 交换, 当且仅当对任意 <code>n ∈ N</code> 都有 <code>x ⦅ z ⦆ ≡ a</code> 且 <code>x ⦅ σ ⦅ n ⦆ ⦆ ≡ r ⦅ x ⦅ n ⦆ ⦆</code>.</p>
<p>第三步, 定义自然数的泛性质: 我们说一个自然数图式 <code>(N , z , σ)</code> 满足自然数的泛性质, 当且仅当对任意自然数图式 <code>(X , a , r)</code>, 存在唯一的底集间映射 <code>x : N →̇ X</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-e45551a00cb7f8e004d3a63e3f29ece0.png" alt="Image" />
<figcaption aria-hidden="true">Image</figcaption>
</figure>
<pre class="Agda">    <a id="10578" class="Comment">-- Definition 3.3.2</a>
    <a id="10602" href="Axiom.html#10602" class="Bound">Nat</a> <a id="10606" class="Symbol">:</a> <a id="10608" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="10618" href="Axiom.html#10602" class="Bound">Nat</a> <a id="10622" class="Symbol">=</a> <a id="10624" class="Symbol">λ</a> <a id="10626" href="Axiom.html#10626" class="Bound">N</a> <a id="10628" class="Symbol">→</a> <a id="10630" href="Axiom.html#4088" class="Bound">Elm</a> <a id="10634" href="Axiom.html#10626" class="Bound">N</a> <a id="10636" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10638" href="Axiom.html#10626" class="Bound">N</a> <a id="10640" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="10643" href="Axiom.html#10626" class="Bound">N</a>

    <a id="10650" href="Axiom.html#10650" class="Bound">NatCommuter</a> <a id="10662" class="Symbol">:</a> <a id="10664" href="Axiom.html#2389" class="Function">Commuter</a> <a id="10673" href="Axiom.html#10602" class="Bound">Nat</a>
    <a id="10681" href="Axiom.html#10650" class="Bound">NatCommuter</a> <a id="10693" class="Symbol">=</a> <a id="10695" class="Symbol">λ</a> <a id="10697" class="Symbol">(</a><a id="10698" href="Axiom.html#10698" class="Bound">N</a> <a id="10700" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10702" href="Axiom.html#10702" class="Bound">z</a> <a id="10704" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10706" href="Axiom.html#10706" class="Bound">σ</a><a id="10707" class="Symbol">)</a> <a id="10709" class="Symbol">(</a><a id="10710" href="Axiom.html#10710" class="Bound">X</a> <a id="10712" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10714" href="Axiom.html#10714" class="Bound">a</a> <a id="10716" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10718" href="Axiom.html#10718" class="Bound">r</a><a id="10719" class="Symbol">)</a> <a id="10721" href="Axiom.html#10721" class="Bound">x</a> <a id="10723" class="Symbol">→</a>
      <a id="10731" href="Axiom.html#4126" class="Bound">∀[</a> <a id="10734" href="Axiom.html#10734" class="Bound">n</a> <a id="10736" href="Axiom.html#4126" class="Bound">∈</a> <a id="10738" href="Axiom.html#10698" class="Bound">N</a> <a id="10740" href="Axiom.html#4126" class="Bound">]</a> <a id="10742" class="Symbol">(</a><a id="10743" href="Axiom.html#10721" class="Bound">x</a> <a id="10745" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10747" href="Axiom.html#10702" class="Bound">z</a> <a id="10749" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10751" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10753" href="Axiom.html#10714" class="Bound">a</a> <a id="10755" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10757" href="Axiom.html#10721" class="Bound">x</a> <a id="10759" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10761" href="Axiom.html#10706" class="Bound">σ</a> <a id="10763" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10765" href="Axiom.html#10734" class="Bound">n</a> <a id="10767" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10769" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10771" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10773" href="Axiom.html#10718" class="Bound">r</a> <a id="10775" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10777" href="Axiom.html#10721" class="Bound">x</a> <a id="10779" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10781" href="Axiom.html#10734" class="Bound">n</a> <a id="10783" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10785" href="Axiom.html#4718" class="Bound Operator">⦆</a><a id="10786" class="Symbol">)</a>

    <a id="10793" href="Axiom.html#10793" class="Bound">isNat</a> <a id="10799" class="Symbol">:</a> <a id="10801" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10809" href="Axiom.html#10602" class="Bound">Nat</a> <a id="10813" class="Symbol">→</a> <a id="10815" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="10823" href="Axiom.html#10793" class="Bound">isNat</a> <a id="10829" class="Symbol">=</a> <a id="10831" href="Axiom.html#2709" class="Function">universal</a> <a id="10841" href="Axiom.html#10650" class="Bound">NatCommuter</a>
</pre>
<p><strong>公理 9 (自然数)</strong> 存在一个自然数图式满足自然数的泛性质.</p>
<pre class="Agda">    <a id="10906" class="Comment">-- Axiom 9</a>
    <a id="10921" class="Keyword">field</a> <a id="10927" href="Axiom.html#10927" class="Field">AxNat</a> <a id="10933" class="Symbol">:</a> <a id="10935" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10937" class="Symbol">(</a><a id="10938" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10946" href="Axiom.html#10602" class="Bound">Nat</a><a id="10949" class="Symbol">)</a> <a id="10951" href="Axiom.html#10793" class="Bound">isNat</a>
</pre>
<p><strong>定义 3.1.8 ii</strong> 给定函数 <code>f : X →̇ Y</code>, 我们称 <code>f</code> 是满射, 当且仅当对任意 <code>y ∈ Y</code> 都存在 <code>x ∈ X</code> 使得 <code>f ⦅ x ⦆ ≡ y</code>.</p>
<pre class="Agda">    <a id="11069" class="Comment">-- Definition 3.1.8 ii</a>
    <a id="11096" href="Axiom.html#11096" class="Bound">surjective</a> <a id="11107" class="Symbol">:</a> <a id="11109" class="Symbol">(</a><a id="11110" href="Axiom.html#11110" class="Bound">f</a> <a id="11112" class="Symbol">:</a> <a id="11114" href="Axiom.html#2973" class="Generalizable">X</a> <a id="11116" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11119" href="Axiom.html#2975" class="Generalizable">Y</a><a id="11120" class="Symbol">)</a> <a id="11122" class="Symbol">→</a> <a id="11124" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11132" href="Axiom.html#11096" class="Bound">surjective</a> <a id="11143" class="Symbol">{</a><a id="11144" href="Axiom.html#11144" class="Bound">X</a><a id="11145" class="Symbol">}</a> <a id="11147" class="Symbol">{</a><a id="11148" href="Axiom.html#11148" class="Bound">Y</a><a id="11149" class="Symbol">}</a> <a id="11151" href="Axiom.html#11151" class="Bound">f</a> <a id="11153" class="Symbol">=</a> <a id="11155" href="Axiom.html#4126" class="Bound">∀[</a> <a id="11158" href="Axiom.html#11158" class="Bound">y</a> <a id="11160" href="Axiom.html#4126" class="Bound">∈</a> <a id="11162" href="Axiom.html#11148" class="Bound">Y</a> <a id="11164" href="Axiom.html#4126" class="Bound">]</a> <a id="11166" href="Axiom.html#4295" class="Bound">∃[</a> <a id="11169" href="Axiom.html#11169" class="Bound">x</a> <a id="11171" href="Axiom.html#4295" class="Bound">∈</a> <a id="11173" href="Axiom.html#11144" class="Bound">X</a> <a id="11175" href="Axiom.html#4295" class="Bound">]</a> <a id="11177" href="Axiom.html#11151" class="Bound">f</a> <a id="11179" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="11181" href="Axiom.html#11169" class="Bound">x</a> <a id="11183" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="11185" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11187" href="Axiom.html#11158" class="Bound">y</a>
</pre>
<p><strong>定义 3.4.1</strong> 给定函数 <code>f : X →̇ Y</code> 和 <code>i : Y →̇ X</code>, 我们称 <code>i</code> 是 <code>f</code> 的截面, 当且仅当 <code>f ∘ i ≡ id</code>.</p>
<pre class="Agda">    <a id="11292" class="Comment">-- Definition 3.4.1</a>
    <a id="11316" href="Axiom.html#11316" class="Bound">section</a> <a id="11324" class="Symbol">:</a> <a id="11326" class="Symbol">(</a><a id="11327" href="Axiom.html#11327" class="Bound">f</a> <a id="11329" class="Symbol">:</a> <a id="11331" href="Axiom.html#2973" class="Generalizable">X</a> <a id="11333" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11336" href="Axiom.html#2975" class="Generalizable">Y</a><a id="11337" class="Symbol">)</a> <a id="11339" class="Symbol">(</a><a id="11340" href="Axiom.html#11340" class="Bound">i</a> <a id="11342" class="Symbol">:</a> <a id="11344" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="11346" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11349" href="Axiom.html#2973" class="Generalizable">X</a><a id="11350" class="Symbol">)</a> <a id="11352" class="Symbol">→</a> <a id="11354" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11362" href="Axiom.html#11316" class="Bound">section</a> <a id="11370" href="Axiom.html#11370" class="Bound">f</a> <a id="11372" href="Axiom.html#11372" class="Bound">i</a> <a id="11374" class="Symbol">=</a> <a id="11376" href="Axiom.html#11370" class="Bound">f</a> <a id="11378" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="11380" href="Axiom.html#11372" class="Bound">i</a> <a id="11382" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11384" href="Axiom.html#1754" class="Function">id</a>
</pre>
<p><strong>公理 10 (选择)</strong> 如果 <code>f : X →̇ Y</code> 是满射, 那么存在 <code>f</code> 的一个截面 <code>i : Y →̇ X</code>.</p>
<pre class="Agda">    <a id="11470" class="Comment">-- Axiom 10</a>
    <a id="11486" class="Keyword">field</a> <a id="11492" href="Axiom.html#11492" class="Field">AxChoice</a> <a id="11501" class="Symbol">:</a> <a id="11503" href="Axiom.html#11096" class="Bound">surjective</a> <a id="11514" href="Axiom.html#2996" class="Generalizable">f</a> <a id="11516" class="Symbol">→</a> <a id="11518" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11520" class="Symbol">(</a><a id="11521" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="11523" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11526" href="Axiom.html#2973" class="Generalizable">X</a><a id="11527" class="Symbol">)</a> <a id="11529" class="Symbol">(</a><a id="11530" href="Axiom.html#11316" class="Bound">section</a> <a id="11538" href="Axiom.html#2996" class="Generalizable">f</a><a id="11539" class="Symbol">)</a>
</pre>
<h2 id="总结">总结</h2>
<p>以下是对公理化的总结. 我们的公理适用于以下资料：</p>
<ul>
<li>一些称为集合的东西;</li>
<li>对于每个集合 <code>X</code> 和集合 <code>Y</code>, 一些称为从 <code>X</code> 到 <code>Y</code> 的函数, 我们用 <code>f : X →̇ Y</code> 表示从 <code>X</code> 到 <code>Y</code> 的函数 <code>f</code>;</li>
<li>对于每个集合 <code>X</code>, 集合 <code>Y</code> 和集合 <code>X</code>, 一个称为复合的运算, 将每对函数 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋予一个函数 <code>f ∘ g : X →̇ Z</code>;</li>
<li>对于每个集合 <code>X</code>， 一个函数 <code>id : X →̇ X</code>, 称为 <code>X</code> 的恒等函数.</li>
</ul>
<p>公理：</p>
<ol type="1">
<li>函数的复合满足结合律, 并且恒等函数起到恒等作用.</li>
<li>存在一个终集.</li>
<li>函数外延性成立.</li>
<li>存在一个空集.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 和 <code>Y</code> 的积.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 到 <code>Y</code> 的函数集.</li>
<li>给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在 <code>f</code> 在 <code>y</code> 上的纤维.</li>
<li>存在一个子集分类器.</li>
<li>存在一个自然数系统.</li>
<li>每个满射都有一个截面.</li>
</ol>
<p>公理 3, 4 和 7 都涉及到元素, 它定义为定义域为终集 <code>１</code> 的函数. 公理 2 以及 5–9 都涉及到泛性质, 并且所有这些公理唯一地刻画了涉及的集合 （在同构意义上）, 这将在接下来的几篇中证明.</p>
<pre class="Agda"><a id="12179" class="Keyword">record</a> <a id="ETCS"></a><a id="12186" href="Axiom.html#12186" class="Record">ETCS</a> <a id="12191" class="Symbol">:</a> <a id="12193" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="12198" class="Keyword">where</a>
  <a id="12206" class="Keyword">field</a>
    <a id="ETCS.etcs"></a><a id="12216" href="Axiom.html#12216" class="Field">etcs</a> <a id="12221" class="Symbol">:</a> <a id="12223" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="12225" href="Axiom.html#1554" class="Record">Data</a> <a id="12230" href="Axiom.html#3069" class="Record">Data.Axiom</a>
  <a id="12243" class="Keyword">open</a> <a id="12248" href="Axiom.html#1554" class="Module">Data</a> <a id="12253" class="Symbol">(</a><a id="12254" href="Axiom.html#12216" class="Field">etcs</a> <a id="12259" class="Symbol">.</a><a id="12260" href="Axiom.html#903" class="Field">fst</a><a id="12263" class="Symbol">)</a> <a id="12265" class="Keyword">public</a>
  <a id="12274" class="Keyword">open</a> <a id="12279" href="Axiom.html#3069" class="Module">Data.Axiom</a> <a id="12290" class="Symbol">(</a><a id="12291" href="Axiom.html#12216" class="Field">etcs</a> <a id="12296" class="Symbol">.</a><a id="12297" href="Axiom.html#917" class="Field">snd</a><a id="12300" class="Symbol">)</a> <a id="12302" class="Keyword">public</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
