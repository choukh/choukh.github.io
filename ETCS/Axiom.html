<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>公理化结构集合论 (1 公理)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">公理化结构集合论 (1 公理)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#公理化结构集合论-1-公理" id="toc-公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#原始概念" id="toc-原始概念">原始概念</a></li>
  <li><a href="#公理" id="toc-公理">公理</a></li>
  <li><a href="#总结" id="toc-总结">总结</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/ETCS/blob/main/src/Axiom.lagda.md">Axiom.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/ETCS/Axiom.html">Axiom.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是对 Tom Leinster 在爱丁堡大学教授的本科课程「公理化结构集合论（ETCS）」<a href="https://www.maths.ed.ac.uk/~tl/ast/ast.pdf">讲义</a>（以下简称「讲义」）的 Agda 形式化. 我们的符号选取和定义表述基本上遵循讲义, 而定理编号与讲义完全一致, 但由于 Agda 的特性而稍微调整了顺序. 注意我们讲的是一种可以作为数学基础的集合论而不是范畴论, 虽然借用了一些范畴论的术语和思想, 但不需要先掌握范畴论.</p>
<p>我们采用原味 Agda 加 stdlib 标准库, 这是我们的元语言, 而 ETCS 将是我们的对象语言. 由于两层语言的高度相似性, 它们的符号/命名冲突我们主要采用如下两种方式解决.</p>
<ol type="1">
<li>如果一个符号已经用于元语言 (如 <code>→</code>), 则在上面加点表示对象语言的相应概念 (如 <code>→̇</code>).</li>
<li>如果一个符号优先用于对象语言 (如 <code>id</code>), 则在后面加上 <code>⒨</code> 表示元语言的相应概念 (如 <code>id⒨</code>).</li>
</ol>
<pre class="Agda"><a id="773" class="Keyword">module</a> <a id="780" href="Axiom.html" class="Module">Axiom</a> <a id="786" class="Keyword">where</a>

<a id="793" class="Keyword">open</a> <a id="798" class="Keyword">import</a> <a id="805" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="816" class="Keyword">public</a> <a id="823" class="Keyword">using</a> <a id="829" class="Symbol">(</a><a id="830" href="Data.Empty.html#914" class="Function">⊥</a><a id="831" class="Symbol">)</a>
<a id="833" class="Keyword">open</a> <a id="838" class="Keyword">import</a> <a id="845" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="855" class="Keyword">public</a> <a id="862" class="Keyword">using</a> <a id="868" class="Symbol">(</a><a id="869" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="870" class="Symbol">;</a> <a id="872" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="874" class="Symbol">)</a>
<a id="876" class="Keyword">open</a> <a id="881" class="Keyword">import</a> <a id="888" href="Data.Product.html" class="Module">Data.Product</a> <a id="901" class="Keyword">public</a> <a id="908" class="Keyword">using</a> <a id="914" class="Symbol">(</a><a id="915" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="916" class="Symbol">;</a> <a id="918" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="921" class="Symbol">;</a> <a id="923" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="926" class="Symbol">)</a>
  <a id="930" class="Keyword">renaming</a> <a id="939" class="Symbol">(</a><a id="940" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="946" class="Symbol">to</a> <a id="949" class="Field">fst</a><a id="952" class="Symbol">;</a> <a id="954" href="Data.Product.Base.html#650" class="Field">proj₂</a> <a id="960" class="Symbol">to</a> <a id="963" class="Field">snd</a><a id="966" class="Symbol">)</a>
<a id="968" class="Keyword">open</a> <a id="973" class="Keyword">import</a> <a id="980" href="Function.html" class="Module">Function</a> <a id="989" class="Keyword">public</a> <a id="996" class="Keyword">using</a> <a id="1002" class="Symbol">(</a><a id="1003" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="1011" class="Symbol">)</a> <a id="1013" class="Keyword">renaming</a> <a id="1022" class="Symbol">(</a><a id="1023" href="Function.Base.html#704" class="Function">id</a> <a id="1026" class="Symbol">to</a> <a id="1029" class="Function">id⒨</a><a id="1032" class="Symbol">)</a>
<a id="1034" class="Keyword">open</a> <a id="1039" class="Keyword">import</a> <a id="1046" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1084" class="Keyword">public</a>
</pre>
<p>本文是系列的第一篇, 我们引入 ETCS 的10条公理. 为了表述公理, 首先需要引入 ETCS 的原始概念, 讲义中称它们为资料 (the data), 有的地方也称之为原语 (primitives) , 语言 (language) 或签名 (signature).</p>
<h2 id="原始概念">原始概念</h2>
<p>形式地, 我们的公理将在如下原始概念上展开表述.</p>
<ul>
<li>一些称为集合的东西, 这样的集合 <code>X</code> 记作 <code>X : CSet</code>, 其中 C 来自范畴 (category).</li>
<li>对每个集合 <code>X</code> 和 <code>Y</code>, 一些称为「<code>X</code> 到 <code>Y</code> 的函数」的东西, 这样的函数 <code>f</code> 记作 <code>f : X →̇ Y</code>.</li>
<li>对每个集合 <code>X</code>, <code>Y</code> 和 <code>Z</code>, 一个称为「复合」的运算, 将每个 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋值为一个函数 <code>g ∘ f : X →̇ Z</code>.</li>
<li>对每个集合 <code>X</code>, 一个称为「恒等函数」的东西, 记作 <code>id⟨ X ⟩ : X →̇ X</code>, <code>X</code> 可以从上下文推断出来时简记作 <code>id</code>.</li>
</ul>
<pre class="Agda"><a id="1577" class="Comment">-- 2.1 The data</a>
<a id="1593" class="Keyword">record</a> <a id="Data"></a><a id="1600" href="Axiom.html#1600" class="Record">Data</a> <a id="1605" class="Symbol">:</a> <a id="1607" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="1612" class="Keyword">where</a>
  <a id="1620" class="Keyword">infixl</a> <a id="1627" class="Number">10</a> <a id="1630" href="Axiom.html#1677" class="Field Operator">_→̇_</a>
  <a id="1637" class="Keyword">infix</a> <a id="1643" class="Number">10</a> <a id="1646" href="Axiom.html#1707" class="Field Operator">_∘_</a>
  <a id="1652" class="Keyword">field</a>
    <a id="Data.CSet"></a><a id="1662" href="Axiom.html#1662" class="Field">CSet</a> <a id="1667" class="Symbol">:</a> <a id="1669" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._→̇_"></a><a id="1677" href="Axiom.html#1677" class="Field Operator">_→̇_</a> <a id="1682" class="Symbol">:</a> <a id="1684" class="Symbol">(</a><a id="1685" href="Axiom.html#1685" class="Bound">X</a> <a id="1687" href="Axiom.html#1687" class="Bound">Y</a> <a id="1689" class="Symbol">:</a> <a id="1691" href="Axiom.html#1662" class="Field">CSet</a><a id="1695" class="Symbol">)</a> <a id="1697" class="Symbol">→</a> <a id="1699" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._∘_"></a><a id="1707" href="Axiom.html#1707" class="Field Operator">_∘_</a> <a id="1711" class="Symbol">:</a> <a id="1713" class="Symbol">{</a><a id="1714" href="Axiom.html#1714" class="Bound">X</a> <a id="1716" href="Axiom.html#1716" class="Bound">Y</a> <a id="1718" href="Axiom.html#1718" class="Bound">Z</a> <a id="1720" class="Symbol">:</a> <a id="1722" href="Axiom.html#1662" class="Field">CSet</a><a id="1726" class="Symbol">}</a> <a id="1728" class="Symbol">(</a><a id="1729" href="Axiom.html#1729" class="Bound">g</a> <a id="1731" class="Symbol">:</a> <a id="1733" href="Axiom.html#1716" class="Bound">Y</a> <a id="1735" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1738" href="Axiom.html#1718" class="Bound">Z</a><a id="1739" class="Symbol">)</a> <a id="1741" class="Symbol">(</a><a id="1742" href="Axiom.html#1742" class="Bound">f</a> <a id="1744" class="Symbol">:</a> <a id="1746" href="Axiom.html#1714" class="Bound">X</a> <a id="1748" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1751" href="Axiom.html#1716" class="Bound">Y</a><a id="1752" class="Symbol">)</a> <a id="1754" class="Symbol">→</a> <a id="1756" class="Symbol">(</a><a id="1757" href="Axiom.html#1714" class="Bound">X</a> <a id="1759" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1762" href="Axiom.html#1718" class="Bound">Z</a><a id="1763" class="Symbol">)</a>
    <a id="Data.id⟨_⟩"></a><a id="1769" href="Axiom.html#1769" class="Field Operator">id⟨_⟩</a> <a id="1775" class="Symbol">:</a> <a id="1777" class="Symbol">(</a><a id="1778" href="Axiom.html#1778" class="Bound">X</a> <a id="1780" class="Symbol">:</a> <a id="1782" href="Axiom.html#1662" class="Field">CSet</a><a id="1786" class="Symbol">)</a> <a id="1788" class="Symbol">→</a> <a id="1790" href="Axiom.html#1778" class="Bound">X</a> <a id="1792" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1795" href="Axiom.html#1778" class="Bound">X</a>

  <a id="Data.id"></a><a id="1800" href="Axiom.html#1800" class="Function">id</a> <a id="1803" class="Symbol">:</a> <a id="1805" class="Symbol">{</a><a id="1806" href="Axiom.html#1806" class="Bound">X</a> <a id="1808" class="Symbol">:</a> <a id="1810" href="Axiom.html#1662" class="Field">CSet</a><a id="1814" class="Symbol">}</a> <a id="1816" class="Symbol">→</a> <a id="1818" href="Axiom.html#1806" class="Bound">X</a> <a id="1820" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="1823" href="Axiom.html#1806" class="Bound">X</a>
  <a id="1827" href="Axiom.html#1800" class="Function">id</a> <a id="1830" class="Symbol">{</a><a id="1831" href="Axiom.html#1831" class="Bound">X</a><a id="1832" class="Symbol">}</a> <a id="1834" class="Symbol">=</a> <a id="1836" href="Axiom.html#1769" class="Field Operator">id⟨</a> <a id="1840" href="Axiom.html#1831" class="Bound">X</a> <a id="1842" href="Axiom.html#1769" class="Field Operator">⟩</a>
</pre>
<p>我们会形式化讲义中没有编号的定义和命题, 这些内容我们编号为负数.</p>
<p><strong>定义 -1.1</strong> 我们把关于集合的性质称为箭头模式 <code>Arrow</code>. 给定这样的性质 <code>A : Arrow</code>, 如果某集合 <code>X</code> 满足 <code>A</code>, 我们就把 <code>a : A X</code> 称为集合 <code>X</code> 的一套 <code>A</code>-箭头.</p>
<pre class="Agda">  <a id="Data.Arrow"></a><a id="2008" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2014" class="Symbol">:</a> <a id="2016" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2023" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2029" class="Symbol">=</a> <a id="2031" href="Axiom.html#1662" class="Field">CSet</a> <a id="2036" class="Symbol">→</a> <a id="2038" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.2</strong> 给定箭头模式 <code>A</code>, 由以下资料组成的东西称为 <code>A</code>-图式 (diagram), 记作 <code>Diagram A</code>.</p>
<ul>
<li>一个集合 <code>X</code></li>
<li><code>X</code> 的一套 <code>A</code>-箭头</li>
</ul>
<p>其中 <code>X</code> 叫做图式的底集 (underlying set).</p>
<pre class="Agda">  <a id="Data.Diagram"></a><a id="2192" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2200" class="Symbol">:</a> <a id="2202" href="Axiom.html#2008" class="Function">Arrow</a> <a id="2208" class="Symbol">→</a> <a id="2210" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2216" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2224" class="Symbol">=</a> <a id="2226" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2228" href="Axiom.html#1662" class="Field">CSet</a>
</pre>
<p><strong>定义 -1.3</strong> 给定箭头模式 <code>A</code>, 我们把关于两个 <code>A</code>-图式以及它们的底集间映射 <code>j</code> 的性质称为 <code>A</code>-交换模式, 记作 <code>Commuter A</code>. 对任意两个 <code>A</code>-图式 <code>a</code> <code>b</code> 以及它们的底集间映射 <code>j</code>, 如果它们满足一个 <code>A</code>-交换模式 <code>C : Commuter A</code>, 我们就称它们 <code>C</code>-交换, 记作 <code>C a b j</code>.</p>
<pre class="Agda">  <a id="Data.Commuter"></a><a id="2437" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2446" class="Symbol">:</a> <a id="2448" class="Symbol">(</a><a id="2449" href="Axiom.html#2449" class="Bound">A</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="Axiom.html#2008" class="Function">Arrow</a><a id="2458" class="Symbol">)</a> <a id="2460" class="Symbol">→</a> <a id="2462" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2469" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2478" href="Axiom.html#2478" class="Bound">A</a> <a id="2480" class="Symbol">=</a> <a id="2482" class="Symbol">(</a><a id="2483" href="Axiom.html#2483" class="Bound">(</a><a id="2484" href="Axiom.html#2484" class="Bound">X</a> <a id="2486" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2488" href="Axiom.html#2483" class="Bound">_)</a> <a id="2491" href="Axiom.html#2491" class="Bound">(</a><a id="2492" href="Axiom.html#2492" class="Bound">Y</a> <a id="2494" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2496" href="Axiom.html#2491" class="Bound">_)</a> <a id="2499" class="Symbol">:</a> <a id="2501" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2509" href="Axiom.html#2478" class="Bound">A</a><a id="2510" class="Symbol">)</a> <a id="2512" class="Symbol">(</a><a id="2513" href="Axiom.html#2513" class="Bound">j</a> <a id="2515" class="Symbol">:</a> <a id="2517" href="Axiom.html#2484" class="Bound">X</a> <a id="2519" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="2522" href="Axiom.html#2492" class="Bound">Y</a><a id="2523" class="Symbol">)</a> <a id="2525" class="Symbol">→</a> <a id="2527" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.4</strong> 给定一个 <code>A</code>-交换模式 <code>C</code> 和一个 <code>A</code>-图式 <code>b</code>, 我们称 <code>b</code> 满足 <code>C</code>-泛性质, 当且仅当对任意 <code>A</code>-图式 <code>a</code>, 存在唯一的底集间映射 <code>j</code> 使得 <code>a</code> <code>b</code> <code>j</code> 满足 <code>C</code>-交换.</p>
<pre class="Agda">  <a id="Data.unique"></a><a id="2674" href="Axiom.html#2674" class="Function">unique</a> <a id="2681" class="Symbol">:</a> <a id="2683" class="Symbol">{</a><a id="2684" href="Axiom.html#2684" class="Bound">A</a> <a id="2686" class="Symbol">:</a> <a id="2688" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2691" class="Symbol">}</a> <a id="2693" class="Symbol">(</a><a id="2694" href="Axiom.html#2694" class="Bound">P</a> <a id="2696" class="Symbol">:</a> <a id="2698" href="Axiom.html#2684" class="Bound">A</a> <a id="2700" class="Symbol">→</a> <a id="2702" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2705" class="Symbol">)</a> <a id="2707" class="Symbol">→</a> <a id="2709" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2715" href="Axiom.html#2674" class="Function">unique</a> <a id="2722" href="Axiom.html#2722" class="Bound">P</a> <a id="2724" class="Symbol">=</a> <a id="2726" class="Symbol">∀</a> <a id="2728" class="Symbol">{</a><a id="2729" href="Axiom.html#2729" class="Bound">a</a> <a id="2731" href="Axiom.html#2731" class="Bound">b</a><a id="2732" class="Symbol">}</a> <a id="2734" class="Symbol">→</a> <a id="2736" href="Axiom.html#2722" class="Bound">P</a> <a id="2738" href="Axiom.html#2729" class="Bound">a</a> <a id="2740" class="Symbol">→</a> <a id="2742" href="Axiom.html#2722" class="Bound">P</a> <a id="2744" href="Axiom.html#2731" class="Bound">b</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="Axiom.html#2729" class="Bound">a</a> <a id="2750" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2752" href="Axiom.html#2731" class="Bound">b</a>

  <a id="Data.universal"></a><a id="2757" href="Axiom.html#2757" class="Function">universal</a> <a id="2767" class="Symbol">:</a> <a id="2769" class="Symbol">{</a><a id="2770" href="Axiom.html#2770" class="Bound">A</a> <a id="2772" class="Symbol">:</a> <a id="2774" href="Axiom.html#2008" class="Function">Arrow</a><a id="2779" class="Symbol">}</a> <a id="2781" class="Symbol">→</a> <a id="2783" href="Axiom.html#2437" class="Function">Commuter</a> <a id="2792" href="Axiom.html#2770" class="Bound">A</a> <a id="2794" class="Symbol">→</a> <a id="2796" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2804" href="Axiom.html#2770" class="Bound">A</a> <a id="2806" class="Symbol">→</a> <a id="2808" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2814" href="Axiom.html#2757" class="Function">universal</a> <a id="2824" class="Symbol">{</a><a id="2825" href="Axiom.html#2825" class="Bound">A</a><a id="2826" class="Symbol">}</a> <a id="2828" href="Axiom.html#2828" class="Bound">C</a> <a id="2830" href="Axiom.html#2830" class="Bound">b</a><a id="2831" class="Symbol">@(</a><a id="2833" href="Axiom.html#2833" class="Bound">Y</a> <a id="2835" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2837" class="Symbol">_)</a> <a id="2840" class="Symbol">=</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Axiom.html#2843" class="Bound">a</a><a id="2844" class="Symbol">@(</a><a id="2846" href="Axiom.html#2846" class="Bound">X</a> <a id="2848" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2850" class="Symbol">_)</a> <a id="2853" class="Symbol">:</a> <a id="2855" href="Axiom.html#2192" class="Function">Diagram</a> <a id="2863" href="Axiom.html#2825" class="Bound">A</a><a id="2864" class="Symbol">)</a> <a id="2866" class="Symbol">→</a>
    <a id="2872" class="Symbol">(</a><a id="2873" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2875" class="Symbol">(</a><a id="2876" href="Axiom.html#2846" class="Bound">X</a> <a id="2878" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="2881" href="Axiom.html#2833" class="Bound">Y</a><a id="2882" class="Symbol">)</a> <a id="2884" class="Symbol">λ</a> <a id="2886" href="Axiom.html#2886" class="Bound">j</a> <a id="2888" class="Symbol">→</a> <a id="2890" href="Axiom.html#2828" class="Bound">C</a> <a id="2892" href="Axiom.html#2843" class="Bound">a</a> <a id="2894" href="Axiom.html#2830" class="Bound">b</a> <a id="2896" href="Axiom.html#2886" class="Bound">j</a><a id="2897" class="Symbol">)</a> <a id="2899" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2901" href="Axiom.html#2674" class="Function">unique</a> <a id="2908" class="Symbol">(</a><a id="2909" href="Axiom.html#2828" class="Bound">C</a> <a id="2911" href="Axiom.html#2843" class="Bound">a</a> <a id="2913" href="Axiom.html#2830" class="Bound">b</a><a id="2914" class="Symbol">)</a>
</pre>
<p>我们约定用 <code>A</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code> <code>X′</code> <code>Y′</code> 表示集合, 用 <code>f</code> <code>g</code> <code>h</code> <code>f′</code> <code>g′</code> 表示函数.</p>
<pre class="Agda">  <a id="3004" class="Keyword">variable</a>
    <a id="3017" href="Axiom.html#3017" class="Generalizable">A</a> <a id="3019" href="Axiom.html#3019" class="Generalizable">W</a> <a id="3021" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3023" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="3025" href="Axiom.html#3025" class="Generalizable">Z</a> <a id="3027" href="Axiom.html#3027" class="Generalizable">X′</a> <a id="3030" href="Axiom.html#3030" class="Generalizable">Y′</a> <a id="3033" class="Symbol">:</a> <a id="3035" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="3044" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3046" href="Axiom.html#3046" class="Generalizable">g</a> <a id="3048" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3050" href="Axiom.html#3050" class="Generalizable">f′</a> <a id="3053" href="Axiom.html#3053" class="Generalizable">g′</a> <a id="3056" class="Symbol">:</a> <a id="3058" href="Axiom.html#3021" class="Generalizable">X</a> <a id="3060" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="3063" href="Axiom.html#3023" class="Generalizable">Y</a>
</pre>
<h2 id="公理">公理</h2>
<p>我们现在可以引入 ETCS 的10条公理.</p>
<pre class="Agda">  <a id="3110" class="Keyword">record</a> <a id="Data.Axiom"></a><a id="3117" href="Axiom.html#3117" class="Record">Axiom</a> <a id="3123" class="Symbol">:</a> <a id="3125" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3129" class="Keyword">where</a>
</pre>
<p><strong>公理 1 (范畴)</strong> 以下三个命题成立.</p>
<ol type="1">
<li>复合运算满足结合律.</li>
<li>恒等函数是复合运算的左单位元.</li>
<li>恒等函数是复合运算的右单位元.</li>
</ol>
<pre class="Agda">    <a id="3230" class="Keyword">field</a>
      <a id="3242" class="Comment">-- Axiom 1</a>
      <a id="3259" href="Axiom.html#3259" class="Field">AxAss</a> <a id="3265" class="Symbol">:</a> <a id="3267" class="Symbol">(</a><a id="3268" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3270" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3272" href="Axiom.html#3046" class="Generalizable">g</a><a id="3273" class="Symbol">)</a> <a id="3275" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3277" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3279" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3281" href="Axiom.html#3048" class="Generalizable">h</a> <a id="3283" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Axiom.html#3046" class="Generalizable">g</a> <a id="3288" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3290" href="Axiom.html#3044" class="Generalizable">f</a><a id="3291" class="Symbol">)</a>
      <a id="3299" href="Axiom.html#3299" class="Field">AxIdˡ</a> <a id="3305" class="Symbol">:</a> <a id="3307" href="Axiom.html#1800" class="Function">id</a> <a id="3310" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3312" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3314" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3316" href="Axiom.html#3044" class="Generalizable">f</a>
      <a id="3324" href="Axiom.html#3324" class="Field">AxIdʳ</a> <a id="3330" class="Symbol">:</a> <a id="3332" href="Axiom.html#3044" class="Generalizable">f</a> <a id="3334" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="3336" href="Axiom.html#1800" class="Function">id</a> <a id="3339" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3341" href="Axiom.html#3044" class="Generalizable">f</a>
</pre>
<p><strong>定义 2.3.1</strong> 我们说一个集合 <code>T</code> 是终集合, 当且仅当对任意集合 <code>X</code>, 存在唯一的 <code>j : X →̇ T</code>. 注意终集合的图式没有箭头, 只有一个集合, 且终集合的交换模式是恒真.</p>
<pre class="Agda">    <a id="3463" class="Comment">-- Definition 2.3.1</a>
    <a id="3487" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3496" class="Symbol">:</a> <a id="3498" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="3508" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3517" class="Symbol">=</a> <a id="3519" class="Symbol">λ</a> <a id="3521" href="Axiom.html#3521" class="Bound">_</a> <a id="3523" class="Symbol">→</a> <a id="3525" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3532" href="Axiom.html#3532" class="Bound">TerminalCommuter</a> <a id="3549" class="Symbol">:</a> <a id="3551" href="Axiom.html#2437" class="Function">Commuter</a> <a id="3560" href="Axiom.html#3487" class="Bound">Terminal</a>
    <a id="3573" href="Axiom.html#3532" class="Bound">TerminalCommuter</a> <a id="3590" class="Symbol">=</a> <a id="3592" class="Symbol">λ</a> <a id="3594" href="Axiom.html#3594" class="Bound">_</a> <a id="3596" href="Axiom.html#3596" class="Bound">_</a> <a id="3598" href="Axiom.html#3598" class="Bound">_</a> <a id="3600" class="Symbol">→</a> <a id="3602" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3609" href="Axiom.html#3609" class="Bound">isTerminal</a> <a id="3620" class="Symbol">:</a> <a id="3622" href="Axiom.html#2192" class="Function">Diagram</a> <a id="3630" href="Axiom.html#3487" class="Bound">Terminal</a> <a id="3639" class="Symbol">→</a> <a id="3641" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="3649" href="Axiom.html#3609" class="Bound">isTerminal</a> <a id="3660" class="Symbol">=</a> <a id="3662" href="Axiom.html#2757" class="Function">universal</a> <a id="3672" href="Axiom.html#3532" class="Bound">TerminalCommuter</a>
</pre>
<p><strong>公理 2 (终集)</strong> 存在一个终集合.</p>
<pre class="Agda">    <a id="3730" class="Comment">-- Axiom 2</a>
    <a id="3745" class="Keyword">field</a> <a id="3751" href="Axiom.html#3751" class="Field">AxTml</a> <a id="3757" class="Symbol">:</a> <a id="3759" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="3761" class="Symbol">(</a><a id="3762" href="Axiom.html#2192" class="Function">Diagram</a> <a id="3770" href="Axiom.html#3487" class="Bound">Terminal</a><a id="3778" class="Symbol">)</a> <a id="3780" href="Axiom.html#3609" class="Bound">isTerminal</a>
</pre>
<p>我们将在后篇证明这样的终集合是唯一的. 实际上, 我们会证明所有用泛性质框定的集合都是唯一的. 所以定义了一种泛性质就唯一定义了一种集合, 所以我们后面会直接说「定义某种集合的泛性质」, 这应该理解为就是在「定义某种集合」.</p>
<p>我们把公理2承诺的集合记作 <code>１</code>, 因为它里面只有一个元素, 这会在下一章证明.</p>
<pre class="Agda">    <a id="3965" href="Axiom.html#3965" class="Bound">１</a> <a id="3967" class="Symbol">:</a> <a id="3969" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="3978" href="Axiom.html#3965" class="Bound">１</a> <a id="3980" class="Symbol">=</a> <a id="3982" href="Axiom.html#3751" class="Field">AxTml</a> <a id="3988" class="Symbol">.</a><a id="3989" href="Axiom.html#949" class="Field">fst</a> <a id="3993" class="Symbol">.</a><a id="3994" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p><strong>定义 2.3.6</strong> 给定集合 <code>X</code>, 我们把 <code>１</code> 到 <code>X</code> 的函数称为 <code>X</code> 的元素, 其类型记作 <code>Elm X</code>. 我们将 <code>x : Elm X</code> 简记为 <code>x ∈ X</code>.</p>
<pre class="Agda">    <a id="4112" class="Comment">-- Definition 2.3.6</a>
    <a id="4136" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4140" class="Symbol">:</a> <a id="4142" href="Axiom.html#1662" class="Field">CSet</a> <a id="4147" class="Symbol">→</a> <a id="4149" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4157" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4161" class="Symbol">=</a> <a id="4163" href="Axiom.html#3965" class="Bound">１</a> <a id="4165" href="Axiom.html#1677" class="Field Operator">→̇_</a>

    <a id="4174" href="Axiom.html#4174" class="Bound">∀[∈]-syntax</a> <a id="4186" class="Symbol">:</a> <a id="4188" class="Symbol">(</a><a id="4189" href="Axiom.html#4189" class="Bound">X</a> <a id="4191" class="Symbol">:</a> <a id="4193" href="Axiom.html#1662" class="Field">CSet</a><a id="4197" class="Symbol">)</a> <a id="4199" class="Symbol">(</a><a id="4200" href="Axiom.html#4200" class="Bound">P</a> <a id="4202" class="Symbol">:</a> <a id="4204" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4208" href="Axiom.html#4189" class="Bound">X</a> <a id="4210" class="Symbol">→</a> <a id="4212" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4215" class="Symbol">)</a> <a id="4217" class="Symbol">→</a> <a id="4219" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4227" href="Axiom.html#4174" class="Bound">∀[∈]-syntax</a> <a id="4239" href="Axiom.html#4239" class="Bound">X</a> <a id="4241" href="Axiom.html#4241" class="Bound">P</a> <a id="4243" class="Symbol">=</a> <a id="4245" class="Symbol">(</a><a id="4246" href="Axiom.html#4246" class="Bound">x</a> <a id="4248" class="Symbol">:</a> <a id="4250" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4254" href="Axiom.html#4239" class="Bound">X</a><a id="4255" class="Symbol">)</a> <a id="4257" class="Symbol">→</a> <a id="4259" href="Axiom.html#4241" class="Bound">P</a> <a id="4261" href="Axiom.html#4246" class="Bound">x</a>

    <a id="4268" class="Keyword">infix</a> <a id="4274" class="Number">3</a> <a id="4276" href="Axiom.html#4174" class="Function">∀[∈]-syntax</a>
    <a id="4292" class="Keyword">syntax</a> <a id="4299" href="Axiom.html#4174" class="Function">∀[∈]-syntax</a> <a id="4311" class="Bound">X</a> <a id="4313" class="Symbol">(λ</a> <a id="4316" class="Bound">x</a> <a id="4318" class="Symbol">→</a> <a id="4320" class="Bound">A</a><a id="4321" class="Symbol">)</a> <a id="4323" class="Symbol">=</a> <a id="4325" class="Function">∀[</a> <a id="4328" class="Bound">x</a> <a id="4330" class="Function">∈</a> <a id="4332" class="Bound">X</a> <a id="4334" class="Function">]</a> <a id="4336" class="Bound">A</a>

    <a id="4343" href="Axiom.html#4343" class="Bound">∃[∈]-syntax</a> <a id="4355" class="Symbol">:</a> <a id="4357" class="Symbol">(</a><a id="4358" href="Axiom.html#4358" class="Bound">X</a> <a id="4360" class="Symbol">:</a> <a id="4362" href="Axiom.html#1662" class="Field">CSet</a><a id="4366" class="Symbol">)</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Axiom.html#4369" class="Bound">P</a> <a id="4371" class="Symbol">:</a> <a id="4373" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4377" href="Axiom.html#4358" class="Bound">X</a> <a id="4379" class="Symbol">→</a> <a id="4381" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4384" class="Symbol">)</a> <a id="4386" class="Symbol">→</a> <a id="4388" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4396" href="Axiom.html#4343" class="Bound">∃[∈]-syntax</a> <a id="4408" href="Axiom.html#4408" class="Bound">X</a> <a id="4410" href="Axiom.html#4410" class="Bound">P</a> <a id="4412" class="Symbol">=</a> <a id="4414" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="4416" class="Symbol">(</a><a id="4417" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4421" href="Axiom.html#4408" class="Bound">X</a><a id="4422" class="Symbol">)</a> <a id="4424" href="Axiom.html#4410" class="Bound">P</a>

    <a id="4431" class="Keyword">infix</a> <a id="4437" class="Number">3</a> <a id="4439" href="Axiom.html#4343" class="Function">∃[∈]-syntax</a>
    <a id="4455" class="Keyword">syntax</a> <a id="4462" href="Axiom.html#4343" class="Function">∃[∈]-syntax</a> <a id="4474" class="Bound">X</a> <a id="4476" class="Symbol">(λ</a> <a id="4479" class="Bound">x</a> <a id="4481" class="Symbol">→</a> <a id="4483" class="Bound">A</a><a id="4484" class="Symbol">)</a> <a id="4486" class="Symbol">=</a> <a id="4488" class="Function">∃[</a> <a id="4491" class="Bound">x</a> <a id="4493" class="Function">∈</a> <a id="4495" class="Bound">X</a> <a id="4497" class="Function">]</a> <a id="4499" class="Bound">A</a>
</pre>
<p><strong>注意</strong> <code>x ∈ X</code> 是一个声明而不是可以讨论真假的命题, 这一点与质料集合论 (ZFC等) 不同. 就像我们说「任意/存在集合 <code>X</code>, 怎么怎么样」一样, 这里不存在 「<code>X</code> 是不是集合」的问题, 我们也只能说「任意/存在元素 <code>x ∈ X</code>, 怎么怎么样」, 而不存在 「<code>x</code> 是不是 <code>X</code> 的元素」的问题. 其根源在于函数是一个独立论域中的事物, 我们不能讨论某 <code>f : X →̇ Y</code> 是不是函数, 就像不能讨论某 <code>X : CSet</code> 是不是集合一样.</p>
<p>给定函数 <code>f : X →̇ Y</code> 和一个元素 <code>x ∈ X</code>, 我们把复合函数 <code>f ∘ x</code> 记作 <code>f ⦅ x ⦆</code>.</p>
<pre class="Agda">    <a id="4824" class="Keyword">infix</a> <a id="4830" class="Number">15</a> <a id="4833" href="Axiom.html#4842" class="Function Operator">_⦅_⦆</a>
    <a id="4842" href="Axiom.html#4842" class="Bound Operator">_⦅_⦆</a> <a id="4847" class="Symbol">:</a> <a id="4849" class="Symbol">(</a><a id="4850" href="Axiom.html#4850" class="Bound">f</a> <a id="4852" class="Symbol">:</a> <a id="4854" href="Axiom.html#3021" class="Generalizable">X</a> <a id="4856" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="4859" href="Axiom.html#3023" class="Generalizable">Y</a><a id="4860" class="Symbol">)</a> <a id="4862" class="Symbol">→</a> <a id="4864" href="Axiom.html#4174" class="Bound">∀[</a> <a id="4867" href="Axiom.html#4867" class="Bound">x</a> <a id="4869" href="Axiom.html#4174" class="Bound">∈</a> <a id="4871" href="Axiom.html#3021" class="Generalizable">X</a> <a id="4873" href="Axiom.html#4174" class="Bound">]</a> <a id="4875" href="Axiom.html#4136" class="Bound">Elm</a> <a id="4879" href="Axiom.html#3023" class="Generalizable">Y</a>
    <a id="4885" href="Axiom.html#4885" class="Bound">f</a> <a id="4887" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="4889" href="Axiom.html#4889" class="Bound">x</a> <a id="4891" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="4893" class="Symbol">=</a> <a id="4895" href="Axiom.html#4885" class="Bound">f</a> <a id="4897" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="4899" href="Axiom.html#4889" class="Bound">x</a>
</pre>
<p><strong>公理 3 (函数外延)</strong> 对任意集合 <code>X Y : CSet</code> 以及函数 <code>f g : X →̇ Y</code>, 如果对任意 <code>x ∈ X</code> 都有 <code>f ⦅ x ⦆ ≡ g ⦅ x ⦆</code>, 那么 <code>f ≡ g</code>.</p>
<pre class="Agda">    <a id="5025" class="Comment">-- Axiom 3</a>
    <a id="5040" class="Keyword">field</a> <a id="5046" href="Axiom.html#5046" class="Field">AxFunExt</a> <a id="5055" class="Symbol">:</a> <a id="5057" class="Symbol">(</a><a id="5058" href="Axiom.html#4174" class="Bound">∀[</a> <a id="5061" href="Axiom.html#5061" class="Bound">x</a> <a id="5063" href="Axiom.html#4174" class="Bound">∈</a> <a id="5065" href="Axiom.html#3021" class="Generalizable">X</a> <a id="5067" href="Axiom.html#4174" class="Bound">]</a> <a id="5069" href="Axiom.html#3044" class="Generalizable">f</a> <a id="5071" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="5073" href="Axiom.html#5061" class="Bound">x</a> <a id="5075" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="5077" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5079" href="Axiom.html#3046" class="Generalizable">g</a> <a id="5081" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="5083" href="Axiom.html#5061" class="Bound">x</a> <a id="5085" href="Axiom.html#4842" class="Bound Operator">⦆</a><a id="5086" class="Symbol">)</a> <a id="5088" class="Symbol">→</a> <a id="5090" href="Axiom.html#3044" class="Generalizable">f</a> <a id="5092" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5094" href="Axiom.html#3046" class="Generalizable">g</a>
</pre>
<p><strong>定义 2.5.1</strong> 我们称一个集合 <code>X</code> 为空集, 当且仅当对任意 <code>x ∈ X</code> 都有 <code>⊥</code>.</p>
<pre class="Agda">    <a id="5168" class="Comment">-- Definition 2.5.1</a>
    <a id="5192" href="Axiom.html#5192" class="Bound">empty</a> <a id="5198" class="Symbol">:</a> <a id="5200" href="Axiom.html#1662" class="Field">CSet</a> <a id="5205" class="Symbol">→</a> <a id="5207" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5215" href="Axiom.html#5192" class="Bound">empty</a> <a id="5221" href="Axiom.html#5221" class="Bound">X</a> <a id="5223" class="Symbol">=</a> <a id="5225" href="Axiom.html#4174" class="Bound">∀[</a> <a id="5228" href="Axiom.html#5228" class="Bound">x</a> <a id="5230" href="Axiom.html#4174" class="Bound">∈</a> <a id="5232" href="Axiom.html#5221" class="Bound">X</a> <a id="5234" href="Axiom.html#4174" class="Bound">]</a> <a id="5236" href="Data.Empty.html#914" class="Function">⊥</a>
</pre>
<p><strong>公理 4 (空集)</strong> 存在一个空集.</p>
<pre class="Agda">    <a id="5278" class="Comment">-- Axiom 4</a>
    <a id="5293" class="Keyword">field</a> <a id="5299" href="Axiom.html#5299" class="Field">AxEmpty</a> <a id="5307" class="Symbol">:</a> <a id="5309" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="5311" href="Axiom.html#1662" class="Field">CSet</a> <a id="5316" href="Axiom.html#5192" class="Bound">empty</a>
</pre>
<p><strong>定义 2.6.2</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的积的泛性质.</p>
<p>第一步, 定义积图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>P</code></li>
<li>一个函数 <code>p : P →̇ X</code></li>
<li>一个函数 <code>q : P →̇ Y</code></li>
</ul>
<p>于是一个积图式具有如下形式</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-7e2a8ae22d3645250a1f82970ba78df1.png" alt="积图式" />
<figcaption aria-hidden="true">积图式</figcaption>
</figure>
<p>我们将这样的积图式简记作 <code>(P , p , q)</code>.</p>
<p>第二步, 定义积图式的交换: 我们说两个积图式 <code>(A , f , g)</code> 和 <code>(P , p , q)</code> 以及底集间映射 <code>h : A →̇ P</code> 交换, 当且仅当 <code>p ∘ h ≡ f</code> 且 <code>q ∘ h ≡ g</code>.</p>
<p>第三步, 定义积的泛性质: 我们说一个积图式 <code>(P , p , q)</code> 满足积的泛性质, 当且仅当对任意积图式 <code>(A , f , g)</code>, 存在唯一的底集间映射 <code>h : A →̇ P</code> 使得它们交换.</p>
<pre class="Agda">    <a id="5801" class="Comment">-- Definition 2.6.2</a>
    <a id="5825" href="Axiom.html#5825" class="Bound">Product</a> <a id="5833" class="Symbol">:</a> <a id="5835" class="Symbol">(</a><a id="5836" href="Axiom.html#5836" class="Bound">X</a> <a id="5838" href="Axiom.html#5838" class="Bound">Y</a> <a id="5840" class="Symbol">:</a> <a id="5842" href="Axiom.html#1662" class="Field">CSet</a><a id="5846" class="Symbol">)</a> <a id="5848" class="Symbol">→</a> <a id="5850" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="5860" href="Axiom.html#5825" class="Bound">Product</a> <a id="5868" href="Axiom.html#5868" class="Bound">X</a> <a id="5870" href="Axiom.html#5870" class="Bound">Y</a> <a id="5872" class="Symbol">=</a> <a id="5874" class="Symbol">λ</a> <a id="5876" href="Axiom.html#5876" class="Bound">P</a> <a id="5878" class="Symbol">→</a> <a id="5880" href="Axiom.html#5876" class="Bound">P</a> <a id="5882" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="5885" href="Axiom.html#5868" class="Bound">X</a> <a id="5887" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5889" href="Axiom.html#5876" class="Bound">P</a> <a id="5891" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="5894" href="Axiom.html#5870" class="Bound">Y</a>

    <a id="5901" href="Axiom.html#5901" class="Bound">ProductCommuter</a> <a id="5917" class="Symbol">:</a> <a id="5919" href="Axiom.html#2437" class="Function">Commuter</a> <a id="5928" class="Symbol">(</a><a id="5929" href="Axiom.html#5825" class="Bound">Product</a> <a id="5937" href="Axiom.html#3021" class="Generalizable">X</a> <a id="5939" href="Axiom.html#3023" class="Generalizable">Y</a><a id="5940" class="Symbol">)</a>
    <a id="5946" href="Axiom.html#5901" class="Bound">ProductCommuter</a> <a id="5962" class="Symbol">=</a> <a id="5964" class="Symbol">λ</a> <a id="5966" class="Symbol">(</a><a id="5967" href="Axiom.html#5967" class="Bound">A</a> <a id="5969" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5971" href="Axiom.html#5971" class="Bound">f</a> <a id="5973" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5975" href="Axiom.html#5975" class="Bound">g</a><a id="5976" class="Symbol">)</a> <a id="5978" class="Symbol">(</a><a id="5979" href="Axiom.html#5979" class="Bound">P</a> <a id="5981" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5983" href="Axiom.html#5983" class="Bound">p</a> <a id="5985" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5987" href="Axiom.html#5987" class="Bound">q</a><a id="5988" class="Symbol">)</a> <a id="5990" href="Axiom.html#5990" class="Bound">h</a> <a id="5992" class="Symbol">→</a> <a id="5994" href="Axiom.html#5983" class="Bound">p</a> <a id="5996" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="5998" href="Axiom.html#5990" class="Bound">h</a> <a id="6000" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6002" href="Axiom.html#5971" class="Bound">f</a> <a id="6004" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6006" href="Axiom.html#5987" class="Bound">q</a> <a id="6008" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="6010" href="Axiom.html#5990" class="Bound">h</a> <a id="6012" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6014" href="Axiom.html#5975" class="Bound">g</a>

    <a id="6021" href="Axiom.html#6021" class="Bound">isProduct</a> <a id="6031" class="Symbol">:</a> <a id="6033" href="Axiom.html#2192" class="Function">Diagram</a> <a id="6041" class="Symbol">(</a><a id="6042" href="Axiom.html#5825" class="Bound">Product</a> <a id="6050" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6052" href="Axiom.html#3023" class="Generalizable">Y</a><a id="6053" class="Symbol">)</a> <a id="6055" class="Symbol">→</a> <a id="6057" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="6065" href="Axiom.html#6021" class="Bound">isProduct</a> <a id="6075" class="Symbol">=</a> <a id="6077" href="Axiom.html#2757" class="Function">universal</a> <a id="6087" href="Axiom.html#5901" class="Bound">ProductCommuter</a>
</pre>
<p><strong>公理 5 (积)</strong> 对任意集合 <code>X Y : CSet</code>, 存在积图式满足积的泛性质.</p>
<pre class="Agda">    <a id="6168" class="Comment">-- Axiom 5</a>
    <a id="6183" class="Keyword">field</a> <a id="6189" href="Axiom.html#6189" class="Field">AxProd</a> <a id="6196" class="Symbol">:</a> <a id="6198" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="6200" class="Symbol">(</a><a id="6201" href="Axiom.html#2192" class="Function">Diagram</a> <a id="6209" class="Symbol">(</a><a id="6210" href="Axiom.html#5825" class="Bound">Product</a> <a id="6218" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6220" href="Axiom.html#3023" class="Generalizable">Y</a><a id="6221" class="Symbol">))</a> <a id="6224" href="Axiom.html#6021" class="Bound">isProduct</a>
</pre>
<p>给定集合 <code>X Y : CSet</code>, 我们把公理5所承诺的积图式的底集称为 <code>X</code> 和 <code>Y</code> 的积, 记作 <code>X ×̇ Y</code>.</p>
<pre class="Agda">    <a id="6317" class="Keyword">infixr</a> <a id="6324" class="Number">15</a> <a id="6327" href="Axiom.html#6336" class="Function Operator">_×̇_</a>
    <a id="6336" href="Axiom.html#6336" class="Bound Operator">_×̇_</a> <a id="6341" class="Symbol">:</a> <a id="6343" href="Axiom.html#1662" class="Field">CSet</a> <a id="6348" class="Symbol">→</a> <a id="6350" href="Axiom.html#1662" class="Field">CSet</a> <a id="6355" class="Symbol">→</a> <a id="6357" href="Axiom.html#1662" class="Field">CSet</a>
    <a id="6366" href="Axiom.html#6366" class="Bound">X</a> <a id="6368" href="Axiom.html#6336" class="Bound Operator">×̇</a> <a id="6371" href="Axiom.html#6371" class="Bound">Y</a> <a id="6373" class="Symbol">=</a> <a id="6375" href="Axiom.html#6189" class="Field">AxProd</a> <a id="6382" class="Symbol">{</a><a id="6383" href="Axiom.html#6366" class="Bound">X</a><a id="6384" class="Symbol">}</a> <a id="6386" class="Symbol">{</a><a id="6387" href="Axiom.html#6371" class="Bound">Y</a><a id="6388" class="Symbol">}</a> <a id="6390" class="Symbol">.</a><a id="6391" href="Axiom.html#949" class="Field">fst</a> <a id="6395" class="Symbol">.</a><a id="6396" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p>给定集合 <code>X Y A : CSet</code> 和函数 <code>f : A →̇ X</code> <code>g : A →̇ Y</code>, 公理5承诺了积图示 <code>(A , f , g)</code> 到积图示 <code>(X ×̇ Y , p , q)</code> 的底集间唯一映射, 我们记作 <code>f ,̇ g : A →̇ X ×̇ Y</code>. 如下图所示, 其中虚线表示唯一. 特别地, 当 <code>A ≡ １</code> 时, <code>f</code> 是 <code>X</code> 的元素, <code>g</code> 是 <code>Y</code> 的元素, <code>f ,̇ g</code> 是 <code>X ×̇ Y</code> 的元素.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2cfcd05207f77e2d965658d158731767.png" alt="积的元素" />
<figcaption aria-hidden="true">积的元素</figcaption>
</figure>
<pre class="Agda">    <a id="6722" class="Keyword">infixr</a> <a id="6729" class="Number">5</a> <a id="6731" href="Axiom.html#6740" class="Function Operator">_,̇_</a>
    <a id="6740" href="Axiom.html#6740" class="Bound Operator">_,̇_</a> <a id="6745" class="Symbol">:</a> <a id="6747" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6749" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6752" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6754" class="Symbol">→</a> <a id="6756" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6758" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6761" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="6763" class="Symbol">→</a> <a id="6765" href="Axiom.html#3017" class="Generalizable">A</a> <a id="6767" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="6770" href="Axiom.html#3021" class="Generalizable">X</a> <a id="6772" href="Axiom.html#6336" class="Bound Operator">×̇</a> <a id="6775" href="Axiom.html#3023" class="Generalizable">Y</a>
    <a id="6781" href="Axiom.html#6781" class="Bound">f</a> <a id="6783" href="Axiom.html#6740" class="Bound Operator">,̇</a> <a id="6786" href="Axiom.html#6786" class="Bound">g</a> <a id="6788" class="Symbol">=</a> <a id="6790" href="Axiom.html#6189" class="Field">AxProd</a> <a id="6797" class="Symbol">.</a><a id="6798" href="Axiom.html#963" class="Field">snd</a> <a id="6802" class="Symbol">(_</a> <a id="6805" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6807" href="Axiom.html#6781" class="Bound">f</a> <a id="6809" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6811" href="Axiom.html#6786" class="Bound">g</a><a id="6812" class="Symbol">)</a> <a id="6814" class="Symbol">.</a><a id="6815" href="Axiom.html#949" class="Field">fst</a> <a id="6819" class="Symbol">.</a><a id="6820" href="Axiom.html#949" class="Field">fst</a>
</pre>
<p><strong>定义 2.7.3</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的函数集 (简称幂) 的泛性质.</p>
<p>第一步, 定义幂图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>F</code></li>
<li>一个函数 <code>e : F ×̇ X →̇ Y</code></li>
</ul>
<p>简记作 <code>(F , e)</code>.</p>
<p>第二步, 定义幂图式的交换: 我们说两个幂图式 <code>(A , q)</code> 和 <code>(F , e)</code> 以及底集间映射 <code>q̅ : A →̇ F</code> 交换, 当且仅当对任意 <code>a ∈ A</code> 和 <code>x ∈ X</code> 都有 <code>q ⦅ a ,̇ x ⦆ ≡ e ⦅ q̅ ⦅ a ⦆ ,̇ x ⦆</code>.</p>
<p>第三步, 定义幂的泛性质: 我们说一个幂图式 <code>(F , e)</code> 满足幂的泛性质, 当且仅当对任意幂图式 <code>(A , q)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ F</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2874a6ccdc996e99f8027e4b11e2383d.png" alt="幂的泛性质" />
<figcaption aria-hidden="true">幂的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="7292" class="Comment">-- Definition 2.7.3</a>
    <a id="7316" href="Axiom.html#7316" class="Bound">FuncSet</a> <a id="7324" class="Symbol">:</a> <a id="7326" class="Symbol">(</a><a id="7327" href="Axiom.html#7327" class="Bound">X</a> <a id="7329" href="Axiom.html#7329" class="Bound">Y</a> <a id="7331" class="Symbol">:</a> <a id="7333" href="Axiom.html#1662" class="Field">CSet</a><a id="7337" class="Symbol">)</a> <a id="7339" class="Symbol">→</a> <a id="7341" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="7351" href="Axiom.html#7316" class="Bound">FuncSet</a> <a id="7359" href="Axiom.html#7359" class="Bound">X</a> <a id="7361" href="Axiom.html#7361" class="Bound">Y</a> <a id="7363" class="Symbol">=</a> <a id="7365" class="Symbol">λ</a> <a id="7367" href="Axiom.html#7367" class="Bound">F</a> <a id="7369" class="Symbol">→</a> <a id="7371" href="Axiom.html#7367" class="Bound">F</a> <a id="7373" href="Axiom.html#6336" class="Bound Operator">×̇</a> <a id="7376" href="Axiom.html#7359" class="Bound">X</a> <a id="7378" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="7381" href="Axiom.html#7361" class="Bound">Y</a>

    <a id="7388" href="Axiom.html#7388" class="Bound">FuncSetCommuter</a> <a id="7404" class="Symbol">:</a> <a id="7406" href="Axiom.html#2437" class="Function">Commuter</a> <a id="7415" class="Symbol">(</a><a id="7416" href="Axiom.html#7316" class="Bound">FuncSet</a> <a id="7424" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7426" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7427" class="Symbol">)</a>
    <a id="7433" href="Axiom.html#7388" class="Bound">FuncSetCommuter</a> <a id="7449" class="Symbol">{</a><a id="7450" href="Axiom.html#7450" class="Bound">X</a><a id="7451" class="Symbol">}</a> <a id="7453" class="Symbol">=</a> <a id="7455" class="Symbol">λ</a> <a id="7457" class="Symbol">(</a><a id="7458" href="Axiom.html#7458" class="Bound">A</a> <a id="7460" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7462" href="Axiom.html#7462" class="Bound">q</a><a id="7463" class="Symbol">)</a> <a id="7465" class="Symbol">(</a><a id="7466" href="Axiom.html#7466" class="Bound">F</a> <a id="7468" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7470" href="Axiom.html#7470" class="Bound">e</a><a id="7471" class="Symbol">)</a> <a id="7473" href="Axiom.html#7473" class="Bound">q̅</a> <a id="7476" class="Symbol">→</a>
      <a id="7484" href="Axiom.html#4174" class="Bound">∀[</a> <a id="7487" href="Axiom.html#7487" class="Bound">a</a> <a id="7489" href="Axiom.html#4174" class="Bound">∈</a> <a id="7491" href="Axiom.html#7458" class="Bound">A</a> <a id="7493" href="Axiom.html#4174" class="Bound">]</a> <a id="7495" href="Axiom.html#4174" class="Bound">∀[</a> <a id="7498" href="Axiom.html#7498" class="Bound">x</a> <a id="7500" href="Axiom.html#4174" class="Bound">∈</a> <a id="7502" href="Axiom.html#7450" class="Bound">X</a> <a id="7504" href="Axiom.html#4174" class="Bound">]</a> <a id="7506" href="Axiom.html#7462" class="Bound">q</a> <a id="7508" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="7510" href="Axiom.html#7487" class="Bound">a</a> <a id="7512" href="Axiom.html#6740" class="Bound Operator">,̇</a> <a id="7515" href="Axiom.html#7498" class="Bound">x</a> <a id="7517" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="7519" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7521" href="Axiom.html#7470" class="Bound">e</a> <a id="7523" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="7525" href="Axiom.html#7473" class="Bound">q̅</a> <a id="7528" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="7530" href="Axiom.html#7487" class="Bound">a</a> <a id="7532" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="7534" href="Axiom.html#6740" class="Bound Operator">,̇</a> <a id="7537" href="Axiom.html#7498" class="Bound">x</a> <a id="7539" href="Axiom.html#4842" class="Bound Operator">⦆</a>

    <a id="7546" href="Axiom.html#7546" class="Bound">isFuncSet</a> <a id="7556" class="Symbol">:</a> <a id="7558" href="Axiom.html#2192" class="Function">Diagram</a> <a id="7566" class="Symbol">(</a><a id="7567" href="Axiom.html#7316" class="Bound">FuncSet</a> <a id="7575" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7577" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7578" class="Symbol">)</a> <a id="7580" class="Symbol">→</a> <a id="7582" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="7590" href="Axiom.html#7546" class="Bound">isFuncSet</a> <a id="7600" class="Symbol">=</a> <a id="7602" href="Axiom.html#2757" class="Function">universal</a> <a id="7612" href="Axiom.html#7388" class="Bound">FuncSetCommuter</a>
</pre>
<p><strong>公理 6 (幂)</strong> 对任意集合 <code>X Y : CSet</code>, 存在幂图式满足幂的泛性质.</p>
<pre class="Agda">    <a id="7693" class="Comment">-- Axiom 6</a>
    <a id="7708" class="Keyword">field</a> <a id="7714" href="Axiom.html#7714" class="Field">AxFuncSet</a> <a id="7724" class="Symbol">:</a> <a id="7726" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="7728" class="Symbol">(</a><a id="7729" href="Axiom.html#2192" class="Function">Diagram</a> <a id="7737" class="Symbol">(</a><a id="7738" href="Axiom.html#7316" class="Bound">FuncSet</a> <a id="7746" href="Axiom.html#3021" class="Generalizable">X</a> <a id="7748" href="Axiom.html#3023" class="Generalizable">Y</a><a id="7749" class="Symbol">))</a> <a id="7752" href="Axiom.html#7546" class="Bound">isFuncSet</a>
</pre>
<p><strong>定义 3.1.4</strong> 给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 我们按以下四步定义关于 <code>f</code> 和 <code>y</code> 的纤维的泛性质.</p>
<p>第零步, 定义什么叫纤维: 我们说一个集合 <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维, 记作 <code>U withInclusion i isFibreOf f over y</code>, 当且仅当对任意 <code>u ∈ U</code> 都有 <code>f ⦅ i ⦅ u ⦆ ⦆ ≡ y</code>, 也就是下图交换. 由于这样的 <code>U</code> 一般又记作 <span class="math inline">f^{-1}(y)</span>, 图中用此记法.</p>
<p>第一步, 定义纤维图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>U</code></li>
<li>一个函数 <code>i : U →̇ X</code></li>
<li>一个证明: <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维</li>
</ul>
<p>简记作 <code>(U , i , fiu)</code>.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-bcacd8638c0c142fb4422fe291b632f7.png" alt="纤维图式" />
<figcaption aria-hidden="true">纤维图式</figcaption>
</figure>
<p>第二步, 定义纤维图式的交换: 我们说两个纤维图式 <code>(A , q , fqa)</code> 和 <code>(U , i , fiu)</code> 以及底集间映射 <code>q̅ : A →̇ U</code> 交换, 当且仅当 <code>q ≡ i ∘ q̅</code>.</p>
<p>第三步, 定义纤维的泛性质: 我们说一个纤维图式 <code>(U , i , fiu)</code> 满足纤维的泛性质, 当且仅当对任意纤维图式 <code>(A , q , fqa)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ U</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-0f5d1b447ca9b15abfd4df13ad044223.png" alt="纤维的泛性质" />
<figcaption aria-hidden="true">纤维的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="8555" class="Comment">-- Definition 3.1.4</a>
    <a id="8579" href="Axiom.html#8579" class="Bound Operator">_withInclusion_isFibreOf_over_</a> <a id="8610" class="Symbol">:</a> <a id="8612" class="Symbol">(</a><a id="8613" href="Axiom.html#8613" class="Bound">U</a> <a id="8615" class="Symbol">:</a> <a id="8617" href="Axiom.html#1662" class="Field">CSet</a><a id="8621" class="Symbol">)</a> <a id="8623" class="Symbol">(</a><a id="8624" href="Axiom.html#8624" class="Bound">i</a> <a id="8626" class="Symbol">:</a> <a id="8628" href="Axiom.html#8613" class="Bound">U</a> <a id="8630" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8633" href="Axiom.html#3021" class="Generalizable">X</a><a id="8634" class="Symbol">)</a> <a id="8636" class="Symbol">(</a><a id="8637" href="Axiom.html#8637" class="Bound">f</a> <a id="8639" class="Symbol">:</a> <a id="8641" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8643" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8646" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8647" class="Symbol">)</a> <a id="8649" class="Symbol">(</a><a id="8650" href="Axiom.html#8650" class="Bound">y</a> <a id="8652" class="Symbol">:</a> <a id="8654" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8658" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8659" class="Symbol">)</a> <a id="8661" class="Symbol">→</a> <a id="8663" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8671" href="Axiom.html#8671" class="Bound">U</a> <a id="8673" href="Axiom.html#8579" class="Bound Operator">withInclusion</a> <a id="8687" href="Axiom.html#8687" class="Bound">i</a> <a id="8689" href="Axiom.html#8579" class="Bound Operator">isFibreOf</a> <a id="8699" href="Axiom.html#8699" class="Bound">f</a> <a id="8701" href="Axiom.html#8579" class="Bound Operator">over</a> <a id="8706" href="Axiom.html#8706" class="Bound">y</a> <a id="8708" class="Symbol">=</a> <a id="8710" href="Axiom.html#4174" class="Bound">∀[</a> <a id="8713" href="Axiom.html#8713" class="Bound">u</a> <a id="8715" href="Axiom.html#4174" class="Bound">∈</a> <a id="8717" class="Symbol">_</a> <a id="8719" href="Axiom.html#4174" class="Bound">]</a> <a id="8721" href="Axiom.html#8699" class="Bound">f</a> <a id="8723" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="8725" href="Axiom.html#8687" class="Bound">i</a> <a id="8727" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="8729" href="Axiom.html#8713" class="Bound">u</a> <a id="8731" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="8733" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="8735" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8737" href="Axiom.html#8706" class="Bound">y</a>

    <a id="8744" href="Axiom.html#8744" class="Bound">Fibre</a> <a id="8750" class="Symbol">:</a> <a id="8752" class="Symbol">(</a><a id="8753" href="Axiom.html#8753" class="Bound">f</a> <a id="8755" class="Symbol">:</a> <a id="8757" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8759" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8762" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8763" class="Symbol">)</a> <a id="8765" class="Symbol">(</a><a id="8766" href="Axiom.html#8766" class="Bound">y</a> <a id="8768" class="Symbol">:</a> <a id="8770" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8774" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8775" class="Symbol">)</a> <a id="8777" class="Symbol">→</a> <a id="8779" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="8789" href="Axiom.html#8744" class="Bound">Fibre</a> <a id="8795" class="Symbol">{</a><a id="8796" href="Axiom.html#8796" class="Bound">X</a><a id="8797" class="Symbol">}</a> <a id="8799" href="Axiom.html#8799" class="Bound">f</a> <a id="8801" href="Axiom.html#8801" class="Bound">y</a> <a id="8803" class="Symbol">=</a> <a id="8805" class="Symbol">λ</a> <a id="8807" href="Axiom.html#8807" class="Bound">U</a> <a id="8809" class="Symbol">→</a> <a id="8811" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="8813" class="Symbol">(</a><a id="8814" href="Axiom.html#8807" class="Bound">U</a> <a id="8816" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8819" href="Axiom.html#8796" class="Bound">X</a><a id="8820" class="Symbol">)</a> <a id="8822" class="Symbol">λ</a> <a id="8824" href="Axiom.html#8824" class="Bound">i</a> <a id="8826" class="Symbol">→</a> <a id="8828" href="Axiom.html#8807" class="Bound">U</a> <a id="8830" href="Axiom.html#8579" class="Bound Operator">withInclusion</a> <a id="8844" href="Axiom.html#8824" class="Bound">i</a> <a id="8846" href="Axiom.html#8579" class="Bound Operator">isFibreOf</a> <a id="8856" href="Axiom.html#8799" class="Bound">f</a> <a id="8858" href="Axiom.html#8579" class="Bound Operator">over</a> <a id="8863" href="Axiom.html#8801" class="Bound">y</a>

    <a id="8870" href="Axiom.html#8870" class="Bound">FibreCommuter</a> <a id="8884" class="Symbol">:</a> <a id="8886" class="Symbol">{</a><a id="8887" href="Axiom.html#8887" class="Bound">f</a> <a id="8889" class="Symbol">:</a> <a id="8891" href="Axiom.html#3021" class="Generalizable">X</a> <a id="8893" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="8896" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8897" class="Symbol">}</a> <a id="8899" class="Symbol">{</a><a id="8900" href="Axiom.html#8900" class="Bound">y</a> <a id="8902" class="Symbol">:</a> <a id="8904" href="Axiom.html#4136" class="Bound">Elm</a> <a id="8908" href="Axiom.html#3023" class="Generalizable">Y</a><a id="8909" class="Symbol">}</a> <a id="8911" class="Symbol">→</a> <a id="8913" href="Axiom.html#2437" class="Function">Commuter</a> <a id="8922" class="Symbol">(</a><a id="8923" href="Axiom.html#8744" class="Bound">Fibre</a> <a id="8929" href="Axiom.html#8887" class="Bound">f</a> <a id="8931" href="Axiom.html#8900" class="Bound">y</a><a id="8932" class="Symbol">)</a>
    <a id="8938" href="Axiom.html#8870" class="Bound">FibreCommuter</a> <a id="8952" class="Symbol">=</a> <a id="8954" class="Symbol">λ</a> <a id="8956" class="Symbol">(</a><a id="8957" href="Axiom.html#8957" class="Bound">A</a> <a id="8959" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8961" href="Axiom.html#8961" class="Bound">q</a> <a id="8963" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8965" href="Axiom.html#8965" class="Bound">fqa</a><a id="8968" class="Symbol">)</a> <a id="8970" class="Symbol">(</a><a id="8971" href="Axiom.html#8971" class="Bound">U</a> <a id="8973" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8975" href="Axiom.html#8975" class="Bound">i</a> <a id="8977" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8979" href="Axiom.html#8979" class="Bound">fiu</a><a id="8982" class="Symbol">)</a> <a id="8984" href="Axiom.html#8984" class="Bound">q̅</a> <a id="8987" class="Symbol">→</a> <a id="8989" href="Axiom.html#8961" class="Bound">q</a> <a id="8991" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8993" href="Axiom.html#8975" class="Bound">i</a> <a id="8995" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="8997" href="Axiom.html#8984" class="Bound">q̅</a>

    <a id="9005" href="Axiom.html#9005" class="Bound">isFibre</a> <a id="9013" class="Symbol">:</a> <a id="9015" class="Symbol">{</a><a id="9016" href="Axiom.html#9016" class="Bound">f</a> <a id="9018" class="Symbol">:</a> <a id="9020" href="Axiom.html#3021" class="Generalizable">X</a> <a id="9022" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="9025" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9026" class="Symbol">}</a> <a id="9028" class="Symbol">{</a><a id="9029" href="Axiom.html#9029" class="Bound">y</a> <a id="9031" class="Symbol">:</a> <a id="9033" href="Axiom.html#4136" class="Bound">Elm</a> <a id="9037" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9038" class="Symbol">}</a> <a id="9040" class="Symbol">→</a> <a id="9042" href="Axiom.html#2192" class="Function">Diagram</a> <a id="9050" class="Symbol">(</a><a id="9051" href="Axiom.html#8744" class="Bound">Fibre</a> <a id="9057" href="Axiom.html#9016" class="Bound">f</a> <a id="9059" href="Axiom.html#9029" class="Bound">y</a><a id="9060" class="Symbol">)</a> <a id="9062" class="Symbol">→</a> <a id="9064" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="9072" href="Axiom.html#9005" class="Bound">isFibre</a> <a id="9080" class="Symbol">=</a> <a id="9082" href="Axiom.html#2757" class="Function">universal</a> <a id="9092" href="Axiom.html#8870" class="Bound">FibreCommuter</a>
</pre>
<p><strong>公理 7 (纤维)</strong> 对任意 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在纤维图式满足纤维的泛性质.</p>
<pre class="Agda">    <a id="9184" class="Comment">-- Axiom 7</a>
    <a id="9199" class="Keyword">field</a> <a id="9205" href="Axiom.html#9205" class="Field">AxFibre</a> <a id="9213" class="Symbol">:</a> <a id="9215" class="Symbol">{</a><a id="9216" href="Axiom.html#9216" class="Bound">f</a> <a id="9218" class="Symbol">:</a> <a id="9220" href="Axiom.html#3021" class="Generalizable">X</a> <a id="9222" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="9225" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9226" class="Symbol">}</a> <a id="9228" class="Symbol">{</a><a id="9229" href="Axiom.html#9229" class="Bound">y</a> <a id="9231" class="Symbol">:</a> <a id="9233" href="Axiom.html#4136" class="Bound">Elm</a> <a id="9237" href="Axiom.html#3023" class="Generalizable">Y</a><a id="9238" class="Symbol">}</a> <a id="9240" class="Symbol">→</a> <a id="9242" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9244" class="Symbol">(</a><a id="9245" href="Axiom.html#2192" class="Function">Diagram</a> <a id="9253" class="Symbol">(</a><a id="9254" href="Axiom.html#8744" class="Bound">Fibre</a> <a id="9260" href="Axiom.html#9216" class="Bound">f</a> <a id="9262" href="Axiom.html#9229" class="Bound">y</a><a id="9263" class="Symbol">))</a> <a id="9266" href="Axiom.html#9005" class="Bound">isFibre</a>
</pre>
<p><strong>定义 3.2.1</strong> 我们按以下三步定义子集分类器的泛性质.</p>
<p>第一步, 我们定义子集分类器图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>Ω</code></li>
<li>一个集合 <code>T</code></li>
<li>一个函数 <code>t : T →̇ Ω</code></li>
</ul>
<p>简记作 <code>(Ω , T , t)</code>.</p>
<p>第二步, 定义子集分类器图式的交换: 我们说两个子集分类器图式 <code>(A , X , i)</code> 和 <code>(Ω , T , t)</code> 以及底集间映射 <code>χ : A →̇ Ω</code> 交换, 当且仅当如果 <code>T ≡ １</code>, 那么 <code>X</code> 配合上 <code>i</code> 是 <code>χ</code> 在 <code>t</code> 上的纤维.</p>
<p>第三步, 定义子集分类器的泛性质: 我们说一个子集分类器图式 <code>(Ω , T , t)</code> 满足子集分类器的泛性质, 当且仅当对任意子集分类器图式 <code>(A , X , i)</code>, 存在唯一的底集间映射 <code>χ : A →̇ Ω</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-f1f7a1eec3df674886ffa5161566c82b.png" alt="子集分类器的泛性质" />
<figcaption aria-hidden="true">子集分类器的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="9755" class="Comment">-- Definition 3.2.1</a>
    <a id="9779" href="Axiom.html#9779" class="Bound">SubCls</a> <a id="9786" class="Symbol">:</a> <a id="9788" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="9798" href="Axiom.html#9779" class="Bound">SubCls</a> <a id="9805" class="Symbol">=</a> <a id="9807" class="Symbol">λ</a> <a id="9809" href="Axiom.html#9809" class="Bound">Ω</a> <a id="9811" class="Symbol">→</a> <a id="9813" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9815" href="Axiom.html#1662" class="Field">CSet</a> <a id="9820" class="Symbol">λ</a> <a id="9822" href="Axiom.html#9822" class="Bound">T</a> <a id="9824" class="Symbol">→</a> <a id="9826" href="Axiom.html#9822" class="Bound">T</a> <a id="9828" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="9831" href="Axiom.html#9809" class="Bound">Ω</a>

    <a id="9838" href="Axiom.html#9838" class="Bound">SubClsCommuter</a> <a id="9853" class="Symbol">:</a> <a id="9855" href="Axiom.html#2437" class="Function">Commuter</a> <a id="9864" href="Axiom.html#9779" class="Bound">SubCls</a>
    <a id="9875" href="Axiom.html#9838" class="Bound">SubClsCommuter</a> <a id="9890" class="Symbol">=</a> <a id="9892" class="Symbol">λ</a> <a id="9894" class="Symbol">(</a><a id="9895" href="Axiom.html#9895" class="Bound">A</a> <a id="9897" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9899" href="Axiom.html#9899" class="Bound">X</a> <a id="9901" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9903" href="Axiom.html#9903" class="Bound">i</a><a id="9904" class="Symbol">)</a> <a id="9906" class="Symbol">(</a><a id="9907" href="Axiom.html#9907" class="Bound">Ω</a> <a id="9909" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9911" href="Axiom.html#9911" class="Bound">T</a> <a id="9913" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9915" href="Axiom.html#9915" class="Bound">t</a><a id="9916" class="Symbol">)</a> <a id="9918" href="Axiom.html#9918" class="Bound">χ</a> <a id="9920" class="Symbol">→</a> <a id="9922" class="Symbol">(</a><a id="9923" href="Axiom.html#9923" class="Bound">eq</a> <a id="9926" class="Symbol">:</a> <a id="9928" href="Axiom.html#9911" class="Bound">T</a> <a id="9930" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9932" href="Axiom.html#3965" class="Bound">１</a><a id="9933" class="Symbol">)</a> <a id="9935" class="Symbol">→</a>
      <a id="9943" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="9948" href="Axiom.html#9923" class="Bound">eq</a> <a id="9951" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="9954" class="Symbol">λ</a> <a id="9956" class="Symbol">{</a> <a id="9958" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9963" class="Symbol">→</a> <a id="9965" href="Axiom.html#9899" class="Bound">X</a> <a id="9967" href="Axiom.html#8579" class="Bound Operator">withInclusion</a> <a id="9981" href="Axiom.html#9903" class="Bound">i</a> <a id="9983" href="Axiom.html#8579" class="Bound Operator">isFibreOf</a> <a id="9993" href="Axiom.html#9918" class="Bound">χ</a> <a id="9995" href="Axiom.html#8579" class="Bound Operator">over</a> <a id="10000" href="Axiom.html#9915" class="Bound">t</a> <a id="10002" class="Symbol">}</a>

    <a id="10009" href="Axiom.html#10009" class="Bound">isSubCls</a> <a id="10018" class="Symbol">:</a> <a id="10020" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10028" href="Axiom.html#9779" class="Bound">SubCls</a> <a id="10035" class="Symbol">→</a> <a id="10037" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="10045" href="Axiom.html#10009" class="Bound">isSubCls</a> <a id="10054" class="Symbol">=</a> <a id="10056" href="Axiom.html#2757" class="Function">universal</a> <a id="10066" href="Axiom.html#9838" class="Bound">SubClsCommuter</a>
</pre>
<p><strong>公理 8 (子集)</strong> 存在一个子集分类器图式 <code>(Ω , １ , t)</code> 满足子集分类器的泛性质.</p>
<pre class="Agda">    <a id="10152" class="Comment">-- Axiom 8</a>
    <a id="10167" class="Keyword">field</a> <a id="10173" href="Axiom.html#10173" class="Field">AxSubCls</a> <a id="10182" class="Symbol">:</a> <a id="10184" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10186" class="Symbol">(</a><a id="10187" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10195" href="Axiom.html#9779" class="Bound">SubCls</a><a id="10201" class="Symbol">)</a> <a id="10203" class="Symbol">λ</a> <a id="10205" href="Axiom.html#10205" class="Bound">d</a><a id="10206" class="Symbol">@(_</a> <a id="10210" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10212" href="Axiom.html#10212" class="Bound">T</a> <a id="10214" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10216" class="Symbol">_)</a> <a id="10219" class="Symbol">→</a> <a id="10221" href="Axiom.html#10212" class="Bound">T</a> <a id="10223" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10225" href="Axiom.html#3965" class="Bound">１</a> <a id="10227" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10229" href="Axiom.html#10009" class="Bound">isSubCls</a> <a id="10238" href="Axiom.html#10205" class="Bound">d</a>
</pre>
<p><strong>定义 3.3.2</strong> 我们按以下三步定义自然数集的泛性质.</p>
<p>第一步, 定义自然数图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>N</code></li>
<li>一个元素 <code>z ∈ N</code></li>
<li>一个函数 <code>σ : N →̇ N</code></li>
</ul>
<p>第二步, 定义自然数图式的交换: 我们说两个自然数图式 <code>(N , z , σ)</code> 和 <code>(X , a , r)</code> 以及底集间映射 <code>x : N →̇ X</code> 交换, 当且仅当对任意 <code>n ∈ N</code> 都有 <code>x ⦅ z ⦆ ≡ a</code> 且 <code>x ⦅ σ ⦅ n ⦆ ⦆ ≡ r ⦅ x ⦅ n ⦆ ⦆</code>.</p>
<p>第三步, 定义自然数的泛性质: 我们说一个自然数图式 <code>(N , z , σ)</code> 满足自然数的泛性质, 当且仅当对任意自然数图式 <code>(X , a , r)</code>, 存在唯一的底集间映射 <code>x : N →̇ X</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-a643f6546c3ea362bb62336c01d46535.png" alt="自然数的泛性质" />
<figcaption aria-hidden="true">自然数的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="10705" class="Comment">-- Definition 3.3.2</a>
    <a id="10729" href="Axiom.html#10729" class="Bound">Nat</a> <a id="10733" class="Symbol">:</a> <a id="10735" href="Axiom.html#2008" class="Function">Arrow</a>
    <a id="10745" href="Axiom.html#10729" class="Bound">Nat</a> <a id="10749" class="Symbol">=</a> <a id="10751" class="Symbol">λ</a> <a id="10753" href="Axiom.html#10753" class="Bound">N</a> <a id="10755" class="Symbol">→</a> <a id="10757" href="Axiom.html#4136" class="Bound">Elm</a> <a id="10761" href="Axiom.html#10753" class="Bound">N</a> <a id="10763" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10765" href="Axiom.html#10753" class="Bound">N</a> <a id="10767" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="10770" href="Axiom.html#10753" class="Bound">N</a>

    <a id="10777" href="Axiom.html#10777" class="Bound">NatCommuter</a> <a id="10789" class="Symbol">:</a> <a id="10791" href="Axiom.html#2437" class="Function">Commuter</a> <a id="10800" href="Axiom.html#10729" class="Bound">Nat</a>
    <a id="10808" href="Axiom.html#10777" class="Bound">NatCommuter</a> <a id="10820" class="Symbol">=</a> <a id="10822" class="Symbol">λ</a> <a id="10824" class="Symbol">(</a><a id="10825" href="Axiom.html#10825" class="Bound">N</a> <a id="10827" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10829" href="Axiom.html#10829" class="Bound">z</a> <a id="10831" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10833" href="Axiom.html#10833" class="Bound">σ</a><a id="10834" class="Symbol">)</a> <a id="10836" class="Symbol">(</a><a id="10837" href="Axiom.html#10837" class="Bound">X</a> <a id="10839" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10841" href="Axiom.html#10841" class="Bound">a</a> <a id="10843" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10845" href="Axiom.html#10845" class="Bound">r</a><a id="10846" class="Symbol">)</a> <a id="10848" href="Axiom.html#10848" class="Bound">x</a> <a id="10850" class="Symbol">→</a>
      <a id="10858" href="Axiom.html#4174" class="Bound">∀[</a> <a id="10861" href="Axiom.html#10861" class="Bound">n</a> <a id="10863" href="Axiom.html#4174" class="Bound">∈</a> <a id="10865" href="Axiom.html#10825" class="Bound">N</a> <a id="10867" href="Axiom.html#4174" class="Bound">]</a> <a id="10869" class="Symbol">(</a><a id="10870" href="Axiom.html#10848" class="Bound">x</a> <a id="10872" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="10874" href="Axiom.html#10829" class="Bound">z</a> <a id="10876" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="10878" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10880" href="Axiom.html#10841" class="Bound">a</a> <a id="10882" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10884" href="Axiom.html#10848" class="Bound">x</a> <a id="10886" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="10888" href="Axiom.html#10833" class="Bound">σ</a> <a id="10890" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="10892" href="Axiom.html#10861" class="Bound">n</a> <a id="10894" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="10896" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="10898" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10900" href="Axiom.html#10845" class="Bound">r</a> <a id="10902" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="10904" href="Axiom.html#10848" class="Bound">x</a> <a id="10906" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="10908" href="Axiom.html#10861" class="Bound">n</a> <a id="10910" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="10912" href="Axiom.html#4842" class="Bound Operator">⦆</a><a id="10913" class="Symbol">)</a>

    <a id="10920" href="Axiom.html#10920" class="Bound">isNat</a> <a id="10926" class="Symbol">:</a> <a id="10928" href="Axiom.html#2192" class="Function">Diagram</a> <a id="10936" href="Axiom.html#10729" class="Bound">Nat</a> <a id="10940" class="Symbol">→</a> <a id="10942" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="10950" href="Axiom.html#10920" class="Bound">isNat</a> <a id="10956" class="Symbol">=</a> <a id="10958" href="Axiom.html#2757" class="Function">universal</a> <a id="10968" href="Axiom.html#10777" class="Bound">NatCommuter</a>
</pre>
<p><strong>公理 9 (自然数)</strong> 存在一个自然数图式满足自然数的泛性质.</p>
<pre class="Agda">    <a id="11033" class="Comment">-- Axiom 9</a>
    <a id="11048" class="Keyword">field</a> <a id="11054" href="Axiom.html#11054" class="Field">AxNat</a> <a id="11060" class="Symbol">:</a> <a id="11062" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11064" class="Symbol">(</a><a id="11065" href="Axiom.html#2192" class="Function">Diagram</a> <a id="11073" href="Axiom.html#10729" class="Bound">Nat</a><a id="11076" class="Symbol">)</a> <a id="11078" href="Axiom.html#10920" class="Bound">isNat</a>
</pre>
<p><strong>定义 3.1.8 ii</strong> 给定函数 <code>f : X →̇ Y</code>, 我们称 <code>f</code> 是满射, 当且仅当对任意 <code>y ∈ Y</code> 都存在 <code>x ∈ X</code> 使得 <code>f ⦅ x ⦆ ≡ y</code>.</p>
<pre class="Agda">    <a id="11196" class="Comment">-- Definition 3.1.8 ii</a>
    <a id="11223" href="Axiom.html#11223" class="Bound">surjective</a> <a id="11234" class="Symbol">:</a> <a id="11236" class="Symbol">(</a><a id="11237" href="Axiom.html#11237" class="Bound">f</a> <a id="11239" class="Symbol">:</a> <a id="11241" href="Axiom.html#3021" class="Generalizable">X</a> <a id="11243" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11246" href="Axiom.html#3023" class="Generalizable">Y</a><a id="11247" class="Symbol">)</a> <a id="11249" class="Symbol">→</a> <a id="11251" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11259" href="Axiom.html#11223" class="Bound">surjective</a> <a id="11270" class="Symbol">{</a><a id="11271" href="Axiom.html#11271" class="Bound">X</a><a id="11272" class="Symbol">}</a> <a id="11274" class="Symbol">{</a><a id="11275" href="Axiom.html#11275" class="Bound">Y</a><a id="11276" class="Symbol">}</a> <a id="11278" href="Axiom.html#11278" class="Bound">f</a> <a id="11280" class="Symbol">=</a> <a id="11282" href="Axiom.html#4174" class="Bound">∀[</a> <a id="11285" href="Axiom.html#11285" class="Bound">y</a> <a id="11287" href="Axiom.html#4174" class="Bound">∈</a> <a id="11289" href="Axiom.html#11275" class="Bound">Y</a> <a id="11291" href="Axiom.html#4174" class="Bound">]</a> <a id="11293" href="Axiom.html#4343" class="Bound">∃[</a> <a id="11296" href="Axiom.html#11296" class="Bound">x</a> <a id="11298" href="Axiom.html#4343" class="Bound">∈</a> <a id="11300" href="Axiom.html#11271" class="Bound">X</a> <a id="11302" href="Axiom.html#4343" class="Bound">]</a> <a id="11304" href="Axiom.html#11278" class="Bound">f</a> <a id="11306" href="Axiom.html#4842" class="Bound Operator">⦅</a> <a id="11308" href="Axiom.html#11296" class="Bound">x</a> <a id="11310" href="Axiom.html#4842" class="Bound Operator">⦆</a> <a id="11312" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11314" href="Axiom.html#11285" class="Bound">y</a>
</pre>
<p><strong>定义 3.4.1</strong> 给定函数 <code>f : X →̇ Y</code> 和 <code>i : Y →̇ X</code>, 我们称 <code>i</code> 是 <code>f</code> 的截面, 当且仅当 <code>f ∘ i ≡ id</code>.</p>
<pre class="Agda">    <a id="11419" class="Comment">-- Definition 3.4.1</a>
    <a id="11443" href="Axiom.html#11443" class="Bound">section</a> <a id="11451" class="Symbol">:</a> <a id="11453" class="Symbol">(</a><a id="11454" href="Axiom.html#11454" class="Bound">f</a> <a id="11456" class="Symbol">:</a> <a id="11458" href="Axiom.html#3021" class="Generalizable">X</a> <a id="11460" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11463" href="Axiom.html#3023" class="Generalizable">Y</a><a id="11464" class="Symbol">)</a> <a id="11466" class="Symbol">(</a><a id="11467" href="Axiom.html#11467" class="Bound">i</a> <a id="11469" class="Symbol">:</a> <a id="11471" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="11473" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11476" href="Axiom.html#3021" class="Generalizable">X</a><a id="11477" class="Symbol">)</a> <a id="11479" class="Symbol">→</a> <a id="11481" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11489" href="Axiom.html#11443" class="Bound">section</a> <a id="11497" href="Axiom.html#11497" class="Bound">f</a> <a id="11499" href="Axiom.html#11499" class="Bound">i</a> <a id="11501" class="Symbol">=</a> <a id="11503" href="Axiom.html#11497" class="Bound">f</a> <a id="11505" href="Axiom.html#1707" class="Field Operator">∘</a> <a id="11507" href="Axiom.html#11499" class="Bound">i</a> <a id="11509" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11511" href="Axiom.html#1800" class="Function">id</a>
</pre>
<p><strong>公理 10 (选择)</strong> 如果 <code>f : X →̇ Y</code> 是满射, 那么存在 <code>f</code> 的一个截面 <code>i : Y →̇ X</code>.</p>
<pre class="Agda">    <a id="11597" class="Comment">-- Axiom 10</a>
    <a id="11613" class="Keyword">field</a> <a id="11619" href="Axiom.html#11619" class="Field">AxChoice</a> <a id="11628" class="Symbol">:</a> <a id="11630" href="Axiom.html#11223" class="Bound">surjective</a> <a id="11641" href="Axiom.html#3044" class="Generalizable">f</a> <a id="11643" class="Symbol">→</a> <a id="11645" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11647" class="Symbol">(</a><a id="11648" href="Axiom.html#3023" class="Generalizable">Y</a> <a id="11650" href="Axiom.html#1677" class="Field Operator">→̇</a> <a id="11653" href="Axiom.html#3021" class="Generalizable">X</a><a id="11654" class="Symbol">)</a> <a id="11656" class="Symbol">(</a><a id="11657" href="Axiom.html#11443" class="Bound">section</a> <a id="11665" href="Axiom.html#3044" class="Generalizable">f</a><a id="11666" class="Symbol">)</a>
</pre>
<h2 id="总结">总结</h2>
<p>以下是对公理化的总结. 我们的公理适用于以下资料：</p>
<ul>
<li>一些称为集合的东西;</li>
<li>对于每个集合 <code>X</code> 和集合 <code>Y</code>, 一些称为从 <code>X</code> 到 <code>Y</code> 的函数, 我们用 <code>f : X →̇ Y</code> 表示从 <code>X</code> 到 <code>Y</code> 的函数 <code>f</code>;</li>
<li>对于每个集合 <code>X</code>, 集合 <code>Y</code> 和集合 <code>X</code>, 一个称为复合的运算, 将每对函数 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋予一个函数 <code>f ∘ g : X →̇ Z</code>;</li>
<li>对于每个集合 <code>X</code>， 一个函数 <code>id : X →̇ X</code>, 称为 <code>X</code> 的恒等函数.</li>
</ul>
<p>公理：</p>
<ol type="1">
<li>函数的复合满足结合律, 并且恒等函数起到恒等作用.</li>
<li>存在一个终集.</li>
<li>函数外延性成立.</li>
<li>存在一个空集.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 和 <code>Y</code> 的积.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 到 <code>Y</code> 的函数集.</li>
<li>给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在 <code>f</code> 在 <code>y</code> 上的纤维.</li>
<li>存在一个子集分类器.</li>
<li>存在一个自然数系统.</li>
<li>每个满射都有一个截面.</li>
</ol>
<p>公理 3, 4 和 7 都涉及到元素, 它定义为定义域为终集 <code>１</code> 的函数. 公理 2 以及 5–9 都涉及到泛性质, 并且所有这些公理唯一地刻画了涉及的集合 (在同构意义上), 这将在接下来的几篇中证明.</p>
<p>为了方便后面引用, 我们将以上资料和公理统称为 <code>ETCS</code> 理论.</p>
<pre class="Agda"><a id="12342" class="Keyword">record</a> <a id="ETCS"></a><a id="12349" href="Axiom.html#12349" class="Record">ETCS</a> <a id="12354" class="Symbol">:</a> <a id="12356" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="12361" class="Keyword">where</a>
  <a id="12369" class="Keyword">field</a>
    <a id="ETCS.etcs"></a><a id="12379" href="Axiom.html#12379" class="Field">etcs</a> <a id="12384" class="Symbol">:</a> <a id="12386" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="12388" href="Axiom.html#1600" class="Record">Data</a> <a id="12393" href="Axiom.html#3117" class="Record">Data.Axiom</a>
  <a id="12406" class="Keyword">open</a> <a id="12411" href="Axiom.html#1600" class="Module">Data</a> <a id="12416" class="Symbol">(</a><a id="12417" href="Axiom.html#12379" class="Field">etcs</a> <a id="12422" class="Symbol">.</a><a id="12423" href="Axiom.html#949" class="Field">fst</a><a id="12426" class="Symbol">)</a> <a id="12428" class="Keyword">public</a>
  <a id="12437" class="Keyword">open</a> <a id="12442" href="Axiom.html#3117" class="Module">Data.Axiom</a> <a id="12453" class="Symbol">(</a><a id="12454" href="Axiom.html#12379" class="Field">etcs</a> <a id="12459" class="Symbol">.</a><a id="12460" href="Axiom.html#963" class="Field">snd</a><a id="12463" class="Symbol">)</a> <a id="12465" class="Keyword">public</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
