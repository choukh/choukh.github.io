<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>公理化结构集合论 (1 公理)</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">公理化结构集合论 (1 公理)</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#公理化结构集合论-1-公理" id="toc-公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#原始概念" id="toc-原始概念">原始概念</a></li>
  <li><a href="#公理" id="toc-公理">公理</a></li>
  <li><a href="#总结" id="toc-总结">总结</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="公理化结构集合论-1-公理">公理化结构集合论 (1 公理)</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/ETCS/blob/main/src/Axiom.lagda.md">Axiom.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/ETCS/Axiom.html">Axiom.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本系列文章是对 Tom Leinster 在爱丁堡大学教授的本科课程「公理化结构集合论（ETCS）」讲义（以下简称「讲义」）的 Agda 形式化. 我们的符号选取和定义表述基本上遵循讲义, 而定理编号与讲义完全一致, 但由于 Agda 的特性而稍微调整了顺序. 注意我们讲的是一种可以作为数学基础的集合论而不是范畴论, 虽然借用了一些范畴论的术语和思想, 但不需要先掌握范畴论.</p>
<p>我们采用原味 Agda 加 stdlib 标准库, 这是我们的元语言, 而 ETCS 将是我们的对象语言. 由于两层语言的高度相似性, 它们的符号/命名冲突我们主要采用如下两种方式解决.</p>
<ol type="1">
<li>如果一个符号已经用于元语言 (如 <code>→</code>), 则在上面加点表示对象语言的相应概念 (如 <code>→̇</code>).</li>
<li>如果一个符号优先用于对象语言 (如 <code>id</code>), 则在后面加上 <code>⒨</code> 表示元语言的相应概念 (如 <code>id⒨</code>).</li>
</ol>
<pre class="Agda"><a id="727" class="Keyword">module</a> <a id="734" href="Axiom.html" class="Module">Axiom</a> <a id="740" class="Keyword">where</a>

<a id="747" class="Keyword">open</a> <a id="752" class="Keyword">import</a> <a id="759" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="770" class="Keyword">public</a> <a id="777" class="Keyword">using</a> <a id="783" class="Symbol">(</a><a id="784" href="Data.Empty.html#914" class="Function">⊥</a><a id="785" class="Symbol">)</a>
<a id="787" class="Keyword">open</a> <a id="792" class="Keyword">import</a> <a id="799" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="809" class="Keyword">public</a> <a id="816" class="Keyword">using</a> <a id="822" class="Symbol">(</a><a id="823" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="824" class="Symbol">;</a> <a id="826" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="828" class="Symbol">)</a>
<a id="830" class="Keyword">open</a> <a id="835" class="Keyword">import</a> <a id="842" href="Data.Product.html" class="Module">Data.Product</a> <a id="855" class="Keyword">public</a> <a id="862" class="Keyword">using</a> <a id="868" class="Symbol">(</a><a id="869" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="870" class="Symbol">;</a> <a id="872" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="875" class="Symbol">;</a> <a id="877" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="880" class="Symbol">)</a>
  <a id="884" class="Keyword">renaming</a> <a id="893" class="Symbol">(</a><a id="894" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="900" class="Symbol">to</a> <a id="903" class="Field">fst</a><a id="906" class="Symbol">;</a> <a id="908" href="Data.Product.Base.html#650" class="Field">proj₂</a> <a id="914" class="Symbol">to</a> <a id="917" class="Field">snd</a><a id="920" class="Symbol">)</a>
<a id="922" class="Keyword">open</a> <a id="927" class="Keyword">import</a> <a id="934" href="Function.html" class="Module">Function</a> <a id="943" class="Keyword">public</a> <a id="950" class="Keyword">using</a> <a id="956" class="Symbol">(</a><a id="957" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="965" class="Symbol">)</a> <a id="967" class="Keyword">renaming</a> <a id="976" class="Symbol">(</a><a id="977" href="Function.Base.html#704" class="Function">id</a> <a id="980" class="Symbol">to</a> <a id="983" class="Function">id⒨</a><a id="986" class="Symbol">)</a>
<a id="988" class="Keyword">open</a> <a id="993" class="Keyword">import</a> <a id="1000" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1038" class="Keyword">public</a>
</pre>
<p>本文是系列的第一篇, 我们引入 ETCS 的10条公理. 为了表示公理, 首先需要引入 ETCS 的原始概念, 讲义中称它们为资料 (the data), 有的地方也称之为原语 (primitives) , 语言 (language) 或签名 (signature).</p>
<h2 id="原始概念">原始概念</h2>
<p>形式地, 我们的公理将在如下原始概念上展开表述.</p>
<ul>
<li>一些称为集合的东西, 这样的集合 <code>X</code> 记作 <code>X : CSet</code>, 其中 C 来自范畴 (category).</li>
<li>对每个集合 <code>X</code> 和 <code>Y</code>, 一些称为「<code>X</code> 到 <code>Y</code> 的函数」的东西, 这样的函数 <code>f</code> 记作 <code>f : X →̇ Y</code>.</li>
<li>对每个集合 <code>X</code>, <code>Y</code> 和 <code>Z</code>, 一个称为「复合」的运算, 将每个 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋值为一个函数 <code>g ∘ f : X →̇ Z</code>.</li>
<li>对每个集合 <code>X</code>, 一个称为「恒等函数」的东西, 记作 <code>id⟨ X ⟩ : X →̇ X</code>, <code>X</code> 可以从上下文推断出来时简记作 <code>id</code>.</li>
</ul>
<pre class="Agda"><a id="1531" class="Comment">-- 2.1 The data</a>
<a id="1547" class="Keyword">record</a> <a id="Data"></a><a id="1554" href="Axiom.html#1554" class="Record">Data</a> <a id="1559" class="Symbol">:</a> <a id="1561" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="1566" class="Keyword">where</a>
  <a id="1574" class="Keyword">infixl</a> <a id="1581" class="Number">10</a> <a id="1584" href="Axiom.html#1631" class="Field Operator">_→̇_</a>
  <a id="1591" class="Keyword">infix</a> <a id="1597" class="Number">10</a> <a id="1600" href="Axiom.html#1661" class="Field Operator">_∘_</a>
  <a id="1606" class="Keyword">field</a>
    <a id="Data.CSet"></a><a id="1616" href="Axiom.html#1616" class="Field">CSet</a> <a id="1621" class="Symbol">:</a> <a id="1623" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._→̇_"></a><a id="1631" href="Axiom.html#1631" class="Field Operator">_→̇_</a> <a id="1636" class="Symbol">:</a> <a id="1638" class="Symbol">(</a><a id="1639" href="Axiom.html#1639" class="Bound">X</a> <a id="1641" href="Axiom.html#1641" class="Bound">Y</a> <a id="1643" class="Symbol">:</a> <a id="1645" href="Axiom.html#1616" class="Field">CSet</a><a id="1649" class="Symbol">)</a> <a id="1651" class="Symbol">→</a> <a id="1653" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="Data._∘_"></a><a id="1661" href="Axiom.html#1661" class="Field Operator">_∘_</a> <a id="1665" class="Symbol">:</a> <a id="1667" class="Symbol">{</a><a id="1668" href="Axiom.html#1668" class="Bound">X</a> <a id="1670" href="Axiom.html#1670" class="Bound">Y</a> <a id="1672" href="Axiom.html#1672" class="Bound">Z</a> <a id="1674" class="Symbol">:</a> <a id="1676" href="Axiom.html#1616" class="Field">CSet</a><a id="1680" class="Symbol">}</a> <a id="1682" class="Symbol">(</a><a id="1683" href="Axiom.html#1683" class="Bound">g</a> <a id="1685" class="Symbol">:</a> <a id="1687" href="Axiom.html#1670" class="Bound">Y</a> <a id="1689" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1692" href="Axiom.html#1672" class="Bound">Z</a><a id="1693" class="Symbol">)</a> <a id="1695" class="Symbol">(</a><a id="1696" href="Axiom.html#1696" class="Bound">f</a> <a id="1698" class="Symbol">:</a> <a id="1700" href="Axiom.html#1668" class="Bound">X</a> <a id="1702" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1705" href="Axiom.html#1670" class="Bound">Y</a><a id="1706" class="Symbol">)</a> <a id="1708" class="Symbol">→</a> <a id="1710" class="Symbol">(</a><a id="1711" href="Axiom.html#1668" class="Bound">X</a> <a id="1713" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1716" href="Axiom.html#1672" class="Bound">Z</a><a id="1717" class="Symbol">)</a>
    <a id="Data.id⟨_⟩"></a><a id="1723" href="Axiom.html#1723" class="Field Operator">id⟨_⟩</a> <a id="1729" class="Symbol">:</a> <a id="1731" class="Symbol">(</a><a id="1732" href="Axiom.html#1732" class="Bound">X</a> <a id="1734" class="Symbol">:</a> <a id="1736" href="Axiom.html#1616" class="Field">CSet</a><a id="1740" class="Symbol">)</a> <a id="1742" class="Symbol">→</a> <a id="1744" href="Axiom.html#1732" class="Bound">X</a> <a id="1746" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1749" href="Axiom.html#1732" class="Bound">X</a>

  <a id="Data.id"></a><a id="1754" href="Axiom.html#1754" class="Function">id</a> <a id="1757" class="Symbol">:</a> <a id="1759" class="Symbol">{</a><a id="1760" href="Axiom.html#1760" class="Bound">X</a> <a id="1762" class="Symbol">:</a> <a id="1764" href="Axiom.html#1616" class="Field">CSet</a><a id="1768" class="Symbol">}</a> <a id="1770" class="Symbol">→</a> <a id="1772" href="Axiom.html#1760" class="Bound">X</a> <a id="1774" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="1777" href="Axiom.html#1760" class="Bound">X</a>
  <a id="1781" href="Axiom.html#1754" class="Function">id</a> <a id="1784" class="Symbol">{</a><a id="1785" href="Axiom.html#1785" class="Bound">X</a><a id="1786" class="Symbol">}</a> <a id="1788" class="Symbol">=</a> <a id="1790" href="Axiom.html#1723" class="Field Operator">id⟨</a> <a id="1794" href="Axiom.html#1785" class="Bound">X</a> <a id="1796" href="Axiom.html#1723" class="Field Operator">⟩</a>
</pre>
<p>我们会形式化讲义中没有编号的概念, 这些概念我们编号为 -1.</p>
<p><strong>定义 -1.1</strong> 我们把关于集合的性质称为箭头模式 <code>Arrow</code>. 给定这样的性质 <code>A : Arrow</code>, 如果某集合 <code>X</code> 满足 <code>A</code>, 我们就把 <code>a : A X</code> 称为集合 <code>X</code> 的一套 <code>A</code>-箭头.</p>
<pre class="Agda">  <a id="Data.Arrow"></a><a id="1960" href="Axiom.html#1960" class="Function">Arrow</a> <a id="1966" class="Symbol">:</a> <a id="1968" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="1975" href="Axiom.html#1960" class="Function">Arrow</a> <a id="1981" class="Symbol">=</a> <a id="1983" href="Axiom.html#1616" class="Field">CSet</a> <a id="1988" class="Symbol">→</a> <a id="1990" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.2</strong> 给定箭头模式 <code>A</code>, 由以下资料组成的东西称为 <code>A</code>-图式 (diagram), 记作 <code>Diagram A</code>.</p>
<ul>
<li>一个集合 <code>X</code></li>
<li><code>X</code> 的一套 <code>A</code>-箭头</li>
</ul>
<p>其中 <code>X</code> 叫做图式的底集 (underlying set).</p>
<pre class="Agda">  <a id="Data.Diagram"></a><a id="2144" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2152" class="Symbol">:</a> <a id="2154" href="Axiom.html#1960" class="Function">Arrow</a> <a id="2160" class="Symbol">→</a> <a id="2162" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2168" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2176" class="Symbol">=</a> <a id="2178" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2180" href="Axiom.html#1616" class="Field">CSet</a>
</pre>
<p><strong>定义 -1.3</strong> 给定箭头模式 <code>A</code>, 我们把关于两个 <code>A</code>-图式以及它们的底集间映射 <code>j</code> 的性质称为 <code>A</code>-交换模式, 记作 <code>Commuter A</code>. 对任意两个 <code>A</code>-图式 <code>a</code> <code>b</code> 以及它们的底集间映射 <code>j</code>, 如果它们满足一个 <code>A</code>-交换模式 <code>C : Commuter A</code>, 我们就称它们 <code>C</code>-交换, 记作 <code>C a b j</code>.</p>
<pre class="Agda">  <a id="Data.Commuter"></a><a id="2389" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2398" class="Symbol">:</a> <a id="2400" class="Symbol">(</a><a id="2401" href="Axiom.html#2401" class="Bound">A</a> <a id="2403" class="Symbol">:</a> <a id="2405" href="Axiom.html#1960" class="Function">Arrow</a><a id="2410" class="Symbol">)</a> <a id="2412" class="Symbol">→</a> <a id="2414" href="Agda.Primitive.html#388" class="Primitive">Set₁</a>
  <a id="2421" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2430" href="Axiom.html#2430" class="Bound">A</a> <a id="2432" class="Symbol">=</a> <a id="2434" class="Symbol">(</a><a id="2435" href="Axiom.html#2435" class="Bound">(</a><a id="2436" href="Axiom.html#2436" class="Bound">X</a> <a id="2438" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2440" href="Axiom.html#2435" class="Bound">_)</a> <a id="2443" href="Axiom.html#2443" class="Bound">(</a><a id="2444" href="Axiom.html#2444" class="Bound">Y</a> <a id="2446" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2448" href="Axiom.html#2443" class="Bound">_)</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2461" href="Axiom.html#2430" class="Bound">A</a><a id="2462" class="Symbol">)</a> <a id="2464" class="Symbol">(</a><a id="2465" href="Axiom.html#2465" class="Bound">j</a> <a id="2467" class="Symbol">:</a> <a id="2469" href="Axiom.html#2436" class="Bound">X</a> <a id="2471" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="2474" href="Axiom.html#2444" class="Bound">Y</a><a id="2475" class="Symbol">)</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="Agda.Primitive.html#388" class="Primitive">Set</a>
</pre>
<p><strong>定义 -1.4</strong> 给定一个 <code>A</code>-交换模式 <code>C</code> 和一个 <code>A</code>-图式 <code>b</code>, 我们称 <code>b</code> 满足 <code>C</code>-泛性质, 当且仅当对任意 <code>A</code>-图式 <code>a</code>, 存在唯一的底集间映射 <code>j</code> 使得 <code>a</code> <code>b</code> <code>j</code> 满足 <code>C</code>-交换.</p>
<pre class="Agda">  <a id="Data.unique"></a><a id="2626" href="Axiom.html#2626" class="Function">unique</a> <a id="2633" class="Symbol">:</a> <a id="2635" class="Symbol">{</a><a id="2636" href="Axiom.html#2636" class="Bound">A</a> <a id="2638" class="Symbol">:</a> <a id="2640" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2643" class="Symbol">}</a> <a id="2645" class="Symbol">(</a><a id="2646" href="Axiom.html#2646" class="Bound">P</a> <a id="2648" class="Symbol">:</a> <a id="2650" href="Axiom.html#2636" class="Bound">A</a> <a id="2652" class="Symbol">→</a> <a id="2654" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="2657" class="Symbol">)</a> <a id="2659" class="Symbol">→</a> <a id="2661" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2667" href="Axiom.html#2626" class="Function">unique</a> <a id="2674" href="Axiom.html#2674" class="Bound">P</a> <a id="2676" class="Symbol">=</a> <a id="2678" class="Symbol">∀</a> <a id="2680" class="Symbol">{</a><a id="2681" href="Axiom.html#2681" class="Bound">a</a> <a id="2683" href="Axiom.html#2683" class="Bound">b</a><a id="2684" class="Symbol">}</a> <a id="2686" class="Symbol">→</a> <a id="2688" href="Axiom.html#2674" class="Bound">P</a> <a id="2690" href="Axiom.html#2681" class="Bound">a</a> <a id="2692" class="Symbol">→</a> <a id="2694" href="Axiom.html#2674" class="Bound">P</a> <a id="2696" href="Axiom.html#2683" class="Bound">b</a> <a id="2698" class="Symbol">→</a> <a id="2700" href="Axiom.html#2681" class="Bound">a</a> <a id="2702" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2704" href="Axiom.html#2683" class="Bound">b</a>

  <a id="Data.universal"></a><a id="2709" href="Axiom.html#2709" class="Function">universal</a> <a id="2719" class="Symbol">:</a> <a id="2721" class="Symbol">{</a><a id="2722" href="Axiom.html#2722" class="Bound">A</a> <a id="2724" class="Symbol">:</a> <a id="2726" href="Axiom.html#1960" class="Function">Arrow</a><a id="2731" class="Symbol">}</a> <a id="2733" class="Symbol">→</a> <a id="2735" href="Axiom.html#2389" class="Function">Commuter</a> <a id="2744" href="Axiom.html#2722" class="Bound">A</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2756" href="Axiom.html#2722" class="Bound">A</a> <a id="2758" class="Symbol">→</a> <a id="2760" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="2766" href="Axiom.html#2709" class="Function">universal</a> <a id="2776" class="Symbol">{</a><a id="2777" href="Axiom.html#2777" class="Bound">A</a><a id="2778" class="Symbol">}</a> <a id="2780" href="Axiom.html#2780" class="Bound">C</a> <a id="2782" href="Axiom.html#2782" class="Bound">b</a><a id="2783" class="Symbol">@(</a><a id="2785" href="Axiom.html#2785" class="Bound">Y</a> <a id="2787" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2789" class="Symbol">_)</a> <a id="2792" class="Symbol">=</a> <a id="2794" class="Symbol">(</a><a id="2795" href="Axiom.html#2795" class="Bound">a</a><a id="2796" class="Symbol">@(</a><a id="2798" href="Axiom.html#2798" class="Bound">X</a> <a id="2800" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2802" class="Symbol">_)</a> <a id="2805" class="Symbol">:</a> <a id="2807" href="Axiom.html#2144" class="Function">Diagram</a> <a id="2815" href="Axiom.html#2777" class="Bound">A</a><a id="2816" class="Symbol">)</a> <a id="2818" class="Symbol">→</a>
    <a id="2824" class="Symbol">(</a><a id="2825" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2827" class="Symbol">(</a><a id="2828" href="Axiom.html#2798" class="Bound">X</a> <a id="2830" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="2833" href="Axiom.html#2785" class="Bound">Y</a><a id="2834" class="Symbol">)</a> <a id="2836" class="Symbol">λ</a> <a id="2838" href="Axiom.html#2838" class="Bound">j</a> <a id="2840" class="Symbol">→</a> <a id="2842" href="Axiom.html#2780" class="Bound">C</a> <a id="2844" href="Axiom.html#2795" class="Bound">a</a> <a id="2846" href="Axiom.html#2782" class="Bound">b</a> <a id="2848" href="Axiom.html#2838" class="Bound">j</a><a id="2849" class="Symbol">)</a> <a id="2851" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2853" href="Axiom.html#2626" class="Function">unique</a> <a id="2860" class="Symbol">(</a><a id="2861" href="Axiom.html#2780" class="Bound">C</a> <a id="2863" href="Axiom.html#2795" class="Bound">a</a> <a id="2865" href="Axiom.html#2782" class="Bound">b</a><a id="2866" class="Symbol">)</a>
</pre>
<p>我们约定用 <code>A</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code> <code>X′</code> <code>Y′</code> 表示集合, 用 <code>f</code> <code>g</code> <code>h</code> <code>f′</code> <code>g′</code> 表示函数.</p>
<pre class="Agda">  <a id="2956" class="Keyword">variable</a>
    <a id="2969" href="Axiom.html#2969" class="Generalizable">A</a> <a id="2971" href="Axiom.html#2971" class="Generalizable">W</a> <a id="2973" href="Axiom.html#2973" class="Generalizable">X</a> <a id="2975" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="2977" href="Axiom.html#2977" class="Generalizable">Z</a> <a id="2979" href="Axiom.html#2979" class="Generalizable">X′</a> <a id="2982" href="Axiom.html#2982" class="Generalizable">Y′</a> <a id="2985" class="Symbol">:</a> <a id="2987" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="2996" href="Axiom.html#2996" class="Generalizable">f</a> <a id="2998" href="Axiom.html#2998" class="Generalizable">g</a> <a id="3000" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3002" href="Axiom.html#3002" class="Generalizable">f′</a> <a id="3005" href="Axiom.html#3005" class="Generalizable">g′</a> <a id="3008" class="Symbol">:</a> <a id="3010" href="Axiom.html#2973" class="Generalizable">X</a> <a id="3012" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="3015" href="Axiom.html#2975" class="Generalizable">Y</a>
</pre>
<h2 id="公理">公理</h2>
<p>我们现在可以引入 ETCS 的10条公理.</p>
<pre class="Agda">  <a id="3062" class="Keyword">record</a> <a id="Data.Axiom"></a><a id="3069" href="Axiom.html#3069" class="Record">Axiom</a> <a id="3075" class="Symbol">:</a> <a id="3077" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3081" class="Keyword">where</a>
</pre>
<p><strong>公理 1 (范畴)</strong> 以下三个命题成立.</p>
<ol type="1">
<li>复合运算满足结合律.</li>
<li>恒等函数是复合运算的左单位元.</li>
<li>恒等函数是复合运算的右单位元.</li>
</ol>
<pre class="Agda">    <a id="3182" class="Keyword">field</a>
      <a id="3194" class="Comment">-- Axiom 1</a>
      <a id="3211" href="Axiom.html#3211" class="Field">AxAss</a> <a id="3217" class="Symbol">:</a> <a id="3219" class="Symbol">(</a><a id="3220" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3222" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3224" href="Axiom.html#2998" class="Generalizable">g</a><a id="3225" class="Symbol">)</a> <a id="3227" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3229" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3231" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3233" href="Axiom.html#3000" class="Generalizable">h</a> <a id="3235" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3237" class="Symbol">(</a><a id="3238" href="Axiom.html#2998" class="Generalizable">g</a> <a id="3240" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3242" href="Axiom.html#2996" class="Generalizable">f</a><a id="3243" class="Symbol">)</a>
      <a id="3251" href="Axiom.html#3251" class="Field">AxIdˡ</a> <a id="3257" class="Symbol">:</a> <a id="3259" href="Axiom.html#1754" class="Function">id</a> <a id="3262" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3264" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3266" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3268" href="Axiom.html#2996" class="Generalizable">f</a>
      <a id="3276" href="Axiom.html#3276" class="Field">AxIdʳ</a> <a id="3282" class="Symbol">:</a> <a id="3284" href="Axiom.html#2996" class="Generalizable">f</a> <a id="3286" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="3288" href="Axiom.html#1754" class="Function">id</a> <a id="3291" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3293" href="Axiom.html#2996" class="Generalizable">f</a>
</pre>
<p><strong>定义 2.3.1</strong> 我们说一个集合 <code>T</code> 是终集合, 当且仅当对任意集合 <code>X</code>, 存在唯一的 <code>j : X →̇ T</code>. 注意终集合的图式没有箭头, 只有一个集合, 且终集合的交换模式是恒真.</p>
<pre class="Agda">    <a id="3415" class="Comment">-- Definition 2.3.1</a>
    <a id="3439" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3448" class="Symbol">:</a> <a id="3450" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="3460" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3469" class="Symbol">=</a> <a id="3471" class="Symbol">λ</a> <a id="3473" href="Axiom.html#3473" class="Bound">_</a> <a id="3475" class="Symbol">→</a> <a id="3477" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3484" href="Axiom.html#3484" class="Bound">TerminalCommuter</a> <a id="3501" class="Symbol">:</a> <a id="3503" href="Axiom.html#2389" class="Function">Commuter</a> <a id="3512" href="Axiom.html#3439" class="Bound">Terminal</a>
    <a id="3525" href="Axiom.html#3484" class="Bound">TerminalCommuter</a> <a id="3542" class="Symbol">=</a> <a id="3544" class="Symbol">λ</a> <a id="3546" href="Axiom.html#3546" class="Bound">_</a> <a id="3548" href="Axiom.html#3548" class="Bound">_</a> <a id="3550" href="Axiom.html#3550" class="Bound">_</a> <a id="3552" class="Symbol">→</a> <a id="3554" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="3561" href="Axiom.html#3561" class="Bound">isTerminal</a> <a id="3572" class="Symbol">:</a> <a id="3574" href="Axiom.html#2144" class="Function">Diagram</a> <a id="3582" href="Axiom.html#3439" class="Bound">Terminal</a> <a id="3591" class="Symbol">→</a> <a id="3593" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="3601" href="Axiom.html#3561" class="Bound">isTerminal</a> <a id="3612" class="Symbol">=</a> <a id="3614" href="Axiom.html#2709" class="Function">universal</a> <a id="3624" href="Axiom.html#3484" class="Bound">TerminalCommuter</a>
</pre>
<p><strong>公理 2 (终集)</strong> 存在一个终集合.</p>
<pre class="Agda">    <a id="3682" class="Comment">-- Axiom 2</a>
    <a id="3697" class="Keyword">field</a> <a id="3703" href="Axiom.html#3703" class="Field">AxTml</a> <a id="3709" class="Symbol">:</a> <a id="3711" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="3713" class="Symbol">(</a><a id="3714" href="Axiom.html#2144" class="Function">Diagram</a> <a id="3722" href="Axiom.html#3439" class="Bound">Terminal</a><a id="3730" class="Symbol">)</a> <a id="3732" href="Axiom.html#3561" class="Bound">isTerminal</a>
</pre>
<p>我们将在后篇证明这样的终集合是唯一的. 实际上, 我们会证明所有用泛性质框定的集合都是唯一的. 所以定义了一种泛性质就唯一定义了一种集合, 所以我们后面会直接说「定义某种集合的泛性质」, 这应该理解为就是在「定义某种集合」.</p>
<p>我们把公理2承诺的集合记作 <code>１</code>, 因为它里面只有一个元素, 这会在下一章证明.</p>
<pre class="Agda">    <a id="3917" href="Axiom.html#3917" class="Bound">１</a> <a id="3919" class="Symbol">:</a> <a id="3921" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="3930" href="Axiom.html#3917" class="Bound">１</a> <a id="3932" class="Symbol">=</a> <a id="3934" href="Axiom.html#3703" class="Field">AxTml</a> <a id="3940" class="Symbol">.</a><a id="3941" href="Axiom.html#903" class="Field">fst</a> <a id="3945" class="Symbol">.</a><a id="3946" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p><strong>定义 2.3.6</strong> 给定集合 <code>X</code>, 我们把 <code>１</code> 到 <code>X</code> 的函数称为 <code>X</code> 的元素, 其类型记作 <code>Elm X</code>. 我们将 <code>x : Elm X</code> 简记为 <code>x ∈ X</code>.</p>
<pre class="Agda">    <a id="4064" class="Comment">-- Definition 2.3.6</a>
    <a id="4088" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4092" class="Symbol">:</a> <a id="4094" href="Axiom.html#1616" class="Field">CSet</a> <a id="4099" class="Symbol">→</a> <a id="4101" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4109" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4113" class="Symbol">=</a> <a id="4115" href="Axiom.html#3917" class="Bound">１</a> <a id="4117" href="Axiom.html#1631" class="Field Operator">→̇_</a>

    <a id="4126" href="Axiom.html#4126" class="Bound">∀[∈]-syntax</a> <a id="4138" class="Symbol">:</a> <a id="4140" class="Symbol">(</a><a id="4141" href="Axiom.html#4141" class="Bound">X</a> <a id="4143" class="Symbol">:</a> <a id="4145" href="Axiom.html#1616" class="Field">CSet</a><a id="4149" class="Symbol">)</a> <a id="4151" class="Symbol">(</a><a id="4152" href="Axiom.html#4152" class="Bound">P</a> <a id="4154" class="Symbol">:</a> <a id="4156" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4160" href="Axiom.html#4141" class="Bound">X</a> <a id="4162" class="Symbol">→</a> <a id="4164" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4167" class="Symbol">)</a> <a id="4169" class="Symbol">→</a> <a id="4171" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4179" href="Axiom.html#4126" class="Bound">∀[∈]-syntax</a> <a id="4191" href="Axiom.html#4191" class="Bound">X</a> <a id="4193" href="Axiom.html#4193" class="Bound">P</a> <a id="4195" class="Symbol">=</a> <a id="4197" class="Symbol">(</a><a id="4198" href="Axiom.html#4198" class="Bound">x</a> <a id="4200" class="Symbol">:</a> <a id="4202" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4206" href="Axiom.html#4191" class="Bound">X</a><a id="4207" class="Symbol">)</a> <a id="4209" class="Symbol">→</a> <a id="4211" href="Axiom.html#4193" class="Bound">P</a> <a id="4213" href="Axiom.html#4198" class="Bound">x</a>

    <a id="4220" class="Keyword">infix</a> <a id="4226" class="Number">3</a> <a id="4228" href="Axiom.html#4126" class="Function">∀[∈]-syntax</a>
    <a id="4244" class="Keyword">syntax</a> <a id="4251" href="Axiom.html#4126" class="Function">∀[∈]-syntax</a> <a id="4263" class="Bound">X</a> <a id="4265" class="Symbol">(λ</a> <a id="4268" class="Bound">x</a> <a id="4270" class="Symbol">→</a> <a id="4272" class="Bound">A</a><a id="4273" class="Symbol">)</a> <a id="4275" class="Symbol">=</a> <a id="4277" class="Function">∀[</a> <a id="4280" class="Bound">x</a> <a id="4282" class="Function">∈</a> <a id="4284" class="Bound">X</a> <a id="4286" class="Function">]</a> <a id="4288" class="Bound">A</a>

    <a id="4295" href="Axiom.html#4295" class="Bound">∃[∈]-syntax</a> <a id="4307" class="Symbol">:</a> <a id="4309" class="Symbol">(</a><a id="4310" href="Axiom.html#4310" class="Bound">X</a> <a id="4312" class="Symbol">:</a> <a id="4314" href="Axiom.html#1616" class="Field">CSet</a><a id="4318" class="Symbol">)</a> <a id="4320" class="Symbol">(</a><a id="4321" href="Axiom.html#4321" class="Bound">P</a> <a id="4323" class="Symbol">:</a> <a id="4325" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4329" href="Axiom.html#4310" class="Bound">X</a> <a id="4331" class="Symbol">→</a> <a id="4333" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="4336" class="Symbol">)</a> <a id="4338" class="Symbol">→</a> <a id="4340" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4348" href="Axiom.html#4295" class="Bound">∃[∈]-syntax</a> <a id="4360" href="Axiom.html#4360" class="Bound">X</a> <a id="4362" href="Axiom.html#4362" class="Bound">P</a> <a id="4364" class="Symbol">=</a> <a id="4366" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4373" href="Axiom.html#4360" class="Bound">X</a><a id="4374" class="Symbol">)</a> <a id="4376" href="Axiom.html#4362" class="Bound">P</a>

    <a id="4383" class="Keyword">infix</a> <a id="4389" class="Number">3</a> <a id="4391" href="Axiom.html#4295" class="Function">∃[∈]-syntax</a>
    <a id="4407" class="Keyword">syntax</a> <a id="4414" href="Axiom.html#4295" class="Function">∃[∈]-syntax</a> <a id="4426" class="Bound">X</a> <a id="4428" class="Symbol">(λ</a> <a id="4431" class="Bound">x</a> <a id="4433" class="Symbol">→</a> <a id="4435" class="Bound">A</a><a id="4436" class="Symbol">)</a> <a id="4438" class="Symbol">=</a> <a id="4440" class="Function">∃[</a> <a id="4443" class="Bound">x</a> <a id="4445" class="Function">∈</a> <a id="4447" class="Bound">X</a> <a id="4449" class="Function">]</a> <a id="4451" class="Bound">A</a>
</pre>
<p><strong>注意</strong> <code>x ∈ X</code> 是一个声明而不是可以讨论真假的命题, 这一点与质料集合论 (ZFC等) 不同. 就像我们说「任意/存在集合 <code>X</code>, 怎么怎么样」一样, 这里不存在 「<code>X</code> 是不是集合」的问题, 我们也只能说「任意/存在元素 <code>x ∈ X</code>, 怎么怎么样」, 而不存在 「<code>x</code> 是不是 <code>X</code> 的元素」的问题.</p>
<p>给定函数 <code>f : X →̇ Y</code> 和一个元素 <code>x ∈ X</code>, 我们把复合函数 <code>f ∘ x</code> 记作 <code>f ⦅ x ⦆</code>.</p>
<pre class="Agda">    <a id="4700" class="Keyword">infix</a> <a id="4706" class="Number">15</a> <a id="4709" href="Axiom.html#4718" class="Function Operator">_⦅_⦆</a>
    <a id="4718" href="Axiom.html#4718" class="Bound Operator">_⦅_⦆</a> <a id="4723" class="Symbol">:</a> <a id="4725" class="Symbol">(</a><a id="4726" href="Axiom.html#4726" class="Bound">f</a> <a id="4728" class="Symbol">:</a> <a id="4730" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4732" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="4735" href="Axiom.html#2975" class="Generalizable">Y</a><a id="4736" class="Symbol">)</a> <a id="4738" class="Symbol">→</a> <a id="4740" href="Axiom.html#4126" class="Bound">∀[</a> <a id="4743" href="Axiom.html#4743" class="Bound">x</a> <a id="4745" href="Axiom.html#4126" class="Bound">∈</a> <a id="4747" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4749" href="Axiom.html#4126" class="Bound">]</a> <a id="4751" href="Axiom.html#4088" class="Bound">Elm</a> <a id="4755" href="Axiom.html#2975" class="Generalizable">Y</a>
    <a id="4761" href="Axiom.html#4761" class="Bound">f</a> <a id="4763" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4765" href="Axiom.html#4765" class="Bound">x</a> <a id="4767" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="4769" class="Symbol">=</a> <a id="4771" href="Axiom.html#4761" class="Bound">f</a> <a id="4773" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="4775" href="Axiom.html#4765" class="Bound">x</a>
</pre>
<p><strong>公理 3 (函数外延)</strong> 对任意集合 <code>X Y : CSet</code> 以及函数 <code>f g : X →̇ Y</code>, 如果对任意 <code>x ∈ X</code> 都有 <code>f ⦅ x ⦆ ≡ g ⦅ x ⦆</code>, 那么 <code>f ≡ g</code>.</p>
<pre class="Agda">    <a id="4901" class="Comment">-- Axiom 3</a>
    <a id="4916" class="Keyword">field</a> <a id="4922" href="Axiom.html#4922" class="Field">AxFunExt</a> <a id="4931" class="Symbol">:</a> <a id="4933" class="Symbol">(</a><a id="4934" href="Axiom.html#4126" class="Bound">∀[</a> <a id="4937" href="Axiom.html#4937" class="Bound">x</a> <a id="4939" href="Axiom.html#4126" class="Bound">∈</a> <a id="4941" href="Axiom.html#2973" class="Generalizable">X</a> <a id="4943" href="Axiom.html#4126" class="Bound">]</a> <a id="4945" href="Axiom.html#2996" class="Generalizable">f</a> <a id="4947" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4949" href="Axiom.html#4937" class="Bound">x</a> <a id="4951" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="4953" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4955" href="Axiom.html#2998" class="Generalizable">g</a> <a id="4957" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="4959" href="Axiom.html#4937" class="Bound">x</a> <a id="4961" href="Axiom.html#4718" class="Bound Operator">⦆</a><a id="4962" class="Symbol">)</a> <a id="4964" class="Symbol">→</a> <a id="4966" href="Axiom.html#2996" class="Generalizable">f</a> <a id="4968" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4970" href="Axiom.html#2998" class="Generalizable">g</a>
</pre>
<p><strong>定义 2.5.1</strong> 我们称一个集合 <code>X</code> 为空集, 当且仅当对任意 <code>x ∈ X</code> 都有 <code>⊥</code>.</p>
<pre class="Agda">    <a id="5044" class="Comment">-- Definition 2.5.1</a>
    <a id="5068" href="Axiom.html#5068" class="Bound">empty</a> <a id="5074" class="Symbol">:</a> <a id="5076" href="Axiom.html#1616" class="Field">CSet</a> <a id="5081" class="Symbol">→</a> <a id="5083" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5091" href="Axiom.html#5068" class="Bound">empty</a> <a id="5097" href="Axiom.html#5097" class="Bound">X</a> <a id="5099" class="Symbol">=</a> <a id="5101" href="Axiom.html#4126" class="Bound">∀[</a> <a id="5104" href="Axiom.html#5104" class="Bound">x</a> <a id="5106" href="Axiom.html#4126" class="Bound">∈</a> <a id="5108" href="Axiom.html#5097" class="Bound">X</a> <a id="5110" href="Axiom.html#4126" class="Bound">]</a> <a id="5112" href="Data.Empty.html#914" class="Function">⊥</a>
</pre>
<p><strong>公理 4 (空集)</strong> 存在一个空集.</p>
<pre class="Agda">    <a id="5154" class="Comment">-- Axiom 4</a>
    <a id="5169" class="Keyword">field</a> <a id="5175" href="Axiom.html#5175" class="Field">AxEmpty</a> <a id="5183" class="Symbol">:</a> <a id="5185" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="5187" href="Axiom.html#1616" class="Field">CSet</a> <a id="5192" href="Axiom.html#5068" class="Bound">empty</a>
</pre>
<p><strong>定义 2.6.2</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的积的泛性质.</p>
<p>第一步, 定义积图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>P</code></li>
<li>一个函数 <code>p : P →̇ X</code></li>
<li>一个函数 <code>q : P →̇ Y</code></li>
</ul>
<p>于是一个积图式具有如下形式</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-7e2a8ae22d3645250a1f82970ba78df1.png" alt="积图式" />
<figcaption aria-hidden="true">积图式</figcaption>
</figure>
<p>我们将这样的积图式简记作 <code>(P , p , q)</code>.</p>
<p>第二步, 定义积图式的交换: 我们说两个积图式 <code>(A , f , g)</code> 和 <code>(P , p , q)</code> 以及底集间映射 <code>h : A →̇ P</code> 交换, 当且仅当 <code>p ∘ h ≡ f</code> 且 <code>q ∘ h ≡ g</code>.</p>
<p>第三步, 定义积的泛性质: 我们说一个积图式 <code>(P , p , q)</code> 满足积的泛性质, 当且仅当对任意积图式 <code>(A , f , g)</code>, 存在唯一的底集间映射 <code>h : A →̇ P</code> 使得它们交换.</p>
<pre class="Agda">    <a id="5677" class="Comment">-- Definition 2.6.2</a>
    <a id="5701" href="Axiom.html#5701" class="Bound">Product</a> <a id="5709" class="Symbol">:</a> <a id="5711" class="Symbol">(</a><a id="5712" href="Axiom.html#5712" class="Bound">X</a> <a id="5714" href="Axiom.html#5714" class="Bound">Y</a> <a id="5716" class="Symbol">:</a> <a id="5718" href="Axiom.html#1616" class="Field">CSet</a><a id="5722" class="Symbol">)</a> <a id="5724" class="Symbol">→</a> <a id="5726" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="5736" href="Axiom.html#5701" class="Bound">Product</a> <a id="5744" href="Axiom.html#5744" class="Bound">X</a> <a id="5746" href="Axiom.html#5746" class="Bound">Y</a> <a id="5748" class="Symbol">=</a> <a id="5750" class="Symbol">λ</a> <a id="5752" href="Axiom.html#5752" class="Bound">P</a> <a id="5754" class="Symbol">→</a> <a id="5756" href="Axiom.html#5752" class="Bound">P</a> <a id="5758" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="5761" href="Axiom.html#5744" class="Bound">X</a> <a id="5763" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5765" href="Axiom.html#5752" class="Bound">P</a> <a id="5767" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="5770" href="Axiom.html#5746" class="Bound">Y</a>

    <a id="5777" href="Axiom.html#5777" class="Bound">ProductCommuter</a> <a id="5793" class="Symbol">:</a> <a id="5795" href="Axiom.html#2389" class="Function">Commuter</a> <a id="5804" class="Symbol">(</a><a id="5805" href="Axiom.html#5701" class="Bound">Product</a> <a id="5813" href="Axiom.html#2973" class="Generalizable">X</a> <a id="5815" href="Axiom.html#2975" class="Generalizable">Y</a><a id="5816" class="Symbol">)</a>
    <a id="5822" href="Axiom.html#5777" class="Bound">ProductCommuter</a> <a id="5838" class="Symbol">=</a> <a id="5840" class="Symbol">λ</a> <a id="5842" class="Symbol">(</a><a id="5843" href="Axiom.html#5843" class="Bound">A</a> <a id="5845" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5847" href="Axiom.html#5847" class="Bound">f</a> <a id="5849" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5851" href="Axiom.html#5851" class="Bound">g</a><a id="5852" class="Symbol">)</a> <a id="5854" class="Symbol">(</a><a id="5855" href="Axiom.html#5855" class="Bound">P</a> <a id="5857" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5859" href="Axiom.html#5859" class="Bound">p</a> <a id="5861" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5863" href="Axiom.html#5863" class="Bound">q</a><a id="5864" class="Symbol">)</a> <a id="5866" href="Axiom.html#5866" class="Bound">h</a> <a id="5868" class="Symbol">→</a> <a id="5870" href="Axiom.html#5859" class="Bound">p</a> <a id="5872" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="5874" href="Axiom.html#5866" class="Bound">h</a> <a id="5876" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5878" href="Axiom.html#5847" class="Bound">f</a> <a id="5880" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5882" href="Axiom.html#5863" class="Bound">q</a> <a id="5884" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="5886" href="Axiom.html#5866" class="Bound">h</a> <a id="5888" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5890" href="Axiom.html#5851" class="Bound">g</a>

    <a id="5897" href="Axiom.html#5897" class="Bound">isProduct</a> <a id="5907" class="Symbol">:</a> <a id="5909" href="Axiom.html#2144" class="Function">Diagram</a> <a id="5917" class="Symbol">(</a><a id="5918" href="Axiom.html#5701" class="Bound">Product</a> <a id="5926" href="Axiom.html#2973" class="Generalizable">X</a> <a id="5928" href="Axiom.html#2975" class="Generalizable">Y</a><a id="5929" class="Symbol">)</a> <a id="5931" class="Symbol">→</a> <a id="5933" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="5941" href="Axiom.html#5897" class="Bound">isProduct</a> <a id="5951" class="Symbol">=</a> <a id="5953" href="Axiom.html#2709" class="Function">universal</a> <a id="5963" href="Axiom.html#5777" class="Bound">ProductCommuter</a>
</pre>
<p><strong>公理 5 (积)</strong> 对任意集合 <code>X Y : CSet</code>, 存在积图式满足积的泛性质.</p>
<pre class="Agda">    <a id="6044" class="Comment">-- Axiom 5</a>
    <a id="6059" class="Keyword">field</a> <a id="6065" href="Axiom.html#6065" class="Field">AxProd</a> <a id="6072" class="Symbol">:</a> <a id="6074" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="6076" class="Symbol">(</a><a id="6077" href="Axiom.html#2144" class="Function">Diagram</a> <a id="6085" class="Symbol">(</a><a id="6086" href="Axiom.html#5701" class="Bound">Product</a> <a id="6094" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6096" href="Axiom.html#2975" class="Generalizable">Y</a><a id="6097" class="Symbol">))</a> <a id="6100" href="Axiom.html#5897" class="Bound">isProduct</a>
</pre>
<p>给定集合 <code>X Y : CSet</code>, 我们把公理5所承诺的积图式的底集称为 <code>X</code> 和 <code>Y</code> 的积, 记作 <code>X ×̇ Y</code>.</p>
<pre class="Agda">    <a id="6193" class="Keyword">infixr</a> <a id="6200" class="Number">15</a> <a id="6203" href="Axiom.html#6212" class="Function Operator">_×̇_</a>
    <a id="6212" href="Axiom.html#6212" class="Bound Operator">_×̇_</a> <a id="6217" class="Symbol">:</a> <a id="6219" href="Axiom.html#1616" class="Field">CSet</a> <a id="6224" class="Symbol">→</a> <a id="6226" href="Axiom.html#1616" class="Field">CSet</a> <a id="6231" class="Symbol">→</a> <a id="6233" href="Axiom.html#1616" class="Field">CSet</a>
    <a id="6242" href="Axiom.html#6242" class="Bound">X</a> <a id="6244" href="Axiom.html#6212" class="Bound Operator">×̇</a> <a id="6247" href="Axiom.html#6247" class="Bound">Y</a> <a id="6249" class="Symbol">=</a> <a id="6251" href="Axiom.html#6065" class="Field">AxProd</a> <a id="6258" class="Symbol">{</a><a id="6259" href="Axiom.html#6242" class="Bound">X</a><a id="6260" class="Symbol">}</a> <a id="6262" class="Symbol">{</a><a id="6263" href="Axiom.html#6247" class="Bound">Y</a><a id="6264" class="Symbol">}</a> <a id="6266" class="Symbol">.</a><a id="6267" href="Axiom.html#903" class="Field">fst</a> <a id="6271" class="Symbol">.</a><a id="6272" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p>给定集合 <code>X Y A : CSet</code> 和函数 <code>f : A →̇ X</code> <code>g : A →̇ Y</code>, 公理5承诺了积图示 <code>(A , f , g)</code> 到积图示 <code>(X ×̇ Y , p , q)</code> 的底集间唯一映射, 我们记作 <code>f ,̇ g : A →̇ X ×̇ Y</code>. 如下图所示, 其中虚线表示唯一. 特别地, 当 <code>A ≡ １</code> 时, <code>f</code> 是 <code>X</code> 的元素, <code>g</code> 是 <code>Y</code> 的元素, <code>f ,̇ g</code> 是 <code>X ×̇ Y</code> 的元素.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2cfcd05207f77e2d965658d158731767.png" alt="积的元素" />
<figcaption aria-hidden="true">积的元素</figcaption>
</figure>
<pre class="Agda">    <a id="6598" class="Keyword">infixr</a> <a id="6605" class="Number">5</a> <a id="6607" href="Axiom.html#6616" class="Function Operator">_,̇_</a>
    <a id="6616" href="Axiom.html#6616" class="Bound Operator">_,̇_</a> <a id="6621" class="Symbol">:</a> <a id="6623" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6625" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6628" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6630" class="Symbol">→</a> <a id="6632" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6634" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6637" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="6639" class="Symbol">→</a> <a id="6641" href="Axiom.html#2969" class="Generalizable">A</a> <a id="6643" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="6646" href="Axiom.html#2973" class="Generalizable">X</a> <a id="6648" href="Axiom.html#6212" class="Bound Operator">×̇</a> <a id="6651" href="Axiom.html#2975" class="Generalizable">Y</a>
    <a id="6657" href="Axiom.html#6657" class="Bound">f</a> <a id="6659" href="Axiom.html#6616" class="Bound Operator">,̇</a> <a id="6662" href="Axiom.html#6662" class="Bound">g</a> <a id="6664" class="Symbol">=</a> <a id="6666" href="Axiom.html#6065" class="Field">AxProd</a> <a id="6673" class="Symbol">.</a><a id="6674" href="Axiom.html#917" class="Field">snd</a> <a id="6678" class="Symbol">(_</a> <a id="6681" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6683" href="Axiom.html#6657" class="Bound">f</a> <a id="6685" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6687" href="Axiom.html#6662" class="Bound">g</a><a id="6688" class="Symbol">)</a> <a id="6690" class="Symbol">.</a><a id="6691" href="Axiom.html#903" class="Field">fst</a> <a id="6695" class="Symbol">.</a><a id="6696" href="Axiom.html#903" class="Field">fst</a>
</pre>
<p><strong>定义 2.7.3</strong> 给定集合 <code>X Y : CSet</code>, 我们按以下三步定义它们的函数集 (简称幂) 的泛性质.</p>
<p>第一步, 定义幂图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>F</code></li>
<li>一个函数 <code>e : F ×̇ X →̇ Y</code></li>
</ul>
<p>简记作 <code>(F , e)</code>.</p>
<p>第二步, 定义幂图式的交换: 我们说两个幂图式 <code>(A , q)</code> 和 <code>(F , e)</code> 以及底集间映射 <code>q̅ : A →̇ F</code> 交换, 当且仅当对任意 <code>a ∈ A</code> 和 <code>x ∈ X</code> 都有 <code>q ⦅ a ,̇ x ⦆ ≡ e ⦅ q̅ ⦅ a ⦆ ,̇ x ⦆</code>.</p>
<p>第三步, 定义幂的泛性质: 我们说一个幂图式 <code>(F , e)</code> 满足幂的泛性质, 当且仅当对任意幂图式 <code>(A , q)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ F</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-2874a6ccdc996e99f8027e4b11e2383d.png" alt="幂的泛性质" />
<figcaption aria-hidden="true">幂的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="7168" class="Comment">-- Definition 2.7.3</a>
    <a id="7192" href="Axiom.html#7192" class="Bound">FuncSet</a> <a id="7200" class="Symbol">:</a> <a id="7202" class="Symbol">(</a><a id="7203" href="Axiom.html#7203" class="Bound">X</a> <a id="7205" href="Axiom.html#7205" class="Bound">Y</a> <a id="7207" class="Symbol">:</a> <a id="7209" href="Axiom.html#1616" class="Field">CSet</a><a id="7213" class="Symbol">)</a> <a id="7215" class="Symbol">→</a> <a id="7217" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="7227" href="Axiom.html#7192" class="Bound">FuncSet</a> <a id="7235" href="Axiom.html#7235" class="Bound">X</a> <a id="7237" href="Axiom.html#7237" class="Bound">Y</a> <a id="7239" class="Symbol">=</a> <a id="7241" class="Symbol">λ</a> <a id="7243" href="Axiom.html#7243" class="Bound">F</a> <a id="7245" class="Symbol">→</a> <a id="7247" href="Axiom.html#7243" class="Bound">F</a> <a id="7249" href="Axiom.html#6212" class="Bound Operator">×̇</a> <a id="7252" href="Axiom.html#7235" class="Bound">X</a> <a id="7254" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="7257" href="Axiom.html#7237" class="Bound">Y</a>

    <a id="7264" href="Axiom.html#7264" class="Bound">FuncSetCommuter</a> <a id="7280" class="Symbol">:</a> <a id="7282" href="Axiom.html#2389" class="Function">Commuter</a> <a id="7291" class="Symbol">(</a><a id="7292" href="Axiom.html#7192" class="Bound">FuncSet</a> <a id="7300" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7302" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7303" class="Symbol">)</a>
    <a id="7309" href="Axiom.html#7264" class="Bound">FuncSetCommuter</a> <a id="7325" class="Symbol">{</a><a id="7326" href="Axiom.html#7326" class="Bound">X</a><a id="7327" class="Symbol">}</a> <a id="7329" class="Symbol">=</a> <a id="7331" class="Symbol">λ</a> <a id="7333" class="Symbol">(</a><a id="7334" href="Axiom.html#7334" class="Bound">A</a> <a id="7336" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7338" href="Axiom.html#7338" class="Bound">q</a><a id="7339" class="Symbol">)</a> <a id="7341" class="Symbol">(</a><a id="7342" href="Axiom.html#7342" class="Bound">F</a> <a id="7344" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7346" href="Axiom.html#7346" class="Bound">e</a><a id="7347" class="Symbol">)</a> <a id="7349" href="Axiom.html#7349" class="Bound">q̅</a> <a id="7352" class="Symbol">→</a>
      <a id="7360" href="Axiom.html#4126" class="Bound">∀[</a> <a id="7363" href="Axiom.html#7363" class="Bound">a</a> <a id="7365" href="Axiom.html#4126" class="Bound">∈</a> <a id="7367" href="Axiom.html#7334" class="Bound">A</a> <a id="7369" href="Axiom.html#4126" class="Bound">]</a> <a id="7371" href="Axiom.html#4126" class="Bound">∀[</a> <a id="7374" href="Axiom.html#7374" class="Bound">x</a> <a id="7376" href="Axiom.html#4126" class="Bound">∈</a> <a id="7378" href="Axiom.html#7326" class="Bound">X</a> <a id="7380" href="Axiom.html#4126" class="Bound">]</a> <a id="7382" href="Axiom.html#7338" class="Bound">q</a> <a id="7384" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7386" href="Axiom.html#7363" class="Bound">a</a> <a id="7388" href="Axiom.html#6616" class="Bound Operator">,̇</a> <a id="7391" href="Axiom.html#7374" class="Bound">x</a> <a id="7393" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="7395" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="7397" href="Axiom.html#7346" class="Bound">e</a> <a id="7399" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7401" href="Axiom.html#7349" class="Bound">q̅</a> <a id="7404" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="7406" href="Axiom.html#7363" class="Bound">a</a> <a id="7408" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="7410" href="Axiom.html#6616" class="Bound Operator">,̇</a> <a id="7413" href="Axiom.html#7374" class="Bound">x</a> <a id="7415" href="Axiom.html#4718" class="Bound Operator">⦆</a>

    <a id="7422" href="Axiom.html#7422" class="Bound">isFuncSet</a> <a id="7432" class="Symbol">:</a> <a id="7434" href="Axiom.html#2144" class="Function">Diagram</a> <a id="7442" class="Symbol">(</a><a id="7443" href="Axiom.html#7192" class="Bound">FuncSet</a> <a id="7451" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7453" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7454" class="Symbol">)</a> <a id="7456" class="Symbol">→</a> <a id="7458" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="7466" href="Axiom.html#7422" class="Bound">isFuncSet</a> <a id="7476" class="Symbol">=</a> <a id="7478" href="Axiom.html#2709" class="Function">universal</a> <a id="7488" href="Axiom.html#7264" class="Bound">FuncSetCommuter</a>
</pre>
<p><strong>公理 6 (幂)</strong> 对任意集合 <code>X Y : CSet</code>, 存在幂图式满足幂的泛性质.</p>
<pre class="Agda">    <a id="7569" class="Comment">-- Axiom 6</a>
    <a id="7584" class="Keyword">field</a> <a id="7590" href="Axiom.html#7590" class="Field">AxFuncSet</a> <a id="7600" class="Symbol">:</a> <a id="7602" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="7604" class="Symbol">(</a><a id="7605" href="Axiom.html#2144" class="Function">Diagram</a> <a id="7613" class="Symbol">(</a><a id="7614" href="Axiom.html#7192" class="Bound">FuncSet</a> <a id="7622" href="Axiom.html#2973" class="Generalizable">X</a> <a id="7624" href="Axiom.html#2975" class="Generalizable">Y</a><a id="7625" class="Symbol">))</a> <a id="7628" href="Axiom.html#7422" class="Bound">isFuncSet</a>
</pre>
<p><strong>定义 3.1.4</strong> 给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 我们按以下四步定义关于 <code>f</code> 和 <code>y</code> 的纤维的泛性质.</p>
<p>第零步, 定义什么叫纤维: 我们说一个集合 <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维, 记作 <code>U withInclusion i isFibreOf f over y</code>, 当且仅当对任意 <code>u ∈ U</code> 都有 <code>f ⦅ i ⦅ u ⦆ ⦆ ≡ y</code>, 也就是下图交换. 由于这样的 <code>U</code> 一般又记作 <span class="math inline">f^{-1}(y)</span>, 图中用此记法.</p>
<p>第一步, 定义纤维图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>U</code></li>
<li>一个函数 <code>i : U →̇ X</code></li>
<li>一个证明: <code>U</code> 配合上一个包含函数 <code>i : U →̇ X</code> 是 <code>f</code> 在 <code>y</code> 上的纤维</li>
</ul>
<p>简记作 <code>(U , i , fiu)</code>.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-bcacd8638c0c142fb4422fe291b632f7.png" alt="纤维图式" />
<figcaption aria-hidden="true">纤维图式</figcaption>
</figure>
<p>第二步, 定义纤维图式的交换: 我们说两个纤维图式 <code>(A , q , fqa)</code> 和 <code>(U , i , fiu)</code> 以及底集间映射 <code>q̅ : A →̇ U</code> 交换, 当且仅当 <code>q ≡ i ∘ q̅</code>.</p>
<p>第三步, 定义纤维的泛性质: 我们说一个纤维图式 <code>(U , i , fiu)</code> 满足纤维的泛性质, 当且仅当对任意纤维图式 <code>(A , q , fqa)</code>, 存在唯一的底集间映射 <code>q̅ : A →̇ U</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-0f5d1b447ca9b15abfd4df13ad044223.png" alt="纤维的泛性质" />
<figcaption aria-hidden="true">纤维的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="8431" class="Comment">-- Definition 3.1.4</a>
    <a id="8455" href="Axiom.html#8455" class="Bound Operator">_withInclusion_isFibreOf_over_</a> <a id="8486" class="Symbol">:</a> <a id="8488" class="Symbol">(</a><a id="8489" href="Axiom.html#8489" class="Bound">U</a> <a id="8491" class="Symbol">:</a> <a id="8493" href="Axiom.html#1616" class="Field">CSet</a><a id="8497" class="Symbol">)</a> <a id="8499" class="Symbol">(</a><a id="8500" href="Axiom.html#8500" class="Bound">i</a> <a id="8502" class="Symbol">:</a> <a id="8504" href="Axiom.html#8489" class="Bound">U</a> <a id="8506" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8509" href="Axiom.html#2973" class="Generalizable">X</a><a id="8510" class="Symbol">)</a> <a id="8512" class="Symbol">(</a><a id="8513" href="Axiom.html#8513" class="Bound">f</a> <a id="8515" class="Symbol">:</a> <a id="8517" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8519" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8522" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8523" class="Symbol">)</a> <a id="8525" class="Symbol">(</a><a id="8526" href="Axiom.html#8526" class="Bound">y</a> <a id="8528" class="Symbol">:</a> <a id="8530" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8534" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8535" class="Symbol">)</a> <a id="8537" class="Symbol">→</a> <a id="8539" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8547" href="Axiom.html#8547" class="Bound">U</a> <a id="8549" href="Axiom.html#8455" class="Bound Operator">withInclusion</a> <a id="8563" href="Axiom.html#8563" class="Bound">i</a> <a id="8565" href="Axiom.html#8455" class="Bound Operator">isFibreOf</a> <a id="8575" href="Axiom.html#8575" class="Bound">f</a> <a id="8577" href="Axiom.html#8455" class="Bound Operator">over</a> <a id="8582" href="Axiom.html#8582" class="Bound">y</a> <a id="8584" class="Symbol">=</a> <a id="8586" href="Axiom.html#4126" class="Bound">∀[</a> <a id="8589" href="Axiom.html#8589" class="Bound">u</a> <a id="8591" href="Axiom.html#4126" class="Bound">∈</a> <a id="8593" class="Symbol">_</a> <a id="8595" href="Axiom.html#4126" class="Bound">]</a> <a id="8597" href="Axiom.html#8575" class="Bound">f</a> <a id="8599" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="8601" href="Axiom.html#8563" class="Bound">i</a> <a id="8603" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="8605" href="Axiom.html#8589" class="Bound">u</a> <a id="8607" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="8609" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="8611" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8613" href="Axiom.html#8582" class="Bound">y</a>

    <a id="8620" href="Axiom.html#8620" class="Bound">Fibre</a> <a id="8626" class="Symbol">:</a> <a id="8628" class="Symbol">(</a><a id="8629" href="Axiom.html#8629" class="Bound">f</a> <a id="8631" class="Symbol">:</a> <a id="8633" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8635" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8638" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8639" class="Symbol">)</a> <a id="8641" class="Symbol">(</a><a id="8642" href="Axiom.html#8642" class="Bound">y</a> <a id="8644" class="Symbol">:</a> <a id="8646" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8650" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8651" class="Symbol">)</a> <a id="8653" class="Symbol">→</a> <a id="8655" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="8665" href="Axiom.html#8620" class="Bound">Fibre</a> <a id="8671" class="Symbol">{</a><a id="8672" href="Axiom.html#8672" class="Bound">X</a><a id="8673" class="Symbol">}</a> <a id="8675" href="Axiom.html#8675" class="Bound">f</a> <a id="8677" href="Axiom.html#8677" class="Bound">y</a> <a id="8679" class="Symbol">=</a> <a id="8681" class="Symbol">λ</a> <a id="8683" href="Axiom.html#8683" class="Bound">U</a> <a id="8685" class="Symbol">→</a> <a id="8687" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="8689" class="Symbol">(</a><a id="8690" href="Axiom.html#8683" class="Bound">U</a> <a id="8692" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8695" href="Axiom.html#8672" class="Bound">X</a><a id="8696" class="Symbol">)</a> <a id="8698" class="Symbol">λ</a> <a id="8700" href="Axiom.html#8700" class="Bound">i</a> <a id="8702" class="Symbol">→</a> <a id="8704" href="Axiom.html#8683" class="Bound">U</a> <a id="8706" href="Axiom.html#8455" class="Bound Operator">withInclusion</a> <a id="8720" href="Axiom.html#8700" class="Bound">i</a> <a id="8722" href="Axiom.html#8455" class="Bound Operator">isFibreOf</a> <a id="8732" href="Axiom.html#8675" class="Bound">f</a> <a id="8734" href="Axiom.html#8455" class="Bound Operator">over</a> <a id="8739" href="Axiom.html#8677" class="Bound">y</a>

    <a id="8746" href="Axiom.html#8746" class="Bound">FibreCommuter</a> <a id="8760" class="Symbol">:</a> <a id="8762" class="Symbol">{</a><a id="8763" href="Axiom.html#8763" class="Bound">f</a> <a id="8765" class="Symbol">:</a> <a id="8767" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8769" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8772" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8773" class="Symbol">}</a> <a id="8775" class="Symbol">{</a><a id="8776" href="Axiom.html#8776" class="Bound">y</a> <a id="8778" class="Symbol">:</a> <a id="8780" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8784" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8785" class="Symbol">}</a> <a id="8787" class="Symbol">→</a> <a id="8789" href="Axiom.html#2389" class="Function">Commuter</a> <a id="8798" class="Symbol">(</a><a id="8799" href="Axiom.html#8620" class="Bound">Fibre</a> <a id="8805" href="Axiom.html#8763" class="Bound">f</a> <a id="8807" href="Axiom.html#8776" class="Bound">y</a><a id="8808" class="Symbol">)</a>
    <a id="8814" href="Axiom.html#8746" class="Bound">FibreCommuter</a> <a id="8828" class="Symbol">=</a> <a id="8830" class="Symbol">λ</a> <a id="8832" class="Symbol">(</a><a id="8833" href="Axiom.html#8833" class="Bound">A</a> <a id="8835" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8837" href="Axiom.html#8837" class="Bound">q</a> <a id="8839" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8841" href="Axiom.html#8841" class="Bound">fqa</a><a id="8844" class="Symbol">)</a> <a id="8846" class="Symbol">(</a><a id="8847" href="Axiom.html#8847" class="Bound">U</a> <a id="8849" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8851" href="Axiom.html#8851" class="Bound">i</a> <a id="8853" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8855" href="Axiom.html#8855" class="Bound">fiu</a><a id="8858" class="Symbol">)</a> <a id="8860" href="Axiom.html#8860" class="Bound">q̅</a> <a id="8863" class="Symbol">→</a> <a id="8865" href="Axiom.html#8837" class="Bound">q</a> <a id="8867" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8869" href="Axiom.html#8851" class="Bound">i</a> <a id="8871" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="8873" href="Axiom.html#8860" class="Bound">q̅</a>

    <a id="8881" href="Axiom.html#8881" class="Bound">isFibre</a> <a id="8889" class="Symbol">:</a> <a id="8891" class="Symbol">{</a><a id="8892" href="Axiom.html#8892" class="Bound">f</a> <a id="8894" class="Symbol">:</a> <a id="8896" href="Axiom.html#2973" class="Generalizable">X</a> <a id="8898" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="8901" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8902" class="Symbol">}</a> <a id="8904" class="Symbol">{</a><a id="8905" href="Axiom.html#8905" class="Bound">y</a> <a id="8907" class="Symbol">:</a> <a id="8909" href="Axiom.html#4088" class="Bound">Elm</a> <a id="8913" href="Axiom.html#2975" class="Generalizable">Y</a><a id="8914" class="Symbol">}</a> <a id="8916" class="Symbol">→</a> <a id="8918" href="Axiom.html#2144" class="Function">Diagram</a> <a id="8926" class="Symbol">(</a><a id="8927" href="Axiom.html#8620" class="Bound">Fibre</a> <a id="8933" href="Axiom.html#8892" class="Bound">f</a> <a id="8935" href="Axiom.html#8905" class="Bound">y</a><a id="8936" class="Symbol">)</a> <a id="8938" class="Symbol">→</a> <a id="8940" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="8948" href="Axiom.html#8881" class="Bound">isFibre</a> <a id="8956" class="Symbol">=</a> <a id="8958" href="Axiom.html#2709" class="Function">universal</a> <a id="8968" href="Axiom.html#8746" class="Bound">FibreCommuter</a>
</pre>
<p><strong>公理 7 (纤维)</strong> 对任意 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在纤维图式满足纤维的泛性质.</p>
<pre class="Agda">    <a id="9060" class="Comment">-- Axiom 7</a>
    <a id="9075" class="Keyword">field</a> <a id="9081" href="Axiom.html#9081" class="Field">AxFibre</a> <a id="9089" class="Symbol">:</a> <a id="9091" class="Symbol">{</a><a id="9092" href="Axiom.html#9092" class="Bound">f</a> <a id="9094" class="Symbol">:</a> <a id="9096" href="Axiom.html#2973" class="Generalizable">X</a> <a id="9098" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="9101" href="Axiom.html#2975" class="Generalizable">Y</a><a id="9102" class="Symbol">}</a> <a id="9104" class="Symbol">{</a><a id="9105" href="Axiom.html#9105" class="Bound">y</a> <a id="9107" class="Symbol">:</a> <a id="9109" href="Axiom.html#4088" class="Bound">Elm</a> <a id="9113" href="Axiom.html#2975" class="Generalizable">Y</a><a id="9114" class="Symbol">}</a> <a id="9116" class="Symbol">→</a> <a id="9118" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9120" class="Symbol">(</a><a id="9121" href="Axiom.html#2144" class="Function">Diagram</a> <a id="9129" class="Symbol">(</a><a id="9130" href="Axiom.html#8620" class="Bound">Fibre</a> <a id="9136" href="Axiom.html#9092" class="Bound">f</a> <a id="9138" href="Axiom.html#9105" class="Bound">y</a><a id="9139" class="Symbol">))</a> <a id="9142" href="Axiom.html#8881" class="Bound">isFibre</a>
</pre>
<p><strong>定义 3.2.1</strong> 我们按以下三步定义子集分类器的泛性质.</p>
<p>第一步, 我们定义子集分类器图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>Ω</code></li>
<li>一个集合 <code>T</code></li>
<li>一个函数 <code>t : T →̇ Ω</code></li>
</ul>
<p>简记作 <code>(Ω , T , t)</code>.</p>
<p>第二步, 定义子集分类器图式的交换: 我们说两个子集分类器图式 <code>(A , X , i)</code> 和 <code>(Ω , T , t)</code> 以及底集间映射 <code>χ : A →̇ Ω</code> 交换, 当且仅当如果 <code>T ≡ １</code>, 那么 <code>X</code> 配合上 <code>i</code> 是 <code>χ</code> 在 <code>t</code> 上的纤维.</p>
<p>第三步, 定义子集分类器的泛性质: 我们说一个子集分类器图式 <code>(Ω , T , t)</code> 满足子集分类器的泛性质, 当且仅当对任意子集分类器图式 <code>(A , X , i)</code>, 存在唯一的底集间映射 <code>χ : A →̇ Ω</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-f1f7a1eec3df674886ffa5161566c82b.png" alt="子集分类器的泛性质" />
<figcaption aria-hidden="true">子集分类器的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="9631" class="Comment">-- Definition 3.2.1</a>
    <a id="9655" href="Axiom.html#9655" class="Bound">SubCls</a> <a id="9662" class="Symbol">:</a> <a id="9664" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="9674" href="Axiom.html#9655" class="Bound">SubCls</a> <a id="9681" class="Symbol">=</a> <a id="9683" class="Symbol">λ</a> <a id="9685" href="Axiom.html#9685" class="Bound">Ω</a> <a id="9687" class="Symbol">→</a> <a id="9689" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="9691" href="Axiom.html#1616" class="Field">CSet</a> <a id="9696" class="Symbol">λ</a> <a id="9698" href="Axiom.html#9698" class="Bound">T</a> <a id="9700" class="Symbol">→</a> <a id="9702" href="Axiom.html#9698" class="Bound">T</a> <a id="9704" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="9707" href="Axiom.html#9685" class="Bound">Ω</a>

    <a id="9714" href="Axiom.html#9714" class="Bound">SubClsCommuter</a> <a id="9729" class="Symbol">:</a> <a id="9731" href="Axiom.html#2389" class="Function">Commuter</a> <a id="9740" href="Axiom.html#9655" class="Bound">SubCls</a>
    <a id="9751" href="Axiom.html#9714" class="Bound">SubClsCommuter</a> <a id="9766" class="Symbol">=</a> <a id="9768" class="Symbol">λ</a> <a id="9770" class="Symbol">(</a><a id="9771" href="Axiom.html#9771" class="Bound">A</a> <a id="9773" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9775" href="Axiom.html#9775" class="Bound">X</a> <a id="9777" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9779" href="Axiom.html#9779" class="Bound">i</a><a id="9780" class="Symbol">)</a> <a id="9782" class="Symbol">(</a><a id="9783" href="Axiom.html#9783" class="Bound">Ω</a> <a id="9785" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9787" href="Axiom.html#9787" class="Bound">T</a> <a id="9789" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9791" href="Axiom.html#9791" class="Bound">t</a><a id="9792" class="Symbol">)</a> <a id="9794" href="Axiom.html#9794" class="Bound">χ</a> <a id="9796" class="Symbol">→</a> <a id="9798" class="Symbol">(</a><a id="9799" href="Axiom.html#9799" class="Bound">eq</a> <a id="9802" class="Symbol">:</a> <a id="9804" href="Axiom.html#9787" class="Bound">T</a> <a id="9806" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9808" href="Axiom.html#3917" class="Bound">１</a><a id="9809" class="Symbol">)</a> <a id="9811" class="Symbol">→</a>
      <a id="9819" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="9824" href="Axiom.html#9799" class="Bound">eq</a> <a id="9827" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="9830" class="Symbol">λ</a> <a id="9832" class="Symbol">{</a> <a id="9834" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="9839" class="Symbol">→</a> <a id="9841" href="Axiom.html#9775" class="Bound">X</a> <a id="9843" href="Axiom.html#8455" class="Bound Operator">withInclusion</a> <a id="9857" href="Axiom.html#9779" class="Bound">i</a> <a id="9859" href="Axiom.html#8455" class="Bound Operator">isFibreOf</a> <a id="9869" href="Axiom.html#9794" class="Bound">χ</a> <a id="9871" href="Axiom.html#8455" class="Bound Operator">over</a> <a id="9876" href="Axiom.html#9791" class="Bound">t</a> <a id="9878" class="Symbol">}</a>

    <a id="9885" href="Axiom.html#9885" class="Bound">isSubCls</a> <a id="9894" class="Symbol">:</a> <a id="9896" href="Axiom.html#2144" class="Function">Diagram</a> <a id="9904" href="Axiom.html#9655" class="Bound">SubCls</a> <a id="9911" class="Symbol">→</a> <a id="9913" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="9921" href="Axiom.html#9885" class="Bound">isSubCls</a> <a id="9930" class="Symbol">=</a> <a id="9932" href="Axiom.html#2709" class="Function">universal</a> <a id="9942" href="Axiom.html#9714" class="Bound">SubClsCommuter</a>
</pre>
<p><strong>公理 8 (子集)</strong> 存在一个子集分类器图式 <code>(Ω , １ , t)</code> 满足子集分类器的泛性质.</p>
<pre class="Agda">    <a id="10028" class="Comment">-- Axiom 8</a>
    <a id="10043" class="Keyword">field</a> <a id="10049" href="Axiom.html#10049" class="Field">AxSubCls</a> <a id="10058" class="Symbol">:</a> <a id="10060" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10062" class="Symbol">(</a><a id="10063" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10071" href="Axiom.html#9655" class="Bound">SubCls</a><a id="10077" class="Symbol">)</a> <a id="10079" class="Symbol">λ</a> <a id="10081" href="Axiom.html#10081" class="Bound">d</a><a id="10082" class="Symbol">@(_</a> <a id="10086" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10088" href="Axiom.html#10088" class="Bound">T</a> <a id="10090" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10092" class="Symbol">_)</a> <a id="10095" class="Symbol">→</a> <a id="10097" href="Axiom.html#10088" class="Bound">T</a> <a id="10099" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10101" href="Axiom.html#3917" class="Bound">１</a> <a id="10103" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10105" href="Axiom.html#9885" class="Bound">isSubCls</a> <a id="10114" href="Axiom.html#10081" class="Bound">d</a>
</pre>
<p><strong>定义 3.3.2</strong> 我们按以下三步定义自然数集的泛性质.</p>
<p>第一步, 定义自然数图式, 它包含如下资料:</p>
<ul>
<li>一个集合 <code>N</code></li>
<li>一个元素 <code>z ∈ N</code></li>
<li>一个函数 <code>σ : N →̇ N</code></li>
</ul>
<p>第二步, 定义自然数图式的交换: 我们说两个自然数图式 <code>(N , z , σ)</code> 和 <code>(X , a , r)</code> 以及底集间映射 <code>x : N →̇ X</code> 交换, 当且仅当对任意 <code>n ∈ N</code> 都有 <code>x ⦅ z ⦆ ≡ a</code> 且 <code>x ⦅ σ ⦅ n ⦆ ⦆ ≡ r ⦅ x ⦅ n ⦆ ⦆</code>.</p>
<p>第三步, 定义自然数的泛性质: 我们说一个自然数图式 <code>(N , z , σ)</code> 满足自然数的泛性质, 当且仅当对任意自然数图式 <code>(X , a , r)</code>, 存在唯一的底集间映射 <code>x : N →̇ X</code> 使得它们交换.</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-a643f6546c3ea362bb62336c01d46535.png" alt="自然数的泛性质" />
<figcaption aria-hidden="true">自然数的泛性质</figcaption>
</figure>
<pre class="Agda">    <a id="10581" class="Comment">-- Definition 3.3.2</a>
    <a id="10605" href="Axiom.html#10605" class="Bound">Nat</a> <a id="10609" class="Symbol">:</a> <a id="10611" href="Axiom.html#1960" class="Function">Arrow</a>
    <a id="10621" href="Axiom.html#10605" class="Bound">Nat</a> <a id="10625" class="Symbol">=</a> <a id="10627" class="Symbol">λ</a> <a id="10629" href="Axiom.html#10629" class="Bound">N</a> <a id="10631" class="Symbol">→</a> <a id="10633" href="Axiom.html#4088" class="Bound">Elm</a> <a id="10637" href="Axiom.html#10629" class="Bound">N</a> <a id="10639" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10641" href="Axiom.html#10629" class="Bound">N</a> <a id="10643" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="10646" href="Axiom.html#10629" class="Bound">N</a>

    <a id="10653" href="Axiom.html#10653" class="Bound">NatCommuter</a> <a id="10665" class="Symbol">:</a> <a id="10667" href="Axiom.html#2389" class="Function">Commuter</a> <a id="10676" href="Axiom.html#10605" class="Bound">Nat</a>
    <a id="10684" href="Axiom.html#10653" class="Bound">NatCommuter</a> <a id="10696" class="Symbol">=</a> <a id="10698" class="Symbol">λ</a> <a id="10700" class="Symbol">(</a><a id="10701" href="Axiom.html#10701" class="Bound">N</a> <a id="10703" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10705" href="Axiom.html#10705" class="Bound">z</a> <a id="10707" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10709" href="Axiom.html#10709" class="Bound">σ</a><a id="10710" class="Symbol">)</a> <a id="10712" class="Symbol">(</a><a id="10713" href="Axiom.html#10713" class="Bound">X</a> <a id="10715" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10717" href="Axiom.html#10717" class="Bound">a</a> <a id="10719" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10721" href="Axiom.html#10721" class="Bound">r</a><a id="10722" class="Symbol">)</a> <a id="10724" href="Axiom.html#10724" class="Bound">x</a> <a id="10726" class="Symbol">→</a>
      <a id="10734" href="Axiom.html#4126" class="Bound">∀[</a> <a id="10737" href="Axiom.html#10737" class="Bound">n</a> <a id="10739" href="Axiom.html#4126" class="Bound">∈</a> <a id="10741" href="Axiom.html#10701" class="Bound">N</a> <a id="10743" href="Axiom.html#4126" class="Bound">]</a> <a id="10745" class="Symbol">(</a><a id="10746" href="Axiom.html#10724" class="Bound">x</a> <a id="10748" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10750" href="Axiom.html#10705" class="Bound">z</a> <a id="10752" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10754" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10756" href="Axiom.html#10717" class="Bound">a</a> <a id="10758" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="10760" href="Axiom.html#10724" class="Bound">x</a> <a id="10762" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10764" href="Axiom.html#10709" class="Bound">σ</a> <a id="10766" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10768" href="Axiom.html#10737" class="Bound">n</a> <a id="10770" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10772" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10774" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10776" href="Axiom.html#10721" class="Bound">r</a> <a id="10778" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10780" href="Axiom.html#10724" class="Bound">x</a> <a id="10782" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="10784" href="Axiom.html#10737" class="Bound">n</a> <a id="10786" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="10788" href="Axiom.html#4718" class="Bound Operator">⦆</a><a id="10789" class="Symbol">)</a>

    <a id="10796" href="Axiom.html#10796" class="Bound">isNat</a> <a id="10802" class="Symbol">:</a> <a id="10804" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10812" href="Axiom.html#10605" class="Bound">Nat</a> <a id="10816" class="Symbol">→</a> <a id="10818" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="10826" href="Axiom.html#10796" class="Bound">isNat</a> <a id="10832" class="Symbol">=</a> <a id="10834" href="Axiom.html#2709" class="Function">universal</a> <a id="10844" href="Axiom.html#10653" class="Bound">NatCommuter</a>
</pre>
<p><strong>公理 9 (自然数)</strong> 存在一个自然数图式满足自然数的泛性质.</p>
<pre class="Agda">    <a id="10909" class="Comment">-- Axiom 9</a>
    <a id="10924" class="Keyword">field</a> <a id="10930" href="Axiom.html#10930" class="Field">AxNat</a> <a id="10936" class="Symbol">:</a> <a id="10938" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="10940" class="Symbol">(</a><a id="10941" href="Axiom.html#2144" class="Function">Diagram</a> <a id="10949" href="Axiom.html#10605" class="Bound">Nat</a><a id="10952" class="Symbol">)</a> <a id="10954" href="Axiom.html#10796" class="Bound">isNat</a>
</pre>
<p><strong>定义 3.1.8 ii</strong> 给定函数 <code>f : X →̇ Y</code>, 我们称 <code>f</code> 是满射, 当且仅当对任意 <code>y ∈ Y</code> 都存在 <code>x ∈ X</code> 使得 <code>f ⦅ x ⦆ ≡ y</code>.</p>
<pre class="Agda">    <a id="11072" class="Comment">-- Definition 3.1.8 ii</a>
    <a id="11099" href="Axiom.html#11099" class="Bound">surjective</a> <a id="11110" class="Symbol">:</a> <a id="11112" class="Symbol">(</a><a id="11113" href="Axiom.html#11113" class="Bound">f</a> <a id="11115" class="Symbol">:</a> <a id="11117" href="Axiom.html#2973" class="Generalizable">X</a> <a id="11119" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11122" href="Axiom.html#2975" class="Generalizable">Y</a><a id="11123" class="Symbol">)</a> <a id="11125" class="Symbol">→</a> <a id="11127" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11135" href="Axiom.html#11099" class="Bound">surjective</a> <a id="11146" class="Symbol">{</a><a id="11147" href="Axiom.html#11147" class="Bound">X</a><a id="11148" class="Symbol">}</a> <a id="11150" class="Symbol">{</a><a id="11151" href="Axiom.html#11151" class="Bound">Y</a><a id="11152" class="Symbol">}</a> <a id="11154" href="Axiom.html#11154" class="Bound">f</a> <a id="11156" class="Symbol">=</a> <a id="11158" href="Axiom.html#4126" class="Bound">∀[</a> <a id="11161" href="Axiom.html#11161" class="Bound">y</a> <a id="11163" href="Axiom.html#4126" class="Bound">∈</a> <a id="11165" href="Axiom.html#11151" class="Bound">Y</a> <a id="11167" href="Axiom.html#4126" class="Bound">]</a> <a id="11169" href="Axiom.html#4295" class="Bound">∃[</a> <a id="11172" href="Axiom.html#11172" class="Bound">x</a> <a id="11174" href="Axiom.html#4295" class="Bound">∈</a> <a id="11176" href="Axiom.html#11147" class="Bound">X</a> <a id="11178" href="Axiom.html#4295" class="Bound">]</a> <a id="11180" href="Axiom.html#11154" class="Bound">f</a> <a id="11182" href="Axiom.html#4718" class="Bound Operator">⦅</a> <a id="11184" href="Axiom.html#11172" class="Bound">x</a> <a id="11186" href="Axiom.html#4718" class="Bound Operator">⦆</a> <a id="11188" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11190" href="Axiom.html#11161" class="Bound">y</a>
</pre>
<p><strong>定义 3.4.1</strong> 给定函数 <code>f : X →̇ Y</code> 和 <code>i : Y →̇ X</code>, 我们称 <code>i</code> 是 <code>f</code> 的截面, 当且仅当 <code>f ∘ i ≡ id</code>.</p>
<pre class="Agda">    <a id="11295" class="Comment">-- Definition 3.4.1</a>
    <a id="11319" href="Axiom.html#11319" class="Bound">section</a> <a id="11327" class="Symbol">:</a> <a id="11329" class="Symbol">(</a><a id="11330" href="Axiom.html#11330" class="Bound">f</a> <a id="11332" class="Symbol">:</a> <a id="11334" href="Axiom.html#2973" class="Generalizable">X</a> <a id="11336" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11339" href="Axiom.html#2975" class="Generalizable">Y</a><a id="11340" class="Symbol">)</a> <a id="11342" class="Symbol">(</a><a id="11343" href="Axiom.html#11343" class="Bound">i</a> <a id="11345" class="Symbol">:</a> <a id="11347" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="11349" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11352" href="Axiom.html#2973" class="Generalizable">X</a><a id="11353" class="Symbol">)</a> <a id="11355" class="Symbol">→</a> <a id="11357" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="11365" href="Axiom.html#11319" class="Bound">section</a> <a id="11373" href="Axiom.html#11373" class="Bound">f</a> <a id="11375" href="Axiom.html#11375" class="Bound">i</a> <a id="11377" class="Symbol">=</a> <a id="11379" href="Axiom.html#11373" class="Bound">f</a> <a id="11381" href="Axiom.html#1661" class="Field Operator">∘</a> <a id="11383" href="Axiom.html#11375" class="Bound">i</a> <a id="11385" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11387" href="Axiom.html#1754" class="Function">id</a>
</pre>
<p><strong>公理 10 (选择)</strong> 如果 <code>f : X →̇ Y</code> 是满射, 那么存在 <code>f</code> 的一个截面 <code>i : Y →̇ X</code>.</p>
<pre class="Agda">    <a id="11473" class="Comment">-- Axiom 10</a>
    <a id="11489" class="Keyword">field</a> <a id="11495" href="Axiom.html#11495" class="Field">AxChoice</a> <a id="11504" class="Symbol">:</a> <a id="11506" href="Axiom.html#11099" class="Bound">surjective</a> <a id="11517" href="Axiom.html#2996" class="Generalizable">f</a> <a id="11519" class="Symbol">→</a> <a id="11521" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="11523" class="Symbol">(</a><a id="11524" href="Axiom.html#2975" class="Generalizable">Y</a> <a id="11526" href="Axiom.html#1631" class="Field Operator">→̇</a> <a id="11529" href="Axiom.html#2973" class="Generalizable">X</a><a id="11530" class="Symbol">)</a> <a id="11532" class="Symbol">(</a><a id="11533" href="Axiom.html#11319" class="Bound">section</a> <a id="11541" href="Axiom.html#2996" class="Generalizable">f</a><a id="11542" class="Symbol">)</a>
</pre>
<h2 id="总结">总结</h2>
<p>以下是对公理化的总结. 我们的公理适用于以下资料：</p>
<ul>
<li>一些称为集合的东西;</li>
<li>对于每个集合 <code>X</code> 和集合 <code>Y</code>, 一些称为从 <code>X</code> 到 <code>Y</code> 的函数, 我们用 <code>f : X →̇ Y</code> 表示从 <code>X</code> 到 <code>Y</code> 的函数 <code>f</code>;</li>
<li>对于每个集合 <code>X</code>, 集合 <code>Y</code> 和集合 <code>X</code>, 一个称为复合的运算, 将每对函数 <code>f : X →̇ Y</code> 和 <code>g : Y →̇ Z</code> 赋予一个函数 <code>f ∘ g : X →̇ Z</code>;</li>
<li>对于每个集合 <code>X</code>， 一个函数 <code>id : X →̇ X</code>, 称为 <code>X</code> 的恒等函数.</li>
</ul>
<p>公理：</p>
<ol type="1">
<li>函数的复合满足结合律, 并且恒等函数起到恒等作用.</li>
<li>存在一个终集.</li>
<li>函数外延性成立.</li>
<li>存在一个空集.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 和 <code>Y</code> 的积.</li>
<li>给定集合 <code>X</code> 和 <code>Y</code>, 存在 <code>X</code> 到 <code>Y</code> 的函数集.</li>
<li>给定函数 <code>f : X →̇ Y</code> 和元素 <code>y ∈ Y</code>, 存在 <code>f</code> 在 <code>y</code> 上的纤维.</li>
<li>存在一个子集分类器.</li>
<li>存在一个自然数系统.</li>
<li>每个满射都有一个截面.</li>
</ol>
<p>公理 3, 4 和 7 都涉及到元素, 它定义为定义域为终集 <code>１</code> 的函数. 公理 2 以及 5–9 都涉及到泛性质, 并且所有这些公理唯一地刻画了涉及的集合 (在同构意义上), 这将在接下来的几篇中证明.</p>
<pre class="Agda"><a id="12182" class="Keyword">record</a> <a id="ETCS"></a><a id="12189" href="Axiom.html#12189" class="Record">ETCS</a> <a id="12194" class="Symbol">:</a> <a id="12196" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="12201" class="Keyword">where</a>
  <a id="12209" class="Keyword">field</a>
    <a id="ETCS.etcs"></a><a id="12219" href="Axiom.html#12219" class="Field">etcs</a> <a id="12224" class="Symbol">:</a> <a id="12226" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="12228" href="Axiom.html#1554" class="Record">Data</a> <a id="12233" href="Axiom.html#3069" class="Record">Data.Axiom</a>
  <a id="12246" class="Keyword">open</a> <a id="12251" href="Axiom.html#1554" class="Module">Data</a> <a id="12256" class="Symbol">(</a><a id="12257" href="Axiom.html#12219" class="Field">etcs</a> <a id="12262" class="Symbol">.</a><a id="12263" href="Axiom.html#903" class="Field">fst</a><a id="12266" class="Symbol">)</a> <a id="12268" class="Keyword">public</a>
  <a id="12277" class="Keyword">open</a> <a id="12282" href="Axiom.html#3069" class="Module">Data.Axiom</a> <a id="12293" class="Symbol">(</a><a id="12294" href="Axiom.html#12219" class="Field">etcs</a> <a id="12299" class="Symbol">.</a><a id="12300" href="Axiom.html#917" class="Field">snd</a><a id="12303" class="Symbol">)</a> <a id="12305" class="Keyword">public</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
