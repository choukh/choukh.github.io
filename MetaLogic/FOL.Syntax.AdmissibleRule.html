<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Syntax.AdmissibleRule</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语法-可容许规则" id="toc-一阶逻辑-语法-可容许规则">一阶逻辑 ▸ 语法 ▸ 可容许规则</a>
  <ul>
  <li><a href="#弱化" id="toc-弱化">弱化</a></li>
  <li><a href="#局部无名" id="toc-局部无名">局部无名</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语法-可容许规则">一阶逻辑 ▸ 语法 ▸ 可容许规则</h1>
<p>若在一个形式系统中添加一个推理规则后, 该系统的定理集合不发生变化, 则称该推理规则在该形式系统中是<strong>可容许的 (admissible)</strong>. 换句话说, 使用该规则可证明的每个公式在没有该规则的情况下已经是可证明的. 因此在某种程度上说, 该规则是冗余的. 但是对于研究这个系统而言, 它们是重要引理.</p>
<pre class="Agda"><a id="222" class="Keyword">open</a> <a id="227" class="Keyword">import</a> <a id="234" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="255" class="Keyword">open</a> <a id="260" class="Keyword">import</a> <a id="267" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="280" class="Keyword">module</a> <a id="287" href="FOL.Syntax.AdmissibleRule.html" class="Module">FOL.Syntax.AdmissibleRule</a> <a id="313" class="Symbol">(</a><a id="314" href="FOL.Syntax.AdmissibleRule.html#314" class="Bound">ℒ</a> <a id="316" class="Symbol">:</a> <a id="318" href="FOL.Language.html#772" class="Record">Language</a><a id="326" class="Symbol">)</a> <a id="328" class="Keyword">where</a>

<a id="335" class="Keyword">open</a> <a id="340" class="Keyword">import</a> <a id="347" href="FOL.Syntax.Base.html" class="Module">FOL.Syntax.Base</a> <a id="363" href="FOL.Syntax.AdmissibleRule.html#314" class="Bound">ℒ</a>
<a id="365" class="Keyword">open</a> <a id="370" class="Keyword">import</a> <a id="377" href="FOL.Syntax.FreshVariables.html" class="Module">FOL.Syntax.FreshVariables</a> <a id="403" href="FOL.Syntax.AdmissibleRule.html#314" class="Bound">ℒ</a>
<a id="405" class="Keyword">open</a> <a id="410" class="Keyword">import</a> <a id="417" href="FOL.Syntax.SubstitutionFacts.html" class="Module">FOL.Syntax.SubstitutionFacts</a> <a id="446" href="FOL.Syntax.AdmissibleRule.html#314" class="Bound">ℒ</a>

<a id="449" class="Keyword">private</a> <a id="457" class="Keyword">variable</a>
  <a id="468" href="FOL.Syntax.AdmissibleRule.html#468" class="Generalizable">n</a> <a id="470" class="Symbol">:</a> <a id="472" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<h2 id="弱化">弱化</h2>
<p>弱化指的是对语境的弱化. 此类规则允许我们通过在弱化的语境中证明某公式, 来说明原语境中就能证明该公式.</p>
<p><strong><u>引理</u></strong> 弱化规则: <code>Γ ⊆ᴸ Δ</code> 蕴含 <code>Γ ⊢ φ → Δ ⊢ φ</code>. <strong><u>证明</u></strong> 对证明树归纳即得. ∎</p>
<pre class="Agda"><a id="Wkn"></a><a id="624" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="628" class="Symbol">:</a> <a id="630" href="FOL.Syntax.Base.html#5239" class="Generalizable">Γ</a> <a id="632" href="Data.List.Relation.Binary.Subset.Setoid.html#825" class="Function Operator">⊆ᴸ</a> <a id="635" href="FOL.Syntax.Base.html#5241" class="Generalizable">Δ</a> <a id="637" class="Symbol">→</a> <a id="639" href="FOL.Syntax.Base.html#5239" class="Generalizable">Γ</a> <a id="641" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">⊢</a> <a id="643" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a> <a id="645" class="Symbol">→</a> <a id="647" href="FOL.Syntax.Base.html#5241" class="Generalizable">Δ</a> <a id="649" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">⊢</a> <a id="651" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a>
<a id="653" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="657" href="FOL.Syntax.AdmissibleRule.html#657" class="Bound">sub</a> <a id="661" class="Symbol">(</a><a id="662" href="FOL.Syntax.Base.html#5976" class="InductiveConstructor">Ctx</a> <a id="666" href="FOL.Syntax.AdmissibleRule.html#666" class="Bound">H</a><a id="667" class="Symbol">)</a> <a id="669" class="Symbol">=</a> <a id="671" href="FOL.Syntax.Base.html#5976" class="InductiveConstructor">Ctx</a> <a id="675" class="Symbol">(</a><a id="676" href="FOL.Syntax.AdmissibleRule.html#657" class="Bound">sub</a> <a id="680" href="FOL.Syntax.AdmissibleRule.html#666" class="Bound">H</a><a id="681" class="Symbol">)</a>
<a id="683" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="687" href="FOL.Syntax.AdmissibleRule.html#687" class="Bound">sub</a> <a id="691" class="Symbol">(</a><a id="692" href="FOL.Syntax.Base.html#6014" class="InductiveConstructor">ImpI</a> <a id="697" href="FOL.Syntax.AdmissibleRule.html#697" class="Bound">H</a><a id="698" class="Symbol">)</a> <a id="700" class="Symbol">=</a> <a id="702" href="FOL.Syntax.Base.html#6014" class="InductiveConstructor">ImpI</a> <a id="707" class="Symbol">(</a><a id="708" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="712" class="Symbol">(</a><a id="713" href="Foundation.Data.List.SetTheoretic.html#3117" class="Function">∷⊆∷</a> <a id="717" href="FOL.Syntax.AdmissibleRule.html#687" class="Bound">sub</a><a id="720" class="Symbol">)</a> <a id="722" href="FOL.Syntax.AdmissibleRule.html#697" class="Bound">H</a><a id="723" class="Symbol">)</a>
<a id="725" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="729" href="FOL.Syntax.AdmissibleRule.html#729" class="Bound">sub</a> <a id="733" class="Symbol">(</a><a id="734" href="FOL.Syntax.Base.html#6057" class="InductiveConstructor">ImpE</a> <a id="739" href="FOL.Syntax.AdmissibleRule.html#739" class="Bound">H₁</a> <a id="742" href="FOL.Syntax.AdmissibleRule.html#742" class="Bound">H₂</a><a id="744" class="Symbol">)</a> <a id="746" class="Symbol">=</a> <a id="748" href="FOL.Syntax.Base.html#6057" class="InductiveConstructor">ImpE</a> <a id="753" class="Symbol">(</a><a id="754" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="758" href="FOL.Syntax.AdmissibleRule.html#729" class="Bound">sub</a> <a id="762" href="FOL.Syntax.AdmissibleRule.html#739" class="Bound">H₁</a><a id="764" class="Symbol">)</a> <a id="766" class="Symbol">(</a><a id="767" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="771" href="FOL.Syntax.AdmissibleRule.html#729" class="Bound">sub</a> <a id="775" href="FOL.Syntax.AdmissibleRule.html#742" class="Bound">H₂</a><a id="777" class="Symbol">)</a>
<a id="779" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="783" href="FOL.Syntax.AdmissibleRule.html#783" class="Bound">sub</a> <a id="787" class="Symbol">(</a><a id="788" href="FOL.Syntax.Base.html#6096" class="InductiveConstructor">AllI</a> <a id="793" href="FOL.Syntax.AdmissibleRule.html#793" class="Bound">H</a><a id="794" class="Symbol">)</a> <a id="796" class="Symbol">=</a> <a id="798" href="FOL.Syntax.Base.html#6096" class="InductiveConstructor">AllI</a> <a id="803" class="Symbol">(</a><a id="804" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="808" class="Symbol">(</a><a id="809" href="Foundation.Data.List.SetTheoretic.html#3222" class="Function">map⊆map</a> <a id="817" href="FOL.Syntax.AdmissibleRule.html#783" class="Bound">sub</a><a id="820" class="Symbol">)</a> <a id="822" href="FOL.Syntax.AdmissibleRule.html#793" class="Bound">H</a><a id="823" class="Symbol">)</a>
<a id="825" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="829" href="FOL.Syntax.AdmissibleRule.html#829" class="Bound">sub</a> <a id="833" class="Symbol">(</a><a id="834" href="FOL.Syntax.Base.html#6137" class="InductiveConstructor">AllE</a> <a id="839" href="FOL.Syntax.AdmissibleRule.html#839" class="Bound">H</a><a id="840" class="Symbol">)</a> <a id="842" class="Symbol">=</a> <a id="844" href="FOL.Syntax.Base.html#6137" class="InductiveConstructor">AllE</a> <a id="849" class="Symbol">(</a><a id="850" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="854" href="FOL.Syntax.AdmissibleRule.html#829" class="Bound">sub</a> <a id="858" href="FOL.Syntax.AdmissibleRule.html#839" class="Bound">H</a><a id="859" class="Symbol">)</a>
<a id="861" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="865" href="FOL.Syntax.AdmissibleRule.html#865" class="Bound">sub</a> <a id="869" class="Symbol">(</a><a id="870" href="FOL.Syntax.Base.html#6183" class="InductiveConstructor">FalseE</a> <a id="877" href="FOL.Syntax.AdmissibleRule.html#877" class="Bound">H</a><a id="878" class="Symbol">)</a> <a id="880" class="Symbol">=</a> <a id="882" href="FOL.Syntax.Base.html#6183" class="InductiveConstructor">FalseE</a> <a id="889" class="Symbol">(</a><a id="890" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="894" href="FOL.Syntax.AdmissibleRule.html#865" class="Bound">sub</a> <a id="898" href="FOL.Syntax.AdmissibleRule.html#877" class="Bound">H</a><a id="899" class="Symbol">)</a>
<a id="901" href="FOL.Syntax.AdmissibleRule.html#624" class="Function">Wkn</a> <a id="905" href="FOL.Syntax.AdmissibleRule.html#905" class="Bound">sub</a> <a id="909" class="Symbol">(</a><a id="910" href="FOL.Syntax.Base.html#6222" class="InductiveConstructor">Peirce</a> <a id="917" href="FOL.Syntax.AdmissibleRule.html#917" class="Bound">φ</a> <a id="919" href="FOL.Syntax.AdmissibleRule.html#919" class="Bound">ψ</a><a id="920" class="Symbol">)</a> <a id="922" class="Symbol">=</a> <a id="924" href="FOL.Syntax.Base.html#6222" class="InductiveConstructor">Peirce</a> <a id="931" href="FOL.Syntax.AdmissibleRule.html#917" class="Bound">φ</a> <a id="933" href="FOL.Syntax.AdmissibleRule.html#919" class="Bound">ψ</a>
</pre>
<p><strong><u>引理</u></strong> 替换弱化规则: 一个证明在其语境和结论同时做同种替换后仍然有效.<br />
<strong><u>证明</u></strong> 对证明树归纳, 我们只讲 <code>AllI</code> 和 <code>AllE</code> 的情况, 其他情况的证明与 <code>Wkn</code> 类似.</p>
<pre class="Agda"><a id="SubstWkn"></a><a id="1065" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1074" class="Symbol">:</a> <a id="1076" class="Symbol">(</a><a id="1077" href="FOL.Syntax.AdmissibleRule.html#1077" class="Bound">σ</a> <a id="1079" class="Symbol">:</a> <a id="1081" href="FOL.Syntax.Base.html#1777" class="Function">Subst</a><a id="1086" class="Symbol">)</a> <a id="1088" class="Symbol">→</a> <a id="1090" href="FOL.Syntax.Base.html#5239" class="Generalizable">Γ</a> <a id="1092" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">⊢</a> <a id="1094" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a> <a id="1096" class="Symbol">→</a> <a id="1098" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1102" href="FOL.Syntax.Base.html#4201" class="Function Operator">_[</a> <a id="1105" href="FOL.Syntax.AdmissibleRule.html#1077" class="Bound">σ</a> <a id="1107" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a> <a id="1110" href="FOL.Syntax.Base.html#5239" class="Generalizable">Γ</a> <a id="1112" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">⊢</a> <a id="1114" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a> <a id="1116" href="FOL.Syntax.Base.html#4201" class="Function Operator">[</a> <a id="1118" href="FOL.Syntax.AdmissibleRule.html#1077" class="Bound">σ</a> <a id="1120" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a>
<a id="1123" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1132" href="FOL.Syntax.AdmissibleRule.html#1132" class="Bound">σ</a> <a id="1134" class="Symbol">(</a><a id="1135" href="FOL.Syntax.Base.html#5976" class="InductiveConstructor">Ctx</a> <a id="1139" href="FOL.Syntax.AdmissibleRule.html#1139" class="Bound">H</a><a id="1140" class="Symbol">)</a> <a id="1142" class="Symbol">=</a> <a id="1144" href="FOL.Syntax.Base.html#5976" class="InductiveConstructor">Ctx</a> <a id="1148" class="Symbol">(</a><a id="1149" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="1160" href="FOL.Syntax.AdmissibleRule.html#1139" class="Bound">H</a> <a id="1162" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="1166" class="Symbol">)</a>
<a id="1168" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1177" href="FOL.Syntax.AdmissibleRule.html#1177" class="Bound">σ</a> <a id="1179" class="Symbol">(</a><a id="1180" href="FOL.Syntax.Base.html#6014" class="InductiveConstructor">ImpI</a> <a id="1185" href="FOL.Syntax.AdmissibleRule.html#1185" class="Bound">H</a><a id="1186" class="Symbol">)</a> <a id="1188" class="Symbol">=</a> <a id="1190" href="FOL.Syntax.Base.html#6014" class="InductiveConstructor">ImpI</a> <a id="1195" class="Symbol">(</a><a id="1196" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1205" href="FOL.Syntax.AdmissibleRule.html#1177" class="Bound">σ</a> <a id="1207" href="FOL.Syntax.AdmissibleRule.html#1185" class="Bound">H</a><a id="1208" class="Symbol">)</a>
<a id="1210" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1219" href="FOL.Syntax.AdmissibleRule.html#1219" class="Bound">σ</a> <a id="1221" class="Symbol">(</a><a id="1222" href="FOL.Syntax.Base.html#6057" class="InductiveConstructor">ImpE</a> <a id="1227" href="FOL.Syntax.AdmissibleRule.html#1227" class="Bound">H₁</a> <a id="1230" href="FOL.Syntax.AdmissibleRule.html#1230" class="Bound">H₂</a><a id="1232" class="Symbol">)</a> <a id="1234" class="Symbol">=</a> <a id="1236" href="FOL.Syntax.Base.html#6057" class="InductiveConstructor">ImpE</a> <a id="1241" class="Symbol">(</a><a id="1242" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1251" href="FOL.Syntax.AdmissibleRule.html#1219" class="Bound">σ</a> <a id="1253" href="FOL.Syntax.AdmissibleRule.html#1227" class="Bound">H₁</a><a id="1255" class="Symbol">)</a> <a id="1257" class="Symbol">(</a><a id="1258" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1267" href="FOL.Syntax.AdmissibleRule.html#1219" class="Bound">σ</a> <a id="1269" href="FOL.Syntax.AdmissibleRule.html#1230" class="Bound">H₂</a><a id="1271" class="Symbol">)</a>
<a id="1273" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1282" href="FOL.Syntax.AdmissibleRule.html#1282" class="Bound">σ</a> <a id="1284" class="Symbol">(</a><a id="1285" href="FOL.Syntax.Base.html#6183" class="InductiveConstructor">FalseE</a> <a id="1292" href="FOL.Syntax.AdmissibleRule.html#1292" class="Bound">H</a><a id="1293" class="Symbol">)</a> <a id="1295" class="Symbol">=</a> <a id="1297" href="FOL.Syntax.Base.html#6183" class="InductiveConstructor">FalseE</a> <a id="1304" class="Symbol">(</a><a id="1305" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1314" href="FOL.Syntax.AdmissibleRule.html#1282" class="Bound">σ</a> <a id="1316" href="FOL.Syntax.AdmissibleRule.html#1292" class="Bound">H</a><a id="1317" class="Symbol">)</a>
<a id="1319" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1328" href="FOL.Syntax.AdmissibleRule.html#1328" class="Bound">σ</a> <a id="1330" class="Symbol">(</a><a id="1331" href="FOL.Syntax.Base.html#6222" class="InductiveConstructor">Peirce</a> <a id="1338" href="FOL.Syntax.AdmissibleRule.html#1338" class="Bound">φ</a> <a id="1340" href="FOL.Syntax.AdmissibleRule.html#1340" class="Bound">ψ</a><a id="1341" class="Symbol">)</a> <a id="1343" class="Symbol">=</a> <a id="1345" href="FOL.Syntax.Base.html#6222" class="InductiveConstructor">Peirce</a> <a id="1352" class="Symbol">(</a><a id="1353" href="FOL.Syntax.AdmissibleRule.html#1338" class="Bound">φ</a> <a id="1355" href="FOL.Syntax.Base.html#4201" class="Function Operator">[</a> <a id="1357" href="FOL.Syntax.AdmissibleRule.html#1328" class="Bound">σ</a> <a id="1359" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a><a id="1361" class="Symbol">)</a> <a id="1363" class="Symbol">(</a><a id="1364" href="FOL.Syntax.AdmissibleRule.html#1340" class="Bound">ψ</a> <a id="1366" href="FOL.Syntax.Base.html#4201" class="Function Operator">[</a> <a id="1368" href="FOL.Syntax.AdmissibleRule.html#1328" class="Bound">σ</a> <a id="1370" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a><a id="1372" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="1387" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1396" href="FOL.Syntax.AdmissibleRule.html#1396" class="Bound">σ</a> <a id="1398" class="Symbol">(</a><a id="1399" href="FOL.Syntax.Base.html#6137" class="InductiveConstructor">AllE</a> <a id="1404" href="FOL.Syntax.AdmissibleRule.html#1404" class="Bound">H</a><a id="1405" class="Symbol">)</a> <a id="1407" class="Symbol">=</a> <a id="1409" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="1415" class="Symbol">(_</a> <a id="1418" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">⊢_</a><a id="1420" class="Symbol">)</a> <a id="1422" class="Symbol">(</a><a id="1423" href="FOL.Syntax.SubstitutionFacts.html#2398" class="Function">[]ᵩ-∘-[]₀</a> <a id="1433" class="Symbol">_)</a> <a id="1436" class="Symbol">(</a><a id="1437" href="FOL.Syntax.Base.html#6137" class="InductiveConstructor">AllE</a> <a id="1442" class="Symbol">(</a><a id="1443" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1452" href="FOL.Syntax.AdmissibleRule.html#1396" class="Bound">σ</a> <a id="1454" href="FOL.Syntax.AdmissibleRule.html#1404" class="Bound">H</a><a id="1455" class="Symbol">))</a>
</pre>
<pre class="Agda"><a id="1471" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1480" class="Symbol">{</a><a id="1481" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a><a id="1482" class="Symbol">}</a> <a id="1484" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1486" class="Symbol">(</a><a id="1487" href="FOL.Syntax.Base.html#6096" class="InductiveConstructor">AllI</a> <a id="1492" href="FOL.Syntax.AdmissibleRule.html#1492" class="Bound">H</a><a id="1493" class="Symbol">)</a> <a id="1495" class="Symbol">=</a> <a id="1497" href="FOL.Syntax.Base.html#6096" class="InductiveConstructor">AllI</a> <a id="1502" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1504" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="1510" class="Symbol">(</a><a id="1511" href="FOL.Syntax.Base.html#5940" class="Datatype Operator">_⊢</a> <a id="1514" class="Symbol">_)</a> <a id="1517" href="FOL.Syntax.AdmissibleRule.html#1548" class="Function">eq</a> <a id="1520" class="Symbol">(</a><a id="1521" href="FOL.Syntax.AdmissibleRule.html#1065" class="Function">SubstWkn</a> <a id="1530" class="Symbol">(</a><a id="1531" href="FOL.Syntax.Base.html#2974" class="Function">↑ₛ</a> <a id="1534" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a><a id="1535" class="Symbol">)</a> <a id="1537" href="FOL.Syntax.AdmissibleRule.html#1492" class="Bound">H</a><a id="1538" class="Symbol">)</a> <a id="1540" class="Keyword">where</a>
  <a id="1548" href="FOL.Syntax.AdmissibleRule.html#1548" class="Function">eq</a> <a id="1551" class="Symbol">=</a> <a id="1553" href="FOL.Syntax.Base.html#5128" class="Function">↑</a> <a id="1555" class="Symbol">(</a><a id="1556" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1560" class="Symbol">(</a><a id="1561" href="FOL.Syntax.Base.html#4201" class="Function Operator">_[</a> <a id="1564" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1566" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a><a id="1568" class="Symbol">)</a> <a id="1570" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a><a id="1571" class="Symbol">)</a>      <a id="1578" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">≡˘⟨</a> <a id="1582" href="Data.List.Properties.html#4146" class="Function">map-∘</a> <a id="1588" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a> <a id="1590" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">⟩</a>
       <a id="1599" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1603" class="Symbol">(</a><a id="1604" href="FOL.Syntax.Base.html#5018" class="Function">↑ᵩ</a> <a id="1607" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="1609" href="FOL.Syntax.Base.html#4201" class="Function Operator">_[</a> <a id="1612" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1614" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a><a id="1616" class="Symbol">)</a> <a id="1618" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a>     <a id="1624" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="1627" href="Foundation.Data.List.SetTheoretic.html#700" class="Function">map-ext</a> <a id="1635" class="Symbol">(λ</a> <a id="1638" href="FOL.Syntax.AdmissibleRule.html#1638" class="Bound">t</a> <a id="1640" href="FOL.Syntax.AdmissibleRule.html#1640" class="Bound">_</a> <a id="1642" class="Symbol">→</a> <a id="1644" href="FOL.Syntax.SubstitutionFacts.html#3634" class="Function">↑ᵩ-∘-[]ᵩ</a> <a id="1653" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1655" href="FOL.Syntax.AdmissibleRule.html#1638" class="Bound">t</a><a id="1656" class="Symbol">)</a> <a id="1658" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
       <a id="1667" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1671" class="Symbol">(</a><a id="1672" href="FOL.Syntax.Base.html#4201" class="Function Operator">_[</a> <a id="1675" href="FOL.Syntax.Base.html#2974" class="Function">↑ₛ</a> <a id="1678" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1680" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a> <a id="1683" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="1685" href="FOL.Syntax.Base.html#5018" class="Function">↑ᵩ</a><a id="1687" class="Symbol">)</a> <a id="1689" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a>  <a id="1692" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="1695" href="Data.List.Properties.html#4146" class="Function">map-∘</a> <a id="1701" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a> <a id="1703" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
       <a id="1712" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1716" class="Symbol">(</a><a id="1717" href="FOL.Syntax.Base.html#4201" class="Function Operator">_[</a> <a id="1720" href="FOL.Syntax.Base.html#2974" class="Function">↑ₛ</a> <a id="1723" href="FOL.Syntax.AdmissibleRule.html#1484" class="Bound">σ</a> <a id="1725" href="FOL.Syntax.Base.html#4201" class="Function Operator">]ᵩ</a><a id="1727" class="Symbol">)</a> <a id="1729" class="Symbol">(</a><a id="1730" href="FOL.Syntax.Base.html#5128" class="Function">↑</a> <a id="1732" href="FOL.Syntax.AdmissibleRule.html#1481" class="Bound">Γ</a><a id="1733" class="Symbol">)</a>   <a id="1737" href="Foundation.Prelude.Equality.html#1248" class="Function Operator">∎</a>
</pre>
<h2 id="局部无名">局部无名</h2>
<p>借助新变元的概念, 我们可以表述关于全称量词的所谓<strong>局部无名 (locally nameless)</strong> 规则 <code>AllI′</code>.</p>
<pre class="Agda"><a id="1827" class="Comment">--AllI′ : fresh n Γ → freshᵩ n (∀̇ φ) → Γ ⊢ φ [ # n ]₀ → Γ ⊢ ∀̇ φ</a>
<a id="1893" class="Comment">--AllI′ freshΓ fresh∀̇φ Γ⊢φ[n] = AllI {!   !}</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Syntax/AdmissibleRule.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Syntax.AdmissibleRule.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.syntax.admissible">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
