<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.TheoryExtension</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-理论的扩张" id="toc-一阶逻辑-理论的扩张">一阶逻辑 ▸ 理论的扩张</a>
  <ul>
  <li><a href="#扩张的输入和输出" id="toc-扩张的输入和输出">扩张的输入和输出</a></li>
  <li><a href="#扩张的构造" id="toc-扩张的构造">扩张的构造</a>
  <ul>
  <li><a href="#理论的无穷扩张" id="toc-理论的无穷扩张">理论的无穷扩张</a></li>
  <li><a href="#henkin扩张" id="toc-henkin扩张">Henkin扩张</a></li>
  <li><a href="#极大一致扩张" id="toc-极大一致扩张">极大一致扩张</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-理论的扩张">一阶逻辑 ▸ 理论的扩张</h1>
<p>扩张理论的目的是使扩张后的理论满足一定的性质, 以证明一阶逻辑的完备性, 这会在下一篇讲解. 本篇先介绍此种扩张 (以下称为完备化扩张) 应具有的性质, 然后讲解该扩张的具体构造.</p>
<pre class="Agda"><a id="145" class="Keyword">open</a> <a id="150" class="Keyword">import</a> <a id="157" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="178" class="Keyword">open</a> <a id="183" class="Keyword">import</a> <a id="190" href="Foundation.Data.Nat.AlternativeOrder.html" class="Module">Foundation.Data.Nat.AlternativeOrder</a>

<a id="228" class="Keyword">open</a> <a id="233" class="Keyword">import</a> <a id="240" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="253" class="Keyword">module</a> <a id="260" href="FOL.TheoryExtension.html" class="Module">FOL.TheoryExtension</a> <a id="280" class="Symbol">(</a><a id="281" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a> <a id="283" class="Symbol">:</a> <a id="285" href="FOL.Language.html#772" class="Record">Language</a><a id="293" class="Symbol">)</a> <a id="295" class="Keyword">where</a>

<a id="302" class="Keyword">open</a> <a id="307" class="Keyword">import</a> <a id="314" href="FOL.Syntax.Base.html" class="Module">FOL.Syntax.Base</a> <a id="330" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a>
<a id="332" class="Keyword">open</a> <a id="337" class="Keyword">import</a> <a id="344" href="FOL.Syntax.Discrete.html" class="Module">FOL.Syntax.Discrete</a> <a id="364" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="FOL.Syntax.Enumeration.html" class="Module">FOL.Syntax.Enumeration</a> <a id="401" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a>
<a id="403" class="Keyword">open</a> <a id="408" class="Keyword">import</a> <a id="415" href="FOL.Syntax.FreshVariables.html" class="Module">FOL.Syntax.FreshVariables</a> <a id="441" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a>
<a id="443" class="Keyword">open</a> <a id="448" class="Keyword">import</a> <a id="455" href="FOL.Syntax.AdmissibleRule.html" class="Module">FOL.Syntax.AdmissibleRule</a> <a id="481" href="FOL.TheoryExtension.html#281" class="Bound">ℒ</a>

<a id="484" class="Keyword">private</a> <a id="492" class="Keyword">variable</a>
  <a id="503" href="FOL.TheoryExtension.html#503" class="Generalizable">m</a> <a id="505" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="507" class="Symbol">:</a> <a id="509" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="513" href="FOL.TheoryExtension.html#513" class="Generalizable">𝒯</a> <a id="515" class="Symbol">:</a> <a id="517" href="FOL.Syntax.Base.html#4795" class="Function">Theory</a>
</pre>
<h2 id="扩张的输入和输出">扩张的输入和输出</h2>
<p>完备化扩张的输入要求是一个闭理论, 即由闭公式所组成的理论.</p>
<pre class="Agda"><a id="582" class="Keyword">module</a> <a id="589" href="FOL.TheoryExtension.html#589" class="Module">_</a> <a id="591" class="Symbol">(</a><a id="592" href="FOL.TheoryExtension.html#592" class="Bound">(</a><a id="593" href="FOL.TheoryExtension.html#593" class="Bound">𝒯ⁱ</a> <a id="596" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="598" href="FOL.TheoryExtension.html#598" class="Bound">𝒯ⁱ-closed</a><a id="607" href="FOL.TheoryExtension.html#592" class="Bound">)</a> <a id="609" class="Symbol">:</a> <a id="611" href="FOL.Syntax.FreshVariables.html#4941" class="Function">ClosedTheory</a><a id="623" class="Symbol">)</a> <a id="625" class="Keyword">where</a>
</pre>
<p>闭理论 <code>𝒯ⁱ</code> 的完备化扩张是一个理论 <code>𝒯ᵒ</code>, 满足</p>
<ul>
<li><code>𝒯ᵒ</code> 是 <code>𝒯ⁱ</code> 的一致扩张, 即 <code>𝒯ᵒ</code> 包含 <code>𝒯ⁱ</code> 且 <code>𝒯ᵒ</code> 相对于 <code>𝒯ⁱ</code> 一致</li>
<li><code>𝒯ᵒ</code> 对证明封闭, 即 <code>𝒯ᵒ</code> 的任意可证的公式都是 <code>𝒯ᵒ</code> 的成员</li>
<li><code>𝒯ᵒ</code> 中的蕴含式满足分配性: <code>φ →̇ ψ</code> 是 <code>𝒯ᵒ</code> 的成员当且仅当 <code>φ</code> 是 <code>𝒯ᵒ</code> 的成员蕴含 <code>ψ</code> 是 <code>𝒯ᵒ</code> 的成员</li>
<li><code>𝒯ᵒ</code> 中的全称量化式满足分配性: <code>∀̇ φ</code> 是 <code>𝒯ᵒ</code> 的成员当且仅当对任意项 <code>t</code>, <code>φ [ t ]₀</code> 是 <code>𝒯ᵒ</code> 的成员</li>
</ul>
<pre class="Agda">  <a id="923" class="Keyword">record</a> <a id="930" href="FOL.TheoryExtension.html#930" class="Record">Output</a> <a id="937" class="Symbol">:</a> <a id="939" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a> <a id="942" class="Keyword">where</a>
    <a id="952" class="Keyword">field</a>
      <a id="964" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="967" class="Symbol">:</a> <a id="969" href="FOL.Syntax.Base.html#4795" class="Function">Theory</a>
      <a id="982" href="FOL.TheoryExtension.html#982" class="Field">𝒯ᵒ-sub</a> <a id="989" class="Symbol">:</a> <a id="991" href="FOL.TheoryExtension.html#593" class="Bound">𝒯ⁱ</a> <a id="994" href="Foundation.Set.Powerset.html#920" class="Function Operator">⊆</a> <a id="996" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a>
      <a id="1005" href="FOL.TheoryExtension.html#1005" class="Field">𝒯ᵒ-con</a> <a id="1012" class="Symbol">:</a> <a id="1014" href="FOL.Syntax.Base.html#7010" class="Function Operator">Con</a> <a id="1018" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="1021" href="FOL.Syntax.Base.html#7010" class="Function Operator">to</a> <a id="1024" href="FOL.TheoryExtension.html#593" class="Bound">𝒯ⁱ</a>
      <a id="1033" href="FOL.TheoryExtension.html#1033" class="Field">𝒯ᵒ-closed-under-⊩</a> <a id="1051" class="Symbol">:</a> <a id="1053" class="Symbol">∀</a> <a id="1055" href="FOL.TheoryExtension.html#1055" class="Bound">φ</a> <a id="1057" class="Symbol">→</a> <a id="1059" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="1062" href="FOL.Syntax.Base.html#6736" class="Function Operator">⊩</a> <a id="1064" href="FOL.TheoryExtension.html#1055" class="Bound">φ</a> <a id="1066" class="Symbol">→</a> <a id="1068" href="FOL.TheoryExtension.html#1055" class="Bound">φ</a> <a id="1070" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1072" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a>

      <a id="1082" href="FOL.TheoryExtension.html#1082" class="Field">𝒯ᵒ-distrib-over-→̇</a> <a id="1101" class="Symbol">:</a> <a id="1103" class="Symbol">∀</a> <a id="1105" href="FOL.TheoryExtension.html#1105" class="Bound">φ</a> <a id="1107" href="FOL.TheoryExtension.html#1107" class="Bound">ψ</a> <a id="1109" class="Symbol">→</a> <a id="1111" href="FOL.TheoryExtension.html#1105" class="Bound">φ</a> <a id="1113" href="FOL.Syntax.Base.html#3818" class="InductiveConstructor Operator">→̇</a> <a id="1116" href="FOL.TheoryExtension.html#1107" class="Bound">ψ</a> <a id="1118" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1120" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="1123" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1125" class="Symbol">(</a><a id="1126" href="FOL.TheoryExtension.html#1105" class="Bound">φ</a> <a id="1128" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1130" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="1133" class="Symbol">→</a> <a id="1135" href="FOL.TheoryExtension.html#1107" class="Bound">ψ</a> <a id="1137" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1139" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a><a id="1141" class="Symbol">)</a>
      <a id="1149" href="FOL.TheoryExtension.html#1149" class="Field">𝒯ᵒ-distrib-over-∀̇</a> <a id="1168" class="Symbol">:</a> <a id="1170" class="Symbol">∀</a> <a id="1172" href="FOL.TheoryExtension.html#1172" class="Bound">φ</a> <a id="1174" class="Symbol">→</a> <a id="1176" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇</a> <a id="1179" href="FOL.TheoryExtension.html#1172" class="Bound">φ</a> <a id="1181" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1183" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a> <a id="1186" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1188" class="Symbol">∀</a> <a id="1190" href="FOL.TheoryExtension.html#1190" class="Bound">t</a> <a id="1192" class="Symbol">→</a> <a id="1194" href="FOL.TheoryExtension.html#1172" class="Bound">φ</a> <a id="1196" href="FOL.Syntax.Base.html#4526" class="Function Operator">[</a> <a id="1198" href="FOL.TheoryExtension.html#1190" class="Bound">t</a> <a id="1200" href="FOL.Syntax.Base.html#4526" class="Function Operator">]₀</a> <a id="1203" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="1205" href="FOL.TheoryExtension.html#964" class="Field">𝒯ᵒ</a>
</pre>
<h2 id="扩张的构造">扩张的构造</h2>
<p>完备化扩张其实不是一轮扩张, 而是由两轮扩张构成, 按顺序分别叫做</p>
<ol type="1">
<li>Henkin扩张</li>
<li>极大一致扩张</li>
</ol>
<p>它们可以抽象出一个共通的基础构造: 理论的无穷扩张. 我们先讲这个.</p>
<h3 id="理论的无穷扩张">理论的无穷扩张</h3>
<p>Henkin扩张和极大一致扩张都不是一步到位的, 而是需要可数无穷步, 每一步都是上一步的一致扩张, 这样的扩张叫做理论的无穷扩张.</p>
<p><strong><u>定义</u></strong> 理论的无穷扩张是理论的一个无穷序列, 其中每一项都是上一项的一致扩张.</p>
<pre class="Agda"><a id="1457" class="Keyword">record</a> <a id="GeneralizedExtension"></a><a id="1464" href="FOL.TheoryExtension.html#1464" class="Record">GeneralizedExtension</a> <a id="1485" class="Symbol">:</a> <a id="1487" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a> <a id="1490" class="Keyword">where</a>
  <a id="1498" class="Keyword">constructor</a> <a id="mkGenExt"></a><a id="1510" href="FOL.TheoryExtension.html#1510" class="InductiveConstructor">mkGenExt</a>
  <a id="1521" class="Keyword">field</a>
    <a id="GeneralizedExtension.𝒯ᵢ"></a><a id="1531" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1534" class="Symbol">:</a> <a id="1536" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1538" class="Symbol">→</a> <a id="1540" href="FOL.Syntax.Base.html#4795" class="Function">Theory</a>
    <a id="GeneralizedExtension.𝒯₊-sub"></a><a id="1551" href="FOL.TheoryExtension.html#1551" class="Field">𝒯₊-sub</a> <a id="1558" class="Symbol">:</a> <a id="1560" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1563" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="1565" href="Foundation.Set.Powerset.html#920" class="Function Operator">⊆</a> <a id="1567" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1570" class="Symbol">(</a><a id="1571" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1575" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a><a id="1576" class="Symbol">)</a>
    <a id="GeneralizedExtension.𝒯₊-con"></a><a id="1582" href="FOL.TheoryExtension.html#1582" class="Field">𝒯₊-con</a> <a id="1589" class="Symbol">:</a> <a id="1591" href="FOL.Syntax.Base.html#7010" class="Function Operator">Con</a> <a id="1595" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1598" class="Symbol">(</a><a id="1599" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1603" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a><a id="1604" class="Symbol">)</a> <a id="1606" href="FOL.Syntax.Base.html#7010" class="Function Operator">to</a> <a id="1609" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1612" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a>
</pre>
<p><strong><u>引理</u></strong> 对任意 <code>m ≤ n</code>, <code>𝒯ᵢ n</code> 是 <code>𝒯ᵢ m</code> 的一致扩张.<br />
<strong><u>证明</u></strong> 对 <code>m ≤ n</code> 归纳, 配合步进一致扩张条件 <code>𝒯₊-sub</code> 和 <code>𝒯₊-con</code> 即得. ∎</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯≤-sub"></a><a id="1747" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="1754" class="Symbol">:</a> <a id="1756" href="FOL.TheoryExtension.html#503" class="Generalizable">m</a> <a id="1758" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="1760" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="1762" class="Symbol">→</a> <a id="1764" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1767" href="FOL.TheoryExtension.html#503" class="Generalizable">m</a> <a id="1769" href="Foundation.Set.Powerset.html#920" class="Function Operator">⊆</a> <a id="1771" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1774" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a>
  <a id="1778" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="1785" href="Foundation.Data.Nat.AlternativeOrder.html#325" class="InductiveConstructor">≤-refl</a> <a id="1792" class="Symbol">=</a> <a id="1794" href="Function.Base.html#704" class="Function">id</a>
  <a id="1799" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="1806" class="Symbol">(</a><a id="1807" href="Foundation.Data.Nat.AlternativeOrder.html#344" class="InductiveConstructor">≤-step</a> <a id="1814" href="FOL.TheoryExtension.html#1814" class="Bound">m≤n</a><a id="1817" class="Symbol">)</a> <a id="1819" href="FOL.TheoryExtension.html#1819" class="Bound">∈𝒯ₘ</a> <a id="1823" class="Symbol">=</a> <a id="1825" href="FOL.TheoryExtension.html#1551" class="Field">𝒯₊-sub</a> <a id="1832" class="Symbol">(</a><a id="1833" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="1840" href="FOL.TheoryExtension.html#1814" class="Bound">m≤n</a> <a id="1844" href="FOL.TheoryExtension.html#1819" class="Bound">∈𝒯ₘ</a><a id="1847" class="Symbol">)</a>

  <a id="GeneralizedExtension.𝒯≤-con"></a><a id="1852" href="FOL.TheoryExtension.html#1852" class="Function">𝒯≤-con</a> <a id="1859" class="Symbol">:</a> <a id="1861" href="FOL.TheoryExtension.html#503" class="Generalizable">m</a> <a id="1863" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="1865" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="1867" class="Symbol">→</a> <a id="1869" href="FOL.Syntax.Base.html#7010" class="Function Operator">Con</a> <a id="1873" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1876" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="1878" href="FOL.Syntax.Base.html#7010" class="Function Operator">to</a> <a id="1881" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="1884" href="FOL.TheoryExtension.html#503" class="Generalizable">m</a>
  <a id="1888" href="FOL.TheoryExtension.html#1852" class="Function">𝒯≤-con</a> <a id="1895" href="Foundation.Data.Nat.AlternativeOrder.html#325" class="InductiveConstructor">≤-refl</a> <a id="1902" class="Symbol">=</a> <a id="1904" href="Function.Base.html#704" class="Function">id</a>
  <a id="1909" href="FOL.TheoryExtension.html#1852" class="Function">𝒯≤-con</a> <a id="1916" class="Symbol">(</a><a id="1917" href="Foundation.Data.Nat.AlternativeOrder.html#344" class="InductiveConstructor">≤-step</a> <a id="1924" href="FOL.TheoryExtension.html#1924" class="Bound">m≤n</a><a id="1927" class="Symbol">)</a> <a id="1929" href="FOL.TheoryExtension.html#1929" class="Bound">𝒯₊⊩⊥̇</a> <a id="1935" class="Symbol">=</a> <a id="1937" href="FOL.TheoryExtension.html#1852" class="Function">𝒯≤-con</a> <a id="1944" href="FOL.TheoryExtension.html#1924" class="Bound">m≤n</a> <a id="1948" class="Symbol">(</a><a id="1949" href="FOL.TheoryExtension.html#1582" class="Field">𝒯₊-con</a> <a id="1956" href="FOL.TheoryExtension.html#1929" class="Bound">𝒯₊⊩⊥̇</a><a id="1961" class="Symbol">)</a>
</pre>
<p><strong><u>定义</u></strong> 无穷扩张的所有步骤所得到的理论的并, 叫做无穷扩张的极限, 记作 <code>𝒯ω</code>.</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯ω"></a><a id="2032" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a> <a id="2035" class="Symbol">:</a> <a id="2037" href="FOL.Syntax.Base.html#4795" class="Function">Theory</a>
  <a id="2046" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a> <a id="2049" class="Symbol">=</a> <a id="2051" href="Foundation.Set.Powerset.html#1928" class="Function">⋃ᵢ</a> <a id="2054" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a>
</pre>
<p><strong><u>引理</u></strong> 无穷扩张的极限包含任意一步理论.<br />
<strong><u>证明</u></strong> 依定义即得. ∎</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯ω-sub"></a><a id="2129" href="FOL.TheoryExtension.html#2129" class="Function">𝒯ω-sub</a> <a id="2136" class="Symbol">:</a> <a id="2138" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2141" href="FOL.TheoryExtension.html#505" class="Generalizable">n</a> <a id="2143" href="Foundation.Set.Powerset.html#920" class="Function Operator">⊆</a> <a id="2145" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a>
  <a id="2150" href="FOL.TheoryExtension.html#2129" class="Function">𝒯ω-sub</a> <a id="2157" class="Symbol">=</a> <a id="2159" href="Foundation.Set.Powerset.html#1981" class="Function">⊆⋃ᵢ</a> <a id="2163" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a>
</pre>
<p><strong><u>引理</u></strong> 如果语境 <code>Γ</code> 包含于无穷扩张的极限, 那么 <code>Γ</code> 包含于某一步理论.<br />
<strong><u>证明</u></strong> 对 <code>Γ</code> 的长度归纳.</p>
<ul>
<li>当 <code>Γ</code> 为空列表时, 显然成立.</li>
<li>当 <code>Γ</code> 为 <code>φ ∷ Γ</code> 时, 由归纳假设, 存在 <code>m</code> 使得 <code>Γ</code> 是 <code>𝒯ᵢ m</code> 的子集. 由前提, 存在 <code>n</code> 使得 <code>φ ∈ 𝒯ᵢ n</code>. 由扩张性 <code>𝒯≤-sub</code>, <code>m</code> 和 <code>n</code> 的较大者 <code>o</code> 将使得 <code>φ ∷ Γ</code> 是 <code>𝒯ᵢ o</code> 的子集. ∎</li>
</ul>
<pre class="Agda">  <a id="GeneralizedExtension.⊆𝒯ω→⊆𝒯ₙ"></a><a id="2430" href="FOL.TheoryExtension.html#2430" class="Function">⊆𝒯ω→⊆𝒯ₙ</a> <a id="2438" class="Symbol">:</a> <a id="2440" class="Symbol">∀</a> <a id="2442" href="FOL.TheoryExtension.html#2442" class="Bound">Γ</a> <a id="2444" class="Symbol">→</a> <a id="2446" href="FOL.TheoryExtension.html#2442" class="Bound">Γ</a> <a id="2448" href="Foundation.Set.Powerset%252BList.html#183" class="Function Operator">ᴸ⊆ᴾ</a> <a id="2452" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a> <a id="2455" class="Symbol">→</a> <a id="2457" href="Foundation.Prop.Logic.html#736" class="Function">∃</a> <a id="2459" href="FOL.TheoryExtension.html#2459" class="Bound">n</a> <a id="2461" href="Foundation.Prop.Logic.html#736" class="Function">，</a> <a id="2463" href="FOL.TheoryExtension.html#2442" class="Bound">Γ</a> <a id="2465" href="Foundation.Set.Powerset%252BList.html#183" class="Function Operator">ᴸ⊆ᴾ</a> <a id="2469" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2472" href="FOL.TheoryExtension.html#2459" class="Bound">n</a>
  <a id="2476" href="FOL.TheoryExtension.html#2430" class="Function">⊆𝒯ω→⊆𝒯ₙ</a> <a id="2484" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2487" class="Symbol">_</a> <a id="2489" class="Symbol">=</a> <a id="2491" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="2494" class="Number">0</a> <a id="2496" class="Symbol">λ</a> <a id="2498" class="Symbol">()</a>
  <a id="2503" href="FOL.TheoryExtension.html#2430" class="Function">⊆𝒯ω→⊆𝒯ₙ</a> <a id="2511" class="Symbol">(</a><a id="2512" href="FOL.TheoryExtension.html#2512" class="Bound">φ</a> <a id="2514" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2516" href="FOL.TheoryExtension.html#2516" class="Bound">Γ</a><a id="2517" class="Symbol">)</a> <a id="2519" href="FOL.TheoryExtension.html#2519" class="Bound">Γ⊆l</a> <a id="2523" class="Symbol">=</a> <a id="2525" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="2532" href="FOL.TheoryExtension.html#2598" class="Function">H</a> <a id="2534" class="Symbol">(</a><a id="2535" href="FOL.TheoryExtension.html#2430" class="Function">⊆𝒯ω→⊆𝒯ₙ</a> <a id="2543" href="FOL.TheoryExtension.html#2516" class="Bound">Γ</a> <a id="2545" class="Symbol">λ</a> <a id="2547" href="FOL.TheoryExtension.html#2547" class="Bound">φ∈Γ</a> <a id="2551" class="Symbol">→</a> <a id="2553" href="FOL.TheoryExtension.html#2519" class="Bound">Γ⊆l</a> <a id="2557" class="Symbol">(</a><a id="2558" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2564" href="FOL.TheoryExtension.html#2547" class="Bound">φ∈Γ</a><a id="2567" class="Symbol">))</a> <a id="2570" class="Symbol">(</a><a id="2571" href="FOL.TheoryExtension.html#2519" class="Bound">Γ⊆l</a> <a id="2575" class="Symbol">(</a><a id="2576" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2581" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2585" class="Symbol">))</a> <a id="2588" class="Keyword">where</a>
    <a id="2598" href="FOL.TheoryExtension.html#2598" class="Function">H</a> <a id="2600" class="Symbol">:</a> <a id="2602" href="Foundation.Prelude.Builtin.html#978" class="Function">Σ</a> <a id="2604" href="FOL.TheoryExtension.html#2604" class="Bound">m</a> <a id="2606" href="Foundation.Prelude.Builtin.html#978" class="Function">，</a> <a id="2608" href="FOL.TheoryExtension.html#2516" class="Bound">Γ</a> <a id="2610" href="Foundation.Set.Powerset%252BList.html#183" class="Function Operator">ᴸ⊆ᴾ</a> <a id="2614" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2617" href="FOL.TheoryExtension.html#2604" class="Bound">m</a> <a id="2619" class="Symbol">→</a> <a id="2621" href="Foundation.Prelude.Builtin.html#978" class="Function">Σ</a> <a id="2623" href="FOL.TheoryExtension.html#2623" class="Bound">n</a> <a id="2625" href="Foundation.Prelude.Builtin.html#978" class="Function">，</a> <a id="2627" href="FOL.TheoryExtension.html#2512" class="Bound">φ</a> <a id="2629" href="Foundation.Set.Powerset.html#632" class="Function Operator">∈</a> <a id="2631" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2634" href="FOL.TheoryExtension.html#2623" class="Bound">n</a> <a id="2636" class="Symbol">→</a> <a id="2638" href="Foundation.Prelude.Builtin.html#978" class="Function">Σ</a> <a id="2640" href="FOL.TheoryExtension.html#2640" class="Bound">o</a> <a id="2642" href="Foundation.Prelude.Builtin.html#978" class="Function">，</a> <a id="2644" class="Symbol">(</a><a id="2645" href="FOL.TheoryExtension.html#2512" class="Bound">φ</a> <a id="2647" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2649" href="FOL.TheoryExtension.html#2516" class="Bound">Γ</a><a id="2650" class="Symbol">)</a> <a id="2652" href="Foundation.Set.Powerset%252BList.html#183" class="Function Operator">ᴸ⊆ᴾ</a> <a id="2656" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2659" href="FOL.TheoryExtension.html#2640" class="Bound">o</a>
    <a id="2665" href="FOL.TheoryExtension.html#2598" class="Function">H</a> <a id="2667" class="Symbol">(</a><a id="2668" href="FOL.TheoryExtension.html#2668" class="Bound">m</a> <a id="2670" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2672" href="FOL.TheoryExtension.html#2672" class="Bound">Γ⊆𝒯ₘ</a><a id="2676" class="Symbol">)</a> <a id="2678" class="Symbol">(</a><a id="2679" href="FOL.TheoryExtension.html#2679" class="Bound">n</a> <a id="2681" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2683" href="FOL.TheoryExtension.html#2683" class="Bound">φ∈𝒯ₙ</a><a id="2687" class="Symbol">)</a> <a id="2689" class="Symbol">=</a> <a id="2691" href="Foundation.Data.Nat.html#133" class="Function">max</a> <a id="2695" href="FOL.TheoryExtension.html#2668" class="Bound">m</a> <a id="2697" href="FOL.TheoryExtension.html#2679" class="Bound">n</a> <a id="2699" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a>
      <a id="2707" class="Symbol">λ</a> <a id="2709" class="Symbol">{</a> <a id="2711" class="Symbol">(</a><a id="2712" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2717" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2721" class="Symbol">)</a> <a id="2723" class="Symbol">→</a> <a id="2725" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="2732" href="Foundation.Data.Nat.AlternativeOrder.html#2709" class="Function">≤maxʳ</a> <a id="2738" href="FOL.TheoryExtension.html#2683" class="Bound">φ∈𝒯ₙ</a>
        <a id="2751" class="Symbol">;</a> <a id="2753" class="Symbol">(</a><a id="2754" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2760" href="FOL.TheoryExtension.html#2760" class="Bound">ψ∈Γ</a><a id="2763" class="Symbol">)</a> <a id="2765" class="Symbol">→</a> <a id="2767" href="FOL.TheoryExtension.html#1747" class="Function">𝒯≤-sub</a> <a id="2774" href="Foundation.Data.Nat.AlternativeOrder.html#2651" class="Function">≤maxˡ</a> <a id="2780" class="Symbol">(</a><a id="2781" href="FOL.TheoryExtension.html#2672" class="Bound">Γ⊆𝒯ₘ</a> <a id="2786" href="FOL.TheoryExtension.html#2760" class="Bound">ψ∈Γ</a><a id="2789" class="Symbol">)</a> <a id="2791" class="Symbol">}</a>
</pre>
<p><strong><u>引理</u></strong> 如果无穷扩张的极限可证 <code>φ</code>, 那么存在其中一步理论可证 <code>φ</code>.<br />
<strong><u>证明</u></strong> 由 <code>_⊩_</code> 的定义和引理 <code>⊆𝒯ω→⊆𝒯ₙ</code> 即得. ∎</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯ω⊩→𝒯ₙ⊩"></a><a id="2905" href="FOL.TheoryExtension.html#2905" class="Function">𝒯ω⊩→𝒯ₙ⊩</a> <a id="2913" class="Symbol">:</a> <a id="2915" class="Symbol">∀</a> <a id="2917" class="Symbol">{</a><a id="2918" href="FOL.TheoryExtension.html#2918" class="Bound">φ</a><a id="2919" class="Symbol">}</a> <a id="2921" class="Symbol">→</a> <a id="2923" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a> <a id="2926" href="FOL.Syntax.Base.html#6736" class="Function Operator">⊩</a> <a id="2928" href="FOL.TheoryExtension.html#2918" class="Bound">φ</a> <a id="2930" class="Symbol">→</a> <a id="2932" href="Foundation.Prop.Logic.html#736" class="Function">∃</a> <a id="2934" href="FOL.TheoryExtension.html#2934" class="Bound">n</a> <a id="2936" href="Foundation.Prop.Logic.html#736" class="Function">，</a> <a id="2938" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="2941" href="FOL.TheoryExtension.html#2934" class="Bound">n</a> <a id="2943" href="FOL.Syntax.Base.html#6736" class="Function Operator">⊩</a> <a id="2945" href="FOL.TheoryExtension.html#2918" class="Bound">φ</a>
  <a id="2949" href="FOL.TheoryExtension.html#2905" class="Function">𝒯ω⊩→𝒯ₙ⊩</a> <a id="2957" class="Symbol">(</a><a id="2958" href="FOL.TheoryExtension.html#2958" class="Bound">Γ</a> <a id="2960" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2962" href="FOL.TheoryExtension.html#2962" class="Bound">Γ⊆l</a> <a id="2966" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2968" href="FOL.TheoryExtension.html#2968" class="Bound">Γ⊢φ</a><a id="2971" class="Symbol">)</a> <a id="2973" class="Symbol">=</a> <a id="2975" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="2981" class="Symbol">(λ</a> <a id="2984" class="Symbol">{</a> <a id="2986" class="Symbol">(</a><a id="2987" href="FOL.TheoryExtension.html#2987" class="Bound">n</a> <a id="2989" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2991" href="FOL.TheoryExtension.html#2991" class="Bound">Γ⊆𝒯ᵢ</a><a id="2995" class="Symbol">)</a> <a id="2997" class="Symbol">→</a> <a id="2999" href="FOL.TheoryExtension.html#2987" class="Bound">n</a> <a id="3001" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3003" href="FOL.TheoryExtension.html#2958" class="Bound">Γ</a> <a id="3005" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3007" href="FOL.TheoryExtension.html#2991" class="Bound">Γ⊆𝒯ᵢ</a> <a id="3012" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3014" href="FOL.TheoryExtension.html#2968" class="Bound">Γ⊢φ</a> <a id="3018" class="Symbol">})</a> <a id="3021" class="Symbol">(</a><a id="3022" href="FOL.TheoryExtension.html#2430" class="Function">⊆𝒯ω→⊆𝒯ₙ</a> <a id="3030" href="FOL.TheoryExtension.html#2958" class="Bound">Γ</a> <a id="3032" href="FOL.TheoryExtension.html#2962" class="Bound">Γ⊆l</a><a id="3035" class="Symbol">)</a>
</pre>
<p><strong><u>引理</u></strong> 无穷扩张的极限相对于起始理论一致.<br />
<strong><u>证明</u></strong> 由引理 <code>𝒯ω⊩→𝒯ₙ⊩</code> 和 <code>𝒯≤-con</code> 即得. ∎</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯ω-con"></a><a id="3132" href="FOL.TheoryExtension.html#3132" class="Function">𝒯ω-con</a> <a id="3139" class="Symbol">:</a> <a id="3141" href="FOL.Syntax.Base.html#7010" class="Function Operator">Con</a> <a id="3145" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a> <a id="3148" href="FOL.Syntax.Base.html#7010" class="Function Operator">to</a> <a id="3151" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="3154" class="Number">0</a>
  <a id="3158" href="FOL.TheoryExtension.html#3132" class="Function">𝒯ω-con</a> <a id="3165" href="FOL.TheoryExtension.html#3165" class="Bound">∥𝒯ω⊩⊥̇∥₁</a> <a id="3174" class="Symbol">=</a> <a id="3176" href="Foundation.Prop.Truncation.html#1472" class="Function">𝟙.intro</a> <a id="3184" href="FOL.TheoryExtension.html#3165" class="Bound">∥𝒯ω⊩⊥̇∥₁</a> <a id="3193" class="Symbol">λ</a> <a id="3195" href="FOL.TheoryExtension.html#3195" class="Bound">𝒯ω⊩⊥̇</a> <a id="3201" class="Symbol">→</a>
    <a id="3207" href="Foundation.Prop.Truncation.html#1472" class="Function">𝟙.intro</a> <a id="3215" class="Symbol">(</a><a id="3216" href="FOL.TheoryExtension.html#2905" class="Function">𝒯ω⊩→𝒯ₙ⊩</a> <a id="3224" href="FOL.TheoryExtension.html#3195" class="Bound">𝒯ω⊩⊥̇</a><a id="3229" class="Symbol">)</a> <a id="3231" class="Symbol">λ</a> <a id="3233" class="Symbol">{</a> <a id="3235" class="Symbol">(</a><a id="3236" href="FOL.TheoryExtension.html#3236" class="Bound">n</a> <a id="3238" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3240" href="FOL.TheoryExtension.html#3240" class="Bound">𝒯ₙ⊩⊥̇</a><a id="3245" class="Symbol">)</a> <a id="3247" class="Symbol">→</a> <a id="3249" href="FOL.TheoryExtension.html#1852" class="Function">𝒯≤-con</a> <a id="3256" href="Data.Nat.Properties.html#61866" class="Function">z≤n</a> <a id="3260" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="3262" href="FOL.TheoryExtension.html#3240" class="Bound">𝒯ₙ⊩⊥̇</a> <a id="3268" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="3271" class="Symbol">}</a>
</pre>
<p><strong><u>引理</u></strong> 如果每一步扩张都是闭理论, 那么极限是闭理论.<br />
<strong><u>证明</u></strong> 依定义即得. ∎</p>
<pre class="Agda">  <a id="GeneralizedExtension.𝒯ω-closed"></a><a id="3352" href="FOL.TheoryExtension.html#3352" class="Function">𝒯ω-closed</a> <a id="3362" class="Symbol">:</a> <a id="3364" class="Symbol">(∀</a> <a id="3367" href="FOL.TheoryExtension.html#3367" class="Bound">n</a> <a id="3369" class="Symbol">→</a> <a id="3371" href="FOL.Syntax.FreshVariables.html#4874" class="Function">closedTheory</a> <a id="3384" class="Symbol">(</a><a id="3385" href="FOL.TheoryExtension.html#1531" class="Field">𝒯ᵢ</a> <a id="3388" href="FOL.TheoryExtension.html#3367" class="Bound">n</a><a id="3389" class="Symbol">))</a> <a id="3392" class="Symbol">→</a> <a id="3394" href="FOL.Syntax.FreshVariables.html#4874" class="Function">closedTheory</a> <a id="3407" href="FOL.TheoryExtension.html#2032" class="Function">𝒯ω</a>
  <a id="3412" href="FOL.TheoryExtension.html#3352" class="Function">𝒯ω-closed</a> <a id="3422" href="FOL.TheoryExtension.html#3422" class="Bound">H</a> <a id="3424" href="FOL.TheoryExtension.html#3424" class="Bound">φ</a> <a id="3426" class="Symbol">=</a> <a id="3428" href="Foundation.Prop.Truncation.html#350" class="Function">𝟙.rec</a> <a id="3434" class="Symbol">(</a><a id="3435" href="FOL.Syntax.FreshVariables.html#5736" class="Function">isPredClosed</a> <a id="3448" href="FOL.TheoryExtension.html#3424" class="Bound">φ</a><a id="3449" class="Symbol">)</a> <a id="3451" class="Symbol">λ</a> <a id="3453" class="Symbol">{</a> <a id="3455" class="Symbol">(</a><a id="3456" href="FOL.TheoryExtension.html#3456" class="Bound">m</a> <a id="3458" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3460" href="FOL.TheoryExtension.html#3460" class="Bound">φ∈𝒯ₘ</a><a id="3464" class="Symbol">)</a> <a id="3466" class="Symbol">→</a> <a id="3468" href="FOL.TheoryExtension.html#3422" class="Bound">H</a> <a id="3470" href="FOL.TheoryExtension.html#3456" class="Bound">m</a> <a id="3472" href="FOL.TheoryExtension.html#3424" class="Bound">φ</a> <a id="3474" href="FOL.TheoryExtension.html#3460" class="Bound">φ∈𝒯ₘ</a> <a id="3479" class="Symbol">}</a>
</pre>
<h3 id="henkin扩张">Henkin扩张</h3>
<p>这里讲的Henkin扩张采用 <a href="https://pauillac.inria.fr/~herbelin/articles/godel-completeness-draft16.pdf">Herbelin 和 Ilik</a> 对原版Henkin扩张的构造主义改良版本.</p>
<p>module HenkinExtension ((𝒯ⁱ , 𝒯ⁱ-closed) : ClosedTheory) where open SetOperation (discreteSet {A = Formula})</p>
<p>isℋ : Theory → 𝕋₁ isℋ 𝒯 = ∀ 𝒯′ φ → 𝒯 ⊆ 𝒯′ → (∀ t → ∥ 𝒯′ ⊩ φ [ t ]₀ ∥₁) → ∥ 𝒯′ ⊩ ∀̇ φ ∥₁</p>
<p>Ax : ℕ → Formula Ax n = (Ψ n) [ # n ]₀ →̇ ∀̇ (Ψ n)</p>
<p>ℋᵢ : ℕ → Theory ℋᵢ zero = 𝒯ⁱ ℋᵢ (suc n) = ℋᵢ n ⨭ Ax n</p>
<p>ℋ₊-sub : ℋᵢ n ⊆ ℋᵢ (suc n) ℋ₊-sub {n} = ⊆⨭ (ℋᵢ n)</p>
<p>ℋ₊-con : Con (ℋᵢ (suc n)) to (ℋᵢ n) ℋ₊-con = 𝟙.map ℋ₊-⊩⊥̇ where ℋ₊-⊩⊥̇ : ℋᵢ (suc n) ⊩ ⊥̇ → ℋᵢ n ⊩ ⊥̇ ℋ₊-⊩⊥̇ (Γ , Γ⊆ℋ₊ , Γ⊢) = {! !} where H1 : freshᵩ n (Ψ n) H1 = Ψ-fresh ≤-refl</p>
<p>open GeneralizedExtension (mkGenExt ℋᵢ ℋ₊-sub ℋ₊-con) public renaming ( 𝒯ω to ℋω ; 𝒯ω-sub to ℋω-sub ; 𝒯ω-con to ℋω-con ; 𝒯ω-closed to ℋω-closed )</p>
<p>ℋω-isℋ-Ψ : ∀ 𝒯 → ℋω ⊆ 𝒯 → 𝒯 ⊩ (Ψ n [ # n ]₀) → 𝒯 ⊩ (∀̇ (Ψ n)) ℋω-isℋ-Ψ {n} 𝒯 ℋω⊆𝒯 (Γ , Γ⊆𝒯 , Γ⊢) = Ax n ∷ Γ , ∷⊆𝒯 , ∷⊢∀̇ where ∷⊆𝒯 : (Ax n ∷ Γ) ᴸ⊆ᴾ 𝒯 ∷⊆𝒯 (here refl) = ℋω⊆𝒯 (ex (suc n) (inr refl)) ∷⊆𝒯 (there φ∈Γ) = Γ⊆𝒯 φ∈Γ ∷⊢∀̇ : (Ax n ∷ Γ) ⊢ ∀̇ (Ψ n) ∷⊢∀̇ = ImpE (Ctx (here refl)) (Wkn there Γ⊢)</p>
<p>ℋω-isℋ : isℋ ℋω ℋω-isℋ 𝒯 φ ℋω⊆𝒯 H∀ = 𝟙.rec 𝟙.squash H (Ψ-wit φ) where H : Σ n ， Ψ n ≡ φ → ∥ 𝒯 ⊩ (∀̇ φ) ∥₁ H (n , refl) = 𝟙.map (ℋω-isℋ-Ψ 𝒯 ℋω⊆𝒯) (H∀ (# n))</p>
<h3 id="极大一致扩张">极大一致扩张</h3>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/TheoryExtension.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.TheoryExtension.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.extension">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
