<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Language</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语言" id="toc-一阶逻辑-语言">一阶逻辑 ▸ 语言</a></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语言">一阶逻辑 ▸ 语言</h1>
<p>一阶逻辑是一种形式语言, 其语句由一些原始符号按一定的语法组合而成. 符号又分为逻辑符号和非逻辑符号. 本篇先讲非逻辑符号.</p>
<p>非逻辑符号分为函数符号和关系符号, 且它们都带有一个称为元数 (arity) 的属性. 例如, 元数为 2 的函数符号即用于表示二元函数. 特别地, 元数为零的函数又称为常量.</p>
<p>较传统的处理方式是给出所有可能的函数符号和关系符号. 即对任意元数 <span class="math inline">n</span>, 都有自然数多个函数符号</p>
<p><span class="math display">f^n_0,\ f^n_1,\ f^n_2,\ f^n_3,\ ...</span></p>
<p>以及自然数多个关系符号</p>
<p><span class="math display">R^n_0,\ R^n_1,\ R^n_2,\ R^n_3,\ ...</span></p>
<p>在这种处理下, 只有唯一一种一阶逻辑语言.</p>
<p>较现代的方式是根据最终要实现的一阶逻辑语言来指定该理论所需的非逻辑符号. 这些特定的符号以及它们的元数所组成的资料叫做理论的<strong>签名 (signature)</strong>. 在这种处理下, 每种签名都对应一种一阶逻辑语言, 因此签名又叫做<strong>语言 (language)</strong>, 语言的实例按惯例记作 ℒ. 由于一阶逻辑的其他部分都是参数化到语言的, 我们把它单独作为一个模块.</p>
<pre class="Agda"><a id="557" class="Keyword">open</a> <a id="562" class="Keyword">import</a> <a id="569" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>

<a id="591" class="Keyword">module</a> <a id="598" href="FOL.Language.html" class="Module">FOL.Language</a> <a id="611" class="Keyword">where</a>
</pre>
<p><strong><u>定义</u></strong> 一阶逻辑的语言 <code>ℒ</code> 是一个六元组</p>
<ul>
<li>离散的函数符号集 <code>𝓕</code></li>
<li>离散的关系符号集 <code>𝓡</code></li>
<li><code>𝓕</code> 到元数的映射 <code>∣_∣ᶠ</code></li>
<li><code>𝓡</code> 到元数的映射 <code>∣_∣ᴿ</code></li>
<li><code>𝓕</code> 的一个枚举</li>
<li><code>𝓡</code> 的一个枚举</li>
</ul>
<pre class="Agda"><a id="759" class="Keyword">record</a> <a id="Language"></a><a id="766" href="FOL.Language.html#766" class="Record">Language</a> <a id="775" class="Symbol">:</a> <a id="777" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a> <a id="780" class="Keyword">where</a>
  <a id="788" class="Keyword">constructor</a> <a id="mkLang"></a><a id="800" href="FOL.Language.html#800" class="InductiveConstructor">mkLang</a>
  <a id="809" class="Keyword">field</a>
    <a id="Language.𝓕"></a><a id="819" href="FOL.Language.html#819" class="Field">𝓕</a> <a id="821" class="Symbol">:</a> <a id="823" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.𝓡"></a><a id="829" href="FOL.Language.html#829" class="Field">𝓡</a> <a id="831" class="Symbol">:</a> <a id="833" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.∣_∣ᶠ"></a><a id="839" href="FOL.Language.html#839" class="Field Operator">∣_∣ᶠ</a> <a id="844" class="Symbol">:</a> <a id="846" href="FOL.Language.html#819" class="Field">𝓕</a> <a id="848" class="Symbol">→</a> <a id="850" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.∣_∣ᴿ"></a><a id="856" href="FOL.Language.html#856" class="Field Operator">∣_∣ᴿ</a> <a id="861" class="Symbol">:</a> <a id="863" href="FOL.Language.html#829" class="Field">𝓡</a> <a id="865" class="Symbol">→</a> <a id="867" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.discr𝓡"></a><a id="873" href="FOL.Language.html#873" class="Field">discr𝓡</a> <a id="880" class="Symbol">:</a> <a id="882" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="891" href="FOL.Language.html#829" class="Field">𝓡</a>
    <a id="Language.discr𝓕"></a><a id="897" href="FOL.Language.html#897" class="Field">discr𝓕</a> <a id="904" class="Symbol">:</a> <a id="906" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="915" href="FOL.Language.html#819" class="Field">𝓕</a>
    <a id="Language.enum𝓕"></a><a id="921" href="FOL.Language.html#921" class="Field">enum𝓕</a> <a id="927" class="Symbol">:</a> <a id="929" href="Foundation.Relation.Unary.Enumerable.html#2191" class="Function">Enum</a> <a id="934" href="FOL.Language.html#819" class="Field">𝓕</a>
    <a id="Language.enum𝓡"></a><a id="940" href="FOL.Language.html#940" class="Field">enum𝓡</a> <a id="946" class="Symbol">:</a> <a id="948" href="Foundation.Relation.Unary.Enumerable.html#2191" class="Function">Enum</a> <a id="953" href="FOL.Language.html#829" class="Field">𝓡</a>
</pre>
<p>注意, 在经典语境下集合一定是离散的, 但在直觉主义 HoTT 中, 离散强于“集合”. 因此当我们要求某 <code>A</code> 是“离散集”的时候, 实际上只要求它是离散类型, 然后它自然是一个集合.</p>
<p><strong><u>定理</u></strong> <code>𝓕</code> 和 <code>𝓡</code> 都是可数集.</p>
<pre class="Agda">  <a id="Language.count𝓕"></a><a id="1098" href="FOL.Language.html#1098" class="Function">count𝓕</a> <a id="1105" class="Symbol">:</a> <a id="1107" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1117" href="FOL.Language.html#819" class="Field">𝓕</a>
  <a id="1121" href="FOL.Language.html#1098" class="Function">count𝓕</a> <a id="1128" class="Symbol">=</a> <a id="1130" href="Foundation.Relation.Unary.Enumerable.html#9081" class="Function">discr→enum→count</a> <a id="1147" href="FOL.Language.html#897" class="Field">discr𝓕</a> <a id="1154" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="1156" href="FOL.Language.html#921" class="Field">enum𝓕</a> <a id="1162" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>

  <a id="Language.count𝓡"></a><a id="1168" href="FOL.Language.html#1168" class="Function">count𝓡</a> <a id="1175" class="Symbol">:</a> <a id="1177" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1187" href="FOL.Language.html#829" class="Field">𝓡</a>
  <a id="1191" href="FOL.Language.html#1168" class="Function">count𝓡</a> <a id="1198" class="Symbol">=</a> <a id="1200" href="Foundation.Relation.Unary.Enumerable.html#9081" class="Function">discr→enum→count</a> <a id="1217" href="FOL.Language.html#873" class="Field">discr𝓡</a> <a id="1224" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="1226" href="FOL.Language.html#940" class="Field">enum𝓡</a> <a id="1232" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>

  <a id="Language.isSet𝓕"></a><a id="1238" href="FOL.Language.html#1238" class="Function">isSet𝓕</a> <a id="1245" class="Symbol">:</a> <a id="1247" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1253" href="FOL.Language.html#819" class="Field">𝓕</a>
  <a id="1257" href="FOL.Language.html#1238" class="Function">isSet𝓕</a> <a id="1264" class="Symbol">=</a> <a id="1266" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1281" href="FOL.Language.html#897" class="Field">discr𝓕</a>

  <a id="Language.isSet𝓡"></a><a id="1291" href="FOL.Language.html#1291" class="Function">isSet𝓡</a> <a id="1298" class="Symbol">:</a> <a id="1300" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1306" href="FOL.Language.html#829" class="Field">𝓡</a>
  <a id="1310" href="FOL.Language.html#1291" class="Function">isSet𝓡</a> <a id="1317" class="Symbol">=</a> <a id="1319" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1334" href="FOL.Language.html#873" class="Field">discr𝓡</a>
</pre>
<p><strong><u>例</u></strong> 下面给出了语言的一个实例 <code>ℒ</code>, 它可以作为皮亚诺算术的语言.</p>
<pre class="Agda"><a id="1401" class="Keyword">private</a> <a id="1409" class="Keyword">module</a> <a id="ExampleLanguagePA"></a><a id="1416" href="FOL.Language.html#1416" class="Module">ExampleLanguagePA</a> <a id="1434" class="Keyword">where</a>

  <a id="1443" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓕"></a><a id="1448" href="FOL.Language.html#1448" class="Datatype">𝓕</a> <a id="1450" class="Symbol">:</a> <a id="1452" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1454" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓕.O"></a><a id="1464" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1466" class="Symbol">:</a> <a id="1468" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.S"></a><a id="1474" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1476" class="Symbol">:</a> <a id="1478" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.+"></a><a id="1484" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1486" class="Symbol">:</a> <a id="1488" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.*"></a><a id="1494" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1496" class="Symbol">:</a> <a id="1498" href="FOL.Language.html#1448" class="Datatype">𝓕</a>

  <a id="1503" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓡"></a><a id="1508" href="FOL.Language.html#1508" class="Datatype">𝓡</a> <a id="1510" class="Symbol">:</a> <a id="1512" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1514" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓡.&lt;"></a><a id="1524" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="1526" class="Symbol">:</a> <a id="1528" href="FOL.Language.html#1508" class="Datatype">𝓡</a>

  <a id="ExampleLanguagePA.∣_∣ᶠ"></a><a id="1533" href="FOL.Language.html#1533" class="Function Operator">∣_∣ᶠ</a> <a id="1538" class="Symbol">:</a> <a id="1540" href="FOL.Language.html#1448" class="Datatype">𝓕</a> <a id="1542" class="Symbol">→</a> <a id="1544" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="1548" href="FOL.Language.html#1533" class="Function Operator">∣</a> <a id="1550" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1552" href="FOL.Language.html#1533" class="Function Operator">∣ᶠ</a> <a id="1555" class="Symbol">=</a> <a id="1557" class="Number">0</a>
  <a id="1561" href="FOL.Language.html#1533" class="Function Operator">∣</a> <a id="1563" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1565" href="FOL.Language.html#1533" class="Function Operator">∣ᶠ</a> <a id="1568" class="Symbol">=</a> <a id="1570" class="Number">1</a>
  <a id="1574" href="FOL.Language.html#1533" class="Function Operator">∣</a> <a id="1576" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1578" href="FOL.Language.html#1533" class="Function Operator">∣ᶠ</a> <a id="1581" class="Symbol">=</a> <a id="1583" class="Number">2</a>
  <a id="1587" href="FOL.Language.html#1533" class="Function Operator">∣</a> <a id="1589" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1591" href="FOL.Language.html#1533" class="Function Operator">∣ᶠ</a> <a id="1594" class="Symbol">=</a> <a id="1596" class="Number">2</a>

  <a id="ExampleLanguagePA.∣_∣ᴿ"></a><a id="1601" href="FOL.Language.html#1601" class="Function Operator">∣_∣ᴿ</a> <a id="1606" class="Symbol">:</a> <a id="1608" href="FOL.Language.html#1508" class="Datatype">𝓡</a> <a id="1610" class="Symbol">→</a> <a id="1612" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="1616" href="FOL.Language.html#1601" class="Function Operator">∣</a> <a id="1618" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="1620" href="FOL.Language.html#1601" class="Function Operator">∣ᴿ</a> <a id="1623" class="Symbol">=</a> <a id="1625" class="Number">2</a>
</pre>
<p>通过模式匹配不难证明归纳定义的 <code>𝓕</code> 和 <code>𝓡</code> 是离散且可枚举的.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.discr𝓕"></a><a id="1679" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1686" class="Symbol">:</a> <a id="1688" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="1697" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
  <a id="1701" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1708" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1710" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1712" class="Symbol">=</a> <a id="1714" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1718" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1725" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1732" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1734" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1736" class="Symbol">=</a> <a id="1738" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1742" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1749" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1756" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1758" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1760" class="Symbol">=</a> <a id="1762" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1766" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1773" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1780" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1782" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1784" class="Symbol">=</a> <a id="1786" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1790" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1797" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1804" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1806" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1808" class="Symbol">=</a> <a id="1810" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1813" class="Symbol">λ</a> <a id="1815" class="Symbol">()</a>
  <a id="1820" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1827" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1829" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1831" class="Symbol">=</a> <a id="1833" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1836" class="Symbol">λ</a> <a id="1838" class="Symbol">()</a>
  <a id="1843" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1850" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1852" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1854" class="Symbol">=</a> <a id="1856" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1859" class="Symbol">λ</a> <a id="1861" class="Symbol">()</a>
  <a id="1866" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1873" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1875" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1877" class="Symbol">=</a> <a id="1879" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1882" class="Symbol">λ</a> <a id="1884" class="Symbol">()</a>
  <a id="1889" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1896" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1898" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1900" class="Symbol">=</a> <a id="1902" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1905" class="Symbol">λ</a> <a id="1907" class="Symbol">()</a>
  <a id="1912" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1919" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1921" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1923" class="Symbol">=</a> <a id="1925" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1928" class="Symbol">λ</a> <a id="1930" class="Symbol">()</a>
  <a id="1935" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1942" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1944" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="1946" class="Symbol">=</a> <a id="1948" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1951" class="Symbol">λ</a> <a id="1953" class="Symbol">()</a>
  <a id="1958" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1965" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1967" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="1969" class="Symbol">=</a> <a id="1971" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1974" class="Symbol">λ</a> <a id="1976" class="Symbol">()</a>
  <a id="1981" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="1988" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="1990" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="1992" class="Symbol">=</a> <a id="1994" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1997" class="Symbol">λ</a> <a id="1999" class="Symbol">()</a>
  <a id="2004" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="2011" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="2013" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="2015" class="Symbol">=</a> <a id="2017" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2020" class="Symbol">λ</a> <a id="2022" class="Symbol">()</a>
  <a id="2027" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="2034" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="2036" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="2038" class="Symbol">=</a> <a id="2040" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2043" class="Symbol">λ</a> <a id="2045" class="Symbol">()</a>
  <a id="2050" href="FOL.Language.html#1679" class="Function">discr𝓕</a> <a id="2057" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="2059" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="2061" class="Symbol">=</a> <a id="2063" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2066" class="Symbol">λ</a> <a id="2068" class="Symbol">()</a>

  <a id="ExampleLanguagePA.discr𝓡"></a><a id="2074" href="FOL.Language.html#2074" class="Function">discr𝓡</a> <a id="2081" class="Symbol">:</a> <a id="2083" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="2092" href="FOL.Language.html#1508" class="Datatype">𝓡</a>
  <a id="2096" href="FOL.Language.html#2074" class="Function">discr𝓡</a> <a id="2103" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="2105" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="2107" class="Symbol">=</a> <a id="2109" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2113" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="ExampleLanguagePA.enum𝓕"></a><a id="2121" href="FOL.Language.html#2121" class="Function">enum𝓕</a> <a id="2127" class="Symbol">:</a> <a id="2129" href="Foundation.Relation.Unary.Enumerable.html#2191" class="Function">Enum</a> <a id="2134" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
  <a id="2138" href="FOL.Language.html#2121" class="Function">enum𝓕</a> <a id="2144" class="Symbol">=</a> <a id="2146" class="Symbol">(λ</a> <a id="2149" href="FOL.Language.html#2149" class="Bound">_</a> <a id="2151" class="Symbol">→</a> <a id="2153" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="2155" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2157" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="2159" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2161" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="2163" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2165" href="Data.List.Base.html#5240" class="Function Operator">[</a> <a id="2167" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="2169" href="Data.List.Base.html#5240" class="Function Operator">]</a><a id="2170" class="Symbol">)</a> <a id="2172" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2174" class="Symbol">(λ</a> <a id="2177" href="FOL.Language.html#2177" class="Bound">_</a> <a id="2179" class="Symbol">→</a> <a id="2181" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2184" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2186" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2190" class="Symbol">)</a> <a id="2192" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a>
    <a id="2198" class="Symbol">λ</a> <a id="2200" class="Symbol">{</a> <a id="2202" href="FOL.Language.html#1464" class="InductiveConstructor">O</a> <a id="2204" class="Symbol">→</a> <a id="2206" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2209" class="Number">0</a> <a id="2211" class="Symbol">(</a><a id="2212" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2217" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2221" class="Symbol">)</a>
      <a id="2229" class="Symbol">;</a> <a id="2231" href="FOL.Language.html#1474" class="InductiveConstructor">S</a> <a id="2233" class="Symbol">→</a> <a id="2235" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2238" class="Number">0</a> <a id="2240" class="Symbol">(</a><a id="2241" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2247" class="Symbol">(</a><a id="2248" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2253" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2257" class="Symbol">))</a>
      <a id="2266" class="Symbol">;</a> <a id="2268" href="FOL.Language.html#1484" class="InductiveConstructor">+</a> <a id="2270" class="Symbol">→</a> <a id="2272" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2275" class="Number">0</a> <a id="2277" class="Symbol">(</a><a id="2278" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2284" class="Symbol">(</a><a id="2285" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2291" class="Symbol">(</a><a id="2292" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2297" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2301" class="Symbol">)))</a>
      <a id="2311" class="Symbol">;</a> <a id="2313" href="FOL.Language.html#1494" class="InductiveConstructor">*</a> <a id="2315" class="Symbol">→</a> <a id="2317" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2320" class="Number">0</a> <a id="2322" class="Symbol">(</a><a id="2323" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2329" class="Symbol">(</a><a id="2330" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2336" class="Symbol">(</a><a id="2337" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2343" class="Symbol">(</a><a id="2344" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2349" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2353" class="Symbol">))))</a> <a id="2358" class="Symbol">}</a>

  <a id="ExampleLanguagePA.enum𝓡"></a><a id="2363" href="FOL.Language.html#2363" class="Function">enum𝓡</a> <a id="2369" class="Symbol">:</a> <a id="2371" href="Foundation.Relation.Unary.Enumerable.html#2191" class="Function">Enum</a> <a id="2376" href="FOL.Language.html#1508" class="Datatype">𝓡</a>
  <a id="2380" href="FOL.Language.html#2363" class="Function">enum𝓡</a> <a id="2386" class="Symbol">=</a> <a id="2388" class="Symbol">(λ</a> <a id="2391" href="FOL.Language.html#2391" class="Bound">_</a> <a id="2393" class="Symbol">→</a> <a id="2395" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="2397" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2399" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2401" class="Symbol">)</a> <a id="2403" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2405" class="Symbol">(λ</a> <a id="2408" href="FOL.Language.html#2408" class="Bound">_</a> <a id="2410" class="Symbol">→</a> <a id="2412" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2415" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2417" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2421" class="Symbol">)</a> <a id="2423" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a>
    <a id="2429" class="Symbol">λ</a> <a id="2431" class="Symbol">{</a> <a id="2433" href="FOL.Language.html#1524" class="InductiveConstructor">&lt;</a> <a id="2435" class="Symbol">→</a> <a id="2437" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2440" class="Number">0</a> <a id="2442" class="Symbol">(</a><a id="2443" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2448" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2452" class="Symbol">)</a> <a id="2454" class="Symbol">}</a>
</pre>
<p>于是它们可以构成语言.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.ℒ"></a><a id="2484" href="FOL.Language.html#2484" class="Function">ℒ</a> <a id="2486" class="Symbol">:</a> <a id="2488" href="FOL.Language.html#766" class="Record">Language</a>
  <a id="2499" href="FOL.Language.html#2484" class="Function">ℒ</a> <a id="2501" class="Symbol">=</a> <a id="2503" class="Keyword">record</a>
    <a id="2514" class="Symbol">{</a> <a id="2516" href="FOL.Language.html#819" class="Field">𝓕</a> <a id="2518" class="Symbol">=</a> <a id="2520" href="FOL.Language.html#1448" class="Datatype">𝓕</a>
    <a id="2526" class="Symbol">;</a> <a id="2528" href="FOL.Language.html#829" class="Field">𝓡</a> <a id="2530" class="Symbol">=</a> <a id="2532" href="FOL.Language.html#1508" class="Datatype">𝓡</a>
    <a id="2538" class="Symbol">;</a> <a id="2540" href="FOL.Language.html#839" class="Field Operator">∣_∣ᶠ</a> <a id="2545" class="Symbol">=</a> <a id="2547" href="FOL.Language.html#1533" class="Function Operator">∣_∣ᶠ</a>
    <a id="2556" class="Symbol">;</a> <a id="2558" href="FOL.Language.html#856" class="Field Operator">∣_∣ᴿ</a> <a id="2563" class="Symbol">=</a> <a id="2565" href="FOL.Language.html#1601" class="Function Operator">∣_∣ᴿ</a>
    <a id="2574" class="Symbol">;</a> <a id="2576" href="FOL.Language.html#897" class="Field">discr𝓕</a> <a id="2583" class="Symbol">=</a> <a id="2585" href="FOL.Language.html#1679" class="Function">discr𝓕</a>
    <a id="2596" class="Symbol">;</a> <a id="2598" href="FOL.Language.html#873" class="Field">discr𝓡</a> <a id="2605" class="Symbol">=</a> <a id="2607" href="FOL.Language.html#2074" class="Function">discr𝓡</a>
    <a id="2618" class="Symbol">;</a> <a id="2620" href="FOL.Language.html#921" class="Field">enum𝓕</a> <a id="2626" class="Symbol">=</a> <a id="2628" href="FOL.Language.html#2121" class="Function">enum𝓕</a>
    <a id="2638" class="Symbol">;</a> <a id="2640" href="FOL.Language.html#940" class="Field">enum𝓡</a> <a id="2646" class="Symbol">=</a> <a id="2648" href="FOL.Language.html#2363" class="Function">enum𝓡</a>
    <a id="2658" class="Symbol">}</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Language.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Language.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.language">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
