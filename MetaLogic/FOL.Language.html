<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Language</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语言" id="toc-一阶逻辑-语言">一阶逻辑: 语言</a></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语言">一阶逻辑: 语言</h1>
<p>一阶逻辑是一种形式语言, 其语句由一些原始符号按一定的语法组合而成. 符号又分为逻辑符号和非逻辑符号. 本篇先讲非逻辑符号.</p>
<p>非逻辑符号分为函数符号和关系符号, 且它们都带有一个称为元数 (arity) 的属性. 例如, 元数为 2 的函数符号即用于表示二元函数. 特别地, 元数为零的函数又称为常量.</p>
<p>较传统的处理方式是给出所有可能的函数符号和关系符号. 即对任意元数 <span class="math inline">n</span>, 都有自然数多个函数符号</p>
<p><span class="math display">f^n_0,\ f^n_1,\ f^n_2,\ f^n_3,\ ...</span></p>
<p>以及自然数多个关系符号</p>
<p><span class="math display">R^n_0,\ R^n_1,\ R^n_2,\ R^n_3,\ ...</span></p>
<p>在这种处理下, 只有唯一一种一阶逻辑语言.</p>
<p>较现代的方式是根据最终要实现的一阶逻辑语言来指定该理论所需的非逻辑符号. 这些特定的符号以及它们的元数所组成的资料叫做理论的<strong>签名 (signature)</strong>. 在这种处理下, 每种签名都对应一种一阶逻辑语言, 因此签名又叫做<strong>语言 (language)</strong>, 语言的实例按惯例记作 ℒ. 由于一阶逻辑的其他部分都是参数化到语言的, 我们把它单独作为一个模块.</p>
<pre class="Agda"><a id="556" class="Keyword">open</a> <a id="561" class="Keyword">import</a> <a id="568" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>

<a id="590" class="Keyword">module</a> <a id="597" href="FOL.Language.html" class="Module">FOL.Language</a> <a id="610" class="Keyword">where</a>
</pre>
<p><strong><u>定义</u></strong> 一阶逻辑的语言 <code>ℒ</code> 是一个四元组</p>
<ul>
<li>离散且可枚举的函数符号集 <code>𝓕</code></li>
<li>离散且可枚举的关系符号集 <code>𝓡</code></li>
<li><code>𝓕</code> 到元数的映射 <code>∣_∣ᶠ</code></li>
<li><code>𝓡</code> 到元数的映射 <code>∣_∣ᴿ</code></li>
</ul>
<pre class="Agda"><a id="742" class="Keyword">record</a> <a id="Language"></a><a id="749" href="FOL.Language.html#749" class="Record">Language</a> <a id="758" class="Symbol">:</a> <a id="760" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a> <a id="763" class="Keyword">where</a>
  <a id="771" class="Keyword">field</a>
    <a id="Language.𝓕"></a><a id="781" href="FOL.Language.html#781" class="Field">𝓕</a> <a id="783" class="Symbol">:</a> <a id="785" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.𝓡"></a><a id="791" href="FOL.Language.html#791" class="Field">𝓡</a> <a id="793" class="Symbol">:</a> <a id="795" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.∣_∣ᶠ"></a><a id="801" href="FOL.Language.html#801" class="Field Operator">∣_∣ᶠ</a> <a id="806" class="Symbol">:</a> <a id="808" href="FOL.Language.html#781" class="Field">𝓕</a> <a id="810" class="Symbol">→</a> <a id="812" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.∣_∣ᴿ"></a><a id="818" href="FOL.Language.html#818" class="Field Operator">∣_∣ᴿ</a> <a id="823" class="Symbol">:</a> <a id="825" href="FOL.Language.html#791" class="Field">𝓡</a> <a id="827" class="Symbol">→</a> <a id="829" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.discr𝓕"></a><a id="835" href="FOL.Language.html#835" class="Field">discr𝓕</a> <a id="842" class="Symbol">:</a> <a id="844" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="853" href="FOL.Language.html#781" class="Field">𝓕</a>
    <a id="Language.discr𝓡"></a><a id="859" href="FOL.Language.html#859" class="Field">discr𝓡</a> <a id="866" class="Symbol">:</a> <a id="868" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="877" href="FOL.Language.html#791" class="Field">𝓡</a>
    <a id="Language.enum𝓕"></a><a id="883" href="FOL.Language.html#883" class="Field">enum𝓕</a> <a id="889" class="Symbol">:</a> <a id="891" href="Foundation.Relation.Unary.Enumerable.html#2531" class="Function">enumerable</a> <a id="902" href="FOL.Language.html#781" class="Field">𝓕</a>
    <a id="Language.enum𝓡"></a><a id="908" href="FOL.Language.html#908" class="Field">enum𝓡</a> <a id="914" class="Symbol">:</a> <a id="916" href="Foundation.Relation.Unary.Enumerable.html#2531" class="Function">enumerable</a> <a id="927" href="FOL.Language.html#791" class="Field">𝓡</a>
</pre>
<p>注意, 在经典语境下集合一定是离散的, 但在直觉主义 HoTT 中, 离散强于“集合”. 因此当我们要求某 <code>A</code> 是“离散集”的时候, 实际上只要求它是离散类型, 然后它自然是一个集合.</p>
<p><strong><u>定理</u></strong> <code>𝓕</code> 和 <code>𝓡</code> 都是可数集.</p>
<pre class="Agda">  <a id="Language.count𝓕"></a><a id="1072" href="FOL.Language.html#1072" class="Function">count𝓕</a> <a id="1079" class="Symbol">:</a> <a id="1081" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1091" href="FOL.Language.html#781" class="Field">𝓕</a>
  <a id="1095" href="FOL.Language.html#1072" class="Function">count𝓕</a> <a id="1102" class="Symbol">=</a> <a id="1104" href="Foundation.Relation.Unary.Enumerable.html#9081" class="Function">discr→enum→count</a> <a id="1121" href="FOL.Language.html#835" class="Field">discr𝓕</a> <a id="1128" href="FOL.Language.html#883" class="Field">enum𝓕</a>

  <a id="Language.count𝓡"></a><a id="1137" href="FOL.Language.html#1137" class="Function">count𝓡</a> <a id="1144" class="Symbol">:</a> <a id="1146" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1156" href="FOL.Language.html#791" class="Field">𝓡</a>
  <a id="1160" href="FOL.Language.html#1137" class="Function">count𝓡</a> <a id="1167" class="Symbol">=</a> <a id="1169" href="Foundation.Relation.Unary.Enumerable.html#9081" class="Function">discr→enum→count</a> <a id="1186" href="FOL.Language.html#859" class="Field">discr𝓡</a> <a id="1193" href="FOL.Language.html#908" class="Field">enum𝓡</a>

  <a id="Language.isSet𝓕"></a><a id="1202" href="FOL.Language.html#1202" class="Function">isSet𝓕</a> <a id="1209" class="Symbol">:</a> <a id="1211" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1217" href="FOL.Language.html#781" class="Field">𝓕</a>
  <a id="1221" href="FOL.Language.html#1202" class="Function">isSet𝓕</a> <a id="1228" class="Symbol">=</a> <a id="1230" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1245" href="FOL.Language.html#835" class="Field">discr𝓕</a>

  <a id="Language.isSet𝓡"></a><a id="1255" href="FOL.Language.html#1255" class="Function">isSet𝓡</a> <a id="1262" class="Symbol">:</a> <a id="1264" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1270" href="FOL.Language.html#791" class="Field">𝓡</a>
  <a id="1274" href="FOL.Language.html#1255" class="Function">isSet𝓡</a> <a id="1281" class="Symbol">=</a> <a id="1283" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1298" href="FOL.Language.html#859" class="Field">discr𝓡</a>
</pre>
<p><strong><u>例</u></strong> 下面给出了语言的一个实例 <code>ℒ</code>, 它可以作为皮亚诺算术的语言.</p>
<pre class="Agda"><a id="1365" class="Keyword">private</a> <a id="1373" class="Keyword">module</a> <a id="ExampleLanguagePA"></a><a id="1380" href="FOL.Language.html#1380" class="Module">ExampleLanguagePA</a> <a id="1398" class="Keyword">where</a>

  <a id="1407" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓕"></a><a id="1412" href="FOL.Language.html#1412" class="Datatype">𝓕</a> <a id="1414" class="Symbol">:</a> <a id="1416" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1418" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓕.O"></a><a id="1428" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1430" class="Symbol">:</a> <a id="1432" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.S"></a><a id="1438" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1440" class="Symbol">:</a> <a id="1442" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.+"></a><a id="1448" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1450" class="Symbol">:</a> <a id="1452" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.*"></a><a id="1458" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1460" class="Symbol">:</a> <a id="1462" href="FOL.Language.html#1412" class="Datatype">𝓕</a>

  <a id="1467" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓡"></a><a id="1472" href="FOL.Language.html#1472" class="Datatype">𝓡</a> <a id="1474" class="Symbol">:</a> <a id="1476" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1478" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓡.&lt;"></a><a id="1488" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="1490" class="Symbol">:</a> <a id="1492" href="FOL.Language.html#1472" class="Datatype">𝓡</a>

  <a id="ExampleLanguagePA.∣_∣ᶠ"></a><a id="1497" href="FOL.Language.html#1497" class="Function Operator">∣_∣ᶠ</a> <a id="1502" class="Symbol">:</a> <a id="1504" href="FOL.Language.html#1412" class="Datatype">𝓕</a> <a id="1506" class="Symbol">→</a> <a id="1508" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="1512" href="FOL.Language.html#1497" class="Function Operator">∣</a> <a id="1514" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1516" href="FOL.Language.html#1497" class="Function Operator">∣ᶠ</a> <a id="1519" class="Symbol">=</a> <a id="1521" class="Number">0</a>
  <a id="1525" href="FOL.Language.html#1497" class="Function Operator">∣</a> <a id="1527" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1529" href="FOL.Language.html#1497" class="Function Operator">∣ᶠ</a> <a id="1532" class="Symbol">=</a> <a id="1534" class="Number">1</a>
  <a id="1538" href="FOL.Language.html#1497" class="Function Operator">∣</a> <a id="1540" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1542" href="FOL.Language.html#1497" class="Function Operator">∣ᶠ</a> <a id="1545" class="Symbol">=</a> <a id="1547" class="Number">2</a>
  <a id="1551" href="FOL.Language.html#1497" class="Function Operator">∣</a> <a id="1553" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1555" href="FOL.Language.html#1497" class="Function Operator">∣ᶠ</a> <a id="1558" class="Symbol">=</a> <a id="1560" class="Number">2</a>

  <a id="ExampleLanguagePA.∣_∣ᴿ"></a><a id="1565" href="FOL.Language.html#1565" class="Function Operator">∣_∣ᴿ</a> <a id="1570" class="Symbol">:</a> <a id="1572" href="FOL.Language.html#1472" class="Datatype">𝓡</a> <a id="1574" class="Symbol">→</a> <a id="1576" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="1580" href="FOL.Language.html#1565" class="Function Operator">∣</a> <a id="1582" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="1584" href="FOL.Language.html#1565" class="Function Operator">∣ᴿ</a> <a id="1587" class="Symbol">=</a> <a id="1589" class="Number">2</a>
</pre>
<p>通过模式匹配不难证明归纳定义的 <code>𝓕</code> 和 <code>𝓡</code> 是离散且可枚举的.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.discr𝓕"></a><a id="1643" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1650" class="Symbol">:</a> <a id="1652" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="1661" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
  <a id="1665" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1672" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1674" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1676" class="Symbol">=</a> <a id="1678" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1682" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1689" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1696" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1698" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1700" class="Symbol">=</a> <a id="1702" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1706" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1713" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1720" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1722" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1724" class="Symbol">=</a> <a id="1726" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1730" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1737" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1744" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1746" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1748" class="Symbol">=</a> <a id="1750" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="1754" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1761" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1768" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1770" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1772" class="Symbol">=</a> <a id="1774" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1777" class="Symbol">λ</a> <a id="1779" class="Symbol">()</a>
  <a id="1784" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1791" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1793" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1795" class="Symbol">=</a> <a id="1797" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1800" class="Symbol">λ</a> <a id="1802" class="Symbol">()</a>
  <a id="1807" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1814" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1816" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1818" class="Symbol">=</a> <a id="1820" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1823" class="Symbol">λ</a> <a id="1825" class="Symbol">()</a>
  <a id="1830" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1837" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1839" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1841" class="Symbol">=</a> <a id="1843" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1846" class="Symbol">λ</a> <a id="1848" class="Symbol">()</a>
  <a id="1853" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1860" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1862" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1864" class="Symbol">=</a> <a id="1866" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1869" class="Symbol">λ</a> <a id="1871" class="Symbol">()</a>
  <a id="1876" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1883" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1885" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1887" class="Symbol">=</a> <a id="1889" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1892" class="Symbol">λ</a> <a id="1894" class="Symbol">()</a>
  <a id="1899" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1906" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1908" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1910" class="Symbol">=</a> <a id="1912" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1915" class="Symbol">λ</a> <a id="1917" class="Symbol">()</a>
  <a id="1922" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1929" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1931" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="1933" class="Symbol">=</a> <a id="1935" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1938" class="Symbol">λ</a> <a id="1940" class="Symbol">()</a>
  <a id="1945" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1952" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="1954" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1956" class="Symbol">=</a> <a id="1958" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1961" class="Symbol">λ</a> <a id="1963" class="Symbol">()</a>
  <a id="1968" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1975" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="1977" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="1979" class="Symbol">=</a> <a id="1981" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="1984" class="Symbol">λ</a> <a id="1986" class="Symbol">()</a>
  <a id="1991" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="1998" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="2000" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="2002" class="Symbol">=</a> <a id="2004" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2007" class="Symbol">λ</a> <a id="2009" class="Symbol">()</a>
  <a id="2014" href="FOL.Language.html#1643" class="Function">discr𝓕</a> <a id="2021" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="2023" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="2025" class="Symbol">=</a> <a id="2027" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2030" class="Symbol">λ</a> <a id="2032" class="Symbol">()</a>

  <a id="ExampleLanguagePA.discr𝓡"></a><a id="2038" href="FOL.Language.html#2038" class="Function">discr𝓡</a> <a id="2045" class="Symbol">:</a> <a id="2047" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="2056" href="FOL.Language.html#1472" class="Datatype">𝓡</a>
  <a id="2060" href="FOL.Language.html#2038" class="Function">discr𝓡</a> <a id="2067" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="2069" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="2071" class="Symbol">=</a> <a id="2073" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2077" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="ExampleLanguagePA.enum𝓕"></a><a id="2085" href="FOL.Language.html#2085" class="Function">enum𝓕</a> <a id="2091" class="Symbol">:</a> <a id="2093" href="Foundation.Relation.Unary.Enumerable.html#2531" class="Function">enumerable</a> <a id="2104" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
  <a id="2108" href="FOL.Language.html#2085" class="Function">enum𝓕</a> <a id="2114" class="Symbol">=</a> <a id="2116" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a> <a id="2121" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2123" class="Symbol">(λ</a> <a id="2126" href="FOL.Language.html#2126" class="Symbol">_</a> <a id="2128" class="Symbol">→</a> <a id="2130" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="2132" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2134" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="2136" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2138" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="2140" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2142" href="Data.List.Base.html#5240" class="Function Operator">[</a> <a id="2144" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="2146" href="Data.List.Base.html#5240" class="Function Operator">]</a><a id="2147" class="Symbol">)</a> <a id="2149" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a> <a id="2151" class="Symbol">(λ</a> <a id="2154" href="FOL.Language.html#2154" class="Symbol">_</a> <a id="2156" class="Symbol">→</a> <a id="2158" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2161" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a> <a id="2163" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2167" class="Symbol">)</a> <a id="2169" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a>
    <a id="2175" class="Symbol">λ</a> <a id="2177" class="Symbol">{</a> <a id="2179" href="FOL.Language.html#1428" class="InductiveConstructor">O</a> <a id="2181" class="Symbol">→</a> <a id="2183" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2186" class="Number">0</a> <a id="2188" class="Symbol">(</a><a id="2189" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2194" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2198" class="Symbol">)</a>
      <a id="2206" class="Symbol">;</a> <a id="2208" href="FOL.Language.html#1438" class="InductiveConstructor">S</a> <a id="2210" class="Symbol">→</a> <a id="2212" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2215" class="Number">0</a> <a id="2217" class="Symbol">(</a><a id="2218" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2224" class="Symbol">(</a><a id="2225" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2230" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2234" class="Symbol">))</a>
      <a id="2243" class="Symbol">;</a> <a id="2245" href="FOL.Language.html#1448" class="InductiveConstructor">+</a> <a id="2247" class="Symbol">→</a> <a id="2249" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2252" class="Number">0</a> <a id="2254" class="Symbol">(</a><a id="2255" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2261" class="Symbol">(</a><a id="2262" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2268" class="Symbol">(</a><a id="2269" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2274" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2278" class="Symbol">)))</a>
      <a id="2288" class="Symbol">;</a> <a id="2290" href="FOL.Language.html#1458" class="InductiveConstructor">*</a> <a id="2292" class="Symbol">→</a> <a id="2294" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2297" class="Number">0</a> <a id="2299" class="Symbol">(</a><a id="2300" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2306" class="Symbol">(</a><a id="2307" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2313" class="Symbol">(</a><a id="2314" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2320" class="Symbol">(</a><a id="2321" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2326" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2330" class="Symbol">))))</a> <a id="2335" class="Symbol">}</a>

  <a id="ExampleLanguagePA.enum𝓡"></a><a id="2340" href="FOL.Language.html#2340" class="Function">enum𝓡</a> <a id="2346" class="Symbol">:</a> <a id="2348" href="Foundation.Relation.Unary.Enumerable.html#2531" class="Function">enumerable</a> <a id="2359" href="FOL.Language.html#1472" class="Datatype">𝓡</a>
  <a id="2363" href="FOL.Language.html#2340" class="Function">enum𝓡</a> <a id="2369" class="Symbol">=</a> <a id="2371" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a> <a id="2376" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2378" class="Symbol">(λ</a> <a id="2381" href="FOL.Language.html#2381" class="Symbol">_</a> <a id="2383" class="Symbol">→</a> <a id="2385" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="2387" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2389" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2391" class="Symbol">)</a> <a id="2393" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a> <a id="2395" class="Symbol">(λ</a> <a id="2398" href="FOL.Language.html#2398" class="Symbol">_</a> <a id="2400" class="Symbol">→</a> <a id="2402" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2405" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a> <a id="2407" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2411" class="Symbol">)</a> <a id="2413" href="Foundation.Prelude.Builtin.html#755" class="InductiveConstructor Operator">,</a>
    <a id="2419" class="Symbol">λ</a> <a id="2421" class="Symbol">{</a> <a id="2423" href="FOL.Language.html#1488" class="InductiveConstructor">&lt;</a> <a id="2425" class="Symbol">→</a> <a id="2427" href="Foundation.Prop.Logic.html#822" class="Function">ex</a> <a id="2430" class="Number">0</a> <a id="2432" class="Symbol">(</a><a id="2433" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2438" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2442" class="Symbol">)</a> <a id="2444" class="Symbol">}</a>
</pre>
<p>于是它们可以构成语言.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.ℒ"></a><a id="2474" href="FOL.Language.html#2474" class="Function">ℒ</a> <a id="2476" class="Symbol">:</a> <a id="2478" href="FOL.Language.html#749" class="Record">Language</a>
  <a id="2489" href="FOL.Language.html#2474" class="Function">ℒ</a> <a id="2491" class="Symbol">=</a> <a id="2493" class="Keyword">record</a>
    <a id="2504" class="Symbol">{</a> <a id="2506" href="FOL.Language.html#781" class="Field">𝓕</a> <a id="2508" class="Symbol">=</a> <a id="2510" href="FOL.Language.html#1412" class="Datatype">𝓕</a>
    <a id="2516" class="Symbol">;</a> <a id="2518" href="FOL.Language.html#791" class="Field">𝓡</a> <a id="2520" class="Symbol">=</a> <a id="2522" href="FOL.Language.html#1472" class="Datatype">𝓡</a>
    <a id="2528" class="Symbol">;</a> <a id="2530" href="FOL.Language.html#801" class="Field Operator">∣_∣ᶠ</a> <a id="2535" class="Symbol">=</a> <a id="2537" href="FOL.Language.html#1497" class="Function Operator">∣_∣ᶠ</a>
    <a id="2546" class="Symbol">;</a> <a id="2548" href="FOL.Language.html#818" class="Field Operator">∣_∣ᴿ</a> <a id="2553" class="Symbol">=</a> <a id="2555" href="FOL.Language.html#1565" class="Function Operator">∣_∣ᴿ</a>
    <a id="2564" class="Symbol">;</a> <a id="2566" href="FOL.Language.html#835" class="Field">discr𝓕</a> <a id="2573" class="Symbol">=</a> <a id="2575" href="FOL.Language.html#1643" class="Function">discr𝓕</a>
    <a id="2586" class="Symbol">;</a> <a id="2588" href="FOL.Language.html#859" class="Field">discr𝓡</a> <a id="2595" class="Symbol">=</a> <a id="2597" href="FOL.Language.html#2038" class="Function">discr𝓡</a>
    <a id="2608" class="Symbol">;</a> <a id="2610" href="FOL.Language.html#883" class="Field">enum𝓕</a> <a id="2616" class="Symbol">=</a> <a id="2618" href="FOL.Language.html#2085" class="Function">enum𝓕</a>
    <a id="2628" class="Symbol">;</a> <a id="2630" href="FOL.Language.html#908" class="Field">enum𝓡</a> <a id="2636" class="Symbol">=</a> <a id="2638" href="FOL.Language.html#2340" class="Function">enum𝓡</a>
    <a id="2648" class="Symbol">}</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Language.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Language.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.language">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
