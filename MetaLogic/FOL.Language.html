<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Language</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语言" id="toc-一阶逻辑-语言">一阶逻辑 ▸ 语言</a></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语言">一阶逻辑 ▸ 语言</h1>
<p>一阶逻辑是一种形式语言, 其语句由一些原始符号按一定的语法组合而成. 符号又分为逻辑符号和非逻辑符号. 本篇先讲非逻辑符号.</p>
<p>非逻辑符号分为函数符号和关系符号, 且它们都带有一个称为元数 (arity) 的属性. 例如, 元数为 2 的函数符号即用于表示二元函数. 特别地, 元数为零的函数又称为常量.</p>
<p>较传统的处理方式是给出所有可能的函数符号和关系符号. 即对任意元数 <span class="math inline">n</span>, 都有自然数多个函数符号</p>
<p><span class="math display">f^n_0,\ f^n_1,\ f^n_2,\ f^n_3,\ ...</span></p>
<p>以及自然数多个关系符号</p>
<p><span class="math display">R^n_0,\ R^n_1,\ R^n_2,\ R^n_3,\ ...</span></p>
<p>在这种处理下, 只有唯一一种一阶逻辑语言.</p>
<p>较现代的方式是根据最终要实现的一阶逻辑语言来指定该理论所需的非逻辑符号. 这些特定的符号以及它们的元数所组成的资料叫做理论的<strong>签名 (signature)</strong>. 在这种处理下, 每种签名都对应一种一阶逻辑语言, 因此签名又叫做<strong>语言 (language)</strong>, 语言的实例按惯例记作 ℒ. 由于一阶逻辑的其他部分都是参数化到语言的, 我们把它单独作为一个模块.</p>
<pre class="Agda"><a id="557" class="Comment">-- 元语言的基本概念</a>
<a id="569" class="Keyword">open</a> <a id="574" class="Keyword">import</a> <a id="581" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="602" class="Comment">-- 可枚举性的相关概念</a>
<a id="615" class="Keyword">open</a> <a id="620" class="Keyword">import</a> <a id="627" href="Enumerability.ListView.html" class="Module">Enumerability.ListView</a>

<a id="651" class="Keyword">module</a> <a id="658" href="FOL.Language.html" class="Module">FOL.Language</a> <a id="671" class="Keyword">where</a>
</pre>
<p><strong><u>定义</u></strong> 一阶逻辑的语言 <code>ℒ</code> 是一个六元组</p>
<ol type="1">
<li>离散的函数符号集 <code>𝓕</code></li>
<li>离散的关系符号集 <code>𝓡</code></li>
<li><code>𝓕</code> 到元数的映射 <code>∣_∣ᶠ</code></li>
<li><code>𝓡</code> 到元数的映射 <code>∣_∣ᴿ</code></li>
<li><code>𝓕</code> 的一个枚举</li>
<li><code>𝓡</code> 的一个枚举</li>
</ol>
<pre class="Agda"><a id="825" class="Keyword">record</a> <a id="Language"></a><a id="832" href="FOL.Language.html#832" class="Record">Language</a> <a id="841" class="Symbol">:</a> <a id="843" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a> <a id="846" class="Keyword">where</a>
  <a id="854" class="Keyword">constructor</a> <a id="mkLang"></a><a id="866" href="FOL.Language.html#866" class="InductiveConstructor">mkLang</a>
  <a id="875" class="Keyword">field</a>
    <a id="Language.𝓕"></a><a id="885" href="FOL.Language.html#885" class="Field">𝓕</a> <a id="887" class="Symbol">:</a> <a id="889" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.𝓡"></a><a id="895" href="FOL.Language.html#895" class="Field">𝓡</a> <a id="897" class="Symbol">:</a> <a id="899" href="Agda.Primitive.html#388" class="Primitive">𝕋</a>
    <a id="Language.∣_∣ᶠ"></a><a id="905" href="FOL.Language.html#905" class="Field Operator">∣_∣ᶠ</a> <a id="910" class="Symbol">:</a> <a id="912" href="FOL.Language.html#885" class="Field">𝓕</a> <a id="914" class="Symbol">→</a> <a id="916" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.∣_∣ᴿ"></a><a id="922" href="FOL.Language.html#922" class="Field Operator">∣_∣ᴿ</a> <a id="927" class="Symbol">:</a> <a id="929" href="FOL.Language.html#895" class="Field">𝓡</a> <a id="931" class="Symbol">→</a> <a id="933" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="Language.discr𝓡"></a><a id="939" href="FOL.Language.html#939" class="Field">discr𝓡</a> <a id="946" class="Symbol">:</a> <a id="948" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="957" href="FOL.Language.html#895" class="Field">𝓡</a>
    <a id="Language.discr𝓕"></a><a id="963" href="FOL.Language.html#963" class="Field">discr𝓕</a> <a id="970" class="Symbol">:</a> <a id="972" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="981" href="FOL.Language.html#885" class="Field">𝓕</a>
    <a id="987" class="Symbol">⦃</a> <a id="Language.enum𝓕"></a><a id="989" href="FOL.Language.html#989" class="Field">enum𝓕</a> <a id="995" class="Symbol">⦄</a> <a id="997" class="Symbol">:</a> <a id="999" href="Enumerability.ListView.Base.html#934" class="Record">Enum</a> <a id="1004" href="FOL.Language.html#885" class="Field">𝓕</a>
    <a id="1010" class="Symbol">⦃</a> <a id="Language.enum𝓡"></a><a id="1012" href="FOL.Language.html#1012" class="Field">enum𝓡</a> <a id="1018" class="Symbol">⦄</a> <a id="1020" class="Symbol">:</a> <a id="1022" href="Enumerability.ListView.Base.html#934" class="Record">Enum</a> <a id="1027" href="FOL.Language.html#895" class="Field">𝓡</a>
</pre>
<p><strong><u>注意</u></strong> 在经典语境下集合一定是离散的, 但在直觉主义 HoTT 中, 离散强于“集合”. 因此当我们要求某 <code>A</code> 是“离散集”的时候, 实际上只要求它是离散类型, 然后它自然是一个集合.</p>
<p><strong><u>注意</u></strong> 回顾<a href="https://www.yuque.com/ocau/metalogic/foundation.essential#c1933822">枚举的定义</a>, 某类型 <code>A</code> 的枚举 <code>Enum A</code>是一个二元组: 1. 满足 <code>wit</code> 的一个函数 <code>enum</code> 2. <code>enum</code> 的一个 <code>cum</code></p>
<p><strong><u>约定</u></strong> 对于一个类型, 我们自始至终只会谈论它的一个枚举. 所以对任意类型的枚举, 我们都会用 <code>enum</code>, <code>wit</code> 和 <code>cum</code> 来指代该类型的那个我们唯一谈论的枚举的 <code>enum</code>, <code>wit</code> 和 <code>cum</code>. 我们通过把 <code>enum𝓕</code> 放到括号 <code>⦃ ⦄</code> 中来声明它是我们唯一谈论的那个 <code>Enum 𝓕</code>. 对于 <code>enum𝓡</code> 也一样.</p>
<p><strong><u>定理</u></strong> <code>𝓕</code> 和 <code>𝓡</code> 都是可数集.</p>
<pre class="Agda">  <a id="Language.count𝓕"></a><a id="1540" href="FOL.Language.html#1540" class="Function">count𝓕</a> <a id="1547" class="Symbol">:</a> <a id="1549" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1559" href="FOL.Language.html#885" class="Field">𝓕</a>
  <a id="1563" href="FOL.Language.html#1540" class="Function">count𝓕</a> <a id="1570" class="Symbol">=</a> <a id="1572" href="Enumerability.ListView.Properties.html#5356" class="Function">discr→enum→count</a> <a id="1589" href="FOL.Language.html#963" class="Field">discr𝓕</a> <a id="1596" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="1598" href="FOL.Language.html#989" class="Field">enum𝓕</a> <a id="1604" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>

  <a id="Language.count𝓡"></a><a id="1610" href="FOL.Language.html#1610" class="Function">count𝓡</a> <a id="1617" class="Symbol">:</a> <a id="1619" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="1629" href="FOL.Language.html#895" class="Field">𝓡</a>
  <a id="1633" href="FOL.Language.html#1610" class="Function">count𝓡</a> <a id="1640" class="Symbol">=</a> <a id="1642" href="Enumerability.ListView.Properties.html#5356" class="Function">discr→enum→count</a> <a id="1659" href="FOL.Language.html#939" class="Field">discr𝓡</a> <a id="1666" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="1668" href="FOL.Language.html#1012" class="Field">enum𝓡</a> <a id="1674" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>

  <a id="Language.isSet𝓕"></a><a id="1680" href="FOL.Language.html#1680" class="Function">isSet𝓕</a> <a id="1687" class="Symbol">:</a> <a id="1689" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1695" href="FOL.Language.html#885" class="Field">𝓕</a>
  <a id="1699" href="FOL.Language.html#1680" class="Function">isSet𝓕</a> <a id="1706" class="Symbol">=</a> <a id="1708" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1723" href="FOL.Language.html#963" class="Field">discr𝓕</a>

  <a id="Language.isSet𝓡"></a><a id="1733" href="FOL.Language.html#1733" class="Function">isSet𝓡</a> <a id="1740" class="Symbol">:</a> <a id="1742" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1748" href="FOL.Language.html#895" class="Field">𝓡</a>
  <a id="1752" href="FOL.Language.html#1733" class="Function">isSet𝓡</a> <a id="1759" class="Symbol">=</a> <a id="1761" href="Foundation.Relation.Nullary.Discrete.html#547" class="Function">discrete→isSet</a> <a id="1776" href="FOL.Language.html#939" class="Field">discr𝓡</a>
</pre>
<p><strong><u>例</u></strong> 下面给出了语言的一个实例 <code>ℒ</code>, 它可以作为皮亚诺算术的语言.</p>
<pre class="Agda"><a id="1843" class="Keyword">private</a> <a id="1851" class="Keyword">module</a> <a id="ExampleLanguagePA"></a><a id="1858" href="FOL.Language.html#1858" class="Module">ExampleLanguagePA</a> <a id="1876" class="Keyword">where</a>

  <a id="1885" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓕"></a><a id="1890" href="FOL.Language.html#1890" class="Datatype">𝓕</a> <a id="1892" class="Symbol">:</a> <a id="1894" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1896" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓕.O"></a><a id="1906" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="1908" class="Symbol">:</a> <a id="1910" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.S"></a><a id="1916" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="1918" class="Symbol">:</a> <a id="1920" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.+"></a><a id="1926" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="1928" class="Symbol">:</a> <a id="1930" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
    <a id="ExampleLanguagePA.𝓕.*"></a><a id="1936" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="1938" class="Symbol">:</a> <a id="1940" href="FOL.Language.html#1890" class="Datatype">𝓕</a>

  <a id="1945" class="Keyword">data</a> <a id="ExampleLanguagePA.𝓡"></a><a id="1950" href="FOL.Language.html#1950" class="Datatype">𝓡</a> <a id="1952" class="Symbol">:</a> <a id="1954" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1956" class="Keyword">where</a>
    <a id="ExampleLanguagePA.𝓡.&lt;"></a><a id="1966" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="1968" class="Symbol">:</a> <a id="1970" href="FOL.Language.html#1950" class="Datatype">𝓡</a>

  <a id="ExampleLanguagePA.∣_∣ᶠ"></a><a id="1975" href="FOL.Language.html#1975" class="Function Operator">∣_∣ᶠ</a> <a id="1980" class="Symbol">:</a> <a id="1982" href="FOL.Language.html#1890" class="Datatype">𝓕</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="1990" href="FOL.Language.html#1975" class="Function Operator">∣</a> <a id="1992" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="1994" href="FOL.Language.html#1975" class="Function Operator">∣ᶠ</a> <a id="1997" class="Symbol">=</a> <a id="1999" class="Number">0</a>
  <a id="2003" href="FOL.Language.html#1975" class="Function Operator">∣</a> <a id="2005" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2007" href="FOL.Language.html#1975" class="Function Operator">∣ᶠ</a> <a id="2010" class="Symbol">=</a> <a id="2012" class="Number">1</a>
  <a id="2016" href="FOL.Language.html#1975" class="Function Operator">∣</a> <a id="2018" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2020" href="FOL.Language.html#1975" class="Function Operator">∣ᶠ</a> <a id="2023" class="Symbol">=</a> <a id="2025" class="Number">2</a>
  <a id="2029" href="FOL.Language.html#1975" class="Function Operator">∣</a> <a id="2031" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2033" href="FOL.Language.html#1975" class="Function Operator">∣ᶠ</a> <a id="2036" class="Symbol">=</a> <a id="2038" class="Number">2</a>

  <a id="ExampleLanguagePA.∣_∣ᴿ"></a><a id="2043" href="FOL.Language.html#2043" class="Function Operator">∣_∣ᴿ</a> <a id="2048" class="Symbol">:</a> <a id="2050" href="FOL.Language.html#1950" class="Datatype">𝓡</a> <a id="2052" class="Symbol">→</a> <a id="2054" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="2058" href="FOL.Language.html#2043" class="Function Operator">∣</a> <a id="2060" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="2062" href="FOL.Language.html#2043" class="Function Operator">∣ᴿ</a> <a id="2065" class="Symbol">=</a> <a id="2067" class="Number">2</a>
</pre>
<p>通过模式匹配不难证明归纳定义的 <code>𝓕</code> 和 <code>𝓡</code> 是离散且可枚举的.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.discr𝓕"></a><a id="2121" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2128" class="Symbol">:</a> <a id="2130" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="2139" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
  <a id="2143" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2150" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2152" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2154" class="Symbol">=</a> <a id="2156" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2160" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="2167" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2174" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2176" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2178" class="Symbol">=</a> <a id="2180" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2184" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="2191" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2198" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2200" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2202" class="Symbol">=</a> <a id="2204" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2208" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="2215" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2222" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2224" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2226" class="Symbol">=</a> <a id="2228" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2232" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="2239" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2246" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2248" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2250" class="Symbol">=</a> <a id="2252" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2255" class="Symbol">λ</a> <a id="2257" class="Symbol">()</a>
  <a id="2262" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2269" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2271" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2273" class="Symbol">=</a> <a id="2275" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2278" class="Symbol">λ</a> <a id="2280" class="Symbol">()</a>
  <a id="2285" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2292" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2294" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2296" class="Symbol">=</a> <a id="2298" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2301" class="Symbol">λ</a> <a id="2303" class="Symbol">()</a>
  <a id="2308" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2315" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2317" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2319" class="Symbol">=</a> <a id="2321" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2324" class="Symbol">λ</a> <a id="2326" class="Symbol">()</a>
  <a id="2331" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2338" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2340" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2342" class="Symbol">=</a> <a id="2344" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2347" class="Symbol">λ</a> <a id="2349" class="Symbol">()</a>
  <a id="2354" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2361" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2363" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2365" class="Symbol">=</a> <a id="2367" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2370" class="Symbol">λ</a> <a id="2372" class="Symbol">()</a>
  <a id="2377" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2384" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2386" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2388" class="Symbol">=</a> <a id="2390" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2393" class="Symbol">λ</a> <a id="2395" class="Symbol">()</a>
  <a id="2400" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2407" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2409" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2411" class="Symbol">=</a> <a id="2413" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2416" class="Symbol">λ</a> <a id="2418" class="Symbol">()</a>
  <a id="2423" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2430" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2432" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2434" class="Symbol">=</a> <a id="2436" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2439" class="Symbol">λ</a> <a id="2441" class="Symbol">()</a>
  <a id="2446" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2453" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2455" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2457" class="Symbol">=</a> <a id="2459" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2462" class="Symbol">λ</a> <a id="2464" class="Symbol">()</a>
  <a id="2469" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2476" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2478" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2480" class="Symbol">=</a> <a id="2482" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2485" class="Symbol">λ</a> <a id="2487" class="Symbol">()</a>
  <a id="2492" href="FOL.Language.html#2121" class="Function">discr𝓕</a> <a id="2499" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2501" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2503" class="Symbol">=</a> <a id="2505" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="2508" class="Symbol">λ</a> <a id="2510" class="Symbol">()</a>

  <a id="ExampleLanguagePA.discr𝓡"></a><a id="2516" href="FOL.Language.html#2516" class="Function">discr𝓡</a> <a id="2523" class="Symbol">:</a> <a id="2525" href="Relation.Binary.Definitions.html#6468" class="Function">discrete</a> <a id="2534" href="FOL.Language.html#1950" class="Datatype">𝓡</a>
  <a id="2538" href="FOL.Language.html#2516" class="Function">discr𝓡</a> <a id="2545" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="2547" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="2549" class="Symbol">=</a> <a id="2551" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="2555" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="ExampleLanguagePA.enum𝓕"></a><a id="2563" href="FOL.Language.html#2563" class="Function">enum𝓕</a> <a id="2569" class="Symbol">:</a> <a id="2571" href="Enumerability.ListView.Base.html#934" class="Record">Enum</a> <a id="2576" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
  <a id="2580" href="FOL.Language.html#2563" class="Function">enum𝓕</a> <a id="2586" class="Symbol">=</a> <a id="2588" href="Enumerability.ListView.Base.html#979" class="InductiveConstructor">mkEnum</a> <a id="2595" class="Symbol">(λ</a> <a id="2598" href="FOL.Language.html#2598" class="Bound">_</a> <a id="2600" class="Symbol">→</a> <a id="2602" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2604" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2606" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2608" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2610" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2612" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2614" href="Data.List.Base.html#5240" class="Function Operator">[</a> <a id="2616" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2618" href="Data.List.Base.html#5240" class="Function Operator">]</a><a id="2619" class="Symbol">)</a> <a id="2621" class="Symbol">(λ</a> <a id="2624" href="FOL.Language.html#2624" class="Bound">_</a> <a id="2626" class="Symbol">→</a> <a id="2628" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2631" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2633" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2637" class="Symbol">)</a>
    <a id="2643" class="Symbol">λ</a> <a id="2645" class="Symbol">{</a> <a id="2647" href="FOL.Language.html#1906" class="InductiveConstructor">O</a> <a id="2649" class="Symbol">→</a> <a id="2651" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="2654" class="Number">0</a> <a id="2656" class="Symbol">(</a><a id="2657" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2662" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2666" class="Symbol">)</a>
      <a id="2674" class="Symbol">;</a> <a id="2676" href="FOL.Language.html#1916" class="InductiveConstructor">S</a> <a id="2678" class="Symbol">→</a> <a id="2680" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="2683" class="Number">0</a> <a id="2685" class="Symbol">(</a><a id="2686" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2692" class="Symbol">(</a><a id="2693" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2698" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2702" class="Symbol">))</a>
      <a id="2711" class="Symbol">;</a> <a id="2713" href="FOL.Language.html#1926" class="InductiveConstructor">+</a> <a id="2715" class="Symbol">→</a> <a id="2717" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="2720" class="Number">0</a> <a id="2722" class="Symbol">(</a><a id="2723" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2729" class="Symbol">(</a><a id="2730" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2736" class="Symbol">(</a><a id="2737" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2742" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2746" class="Symbol">)))</a>
      <a id="2756" class="Symbol">;</a> <a id="2758" href="FOL.Language.html#1936" class="InductiveConstructor">*</a> <a id="2760" class="Symbol">→</a> <a id="2762" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="2765" class="Number">0</a> <a id="2767" class="Symbol">(</a><a id="2768" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2774" class="Symbol">(</a><a id="2775" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2781" class="Symbol">(</a><a id="2782" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="2788" class="Symbol">(</a><a id="2789" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2794" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2798" class="Symbol">))))</a> <a id="2803" class="Symbol">}</a>

  <a id="ExampleLanguagePA.enum𝓡"></a><a id="2808" href="FOL.Language.html#2808" class="Function">enum𝓡</a> <a id="2814" class="Symbol">:</a> <a id="2816" href="Enumerability.ListView.Base.html#934" class="Record">Enum</a> <a id="2821" href="FOL.Language.html#1950" class="Datatype">𝓡</a>
  <a id="2825" href="FOL.Language.html#2808" class="Function">enum𝓡</a> <a id="2831" class="Symbol">=</a> <a id="2833" href="Enumerability.ListView.Base.html#979" class="InductiveConstructor">mkEnum</a> <a id="2840" class="Symbol">(λ</a> <a id="2843" href="FOL.Language.html#2843" class="Bound">_</a> <a id="2845" class="Symbol">→</a> <a id="2847" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="2849" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2851" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2853" class="Symbol">)</a> <a id="2855" class="Symbol">(λ</a> <a id="2858" href="FOL.Language.html#2858" class="Bound">_</a> <a id="2860" class="Symbol">→</a> <a id="2862" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2865" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2867" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2871" class="Symbol">)</a>
    <a id="2877" class="Symbol">λ</a> <a id="2879" class="Symbol">{</a> <a id="2881" href="FOL.Language.html#1966" class="InductiveConstructor">&lt;</a> <a id="2883" class="Symbol">→</a> <a id="2885" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="2888" class="Number">0</a> <a id="2890" class="Symbol">(</a><a id="2891" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2896" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2900" class="Symbol">)</a> <a id="2902" class="Symbol">}</a>
</pre>
<p>于是它们可以构成语言.</p>
<pre class="Agda">  <a id="ExampleLanguagePA.ℒ"></a><a id="2932" href="FOL.Language.html#2932" class="Function">ℒ</a> <a id="2934" class="Symbol">:</a> <a id="2936" href="FOL.Language.html#832" class="Record">Language</a>
  <a id="2947" href="FOL.Language.html#2932" class="Function">ℒ</a> <a id="2949" class="Symbol">=</a> <a id="2951" class="Keyword">record</a>
    <a id="2962" class="Symbol">{</a> <a id="2964" href="FOL.Language.html#885" class="Field">𝓕</a> <a id="2966" class="Symbol">=</a> <a id="2968" href="FOL.Language.html#1890" class="Datatype">𝓕</a>
    <a id="2974" class="Symbol">;</a> <a id="2976" href="FOL.Language.html#895" class="Field">𝓡</a> <a id="2978" class="Symbol">=</a> <a id="2980" href="FOL.Language.html#1950" class="Datatype">𝓡</a>
    <a id="2986" class="Symbol">;</a> <a id="2988" href="FOL.Language.html#905" class="Field Operator">∣_∣ᶠ</a> <a id="2993" class="Symbol">=</a> <a id="2995" href="FOL.Language.html#1975" class="Function Operator">∣_∣ᶠ</a>
    <a id="3004" class="Symbol">;</a> <a id="3006" href="FOL.Language.html#922" class="Field Operator">∣_∣ᴿ</a> <a id="3011" class="Symbol">=</a> <a id="3013" href="FOL.Language.html#2043" class="Function Operator">∣_∣ᴿ</a>
    <a id="3022" class="Symbol">;</a> <a id="3024" href="FOL.Language.html#963" class="Field">discr𝓕</a> <a id="3031" class="Symbol">=</a> <a id="3033" href="FOL.Language.html#2121" class="Function">discr𝓕</a>
    <a id="3044" class="Symbol">;</a> <a id="3046" href="FOL.Language.html#939" class="Field">discr𝓡</a> <a id="3053" class="Symbol">=</a> <a id="3055" href="FOL.Language.html#2516" class="Function">discr𝓡</a>
    <a id="3066" class="Symbol">;</a> <a id="3068" href="FOL.Language.html#989" class="Field">enum𝓕</a> <a id="3074" class="Symbol">=</a> <a id="3076" href="FOL.Language.html#2563" class="Function">enum𝓕</a>
    <a id="3086" class="Symbol">;</a> <a id="3088" href="FOL.Language.html#1012" class="Field">enum𝓡</a> <a id="3094" class="Symbol">=</a> <a id="3096" href="FOL.Language.html#2808" class="Function">enum𝓡</a>
    <a id="3106" class="Symbol">}</a>
</pre>
<p><strong><u>约定</u></strong> 我们一次只会谈论一种语言, 它在上下文中是明确的, 首次出现时会放在括号 <code>⦃ ⦄</code> 中或使用 <code>instance</code> 关键字来声明, 所以每次提到语言中的概念时不会一一带上某语言 <code>ℒ</code> 作为参数, 从而精简表达. 该约定表达为以下代码.</p>
<pre class="Agda"><a id="3256" class="Keyword">open</a> <a id="3261" href="FOL.Language.html#832" class="Module">Language</a> <a id="3270" class="Symbol">⦃...⦄</a> <a id="3276" class="Keyword">public</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Language.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Language.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.language">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
