<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Syntax.Properties</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语法-性质" id="toc-一阶逻辑-语法-性质">一阶逻辑 ▸ 语法 ▸⁻ 性质</a></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语法-性质">一阶逻辑 ▸ 语法 ▸⁻ 性质</h1>
<p>这是一篇标题中带上标减号 (⁻) 的章节. 这表示这种章节不推荐线性阅读, 读者应该在需要时再回来查看. 因为这种章节只是一些枯燥引理及其证明的简单罗列, 而不包含动机的说明. 读者应该在使用这些引理的章节中寻找动机.</p>
<pre class="Agda"><a id="175" class="Keyword">open</a> <a id="180" class="Keyword">import</a> <a id="187" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="208" class="Keyword">open</a> <a id="213" class="Keyword">import</a> <a id="220" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="233" class="Keyword">module</a> <a id="240" href="FOL.Syntax.Properties.html" class="Module">FOL.Syntax.Properties</a> <a id="262" class="Symbol">(</a><a id="263" href="FOL.Syntax.Properties.html#263" class="Bound">ℒ</a> <a id="265" class="Symbol">:</a> <a id="267" href="FOL.Language.html#750" class="Record">Language</a><a id="275" class="Symbol">)</a> <a id="277" class="Keyword">where</a>

<a id="284" class="Keyword">open</a> <a id="289" class="Keyword">import</a> <a id="296" href="FOL.Syntax.html" class="Module">FOL.Syntax</a> <a id="307" href="FOL.Syntax.Properties.html#263" class="Bound">ℒ</a>
</pre>
<p><strong><u>引理</u></strong> 项的归纳法: 任意给定项的性质 <code>P</code>, 可以证明任意项都满足 <code>P</code>, 只要证明以下两点</p>
<ol type="1">
<li><code>P</code> 对所有变元成立</li>
<li><code>P</code> 对所有形如 <code>f $̇ t⃗</code> 的项成立, 只要 <code>P</code> 对所有 <code>t ∈⃗ t⃗</code> 成立</li>
</ol>
<p><strong><u>递归证明</u></strong> 对项的结构归纳, 分两种情况</p>
<ul>
<li>当项是变元时, 由前提1即证</li>
<li>当项是函数应用 <code>f $̇ t⃗</code> 时, 由前提2, 只要证 <code>P</code> 对所有 <code>t ∈⃗ t⃗</code> 成立, 把它视作一个内部引理, 命名为 <code>H</code>. 我们递归证明 <code>H</code>, 给定 <code>t ∈⃗ t⃗</code>, 又分两种情况
<ul>
<li>当 <code>t</code> 位于 <code>t⃗</code> 的头部时, 用项的归纳法即证</li>
<li>当 <code>t</code> 位于 <code>t⃗</code> 的尾部时, 递归使用 <code>H</code> 即证 ∎</li>
</ul></li>
</ul>
<pre class="Agda"><a id="term-elim"></a><a id="682" href="FOL.Syntax.Properties.html#682" class="Function">term-elim</a> <a id="692" class="Symbol">:</a> <a id="694" class="Symbol">{</a><a id="695" href="FOL.Syntax.Properties.html#695" class="Bound">P</a> <a id="697" class="Symbol">:</a> <a id="699" href="FOL.Syntax.html#698" class="Datatype">Term</a> <a id="704" class="Symbol">→</a> <a id="706" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="708" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="709" class="Symbol">}</a> <a id="711" class="Symbol">→</a> <a id="713" class="Symbol">(∀</a> <a id="716" href="FOL.Syntax.Properties.html#716" class="Bound">n</a> <a id="718" class="Symbol">→</a> <a id="720" href="FOL.Syntax.Properties.html#695" class="Bound">P</a> <a id="722" class="Symbol">(</a><a id="723" href="FOL.Syntax.html#715" class="InductiveConstructor Operator">#</a> <a id="725" href="FOL.Syntax.Properties.html#716" class="Bound">n</a><a id="726" class="Symbol">))</a> <a id="729" class="Symbol">→</a>
  <a id="733" class="Symbol">(∀</a> <a id="736" href="FOL.Syntax.Properties.html#736" class="Bound">f</a> <a id="738" href="FOL.Syntax.Properties.html#738" class="Bound">t⃗</a> <a id="741" class="Symbol">→</a> <a id="743" class="Symbol">(∀</a> <a id="746" href="FOL.Syntax.Properties.html#746" class="Bound">t</a> <a id="748" class="Symbol">→</a> <a id="750" href="FOL.Syntax.Properties.html#746" class="Bound">t</a> <a id="752" href="Foundation.Essential.html#11309" class="Function Operator">∈⃗</a> <a id="755" href="FOL.Syntax.Properties.html#738" class="Bound">t⃗</a> <a id="758" class="Symbol">→</a> <a id="760" href="FOL.Syntax.Properties.html#695" class="Bound">P</a> <a id="762" href="FOL.Syntax.Properties.html#746" class="Bound">t</a><a id="763" class="Symbol">)</a> <a id="765" class="Symbol">→</a> <a id="767" href="FOL.Syntax.Properties.html#695" class="Bound">P</a> <a id="769" class="Symbol">(</a><a id="770" href="FOL.Syntax.Properties.html#736" class="Bound">f</a> <a id="772" class="InductiveConstructor Operator">$̇</a> <a id="775" href="FOL.Syntax.Properties.html#738" class="Bound">t⃗</a><a id="777" class="Symbol">))</a> <a id="780" class="Symbol">→</a> <a id="782" class="Symbol">∀</a> <a id="784" href="FOL.Syntax.Properties.html#784" class="Bound">t</a> <a id="786" class="Symbol">→</a> <a id="788" href="FOL.Syntax.Properties.html#695" class="Bound">P</a> <a id="790" href="FOL.Syntax.Properties.html#784" class="Bound">t</a>
<a id="792" href="FOL.Syntax.Properties.html#682" class="Function">term-elim</a> <a id="802" href="FOL.Syntax.Properties.html#802" class="Bound">H1</a> <a id="805" href="FOL.Syntax.Properties.html#805" class="Bound">H2</a> <a id="808" class="Symbol">(</a><a id="809" href="FOL.Syntax.html#715" class="InductiveConstructor Operator">#</a> <a id="811" href="FOL.Syntax.Properties.html#811" class="Bound">n</a><a id="812" class="Symbol">)</a> <a id="814" class="Symbol">=</a> <a id="816" href="FOL.Syntax.Properties.html#802" class="Bound">H1</a> <a id="819" href="FOL.Syntax.Properties.html#811" class="Bound">n</a>
<a id="821" href="FOL.Syntax.Properties.html#682" class="Function">term-elim</a> <a id="831" class="Symbol">{</a><a id="832" href="FOL.Syntax.Properties.html#832" class="Bound">P</a><a id="833" class="Symbol">}</a> <a id="835" href="FOL.Syntax.Properties.html#835" class="Bound">H1</a> <a id="838" href="FOL.Syntax.Properties.html#838" class="Bound">H2</a> <a id="841" class="Symbol">(</a><a id="842" href="FOL.Syntax.Properties.html#842" class="Bound">f</a> <a id="844" href="FOL.Syntax.html#731" class="InductiveConstructor Operator">$̇</a> <a id="847" href="FOL.Syntax.Properties.html#847" class="Bound">t⃗</a><a id="849" class="Symbol">)</a> <a id="851" class="Symbol">=</a> <a id="853" href="FOL.Syntax.Properties.html#838" class="Bound">H2</a> <a id="856" href="FOL.Syntax.Properties.html#842" class="Bound">f</a> <a id="858" href="FOL.Syntax.Properties.html#847" class="Bound">t⃗</a> <a id="861" href="FOL.Syntax.Properties.html#871" class="Function">H</a> <a id="863" class="Keyword">where</a>
  <a id="871" href="FOL.Syntax.Properties.html#871" class="Function">H</a> <a id="873" class="Symbol">:</a> <a id="875" class="Symbol">∀</a> <a id="877" class="Symbol">{</a><a id="878" href="FOL.Syntax.Properties.html#878" class="Bound">n</a><a id="879" class="Symbol">}</a> <a id="881" class="Symbol">{</a><a id="882" href="FOL.Syntax.Properties.html#882" class="Bound">t⃗</a> <a id="885" class="Symbol">:</a> <a id="887" href="Data.Vec.Base.html#1107" class="Datatype">𝕍</a> <a id="889" href="FOL.Syntax.html#698" class="Datatype">Term</a> <a id="894" href="FOL.Syntax.Properties.html#878" class="Bound">n</a><a id="895" class="Symbol">}</a> <a id="897" href="FOL.Syntax.Properties.html#897" class="Bound">t</a> <a id="899" class="Symbol">→</a> <a id="901" href="FOL.Syntax.Properties.html#897" class="Bound">t</a> <a id="903" href="Foundation.Essential.html#11309" class="Function Operator">∈⃗</a> <a id="906" href="FOL.Syntax.Properties.html#882" class="Bound">t⃗</a> <a id="909" class="Symbol">→</a> <a id="911" href="FOL.Syntax.Properties.html#832" class="Bound">P</a> <a id="913" href="FOL.Syntax.Properties.html#897" class="Bound">t</a>
  <a id="917" href="FOL.Syntax.Properties.html#871" class="Function">H</a> <a id="919" href="FOL.Syntax.Properties.html#919" class="Bound">t</a> <a id="921" class="Symbol">(</a><a id="922" href="Data.Vec.Relation.Unary.Any.html#1144" class="InductiveConstructor">here</a> <a id="927" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="931" class="Symbol">)</a> <a id="933" class="Symbol">=</a> <a id="935" href="FOL.Syntax.Properties.html#682" class="Function">term-elim</a> <a id="945" href="FOL.Syntax.Properties.html#835" class="Bound">H1</a> <a id="948" href="FOL.Syntax.Properties.html#838" class="Bound">H2</a> <a id="951" href="FOL.Syntax.Properties.html#919" class="Bound">t</a>
  <a id="955" href="FOL.Syntax.Properties.html#871" class="Function">H</a> <a id="957" href="FOL.Syntax.Properties.html#957" class="Bound">t</a> <a id="959" class="Symbol">(</a><a id="960" href="Data.Vec.Relation.Unary.Any.html#1211" class="InductiveConstructor">there</a> <a id="966" href="FOL.Syntax.Properties.html#966" class="Bound">t∈⃗t⃗</a><a id="971" class="Symbol">)</a> <a id="973" class="Symbol">=</a> <a id="975" href="FOL.Syntax.Properties.html#871" class="Function">H</a> <a id="977" href="FOL.Syntax.Properties.html#957" class="Bound">t</a> <a id="979" href="FOL.Syntax.Properties.html#966" class="Bound">t∈⃗t⃗</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Syntax/Properties.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Syntax.Properties.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.syntax.properties">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
