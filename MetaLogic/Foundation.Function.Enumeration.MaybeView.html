<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Foundation.Function.Enumeration.MaybeView</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#元语言-可枚举性-可选值序列视角" id="toc-元语言-可枚举性-可选值序列视角">元语言 ▸ 可枚举性 ▸ 可选值序列视角</a></li>
  </ul>
</nav>

<main>
<h1 id="元语言-可枚举性-可选值序列视角">元语言 ▸ 可枚举性 ▸ 可选值序列视角</h1>
<p>我们一共引入枚举的三种视角， 分别是：</p>
<ol type="1">
<li>可选值序列视角 (本篇): 与传统定义接轨, 但不会实际使用. 与视角2等价, 可以说明视角2的合理性.</li>
<li><a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.listview.base">累积列表视角</a>: 是我们实际构造的枚举函数.</li>
<li><a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.plainview">普通视角</a>: 是我们证明命题时实际使用的枚举函数, 从视角2转化.</li>
</ol>
<p>我们首先介绍可选值序列视角, 也就是传统的枚举定义.</p>
<pre class="Agda"><a id="397" class="Keyword">module</a> <a id="404" href="Foundation.Function.Enumeration.MaybeView.html" class="Module">Foundation.Function.Enumeration.MaybeView</a> <a id="446" class="Keyword">where</a>

<a id="453" class="Keyword">open</a> <a id="458" class="Keyword">import</a> <a id="465" href="Foundation.Prelude.html" class="Module">Foundation.Prelude</a>
<a id="484" class="Keyword">open</a> <a id="489" class="Keyword">import</a> <a id="496" href="Foundation.Prop.Logic.html" class="Module">Foundation.Prop.Logic</a>
<a id="518" class="Keyword">open</a> <a id="523" class="Keyword">import</a> <a id="530" href="Foundation.Prop.Iff.html" class="Module">Foundation.Prop.Iff</a>
<a id="550" class="Keyword">open</a> <a id="555" class="Keyword">import</a> <a id="562" href="Foundation.Prop.Truncation.html" class="Module">Foundation.Prop.Truncation</a>
<a id="589" class="Keyword">open</a> <a id="594" class="Keyword">import</a> <a id="601" href="Foundation.Function.Bijection.html" class="Module">Foundation.Function.Bijection</a>

<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="Foundation.Data.Maybe.html" class="Module">Foundation.Data.Maybe</a>
<a id="666" class="Keyword">open</a> <a id="671" class="Keyword">import</a> <a id="678" href="Foundation.Data.Nat.ConstructiveEpsilon.html" class="Module">Foundation.Data.Nat.ConstructiveEpsilon</a>
<a id="718" class="Keyword">open</a> <a id="723" class="Keyword">import</a> <a id="730" href="Foundation.Relation.Nullary.Decidable.html" class="Module">Foundation.Relation.Nullary.Decidable</a>
<a id="768" class="Keyword">open</a> <a id="773" class="Keyword">import</a> <a id="780" href="Foundation.Relation.Nullary.Discrete.Base.html" class="Module">Foundation.Relation.Nullary.Discrete.Base</a>
<a id="822" class="Keyword">open</a> <a id="827" class="Keyword">import</a> <a id="834" href="Foundation.Relation.Nullary.Discrete.Instance.html" class="Module">Foundation.Relation.Nullary.Discrete.Instance</a>
<a id="880" class="Keyword">open</a> <a id="885" class="Keyword">import</a> <a id="892" href="Foundation.Relation.Unary.Countable.html" class="Module">Foundation.Relation.Unary.Countable</a>
</pre>
<p><strong><u>定义</u></strong> <code>x : A</code> 在 <code>A</code> 的可选值序列 <code>f : ℕ → A ？</code> 中的见证集, 记作 <code>Witness f x</code>, 定义为满足 <code>f n ≡ some x</code> 的所有 <code>n</code> 组成的集合.</p>
<pre class="Agda"><a id="Witness"></a><a id="1052" href="Foundation.Function.Enumeration.MaybeView.html#1052" class="Function">Witness</a> <a id="1060" class="Symbol">:</a> <a id="1062" class="Symbol">(</a><a id="1063" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1065" class="Symbol">→</a> <a id="1067" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1069" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="1070" class="Symbol">)</a> <a id="1072" class="Symbol">→</a> <a id="1074" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1076" class="Symbol">→</a> <a id="1078" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1080" class="Symbol">_</a>
<a id="1082" href="Foundation.Function.Enumeration.MaybeView.html#1052" class="Function">Witness</a> <a id="1090" href="Foundation.Function.Enumeration.MaybeView.html#1090" class="Bound">f</a> <a id="1092" href="Foundation.Function.Enumeration.MaybeView.html#1092" class="Bound">x</a> <a id="1094" class="Symbol">=</a> <a id="1096" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1098" href="Foundation.Function.Enumeration.MaybeView.html#1098" class="Bound">n</a> <a id="1100" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1102" href="Foundation.Function.Enumeration.MaybeView.html#1090" class="Bound">f</a> <a id="1104" href="Foundation.Function.Enumeration.MaybeView.html#1098" class="Bound">n</a> <a id="1106" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1108" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="1113" href="Foundation.Function.Enumeration.MaybeView.html#1092" class="Bound">x</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>f</code> 见证了 <code>x</code>, 记作 <code>f witness x</code>, 当且仅当见证集 <code>Witness f x</code> 有值, 也即存在 <code>n</code> 满足 <code>f n ≡ some x</code>.</p>
<pre class="Agda"><a id="_witness_"></a><a id="1232" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">_witness_</a> <a id="1242" class="Symbol">:</a> <a id="1244" class="Symbol">(</a><a id="1245" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1247" class="Symbol">→</a> <a id="1249" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1251" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="1252" class="Symbol">)</a> <a id="1254" class="Symbol">→</a> <a id="1256" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1258" class="Symbol">→</a> <a id="1260" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1262" class="Symbol">_</a>
<a id="1264" href="Foundation.Function.Enumeration.MaybeView.html#1264" class="Bound">f</a> <a id="1266" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">witness</a> <a id="1274" href="Foundation.Function.Enumeration.MaybeView.html#1274" class="Bound">x</a> <a id="1276" class="Symbol">=</a> <a id="1278" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="1280" href="Foundation.Function.Enumeration.MaybeView.html#1052" class="Function">Witness</a> <a id="1288" href="Foundation.Function.Enumeration.MaybeView.html#1264" class="Bound">f</a> <a id="1290" href="Foundation.Function.Enumeration.MaybeView.html#1274" class="Bound">x</a> <a id="1292" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p><strong><u>定义</u></strong> 见证了所有 <code>x : A</code> 的 <code>f</code> 构成了 <code>A</code> 的一个枚举, 记作 <code>Enum f</code>.</p>
<pre class="Agda"><a id="Enum"></a><a id="1371" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="1376" class="Symbol">:</a> <a id="1378" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1380" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a> <a id="1382" class="Symbol">→</a> <a id="1384" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1386" class="Symbol">_</a>
<a id="1388" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="1393" href="Foundation.Function.Enumeration.MaybeView.html#1393" class="Bound">A</a> <a id="1395" class="Symbol">=</a> <a id="1397" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1399" href="Foundation.Function.Enumeration.MaybeView.html#1399" class="Bound">f</a> <a id="1401" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1403" class="Symbol">∀</a> <a id="1405" class="Symbol">(</a><a id="1406" href="Foundation.Function.Enumeration.MaybeView.html#1406" class="Bound">x</a> <a id="1408" class="Symbol">:</a> <a id="1410" href="Foundation.Function.Enumeration.MaybeView.html#1393" class="Bound">A</a><a id="1411" class="Symbol">)</a> <a id="1413" class="Symbol">→</a> <a id="1415" href="Foundation.Function.Enumeration.MaybeView.html#1399" class="Bound">f</a> <a id="1417" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">witness</a> <a id="1425" href="Foundation.Function.Enumeration.MaybeView.html#1406" class="Bound">x</a>
</pre>
<p><strong><u>定义</u></strong> 当且仅当 <code>P x</code> 成立时会见证 <code>x</code> 的 <code>f</code> 构成了满足 <code>P</code> 的那些 <code>x : A</code> 的一个枚举, 简称 <code>P</code> 的一个枚举, 记作 <code>Enumℙ P</code>.</p>
<pre class="Agda"><a id="Enumℙ"></a><a id="1540" href="Foundation.Function.Enumeration.MaybeView.html#1540" class="Function">Enumℙ</a> <a id="1546" class="Symbol">:</a> <a id="1548" class="Symbol">(</a><a id="1549" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1551" class="Symbol">→</a> <a id="1553" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1555" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="1556" class="Symbol">)</a> <a id="1558" class="Symbol">→</a> <a id="1560" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1562" class="Symbol">_</a>
<a id="1564" href="Foundation.Function.Enumeration.MaybeView.html#1540" class="Function">Enumℙ</a> <a id="1570" href="Foundation.Function.Enumeration.MaybeView.html#1570" class="Bound">P</a> <a id="1572" class="Symbol">=</a> <a id="1574" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1576" href="Foundation.Function.Enumeration.MaybeView.html#1576" class="Bound">f</a> <a id="1578" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1580" class="Symbol">∀</a> <a id="1582" href="Foundation.Function.Enumeration.MaybeView.html#1582" class="Bound">x</a> <a id="1584" class="Symbol">→</a> <a id="1586" href="Foundation.Function.Enumeration.MaybeView.html#1570" class="Bound">P</a> <a id="1588" href="Foundation.Function.Enumeration.MaybeView.html#1582" class="Bound">x</a> <a id="1590" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1592" href="Foundation.Function.Enumeration.MaybeView.html#1576" class="Bound">f</a> <a id="1594" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">witness</a> <a id="1602" href="Foundation.Function.Enumeration.MaybeView.html#1582" class="Bound">x</a>
</pre>
<p>当 <code>P</code> 是恒真性质时, 以上两种枚举可以相互转化.</p>
<pre class="Agda"><a id="Enum↔ℙ"></a><a id="1646" href="Foundation.Function.Enumeration.MaybeView.html#1646" class="Function">Enum↔ℙ</a> <a id="1653" class="Symbol">:</a> <a id="1655" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="1660" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1662" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1664" href="Foundation.Function.Enumeration.MaybeView.html#1540" class="Function">Enumℙ</a> <a id="1670" class="Symbol">λ</a> <a id="1672" class="Symbol">(</a><a id="1673" href="Foundation.Function.Enumeration.MaybeView.html#1673" class="Bound">_</a> <a id="1675" class="Symbol">:</a> <a id="1677" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a><a id="1678" class="Symbol">)</a> <a id="1680" class="Symbol">→</a> <a id="1682" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="1684" href="Foundation.Function.Enumeration.MaybeView.html#1646" class="Function">Enum↔ℙ</a> <a id="1691" class="Symbol">=</a> <a id="1693" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇒:</a> <a id="1696" class="Symbol">(λ</a> <a id="1699" class="Symbol">(</a><a id="1700" href="Foundation.Function.Enumeration.MaybeView.html#1700" class="Bound">f</a> <a id="1702" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1704" href="Foundation.Function.Enumeration.MaybeView.html#1704" class="Bound">H</a><a id="1705" class="Symbol">)</a> <a id="1707" class="Symbol">→</a> <a id="1709" href="Foundation.Function.Enumeration.MaybeView.html#1700" class="Bound">f</a> <a id="1711" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1713" class="Symbol">λ</a> <a id="1715" href="Foundation.Function.Enumeration.MaybeView.html#1715" class="Bound">x</a> <a id="1717" class="Symbol">→</a> <a id="1719" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇒:</a> <a id="1722" class="Symbol">(λ</a> <a id="1725" href="Foundation.Function.Enumeration.MaybeView.html#1725" class="Bound">_</a> <a id="1727" class="Symbol">→</a> <a id="1729" href="Foundation.Function.Enumeration.MaybeView.html#1704" class="Bound">H</a> <a id="1731" href="Foundation.Function.Enumeration.MaybeView.html#1715" class="Bound">x</a><a id="1732" class="Symbol">)</a> <a id="1734" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇐:</a> <a id="1737" class="Symbol">(λ</a> <a id="1740" href="Foundation.Function.Enumeration.MaybeView.html#1740" class="Bound">_</a> <a id="1742" class="Symbol">→</a> <a id="1744" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1746" class="Symbol">))</a>
         <a id="1758" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇐:</a> <a id="1761" class="Symbol">(λ</a> <a id="1764" class="Symbol">(</a><a id="1765" href="Foundation.Function.Enumeration.MaybeView.html#1765" class="Bound">f</a> <a id="1767" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1769" href="Foundation.Function.Enumeration.MaybeView.html#1769" class="Bound">H</a><a id="1770" class="Symbol">)</a> <a id="1772" class="Symbol">→</a> <a id="1774" href="Foundation.Function.Enumeration.MaybeView.html#1765" class="Bound">f</a> <a id="1776" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1778" class="Symbol">λ</a> <a id="1780" href="Foundation.Function.Enumeration.MaybeView.html#1780" class="Bound">x</a> <a id="1782" class="Symbol">→</a> <a id="1784" href="Foundation.Function.Enumeration.MaybeView.html#1769" class="Bound">H</a> <a id="1786" href="Foundation.Function.Enumeration.MaybeView.html#1780" class="Bound">x</a> <a id="1788" class="Symbol">.</a><a id="1789" href="Foundation.Prop.Iff.html#373" class="Field">⇒</a> <a id="1791" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1793" class="Symbol">)</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>A</code> 递归可枚举, 当且仅当存在 <code>A</code> 的一个枚举.</p>
<pre class="Agda"><a id="enumerable"></a><a id="1856" href="Foundation.Function.Enumeration.MaybeView.html#1856" class="Function">enumerable</a> <a id="1867" class="Symbol">:</a> <a id="1869" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1871" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a> <a id="1873" class="Symbol">→</a> <a id="1875" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1877" class="Symbol">_</a>
<a id="1879" href="Foundation.Function.Enumeration.MaybeView.html#1856" class="Function">enumerable</a> <a id="1890" href="Foundation.Function.Enumeration.MaybeView.html#1890" class="Bound">A</a> <a id="1892" class="Symbol">=</a> <a id="1894" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="1896" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="1901" href="Foundation.Function.Enumeration.MaybeView.html#1890" class="Bound">A</a> <a id="1903" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>P</code> 递归可枚举, 当且仅当存在 <code>P</code> 的一个枚举.</p>
<pre class="Agda"><a id="enumerableℙ"></a><a id="1967" href="Foundation.Function.Enumeration.MaybeView.html#1967" class="Function">enumerableℙ</a> <a id="1979" class="Symbol">:</a> <a id="1981" class="Symbol">(</a><a id="1982" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1988" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="1989" class="Symbol">)</a> <a id="1991" class="Symbol">→</a> <a id="1993" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1995" class="Symbol">_</a>
<a id="1997" href="Foundation.Function.Enumeration.MaybeView.html#1967" class="Function">enumerableℙ</a> <a id="2009" href="Foundation.Function.Enumeration.MaybeView.html#2009" class="Bound">P</a> <a id="2011" class="Symbol">=</a> <a id="2013" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="2015" href="Foundation.Function.Enumeration.MaybeView.html#1540" class="Function">Enumℙ</a> <a id="2021" href="Foundation.Function.Enumeration.MaybeView.html#2009" class="Bound">P</a> <a id="2023" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p>当 <code>P</code> 是恒真性质时, 以上两种递归可枚举性等价.</p>
<pre class="Agda"><a id="enumerable↔ℙ"></a><a id="2068" href="Foundation.Function.Enumeration.MaybeView.html#2068" class="Function">enumerable↔ℙ</a> <a id="2081" class="Symbol">:</a> <a id="2083" href="Foundation.Function.Enumeration.MaybeView.html#1856" class="Function">enumerable</a> <a id="2094" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2096" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="2098" href="Foundation.Function.Enumeration.MaybeView.html#1967" class="Function">enumerableℙ</a> <a id="2110" class="Symbol">λ</a> <a id="2112" class="Symbol">(</a><a id="2113" href="Foundation.Function.Enumeration.MaybeView.html#2113" class="Bound">_</a> <a id="2115" class="Symbol">:</a> <a id="2117" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a><a id="2118" class="Symbol">)</a> <a id="2120" class="Symbol">→</a> <a id="2122" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="2124" href="Foundation.Function.Enumeration.MaybeView.html#2068" class="Function">enumerable↔ℙ</a> <a id="2137" class="Symbol">=</a> <a id="2139" href="Foundation.Prop.Iff.html#2826" class="Function">↔-map</a> <a id="2145" href="Foundation.Function.Enumeration.MaybeView.html#1646" class="Function">Enum↔ℙ</a>
</pre>
<p><strong><u>引理</u></strong> 如果 <code>f</code> 见证了整个离散集 <code>A</code>, 那么可以取到每个 <code>x : A</code> 的见证.<br />
<strong><u>证明</u></strong> 这是一个类似选择公理的形式, 自然数的良序性提供了“选择函数”, 即对每个 <code>x : A</code> 取最小的见证 <code>n</code> 即可. ∎</p>
<pre class="Agda"><a id="discr→wit→Wit"></a><a id="2302" href="Foundation.Function.Enumeration.MaybeView.html#2302" class="Function">discr→wit→Wit</a> <a id="2316" class="Symbol">:</a> <a id="2318" class="Symbol">⦃</a> <a id="2320" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="2329" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2331" class="Symbol">⦄</a> <a id="2333" class="Symbol">→</a> <a id="2335" class="Symbol">{</a><a id="2336" href="Foundation.Function.Enumeration.MaybeView.html#2336" class="Bound">f</a> <a id="2338" class="Symbol">:</a> <a id="2340" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2342" class="Symbol">→</a> <a id="2344" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2346" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="2347" class="Symbol">}</a> <a id="2349" class="Symbol">→</a> <a id="2351" class="Symbol">(∀</a> <a id="2354" href="Foundation.Function.Enumeration.MaybeView.html#2354" class="Bound">x</a> <a id="2356" class="Symbol">→</a> <a id="2358" href="Foundation.Function.Enumeration.MaybeView.html#2336" class="Bound">f</a> <a id="2360" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">witness</a> <a id="2368" href="Foundation.Function.Enumeration.MaybeView.html#2354" class="Bound">x</a><a id="2369" class="Symbol">)</a> <a id="2371" class="Symbol">→</a> <a id="2373" class="Symbol">(∀</a> <a id="2376" href="Foundation.Function.Enumeration.MaybeView.html#2376" class="Bound">x</a> <a id="2378" class="Symbol">→</a> <a id="2380" href="Foundation.Function.Enumeration.MaybeView.html#1052" class="Function">Witness</a> <a id="2388" href="Foundation.Function.Enumeration.MaybeView.html#2336" class="Bound">f</a> <a id="2390" href="Foundation.Function.Enumeration.MaybeView.html#2376" class="Bound">x</a><a id="2391" class="Symbol">)</a>
<a id="2393" href="Foundation.Function.Enumeration.MaybeView.html#2302" class="Function">discr→wit→Wit</a> <a id="2407" class="Symbol">{</a><a id="2408" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">f</a><a id="2409" class="Symbol">}</a> <a id="2411" href="Foundation.Function.Enumeration.MaybeView.html#2411" class="Bound">wit</a> <a id="2415" href="Foundation.Function.Enumeration.MaybeView.html#2415" class="Bound">x</a> <a id="2417" class="Symbol">=</a> <a id="2419" href="Foundation.Data.Nat.ConstructiveEpsilon.html#1428" class="Function">ε</a> <a id="2421" href="Foundation.Function.Enumeration.MaybeView.html#2448" class="Function">sets</a> <a id="2426" href="Foundation.Function.Enumeration.MaybeView.html#2540" class="Function">discr</a> <a id="2432" class="Symbol">(</a><a id="2433" href="Foundation.Function.Enumeration.MaybeView.html#2411" class="Bound">wit</a> <a id="2437" href="Foundation.Function.Enumeration.MaybeView.html#2415" class="Bound">x</a><a id="2438" class="Symbol">)</a> <a id="2440" class="Keyword">where</a>
  <a id="2448" href="Foundation.Function.Enumeration.MaybeView.html#2448" class="Function">sets</a> <a id="2453" class="Symbol">:</a> <a id="2455" href="Foundation.Prelude.HLevel.html#945" class="Function">isSets</a> <a id="2462" class="Symbol">(λ</a> <a id="2465" href="Foundation.Function.Enumeration.MaybeView.html#2465" class="Bound">n</a> <a id="2467" class="Symbol">→</a> <a id="2469" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">f</a> <a id="2471" href="Foundation.Function.Enumeration.MaybeView.html#2465" class="Bound">n</a> <a id="2473" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2475" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="2480" href="Foundation.Function.Enumeration.MaybeView.html#2415" class="Bound">x</a><a id="2481" class="Symbol">)</a>
  <a id="2485" href="Foundation.Function.Enumeration.MaybeView.html#2448" class="Function">sets</a> <a id="2490" href="Foundation.Function.Enumeration.MaybeView.html#2490" class="Bound">n</a> <a id="2492" class="Symbol">=</a> <a id="2494" href="Foundation.Prelude.HLevel.html#2002" class="Function">isProp→isSet</a> <a id="2507" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2509" class="Symbol">(</a><a id="2510" href="Foundation.Data.Maybe.html#1098" class="Function">isSetMaybe</a> <a id="2521" href="Foundation.Relation.Nullary.Discrete.Base.html#1631" class="Function">discreteSet</a><a id="2532" class="Symbol">)</a> <a id="2534" class="Symbol">_</a> <a id="2536" class="Symbol">_</a>
  <a id="2540" href="Foundation.Function.Enumeration.MaybeView.html#2540" class="Function">discr</a> <a id="2546" class="Symbol">:</a> <a id="2548" class="Symbol">∀</a> <a id="2550" href="Foundation.Function.Enumeration.MaybeView.html#2550" class="Bound">n</a> <a id="2552" class="Symbol">→</a> <a id="2554" href="Relation.Nullary.Decidable.Core.html#1478" class="Record">Dec</a> <a id="2558" class="Symbol">(</a><a id="2559" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">f</a> <a id="2561" href="Foundation.Function.Enumeration.MaybeView.html#2550" class="Bound">n</a> <a id="2563" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2565" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="2570" href="Foundation.Function.Enumeration.MaybeView.html#2415" class="Bound">x</a><a id="2571" class="Symbol">)</a>
  <a id="2575" href="Foundation.Function.Enumeration.MaybeView.html#2540" class="Function">discr</a> <a id="2581" href="Foundation.Function.Enumeration.MaybeView.html#2581" class="Bound">n</a> <a id="2583" class="Symbol">=</a> <a id="2585" href="Function.Base.html#4724" class="Function">it</a>
</pre>
<p><strong><u>事实</u></strong> 离散的递归可枚举集可数.<br />
<strong><u>证明</u></strong> 只需证 <code>A</code> 的枚举可以转化为 <code>A</code> 到 <code>ℕ</code> 的单射. 用 <code>discr→wit→Wit</code> 取每个 <code>x</code> 的见证 <code>n</code>, 将该映射记为 <code>g</code>, 它满足</p>
<p><code>f∘g-wit : ∀ x → f (g x) ≡ some x</code></p>
<p>我们证明 <code>g</code> 即是单射. 给定等式 <code>g x ≡ g y</code>, 则有 <code>f (g x) ≡ f (g y)</code>. 两边用 <code>f∘g-wit</code> 换成 <code>some</code> 形式, 再用 <code>some</code> 的单射性即得 <code>x ≡ y</code>. ∎</p>
<pre class="Agda"><a id="discr→enum→count"></a><a id="2878" href="Foundation.Function.Enumeration.MaybeView.html#2878" class="Function">discr→enum→count</a> <a id="2895" class="Symbol">:</a> <a id="2897" class="Symbol">⦃</a> <a id="2899" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="2908" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2910" class="Symbol">⦄</a> <a id="2912" class="Symbol">→</a> <a id="2914" href="Foundation.Function.Enumeration.MaybeView.html#1856" class="Function">enumerable</a> <a id="2925" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2927" class="Symbol">→</a> <a id="2929" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="2939" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="2941" href="Foundation.Function.Enumeration.MaybeView.html#2878" class="Function">discr→enum→count</a> <a id="2958" class="Symbol">{</a><a id="2959" href="Foundation.Function.Enumeration.MaybeView.html#2959" class="Bound">A</a><a id="2960" class="Symbol">}</a> <a id="2962" class="Symbol">=</a> <a id="2964" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="2970" href="Foundation.Function.Enumeration.MaybeView.html#2980" class="Function">H</a> <a id="2972" class="Keyword">where</a>
  <a id="2980" href="Foundation.Function.Enumeration.MaybeView.html#2980" class="Function">H</a> <a id="2982" class="Symbol">:</a> <a id="2984" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="2989" href="Foundation.Function.Enumeration.MaybeView.html#2959" class="Bound">A</a> <a id="2991" class="Symbol">→</a> <a id="2993" href="Foundation.Function.Enumeration.MaybeView.html#2959" class="Bound">A</a> <a id="2995" href="Foundation.Function.Bijection.html#1202" class="Function Operator">↣</a> <a id="2997" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="3001" href="Foundation.Function.Enumeration.MaybeView.html#2980" class="Function">H</a> <a id="3003" class="Symbol">(</a><a id="3004" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3006" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3008" href="Foundation.Function.Enumeration.MaybeView.html#3008" class="Bound">f-wit</a><a id="3013" class="Symbol">)</a> <a id="3015" class="Symbol">=</a> <a id="3017" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3019" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3021" href="Foundation.Function.Enumeration.MaybeView.html#3188" class="Function">g-inj</a> <a id="3027" class="Keyword">where</a>
    <a id="3037" href="Foundation.Function.Enumeration.MaybeView.html#3037" class="Function">Wit</a> <a id="3041" class="Symbol">:</a> <a id="3043" class="Symbol">∀</a> <a id="3045" href="Foundation.Function.Enumeration.MaybeView.html#3045" class="Bound">x</a> <a id="3047" class="Symbol">→</a> <a id="3049" href="Foundation.Function.Enumeration.MaybeView.html#1052" class="Function">Witness</a> <a id="3057" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3059" href="Foundation.Function.Enumeration.MaybeView.html#3045" class="Bound">x</a>
    <a id="3065" href="Foundation.Function.Enumeration.MaybeView.html#3037" class="Function">Wit</a> <a id="3069" class="Symbol">=</a> <a id="3071" href="Foundation.Function.Enumeration.MaybeView.html#2302" class="Function">discr→wit→Wit</a> <a id="3085" href="Foundation.Function.Enumeration.MaybeView.html#3008" class="Bound">f-wit</a>
    <a id="3095" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3097" class="Symbol">:</a> <a id="3099" href="Foundation.Function.Enumeration.MaybeView.html#2959" class="Bound">A</a> <a id="3101" class="Symbol">→</a> <a id="3103" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="3109" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3111" class="Symbol">=</a> <a id="3113" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="3117" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3119" href="Foundation.Function.Enumeration.MaybeView.html#3037" class="Function">Wit</a>
    <a id="3127" href="Foundation.Function.Enumeration.MaybeView.html#3127" class="Function">f∘g-wit</a> <a id="3135" class="Symbol">:</a> <a id="3137" class="Symbol">∀</a> <a id="3139" href="Foundation.Function.Enumeration.MaybeView.html#3139" class="Bound">x</a> <a id="3141" class="Symbol">→</a> <a id="3143" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3145" class="Symbol">(</a><a id="3146" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3148" href="Foundation.Function.Enumeration.MaybeView.html#3139" class="Bound">x</a><a id="3149" class="Symbol">)</a> <a id="3151" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3153" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3158" href="Foundation.Function.Enumeration.MaybeView.html#3139" class="Bound">x</a>
    <a id="3164" href="Foundation.Function.Enumeration.MaybeView.html#3127" class="Function">f∘g-wit</a> <a id="3172" class="Symbol">=</a> <a id="3174" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="3178" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3180" href="Foundation.Function.Enumeration.MaybeView.html#3037" class="Function">Wit</a>
    <a id="3188" href="Foundation.Function.Enumeration.MaybeView.html#3188" class="Function">g-inj</a> <a id="3194" class="Symbol">:</a> <a id="3196" href="Foundation.Function.Bijection.html#653" class="Function">injective</a> <a id="3206" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a>
    <a id="3212" href="Foundation.Function.Enumeration.MaybeView.html#3188" class="Function">g-inj</a> <a id="3218" class="Symbol">{</a><a id="3219" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">x</a><a id="3220" class="Symbol">}</a> <a id="3222" class="Symbol">{</a><a id="3223" href="Foundation.Function.Enumeration.MaybeView.html#3223" class="Bound">y</a><a id="3224" class="Symbol">}</a> <a id="3226" href="Foundation.Function.Enumeration.MaybeView.html#3226" class="Bound">eq</a> <a id="3229" class="Symbol">=</a> <a id="3231" href="Data.Maybe.Properties.html#1056" class="Function">some-inj</a> <a id="3240" href="Function.Base.html#1974" class="Function Operator">$</a>
      <a id="3248" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3253" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">x</a>   <a id="3257" href="Foundation.Prelude.Equality.html#1139" class="Function Operator">≡˘⟨</a> <a id="3261" href="Foundation.Function.Enumeration.MaybeView.html#3127" class="Function">f∘g-wit</a> <a id="3269" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">x</a> <a id="3271" href="Foundation.Prelude.Equality.html#1139" class="Function Operator">⟩</a>
      <a id="3279" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3281" class="Symbol">(</a><a id="3282" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3284" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">x</a><a id="3285" class="Symbol">)</a>  <a id="3288" href="Foundation.Prelude.Equality.html#1068" class="Function Operator">≡⟨</a> <a id="3291" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="3296" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3298" href="Foundation.Function.Enumeration.MaybeView.html#3226" class="Bound">eq</a> <a id="3301" href="Foundation.Prelude.Equality.html#1068" class="Function Operator">⟩</a>
      <a id="3309" href="Foundation.Function.Enumeration.MaybeView.html#3004" class="Bound">f</a> <a id="3311" class="Symbol">(</a><a id="3312" href="Foundation.Function.Enumeration.MaybeView.html#3095" class="Function">g</a> <a id="3314" href="Foundation.Function.Enumeration.MaybeView.html#3223" class="Bound">y</a><a id="3315" class="Symbol">)</a>  <a id="3318" href="Foundation.Prelude.Equality.html#1068" class="Function Operator">≡⟨</a> <a id="3321" href="Foundation.Function.Enumeration.MaybeView.html#3127" class="Function">f∘g-wit</a> <a id="3329" href="Foundation.Function.Enumeration.MaybeView.html#3223" class="Bound">y</a> <a id="3331" href="Foundation.Prelude.Equality.html#1068" class="Function Operator">⟩</a>
      <a id="3339" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3344" href="Foundation.Function.Enumeration.MaybeView.html#3223" class="Bound">y</a>   <a id="3348" href="Foundation.Prelude.Equality.html#1227" class="Function Operator">∎</a>
</pre>
<p><strong><u>事实</u></strong> 可数无穷集离散.<br />
<strong><u>证明</u></strong> 由于集合的离散性是命题, 可转化为证 <code>A ≅ ℕ → discrete A</code>, 于是可归结为 <code>ℕ</code> 的离散性. ∎</p>
<pre class="Agda"><a id="count∞→discr"></a><a id="3463" href="Foundation.Function.Enumeration.MaybeView.html#3463" class="Function">count∞→discr</a> <a id="3476" class="Symbol">:</a> <a id="3478" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="3484" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3486" class="Symbol">→</a> <a id="3488" href="Foundation.Relation.Unary.Countable.html#212" class="Function">countablyInfinite</a> <a id="3506" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3508" class="Symbol">→</a> <a id="3510" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="3519" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="3521" href="Foundation.Function.Enumeration.MaybeView.html#3463" class="Function">count∞→discr</a> <a id="3534" href="Foundation.Function.Enumeration.MaybeView.html#3534" class="Bound">sA</a> <a id="3537" class="Symbol">=</a> <a id="3539" href="Foundation.Prop.Truncation.html#350" class="Function">𝟙.rec</a> <a id="3545" class="Symbol">(</a><a id="3546" href="Foundation.Relation.Nullary.Discrete.Base.html#1355" class="Function">isPropDiscrete</a> <a id="3561" href="Foundation.Function.Enumeration.MaybeView.html#3534" class="Bound">sA</a><a id="3563" class="Symbol">)</a> <a id="3565" href="Foundation.Function.Enumeration.MaybeView.html#3575" class="Function">H</a> <a id="3567" class="Keyword">where</a>
  <a id="3575" href="Foundation.Function.Enumeration.MaybeView.html#3575" class="Function">H</a> <a id="3577" class="Symbol">:</a> <a id="3579" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3581" href="Foundation.Prelude.Equality.html#408" class="Record Operator">≅</a> <a id="3583" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3585" class="Symbol">→</a> <a id="3587" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="3596" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
  <a id="3600" href="Foundation.Function.Enumeration.MaybeView.html#3575" class="Function">H</a> <a id="3602" class="Symbol">(</a><a id="3603" href="Foundation.Prelude.Equality.html#434" class="InductiveConstructor">mk≅</a> <a id="3607" href="Foundation.Function.Enumeration.MaybeView.html#3607" class="Bound">f</a> <a id="3609" href="Foundation.Function.Enumeration.MaybeView.html#3609" class="Bound">f⁻¹</a> <a id="3613" href="Foundation.Function.Enumeration.MaybeView.html#3613" class="Bound">f∘f⁻¹</a> <a id="3619" href="Foundation.Function.Enumeration.MaybeView.html#3619" class="Bound">f⁻¹∘f</a><a id="3624" class="Symbol">)</a> <a id="3626" class="Symbol">{</a><a id="3627" href="Foundation.Function.Enumeration.MaybeView.html#3627" class="Bound">x</a><a id="3628" class="Symbol">}</a> <a id="3630" class="Symbol">{</a><a id="3631" href="Foundation.Function.Enumeration.MaybeView.html#3631" class="Bound">y</a><a id="3632" class="Symbol">}</a> <a id="3634" class="Keyword">with</a> <a id="3639" href="Foundation.Function.Enumeration.MaybeView.html#3607" class="Bound">f</a> <a id="3641" href="Foundation.Function.Enumeration.MaybeView.html#3627" class="Bound">x</a> <a id="3643" href="Foundation.Relation.Nullary.Discrete.Base.html#999" class="Function Operator">≟</a> <a id="3645" href="Foundation.Function.Enumeration.MaybeView.html#3607" class="Bound">f</a> <a id="3647" href="Foundation.Function.Enumeration.MaybeView.html#3631" class="Bound">y</a>
  <a id="3651" class="Symbol">...</a> <a id="3655" class="Symbol">|</a> <a id="3657" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="3661" href="Foundation.Function.Enumeration.MaybeView.html#3661" class="Bound">p</a> <a id="3663" class="Symbol">=</a> <a id="3665" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="3669" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3671" href="Foundation.Prelude.Equality.html#1426" class="Function">subst2</a> <a id="3678" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="3682" class="Symbol">(</a><a id="3683" class="Bound">f⁻¹∘f</a> <a id="3689" class="Symbol">_)</a> <a id="3692" class="Symbol">(</a><a id="3693" class="Bound">f⁻¹∘f</a> <a id="3699" class="Symbol">_)</a> <a id="3702" class="Symbol">(</a><a id="3703" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="3708" class="Bound">f⁻¹</a> <a id="3712" href="Foundation.Function.Enumeration.MaybeView.html#3661" class="Bound">p</a><a id="3713" class="Symbol">)</a>
  <a id="3717" class="Symbol">...</a> <a id="3721" class="Symbol">|</a> <a id="3723" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="3726" href="Foundation.Function.Enumeration.MaybeView.html#3726" class="Bound">¬p</a> <a id="3729" class="Symbol">=</a> <a id="3731" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="3734" class="Symbol">λ</a> <a id="3736" class="Symbol">{</a> <a id="3738" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3743" class="Symbol">→</a> <a id="3745" href="Foundation.Function.Enumeration.MaybeView.html#3726" class="Bound">¬p</a> <a id="3748" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3753" class="Symbol">}</a>
</pre>
<p><strong><u>事实</u></strong> 可数无穷蕴含递归可枚举.<br />
<strong><u>证明</u></strong> 即证与自然数集的同构可以转化为枚举. 同构给了我们互逆的 <code>f : A → ℕ</code> 和 <code>f⁻¹ : ℕ → A</code>. <code>some</code> 与 <code>f⁻¹</code> 的复合即是所需的枚举函数, <code>f x</code> 给出了 <code>x</code> 在 <code>some ∘ f⁻¹</code> 中的一个见证. ∎</p>
<pre class="Agda"><a id="count∞→enum"></a><a id="3938" href="Foundation.Function.Enumeration.MaybeView.html#3938" class="Function">count∞→enum</a> <a id="3950" class="Symbol">:</a> <a id="3952" href="Foundation.Relation.Unary.Countable.html#212" class="Function">countablyInfinite</a> <a id="3970" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3972" class="Symbol">→</a> <a id="3974" href="Foundation.Function.Enumeration.MaybeView.html#1856" class="Function">enumerable</a> <a id="3985" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="3987" href="Foundation.Function.Enumeration.MaybeView.html#3938" class="Function">count∞→enum</a> <a id="3999" class="Symbol">{</a><a id="4000" href="Foundation.Function.Enumeration.MaybeView.html#4000" class="Bound">A</a><a id="4001" class="Symbol">}</a> <a id="4003" class="Symbol">=</a> <a id="4005" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="4011" href="Foundation.Function.Enumeration.MaybeView.html#4021" class="Function">H</a> <a id="4013" class="Keyword">where</a>
  <a id="4021" href="Foundation.Function.Enumeration.MaybeView.html#4021" class="Function">H</a> <a id="4023" class="Symbol">:</a> <a id="4025" href="Foundation.Function.Enumeration.MaybeView.html#4000" class="Bound">A</a> <a id="4027" href="Foundation.Prelude.Equality.html#408" class="Record Operator">≅</a> <a id="4029" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4031" class="Symbol">→</a> <a id="4033" href="Foundation.Function.Enumeration.MaybeView.html#1371" class="Function">Enum</a> <a id="4038" href="Foundation.Function.Enumeration.MaybeView.html#4000" class="Bound">A</a>
  <a id="4042" href="Foundation.Function.Enumeration.MaybeView.html#4021" class="Function">H</a> <a id="4044" class="Symbol">(</a><a id="4045" href="Foundation.Prelude.Equality.html#434" class="InductiveConstructor">mk≅</a> <a id="4049" href="Foundation.Function.Enumeration.MaybeView.html#4049" class="Bound">f</a> <a id="4051" href="Foundation.Function.Enumeration.MaybeView.html#4051" class="Bound">f⁻¹</a> <a id="4055" href="Foundation.Function.Enumeration.MaybeView.html#4055" class="Bound">f∘f⁻¹</a> <a id="4061" href="Foundation.Function.Enumeration.MaybeView.html#4061" class="Bound">f⁻¹∘f</a><a id="4066" class="Symbol">)</a> <a id="4068" class="Symbol">=</a> <a id="4070" href="Foundation.Function.Enumeration.MaybeView.html#4088" class="Function">g</a> <a id="4072" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4074" href="Foundation.Function.Enumeration.MaybeView.html#4107" class="Function">wit</a> <a id="4078" class="Keyword">where</a>
    <a id="4088" href="Foundation.Function.Enumeration.MaybeView.html#4088" class="Function">g</a> <a id="4090" class="Symbol">=</a> <a id="4092" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="4097" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4099" href="Foundation.Function.Enumeration.MaybeView.html#4051" class="Bound">f⁻¹</a>
    <a id="4107" href="Foundation.Function.Enumeration.MaybeView.html#4107" class="Function">wit</a> <a id="4111" class="Symbol">:</a> <a id="4113" class="Symbol">∀</a> <a id="4115" href="Foundation.Function.Enumeration.MaybeView.html#4115" class="Bound">x</a> <a id="4117" class="Symbol">→</a> <a id="4119" href="Foundation.Function.Enumeration.MaybeView.html#4088" class="Function">g</a> <a id="4121" href="Foundation.Function.Enumeration.MaybeView.html#1232" class="Function Operator">witness</a> <a id="4129" href="Foundation.Function.Enumeration.MaybeView.html#4115" class="Bound">x</a>
    <a id="4135" href="Foundation.Function.Enumeration.MaybeView.html#4107" class="Function">wit</a> <a id="4139" href="Foundation.Function.Enumeration.MaybeView.html#4139" class="Bound">x</a> <a id="4141" class="Symbol">=</a> <a id="4143" href="Foundation.Prop.Logic.html#821" class="Function">ex</a> <a id="4146" class="Symbol">(</a><a id="4147" href="Foundation.Function.Enumeration.MaybeView.html#4049" class="Bound">f</a> <a id="4149" href="Foundation.Function.Enumeration.MaybeView.html#4139" class="Bound">x</a><a id="4150" class="Symbol">)</a> <a id="4152" class="Symbol">(</a><a id="4153" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="4158" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="4163" class="Symbol">(</a><a id="4164" href="Foundation.Function.Enumeration.MaybeView.html#4061" class="Bound">f⁻¹∘f</a> <a id="4170" href="Foundation.Function.Enumeration.MaybeView.html#4139" class="Bound">x</a><a id="4171" class="Symbol">))</a>
</pre>
<p><strong><u>注意</u></strong> 由以上三个事实, 可以看出, 在我们的元语言中, 离散的递归可枚举集等价于可数集, 只要该可数集的基数被构造地给出.</p>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Function/Enumeration/MaybeView.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/Foundation.Function.Enumeration.MaybeView.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.maybeview">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
