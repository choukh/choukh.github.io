<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Foundation.Function.Enumeration.MaybeView</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#元语言-可枚举性-可选值序列视角" id="toc-元语言-可枚举性-可选值序列视角">元语言 ▸ 可枚举性 ▸ 可选值序列视角</a></li>
  </ul>
</nav>

<main>
<h1 id="元语言-可枚举性-可选值序列视角">元语言 ▸ 可枚举性 ▸ 可选值序列视角</h1>
<p>我们一共引入枚举的三种视角， 分别是：</p>
<ol type="1">
<li>可选值序列视角 (本篇): 与传统定义接轨, 但不会实际使用. 与视角2等价, 可以说明视角2的合理性.</li>
<li><a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.listview.base">累积列表视角</a>: 是我们实际构造的枚举函数.</li>
<li><a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.plainview">普通视角</a>: 是我们证明命题时实际使用的枚举函数, 从视角2转化.</li>
</ol>
<p>我们首先介绍可选值序列视角, 也就是传统的枚举定义.</p>
<pre class="Agda"><a id="397" class="Keyword">module</a> <a id="404" href="Foundation.Function.Enumeration.MaybeView.html" class="Module">Foundation.Function.Enumeration.MaybeView</a> <a id="446" class="Keyword">where</a>

<a id="453" class="Keyword">open</a> <a id="458" class="Keyword">import</a> <a id="465" href="Foundation.Prelude.html" class="Module">Foundation.Prelude</a>
<a id="484" class="Keyword">open</a> <a id="489" class="Keyword">import</a> <a id="496" href="Foundation.Prop.Logic.html" class="Module">Foundation.Prop.Logic</a>
<a id="518" class="Keyword">open</a> <a id="523" class="Keyword">import</a> <a id="530" href="Foundation.Prop.Iff.html" class="Module">Foundation.Prop.Iff</a>
<a id="550" class="Keyword">open</a> <a id="555" class="Keyword">import</a> <a id="562" href="Foundation.Prop.Truncation.html" class="Module">Foundation.Prop.Truncation</a>
<a id="589" class="Keyword">open</a> <a id="594" class="Keyword">import</a> <a id="601" href="Foundation.Function.Bijection.html" class="Module">Foundation.Function.Bijection</a>

<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="Foundation.Data.Maybe.html" class="Module">Foundation.Data.Maybe</a>
<a id="666" class="Keyword">open</a> <a id="671" class="Keyword">import</a> <a id="678" href="Foundation.Data.Nat.ConstructiveEpsilon.html" class="Module">Foundation.Data.Nat.ConstructiveEpsilon</a>
<a id="718" class="Keyword">open</a> <a id="723" class="Keyword">import</a> <a id="730" href="Foundation.Relation.Nullary.Decidable.html" class="Module">Foundation.Relation.Nullary.Decidable</a>
<a id="768" class="Keyword">open</a> <a id="773" class="Keyword">import</a> <a id="780" href="Foundation.Relation.Nullary.Discrete.Base.html" class="Module">Foundation.Relation.Nullary.Discrete.Base</a>
<a id="822" class="Keyword">open</a> <a id="827" class="Keyword">import</a> <a id="834" href="Foundation.Relation.Nullary.Discrete.Instance.html" class="Module">Foundation.Relation.Nullary.Discrete.Instance</a>
<a id="880" class="Keyword">open</a> <a id="885" class="Keyword">import</a> <a id="892" href="Foundation.Relation.Unary.Countable.html" class="Module">Foundation.Relation.Unary.Countable</a>
</pre>
<p><strong><u>定义</u></strong> <code>x : A</code> 在可选值序列 <code>f : ℕ → A ？</code> 中的见证集, 记作 <code>Witness f x</code>, 定义为满足 <code>f n ≡ some x</code> 的所有 <code>n</code> (称为 <code>x</code> 的见证) 组成的集合.</p>
<pre class="Agda"><a id="Witness"></a><a id="1059" href="Foundation.Function.Enumeration.MaybeView.html#1059" class="Function">Witness</a> <a id="1067" class="Symbol">:</a> <a id="1069" class="Symbol">(</a><a id="1070" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1072" class="Symbol">→</a> <a id="1074" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1076" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="1077" class="Symbol">)</a> <a id="1079" class="Symbol">→</a> <a id="1081" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1083" class="Symbol">→</a> <a id="1085" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1087" class="Symbol">_</a>
<a id="1089" href="Foundation.Function.Enumeration.MaybeView.html#1059" class="Function">Witness</a> <a id="1097" href="Foundation.Function.Enumeration.MaybeView.html#1097" class="Bound">f</a> <a id="1099" href="Foundation.Function.Enumeration.MaybeView.html#1099" class="Bound">x</a> <a id="1101" class="Symbol">=</a> <a id="1103" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1105" href="Foundation.Function.Enumeration.MaybeView.html#1105" class="Bound">n</a> <a id="1107" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1109" href="Foundation.Function.Enumeration.MaybeView.html#1097" class="Bound">f</a> <a id="1111" href="Foundation.Function.Enumeration.MaybeView.html#1105" class="Bound">n</a> <a id="1113" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1115" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="1120" href="Foundation.Function.Enumeration.MaybeView.html#1099" class="Bound">x</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>f</code> 见证了 <code>x</code>, 记作 <code>f witness x</code>, 当且仅当见证集 <code>Witness f x</code> 有值, 也即存在 <code>x</code> 的见证.</p>
<pre class="Agda"><a id="_witness_"></a><a id="1225" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">_witness_</a> <a id="1235" class="Symbol">:</a> <a id="1237" class="Symbol">(</a><a id="1238" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1240" class="Symbol">→</a> <a id="1242" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1244" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="1245" class="Symbol">)</a> <a id="1247" class="Symbol">→</a> <a id="1249" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1251" class="Symbol">→</a> <a id="1253" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1255" class="Symbol">_</a>
<a id="1257" href="Foundation.Function.Enumeration.MaybeView.html#1257" class="Bound">f</a> <a id="1259" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">witness</a> <a id="1267" href="Foundation.Function.Enumeration.MaybeView.html#1267" class="Bound">x</a> <a id="1269" class="Symbol">=</a> <a id="1271" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="1273" href="Foundation.Function.Enumeration.MaybeView.html#1059" class="Function">Witness</a> <a id="1281" href="Foundation.Function.Enumeration.MaybeView.html#1257" class="Bound">f</a> <a id="1283" href="Foundation.Function.Enumeration.MaybeView.html#1267" class="Bound">x</a> <a id="1285" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p><strong><u>定义</u></strong> 见证了所有 <code>x : A</code> 的 <code>f</code> 构成了 <code>A</code> 的一个枚举, 记作 <code>Enum f</code>.</p>
<pre class="Agda"><a id="Enum"></a><a id="1364" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="1369" class="Symbol">:</a> <a id="1371" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1373" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a> <a id="1375" class="Symbol">→</a> <a id="1377" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1379" class="Symbol">_</a>
<a id="1381" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="1386" href="Foundation.Function.Enumeration.MaybeView.html#1386" class="Bound">A</a> <a id="1388" class="Symbol">=</a> <a id="1390" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1392" href="Foundation.Function.Enumeration.MaybeView.html#1392" class="Bound">f</a> <a id="1394" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1396" class="Symbol">∀</a> <a id="1398" class="Symbol">(</a><a id="1399" href="Foundation.Function.Enumeration.MaybeView.html#1399" class="Bound">x</a> <a id="1401" class="Symbol">:</a> <a id="1403" href="Foundation.Function.Enumeration.MaybeView.html#1386" class="Bound">A</a><a id="1404" class="Symbol">)</a> <a id="1406" class="Symbol">→</a> <a id="1408" href="Foundation.Function.Enumeration.MaybeView.html#1392" class="Bound">f</a> <a id="1410" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">witness</a> <a id="1418" href="Foundation.Function.Enumeration.MaybeView.html#1399" class="Bound">x</a>
</pre>
<p><strong><u>定义</u></strong> 当且仅当 <code>P x</code> 成立时会见证 <code>x</code> 的 <code>f</code> 构成了满足 <code>P</code> 的那些 <code>x : A</code> 的一个枚举, 简称 <code>P</code> 的一个枚举, 记作 <code>Enumℙ P</code>.</p>
<pre class="Agda"><a id="Enumℙ"></a><a id="1533" href="Foundation.Function.Enumeration.MaybeView.html#1533" class="Function">Enumℙ</a> <a id="1539" class="Symbol">:</a> <a id="1541" class="Symbol">(</a><a id="1542" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1544" class="Symbol">→</a> <a id="1546" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1548" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="1549" class="Symbol">)</a> <a id="1551" class="Symbol">→</a> <a id="1553" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1555" class="Symbol">_</a>
<a id="1557" href="Foundation.Function.Enumeration.MaybeView.html#1533" class="Function">Enumℙ</a> <a id="1563" href="Foundation.Function.Enumeration.MaybeView.html#1563" class="Bound">P</a> <a id="1565" class="Symbol">=</a> <a id="1567" href="Foundation.Prelude.Builtin.html#976" class="Function">Σ</a> <a id="1569" href="Foundation.Function.Enumeration.MaybeView.html#1569" class="Bound">f</a> <a id="1571" href="Foundation.Prelude.Builtin.html#976" class="Function">，</a> <a id="1573" class="Symbol">∀</a> <a id="1575" href="Foundation.Function.Enumeration.MaybeView.html#1575" class="Bound">x</a> <a id="1577" class="Symbol">→</a> <a id="1579" href="Foundation.Function.Enumeration.MaybeView.html#1563" class="Bound">P</a> <a id="1581" href="Foundation.Function.Enumeration.MaybeView.html#1575" class="Bound">x</a> <a id="1583" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1585" href="Foundation.Function.Enumeration.MaybeView.html#1569" class="Bound">f</a> <a id="1587" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">witness</a> <a id="1595" href="Foundation.Function.Enumeration.MaybeView.html#1575" class="Bound">x</a>
</pre>
<p>当 <code>P</code> 是恒真性质时, 以上两种枚举可以相互转化.</p>
<pre class="Agda"><a id="Enum↔ℙ"></a><a id="1639" href="Foundation.Function.Enumeration.MaybeView.html#1639" class="Function">Enum↔ℙ</a> <a id="1646" class="Symbol">:</a> <a id="1648" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="1653" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1655" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="1657" href="Foundation.Function.Enumeration.MaybeView.html#1533" class="Function">Enumℙ</a> <a id="1663" class="Symbol">λ</a> <a id="1665" class="Symbol">(</a><a id="1666" href="Foundation.Function.Enumeration.MaybeView.html#1666" class="Bound">_</a> <a id="1668" class="Symbol">:</a> <a id="1670" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a><a id="1671" class="Symbol">)</a> <a id="1673" class="Symbol">→</a> <a id="1675" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="1677" href="Foundation.Function.Enumeration.MaybeView.html#1639" class="Function">Enum↔ℙ</a> <a id="1684" class="Symbol">=</a> <a id="1686" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇒:</a> <a id="1689" class="Symbol">(λ</a> <a id="1692" class="Symbol">(</a><a id="1693" href="Foundation.Function.Enumeration.MaybeView.html#1693" class="Bound">f</a> <a id="1695" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1697" href="Foundation.Function.Enumeration.MaybeView.html#1697" class="Bound">H</a><a id="1698" class="Symbol">)</a> <a id="1700" class="Symbol">→</a> <a id="1702" href="Foundation.Function.Enumeration.MaybeView.html#1693" class="Bound">f</a> <a id="1704" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1706" class="Symbol">λ</a> <a id="1708" href="Foundation.Function.Enumeration.MaybeView.html#1708" class="Bound">x</a> <a id="1710" class="Symbol">→</a> <a id="1712" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇒:</a> <a id="1715" class="Symbol">(λ</a> <a id="1718" href="Foundation.Function.Enumeration.MaybeView.html#1718" class="Bound">_</a> <a id="1720" class="Symbol">→</a> <a id="1722" href="Foundation.Function.Enumeration.MaybeView.html#1697" class="Bound">H</a> <a id="1724" href="Foundation.Function.Enumeration.MaybeView.html#1708" class="Bound">x</a><a id="1725" class="Symbol">)</a> <a id="1727" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇐:</a> <a id="1730" class="Symbol">(λ</a> <a id="1733" href="Foundation.Function.Enumeration.MaybeView.html#1733" class="Bound">_</a> <a id="1735" class="Symbol">→</a> <a id="1737" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1739" class="Symbol">))</a>
         <a id="1751" href="Foundation.Prop.Iff.html#354" class="InductiveConstructor Operator">⇐:</a> <a id="1754" class="Symbol">(λ</a> <a id="1757" class="Symbol">(</a><a id="1758" href="Foundation.Function.Enumeration.MaybeView.html#1758" class="Bound">f</a> <a id="1760" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1762" href="Foundation.Function.Enumeration.MaybeView.html#1762" class="Bound">H</a><a id="1763" class="Symbol">)</a> <a id="1765" class="Symbol">→</a> <a id="1767" href="Foundation.Function.Enumeration.MaybeView.html#1758" class="Bound">f</a> <a id="1769" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1771" class="Symbol">λ</a> <a id="1773" href="Foundation.Function.Enumeration.MaybeView.html#1773" class="Bound">x</a> <a id="1775" class="Symbol">→</a> <a id="1777" href="Foundation.Function.Enumeration.MaybeView.html#1762" class="Bound">H</a> <a id="1779" href="Foundation.Function.Enumeration.MaybeView.html#1773" class="Bound">x</a> <a id="1781" class="Symbol">.</a><a id="1782" href="Foundation.Prop.Iff.html#373" class="Field">⇒</a> <a id="1784" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="1786" class="Symbol">)</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>A</code> 递归可枚举, 当且仅当存在 <code>A</code> 的一个枚举.</p>
<pre class="Agda"><a id="enumerable"></a><a id="1849" href="Foundation.Function.Enumeration.MaybeView.html#1849" class="Function">enumerable</a> <a id="1860" class="Symbol">:</a> <a id="1862" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1864" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a> <a id="1866" class="Symbol">→</a> <a id="1868" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1870" class="Symbol">_</a>
<a id="1872" href="Foundation.Function.Enumeration.MaybeView.html#1849" class="Function">enumerable</a> <a id="1883" href="Foundation.Function.Enumeration.MaybeView.html#1883" class="Bound">A</a> <a id="1885" class="Symbol">=</a> <a id="1887" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="1889" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="1894" href="Foundation.Function.Enumeration.MaybeView.html#1883" class="Bound">A</a> <a id="1896" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p><strong><u>定义</u></strong> 我们说 <code>P</code> 递归可枚举, 当且仅当存在 <code>P</code> 的一个枚举.</p>
<pre class="Agda"><a id="enumerableℙ"></a><a id="1960" href="Foundation.Function.Enumeration.MaybeView.html#1960" class="Function">enumerableℙ</a> <a id="1972" class="Symbol">:</a> <a id="1974" class="Symbol">(</a><a id="1975" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1977" class="Symbol">→</a> <a id="1979" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1981" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="1982" class="Symbol">)</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="1988" class="Symbol">_</a>
<a id="1990" href="Foundation.Function.Enumeration.MaybeView.html#1960" class="Function">enumerableℙ</a> <a id="2002" href="Foundation.Function.Enumeration.MaybeView.html#2002" class="Bound">P</a> <a id="2004" class="Symbol">=</a> <a id="2006" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="2008" href="Foundation.Function.Enumeration.MaybeView.html#1533" class="Function">Enumℙ</a> <a id="2014" href="Foundation.Function.Enumeration.MaybeView.html#2002" class="Bound">P</a> <a id="2016" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
</pre>
<p>当 <code>P</code> 是恒真性质时, 以上两种递归可枚举性等价.</p>
<pre class="Agda"><a id="enumerable↔ℙ"></a><a id="2061" href="Foundation.Function.Enumeration.MaybeView.html#2061" class="Function">enumerable↔ℙ</a> <a id="2074" class="Symbol">:</a> <a id="2076" href="Foundation.Function.Enumeration.MaybeView.html#1849" class="Function">enumerable</a> <a id="2087" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2089" href="Foundation.Prop.Iff.html#296" class="Record Operator">↔</a> <a id="2091" href="Foundation.Function.Enumeration.MaybeView.html#1960" class="Function">enumerableℙ</a> <a id="2103" class="Symbol">λ</a> <a id="2105" class="Symbol">(</a><a id="2106" href="Foundation.Function.Enumeration.MaybeView.html#2106" class="Bound">_</a> <a id="2108" class="Symbol">:</a> <a id="2110" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a><a id="2111" class="Symbol">)</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="2117" href="Foundation.Function.Enumeration.MaybeView.html#2061" class="Function">enumerable↔ℙ</a> <a id="2130" class="Symbol">=</a> <a id="2132" href="Foundation.Prop.Iff.html#2826" class="Function">↔-map</a> <a id="2138" href="Foundation.Function.Enumeration.MaybeView.html#1639" class="Function">Enum↔ℙ</a>
</pre>
<p><strong><u>引理</u></strong> 如果 <code>f</code> 见证了整个离散集 <code>A</code>, 那么可以取到每个 <code>x : A</code> 的见证.<br />
<strong><u>证明</u></strong> 这是一个类似选择公理的形式, 自然数的良序性提供了“选择函数”, 即对每个 <code>x : A</code> 取最小的见证 <code>n</code> 即可. ∎</p>
<pre class="Agda"><a id="discr→wit→Wit"></a><a id="2295" href="Foundation.Function.Enumeration.MaybeView.html#2295" class="Function">discr→wit→Wit</a> <a id="2309" class="Symbol">:</a> <a id="2311" class="Symbol">⦃</a> <a id="2313" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="2322" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2324" class="Symbol">⦄</a> <a id="2326" class="Symbol">→</a> <a id="2328" class="Symbol">{</a><a id="2329" href="Foundation.Function.Enumeration.MaybeView.html#2329" class="Bound">f</a> <a id="2331" class="Symbol">:</a> <a id="2333" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2335" class="Symbol">→</a> <a id="2337" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2339" href="Agda.Builtin.Maybe.html#135" class="Datatype Operator">？</a><a id="2340" class="Symbol">}</a> <a id="2342" class="Symbol">→</a> <a id="2344" class="Symbol">(∀</a> <a id="2347" href="Foundation.Function.Enumeration.MaybeView.html#2347" class="Bound">x</a> <a id="2349" class="Symbol">→</a> <a id="2351" href="Foundation.Function.Enumeration.MaybeView.html#2329" class="Bound">f</a> <a id="2353" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">witness</a> <a id="2361" href="Foundation.Function.Enumeration.MaybeView.html#2347" class="Bound">x</a><a id="2362" class="Symbol">)</a> <a id="2364" class="Symbol">→</a> <a id="2366" class="Symbol">(∀</a> <a id="2369" href="Foundation.Function.Enumeration.MaybeView.html#2369" class="Bound">x</a> <a id="2371" class="Symbol">→</a> <a id="2373" href="Foundation.Function.Enumeration.MaybeView.html#1059" class="Function">Witness</a> <a id="2381" href="Foundation.Function.Enumeration.MaybeView.html#2329" class="Bound">f</a> <a id="2383" href="Foundation.Function.Enumeration.MaybeView.html#2369" class="Bound">x</a><a id="2384" class="Symbol">)</a>
<a id="2386" href="Foundation.Function.Enumeration.MaybeView.html#2295" class="Function">discr→wit→Wit</a> <a id="2400" class="Symbol">{</a><a id="2401" href="Foundation.Function.Enumeration.MaybeView.html#2401" class="Bound">f</a><a id="2402" class="Symbol">}</a> <a id="2404" href="Foundation.Function.Enumeration.MaybeView.html#2404" class="Bound">wit</a> <a id="2408" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">x</a> <a id="2410" class="Symbol">=</a> <a id="2412" href="Foundation.Data.Nat.ConstructiveEpsilon.html#1428" class="Function">ε</a> <a id="2414" href="Foundation.Function.Enumeration.MaybeView.html#2441" class="Function">sets</a> <a id="2419" href="Foundation.Function.Enumeration.MaybeView.html#2533" class="Function">discr</a> <a id="2425" class="Symbol">(</a><a id="2426" href="Foundation.Function.Enumeration.MaybeView.html#2404" class="Bound">wit</a> <a id="2430" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">x</a><a id="2431" class="Symbol">)</a> <a id="2433" class="Keyword">where</a>
  <a id="2441" href="Foundation.Function.Enumeration.MaybeView.html#2441" class="Function">sets</a> <a id="2446" class="Symbol">:</a> <a id="2448" href="Foundation.Prelude.HLevel.html#945" class="Function">isSets</a> <a id="2455" class="Symbol">(λ</a> <a id="2458" href="Foundation.Function.Enumeration.MaybeView.html#2458" class="Bound">n</a> <a id="2460" class="Symbol">→</a> <a id="2462" href="Foundation.Function.Enumeration.MaybeView.html#2401" class="Bound">f</a> <a id="2464" href="Foundation.Function.Enumeration.MaybeView.html#2458" class="Bound">n</a> <a id="2466" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2468" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="2473" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">x</a><a id="2474" class="Symbol">)</a>
  <a id="2478" href="Foundation.Function.Enumeration.MaybeView.html#2441" class="Function">sets</a> <a id="2483" href="Foundation.Function.Enumeration.MaybeView.html#2483" class="Bound">n</a> <a id="2485" class="Symbol">=</a> <a id="2487" href="Foundation.Prelude.HLevel.html#2002" class="Function">isProp→isSet</a> <a id="2500" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2502" class="Symbol">(</a><a id="2503" href="Foundation.Data.Maybe.html#1098" class="Function">isSetMaybe</a> <a id="2514" href="Foundation.Relation.Nullary.Discrete.Base.html#1631" class="Function">discreteSet</a><a id="2525" class="Symbol">)</a> <a id="2527" class="Symbol">_</a> <a id="2529" class="Symbol">_</a>
  <a id="2533" href="Foundation.Function.Enumeration.MaybeView.html#2533" class="Function">discr</a> <a id="2539" class="Symbol">:</a> <a id="2541" class="Symbol">∀</a> <a id="2543" href="Foundation.Function.Enumeration.MaybeView.html#2543" class="Bound">n</a> <a id="2545" class="Symbol">→</a> <a id="2547" href="Relation.Nullary.Decidable.Core.html#1478" class="Record">Dec</a> <a id="2551" class="Symbol">(</a><a id="2552" href="Foundation.Function.Enumeration.MaybeView.html#2401" class="Bound">f</a> <a id="2554" href="Foundation.Function.Enumeration.MaybeView.html#2543" class="Bound">n</a> <a id="2556" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2558" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="2563" href="Foundation.Function.Enumeration.MaybeView.html#2408" class="Bound">x</a><a id="2564" class="Symbol">)</a>
  <a id="2568" href="Foundation.Function.Enumeration.MaybeView.html#2533" class="Function">discr</a> <a id="2574" href="Foundation.Function.Enumeration.MaybeView.html#2574" class="Bound">n</a> <a id="2576" class="Symbol">=</a> <a id="2578" href="Function.Base.html#4724" class="Function">it</a>
</pre>
<p><strong><u>事实</u></strong> 离散的递归可枚举集可数.<br />
<strong><u>证明</u></strong> 只需证 <code>A</code> 的枚举可以转化为 <code>A</code> 到 <code>ℕ</code> 的单射. 用 <code>discr→wit→Wit</code> 取每个 <code>x</code> 的见证 <code>n</code>, 将该映射记为 <code>g</code>, 它满足</p>
<p><code>f∘g-wit : ∀ x → f (g x) ≡ some x</code></p>
<p>我们证明 <code>g</code> 即是单射. 给定等式 <code>g x ≡ g y</code>, 则有 <code>f (g x) ≡ f (g y)</code>. 两边用 <code>f∘g-wit</code> 换成 <code>some</code> 形式, 再用 <code>some</code> 的单射性即得 <code>x ≡ y</code>. ∎</p>
<pre class="Agda"><a id="discr→enum→count"></a><a id="2871" href="Foundation.Function.Enumeration.MaybeView.html#2871" class="Function">discr→enum→count</a> <a id="2888" class="Symbol">:</a> <a id="2890" class="Symbol">⦃</a> <a id="2892" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="2901" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2903" class="Symbol">⦄</a> <a id="2905" class="Symbol">→</a> <a id="2907" href="Foundation.Function.Enumeration.MaybeView.html#1849" class="Function">enumerable</a> <a id="2918" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="2920" class="Symbol">→</a> <a id="2922" href="Foundation.Relation.Unary.Countable.html#164" class="Function">countable</a> <a id="2932" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="2934" href="Foundation.Function.Enumeration.MaybeView.html#2871" class="Function">discr→enum→count</a> <a id="2951" class="Symbol">{</a><a id="2952" href="Foundation.Function.Enumeration.MaybeView.html#2952" class="Bound">A</a><a id="2953" class="Symbol">}</a> <a id="2955" class="Symbol">=</a> <a id="2957" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="2963" href="Foundation.Function.Enumeration.MaybeView.html#2973" class="Function">H</a> <a id="2965" class="Keyword">where</a>
  <a id="2973" href="Foundation.Function.Enumeration.MaybeView.html#2973" class="Function">H</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="2982" href="Foundation.Function.Enumeration.MaybeView.html#2952" class="Bound">A</a> <a id="2984" class="Symbol">→</a> <a id="2986" href="Foundation.Function.Enumeration.MaybeView.html#2952" class="Bound">A</a> <a id="2988" href="Foundation.Function.Bijection.html#1202" class="Function Operator">↣</a> <a id="2990" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="2994" href="Foundation.Function.Enumeration.MaybeView.html#2973" class="Function">H</a> <a id="2996" class="Symbol">(</a><a id="2997" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="2999" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3001" href="Foundation.Function.Enumeration.MaybeView.html#3001" class="Bound">f-wit</a><a id="3006" class="Symbol">)</a> <a id="3008" class="Symbol">=</a> <a id="3010" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3012" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3014" href="Foundation.Function.Enumeration.MaybeView.html#3181" class="Function">g-inj</a> <a id="3020" class="Keyword">where</a>
    <a id="3030" href="Foundation.Function.Enumeration.MaybeView.html#3030" class="Function">Wit</a> <a id="3034" class="Symbol">:</a> <a id="3036" class="Symbol">∀</a> <a id="3038" href="Foundation.Function.Enumeration.MaybeView.html#3038" class="Bound">x</a> <a id="3040" class="Symbol">→</a> <a id="3042" href="Foundation.Function.Enumeration.MaybeView.html#1059" class="Function">Witness</a> <a id="3050" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="3052" href="Foundation.Function.Enumeration.MaybeView.html#3038" class="Bound">x</a>
    <a id="3058" href="Foundation.Function.Enumeration.MaybeView.html#3030" class="Function">Wit</a> <a id="3062" class="Symbol">=</a> <a id="3064" href="Foundation.Function.Enumeration.MaybeView.html#2295" class="Function">discr→wit→Wit</a> <a id="3078" href="Foundation.Function.Enumeration.MaybeView.html#3001" class="Bound">f-wit</a>
    <a id="3088" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3090" class="Symbol">:</a> <a id="3092" href="Foundation.Function.Enumeration.MaybeView.html#2952" class="Bound">A</a> <a id="3094" class="Symbol">→</a> <a id="3096" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="3102" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3104" class="Symbol">=</a> <a id="3106" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="3110" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3112" href="Foundation.Function.Enumeration.MaybeView.html#3030" class="Function">Wit</a>
    <a id="3120" href="Foundation.Function.Enumeration.MaybeView.html#3120" class="Function">f∘g-wit</a> <a id="3128" class="Symbol">:</a> <a id="3130" class="Symbol">∀</a> <a id="3132" href="Foundation.Function.Enumeration.MaybeView.html#3132" class="Bound">x</a> <a id="3134" class="Symbol">→</a> <a id="3136" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="3138" class="Symbol">(</a><a id="3139" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3141" href="Foundation.Function.Enumeration.MaybeView.html#3132" class="Bound">x</a><a id="3142" class="Symbol">)</a> <a id="3144" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3146" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3151" href="Foundation.Function.Enumeration.MaybeView.html#3132" class="Bound">x</a>
    <a id="3157" href="Foundation.Function.Enumeration.MaybeView.html#3120" class="Function">f∘g-wit</a> <a id="3165" class="Symbol">=</a> <a id="3167" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="3171" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3173" href="Foundation.Function.Enumeration.MaybeView.html#3030" class="Function">Wit</a>
    <a id="3181" href="Foundation.Function.Enumeration.MaybeView.html#3181" class="Function">g-inj</a> <a id="3187" class="Symbol">:</a> <a id="3189" href="Foundation.Function.Bijection.html#653" class="Function">injective</a> <a id="3199" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a>
    <a id="3205" href="Foundation.Function.Enumeration.MaybeView.html#3181" class="Function">g-inj</a> <a id="3211" class="Symbol">{</a><a id="3212" href="Foundation.Function.Enumeration.MaybeView.html#3212" class="Bound">x</a><a id="3213" class="Symbol">}</a> <a id="3215" class="Symbol">{</a><a id="3216" href="Foundation.Function.Enumeration.MaybeView.html#3216" class="Bound">y</a><a id="3217" class="Symbol">}</a> <a id="3219" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">eq</a> <a id="3222" class="Symbol">=</a> <a id="3224" href="Data.Maybe.Properties.html#1056" class="Function">some-inj</a> <a id="3233" href="Function.Base.html#1974" class="Function Operator">$</a>
      <a id="3241" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3246" href="Foundation.Function.Enumeration.MaybeView.html#3212" class="Bound">x</a>   <a id="3250" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">≡˘⟨</a> <a id="3254" href="Foundation.Function.Enumeration.MaybeView.html#3120" class="Function">f∘g-wit</a> <a id="3262" href="Foundation.Function.Enumeration.MaybeView.html#3212" class="Bound">x</a> <a id="3264" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">⟩</a>
      <a id="3272" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="3274" class="Symbol">(</a><a id="3275" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3277" href="Foundation.Function.Enumeration.MaybeView.html#3212" class="Bound">x</a><a id="3278" class="Symbol">)</a>  <a id="3281" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="3284" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="3289" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="3291" href="Foundation.Function.Enumeration.MaybeView.html#3219" class="Bound">eq</a> <a id="3294" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
      <a id="3302" href="Foundation.Function.Enumeration.MaybeView.html#2997" class="Bound">f</a> <a id="3304" class="Symbol">(</a><a id="3305" href="Foundation.Function.Enumeration.MaybeView.html#3088" class="Function">g</a> <a id="3307" href="Foundation.Function.Enumeration.MaybeView.html#3216" class="Bound">y</a><a id="3308" class="Symbol">)</a>  <a id="3311" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="3314" href="Foundation.Function.Enumeration.MaybeView.html#3120" class="Function">f∘g-wit</a> <a id="3322" href="Foundation.Function.Enumeration.MaybeView.html#3216" class="Bound">y</a> <a id="3324" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
      <a id="3332" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="3337" href="Foundation.Function.Enumeration.MaybeView.html#3216" class="Bound">y</a>   <a id="3341" href="Foundation.Prelude.Equality.html#1248" class="Function Operator">∎</a>
</pre>
<p><strong><u>事实</u></strong> 可数无穷集离散.<br />
<strong><u>证明</u></strong> 由于集合的离散性是命题, 可转化为证 <code>A ≅ ℕ → discrete A</code>, 于是可归结为 <code>ℕ</code> 的离散性. ∎</p>
<pre class="Agda"><a id="count∞→discr"></a><a id="3456" href="Foundation.Function.Enumeration.MaybeView.html#3456" class="Function">count∞→discr</a> <a id="3469" class="Symbol">:</a> <a id="3471" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="3477" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3479" class="Symbol">→</a> <a id="3481" href="Foundation.Relation.Unary.Countable.html#212" class="Function">countablyInfinite</a> <a id="3499" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3501" class="Symbol">→</a> <a id="3503" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="3512" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="3514" href="Foundation.Function.Enumeration.MaybeView.html#3456" class="Function">count∞→discr</a> <a id="3527" href="Foundation.Function.Enumeration.MaybeView.html#3527" class="Bound">sA</a> <a id="3530" class="Symbol">=</a> <a id="3532" href="Foundation.Prop.Truncation.html#350" class="Function">𝟙.rec</a> <a id="3538" class="Symbol">(</a><a id="3539" href="Foundation.Relation.Nullary.Discrete.Base.html#1355" class="Function">isPropDiscrete</a> <a id="3554" href="Foundation.Function.Enumeration.MaybeView.html#3527" class="Bound">sA</a><a id="3556" class="Symbol">)</a> <a id="3558" href="Foundation.Function.Enumeration.MaybeView.html#3568" class="Function">H</a> <a id="3560" class="Keyword">where</a>
  <a id="3568" href="Foundation.Function.Enumeration.MaybeView.html#3568" class="Function">H</a> <a id="3570" class="Symbol">:</a> <a id="3572" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3574" href="Foundation.Prelude.Equality.html#429" class="Record Operator">≅</a> <a id="3576" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3578" class="Symbol">→</a> <a id="3580" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="3589" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
  <a id="3593" href="Foundation.Function.Enumeration.MaybeView.html#3568" class="Function">H</a> <a id="3595" class="Symbol">(</a><a id="3596" href="Foundation.Prelude.Equality.html#455" class="InductiveConstructor">mk≅</a> <a id="3600" href="Foundation.Function.Enumeration.MaybeView.html#3600" class="Bound">f</a> <a id="3602" href="Foundation.Function.Enumeration.MaybeView.html#3602" class="Bound">f⁻¹</a> <a id="3606" href="Foundation.Function.Enumeration.MaybeView.html#3606" class="Bound">f∘f⁻¹</a> <a id="3612" href="Foundation.Function.Enumeration.MaybeView.html#3612" class="Bound">f⁻¹∘f</a><a id="3617" class="Symbol">)</a> <a id="3619" class="Symbol">{</a><a id="3620" href="Foundation.Function.Enumeration.MaybeView.html#3620" class="Bound">x</a><a id="3621" class="Symbol">}</a> <a id="3623" class="Symbol">{</a><a id="3624" href="Foundation.Function.Enumeration.MaybeView.html#3624" class="Bound">y</a><a id="3625" class="Symbol">}</a> <a id="3627" class="Keyword">with</a> <a id="3632" href="Foundation.Function.Enumeration.MaybeView.html#3600" class="Bound">f</a> <a id="3634" href="Foundation.Function.Enumeration.MaybeView.html#3620" class="Bound">x</a> <a id="3636" href="Foundation.Relation.Nullary.Discrete.Base.html#999" class="Function Operator">≟</a> <a id="3638" href="Foundation.Function.Enumeration.MaybeView.html#3600" class="Bound">f</a> <a id="3640" href="Foundation.Function.Enumeration.MaybeView.html#3624" class="Bound">y</a>
  <a id="3644" class="Symbol">...</a> <a id="3648" class="Symbol">|</a> <a id="3650" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="3654" href="Foundation.Function.Enumeration.MaybeView.html#3654" class="Bound">p</a> <a id="3656" class="Symbol">=</a> <a id="3658" href="Relation.Nullary.Decidable.Core.html#1611" class="InductiveConstructor">yes</a> <a id="3662" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3664" href="Foundation.Prelude.Equality.html#1447" class="Function">subst2</a> <a id="3671" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="3675" class="Symbol">(</a><a id="3676" class="Bound">f⁻¹∘f</a> <a id="3682" class="Symbol">_)</a> <a id="3685" class="Symbol">(</a><a id="3686" class="Bound">f⁻¹∘f</a> <a id="3692" class="Symbol">_)</a> <a id="3695" class="Symbol">(</a><a id="3696" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="3701" class="Bound">f⁻¹</a> <a id="3705" href="Foundation.Function.Enumeration.MaybeView.html#3654" class="Bound">p</a><a id="3706" class="Symbol">)</a>
  <a id="3710" class="Symbol">...</a> <a id="3714" class="Symbol">|</a> <a id="3716" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="3719" href="Foundation.Function.Enumeration.MaybeView.html#3719" class="Bound">¬p</a> <a id="3722" class="Symbol">=</a> <a id="3724" href="Relation.Nullary.Decidable.Core.html#1648" class="InductiveConstructor">no</a> <a id="3727" class="Symbol">λ</a> <a id="3729" class="Symbol">{</a> <a id="3731" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3736" class="Symbol">→</a> <a id="3738" href="Foundation.Function.Enumeration.MaybeView.html#3719" class="Bound">¬p</a> <a id="3741" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3746" class="Symbol">}</a>
</pre>
<p><strong><u>事实</u></strong> 可数无穷蕴含递归可枚举.<br />
<strong><u>证明</u></strong> 即证与自然数集的同构可以转化为枚举. 同构给了我们互逆的 <code>f : A → ℕ</code> 和 <code>f⁻¹ : ℕ → A</code>. <code>some</code> 与 <code>f⁻¹</code> 的复合即是所需的枚举函数, <code>f x</code> 给出了 <code>x</code> 在 <code>some ∘ f⁻¹</code> 中的一个见证. ∎</p>
<pre class="Agda"><a id="count∞→enum"></a><a id="3931" href="Foundation.Function.Enumeration.MaybeView.html#3931" class="Function">count∞→enum</a> <a id="3943" class="Symbol">:</a> <a id="3945" href="Foundation.Relation.Unary.Countable.html#212" class="Function">countablyInfinite</a> <a id="3963" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="3965" class="Symbol">→</a> <a id="3967" href="Foundation.Function.Enumeration.MaybeView.html#1849" class="Function">enumerable</a> <a id="3978" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="3980" href="Foundation.Function.Enumeration.MaybeView.html#3931" class="Function">count∞→enum</a> <a id="3992" class="Symbol">{</a><a id="3993" href="Foundation.Function.Enumeration.MaybeView.html#3993" class="Bound">A</a><a id="3994" class="Symbol">}</a> <a id="3996" class="Symbol">=</a> <a id="3998" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="4004" href="Foundation.Function.Enumeration.MaybeView.html#4014" class="Function">H</a> <a id="4006" class="Keyword">where</a>
  <a id="4014" href="Foundation.Function.Enumeration.MaybeView.html#4014" class="Function">H</a> <a id="4016" class="Symbol">:</a> <a id="4018" href="Foundation.Function.Enumeration.MaybeView.html#3993" class="Bound">A</a> <a id="4020" href="Foundation.Prelude.Equality.html#429" class="Record Operator">≅</a> <a id="4022" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4024" class="Symbol">→</a> <a id="4026" href="Foundation.Function.Enumeration.MaybeView.html#1364" class="Function">Enum</a> <a id="4031" href="Foundation.Function.Enumeration.MaybeView.html#3993" class="Bound">A</a>
  <a id="4035" href="Foundation.Function.Enumeration.MaybeView.html#4014" class="Function">H</a> <a id="4037" class="Symbol">(</a><a id="4038" href="Foundation.Prelude.Equality.html#455" class="InductiveConstructor">mk≅</a> <a id="4042" href="Foundation.Function.Enumeration.MaybeView.html#4042" class="Bound">f</a> <a id="4044" href="Foundation.Function.Enumeration.MaybeView.html#4044" class="Bound">f⁻¹</a> <a id="4048" href="Foundation.Function.Enumeration.MaybeView.html#4048" class="Bound">f∘f⁻¹</a> <a id="4054" href="Foundation.Function.Enumeration.MaybeView.html#4054" class="Bound">f⁻¹∘f</a><a id="4059" class="Symbol">)</a> <a id="4061" class="Symbol">=</a> <a id="4063" href="Foundation.Function.Enumeration.MaybeView.html#4081" class="Function">g</a> <a id="4065" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4067" href="Foundation.Function.Enumeration.MaybeView.html#4100" class="Function">wit</a> <a id="4071" class="Keyword">where</a>
    <a id="4081" href="Foundation.Function.Enumeration.MaybeView.html#4081" class="Function">g</a> <a id="4083" class="Symbol">=</a> <a id="4085" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="4090" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="4092" href="Foundation.Function.Enumeration.MaybeView.html#4044" class="Bound">f⁻¹</a>
    <a id="4100" href="Foundation.Function.Enumeration.MaybeView.html#4100" class="Function">wit</a> <a id="4104" class="Symbol">:</a> <a id="4106" class="Symbol">∀</a> <a id="4108" href="Foundation.Function.Enumeration.MaybeView.html#4108" class="Bound">x</a> <a id="4110" class="Symbol">→</a> <a id="4112" href="Foundation.Function.Enumeration.MaybeView.html#4081" class="Function">g</a> <a id="4114" href="Foundation.Function.Enumeration.MaybeView.html#1225" class="Function Operator">witness</a> <a id="4122" href="Foundation.Function.Enumeration.MaybeView.html#4108" class="Bound">x</a>
    <a id="4128" href="Foundation.Function.Enumeration.MaybeView.html#4100" class="Function">wit</a> <a id="4132" href="Foundation.Function.Enumeration.MaybeView.html#4132" class="Bound">x</a> <a id="4134" class="Symbol">=</a> <a id="4136" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="4139" class="Symbol">(</a><a id="4140" href="Foundation.Function.Enumeration.MaybeView.html#4042" class="Bound">f</a> <a id="4142" href="Foundation.Function.Enumeration.MaybeView.html#4132" class="Bound">x</a><a id="4143" class="Symbol">)</a> <a id="4145" class="Symbol">(</a><a id="4146" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="4151" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">some</a> <a id="4156" class="Symbol">(</a><a id="4157" href="Foundation.Function.Enumeration.MaybeView.html#4054" class="Bound">f⁻¹∘f</a> <a id="4163" href="Foundation.Function.Enumeration.MaybeView.html#4132" class="Bound">x</a><a id="4164" class="Symbol">))</a>
</pre>
<p><strong><u>注意</u></strong> 由以上三个事实, 可以看出, 在我们的元语言中, 离散的递归可枚举集等价于可数集, 只要该可数集的基数被构造地给出. 此结果与经典不符, 原因在于经典的可数集不一定构造地给出了其基数.</p>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Function/Enumeration/MaybeView.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/Foundation.Function.Enumeration.MaybeView.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.maybeview">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
