<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Syntax.Enumeration</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语法-公式的枚举" id="toc-一阶逻辑-语法-公式的枚举">一阶逻辑 ▸ 语法 ▸ 公式的枚举</a>
  <ul>
  <li><a href="#项的枚举" id="toc-项的枚举">项的枚举</a>
  <ul>
  <li><a href="#项的列表的无穷序列-e" id="toc-项的列表的无穷序列-e">1. 项的列表的无穷序列 <code>e</code></a></li>
  <li><a href="#e-的累积-c" id="toc-e-的累积-c">2. <code>e</code> 的累积 <code>c</code></a></li>
  <li><a href="#命题-w-e-见证了任意项-t" id="toc-命题-w-e-见证了任意项-t">3. 命题 <code>w</code> : <code>e</code> 见证了任意项 <code>t</code></a></li>
  </ul></li>
  <li><a href="#公式的枚举" id="toc-公式的枚举">公式的枚举</a>
  <ul>
  <li><a href="#公式的列表的无穷序列-e" id="toc-公式的列表的无穷序列-e">1. 公式的列表的无穷序列 <code>e</code></a></li>
  <li><a href="#e-的累积-c-1" id="toc-e-的累积-c-1">2. <code>e</code> 的累积 <code>c</code></a></li>
  <li><a href="#命题-w-e-见证了任意公式-φ" id="toc-命题-w-e-见证了任意公式-φ">3. 命题 <code>w</code> : <code>e</code> 见证了任意公式 <code>φ</code></a></li>
  </ul></li>
  <li><a href="#枚举物的新变元" id="toc-枚举物的新变元">枚举物的新变元</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语法-公式的枚举">一阶逻辑 ▸ 语法 ▸ 公式的枚举</h1>
<p>本篇的目标是构造公式的<a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.plainview">普通视角枚举函数</a> <code>Ψ : ℕ → Formula</code>, 满足对任意 <code>φ : Formula</code> 都存在 <code>n : ℕ</code> 使得 <code>Ψ n ≡ φ</code>.</p>
<pre class="Agda"><a id="226" class="Symbol">{-#</a> <a id="230" class="Keyword">OPTIONS</a> <a id="238" class="Pragma">--lossy-unification</a> <a id="258" class="Symbol">#-}</a>
<a id="262" class="Keyword">open</a> <a id="267" class="Keyword">import</a> <a id="274" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Foundation.Data.Nat.AlternativeOrder.html" class="Module">Foundation.Data.Nat.AlternativeOrder</a>
<a id="344" class="Keyword">open</a> <a id="349" class="Keyword">import</a> <a id="356" href="Foundation.Data.List.SetTheoretic.html" class="Module">Foundation.Data.List.SetTheoretic</a> <a id="390" class="Keyword">renaming</a> <a id="399" class="Symbol">(</a><a id="400" href="Data.List.Membership.Setoid.html#943" class="Function Operator">_∈_</a> <a id="404" class="Symbol">to</a> <a id="407" class="Function Operator">_∈ᴸ_</a><a id="411" class="Symbol">)</a>
<a id="413" class="Keyword">open</a> <a id="418" class="Keyword">import</a> <a id="425" href="Foundation.Function.Enumeration.PlainView.html" class="Module">Foundation.Function.Enumeration.PlainView</a>

<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="493" class="Keyword">module</a> <a id="500" href="FOL.Syntax.Enumeration.html" class="Module">FOL.Syntax.Enumeration</a> <a id="523" class="Symbol">(</a><a id="524" href="FOL.Syntax.Enumeration.html#524" class="Bound">ℒ</a> <a id="526" class="Symbol">:</a> <a id="528" href="FOL.Language.html#772" class="Record">Language</a><a id="536" class="Symbol">)</a> <a id="538" class="Keyword">where</a>
<a id="544" class="Keyword">open</a> <a id="549" class="Keyword">import</a> <a id="556" href="FOL.Syntax.Base.html" class="Module">FOL.Syntax.Base</a> <a id="572" href="FOL.Syntax.Enumeration.html#524" class="Bound">ℒ</a>
<a id="574" class="Keyword">open</a> <a id="579" class="Keyword">import</a> <a id="586" href="FOL.Syntax.Discrete.html" class="Module">FOL.Syntax.Discrete</a> <a id="606" href="FOL.Syntax.Enumeration.html#524" class="Bound">ℒ</a>
<a id="608" class="Keyword">open</a> <a id="613" class="Keyword">import</a> <a id="620" href="FOL.Syntax.FreshVariables.html" class="Module">FOL.Syntax.FreshVariables</a> <a id="646" href="FOL.Syntax.Enumeration.html#524" class="Bound">ℒ</a>
<a id="648" class="Keyword">instance</a> <a id="657" href="FOL.Syntax.Enumeration.html#657" class="Function">_</a> <a id="659" class="Symbol">=</a> <a id="661" href="FOL.Syntax.Enumeration.html#524" class="Bound">ℒ</a>

<a id="664" class="Keyword">private</a> <a id="672" class="Keyword">variable</a>
  <a id="683" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="685" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="687" href="FOL.Syntax.Enumeration.html#687" class="Generalizable">o</a> <a id="689" class="Symbol">:</a> <a id="691" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<h2 id="项的枚举">项的枚举</h2>
<p><strong><u>实例/构造</u></strong> 项的枚举由以下 <code>e</code>, <code>c</code>, <code>w</code> 三部分构成:</p>
<pre class="Agda"><a id="762" class="Keyword">instance</a>
  <a id="enumTerm"></a><a id="773" href="FOL.Syntax.Enumeration.html#773" class="Function">enumTerm</a> <a id="782" class="Symbol">:</a> <a id="784" href="Foundation.Function.Enumeration.ListView.Base.html#2865" class="Record">Enum</a> <a id="789" href="FOL.Syntax.Base.html#723" class="Datatype">Term</a>
  <a id="796" href="FOL.Syntax.Enumeration.html#773" class="Function">enumTerm</a> <a id="805" class="Symbol">=</a> <a id="807" href="Foundation.Function.Enumeration.ListView.Base.html#2910" class="InductiveConstructor">mkEnum</a> <a id="814" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="816" href="FOL.Syntax.Enumeration.html#1550" class="Function">c</a> <a id="818" href="FOL.Syntax.Enumeration.html#2027" class="Function">w</a> <a id="820" class="Keyword">where</a>
</pre>
<h3 id="项的列表的无穷序列-e">1. 项的列表的无穷序列 <code>e</code></h3>
<p>我们需要同时互递归构造某函数 <code>f : 𝓕</code> 的所有 <code>e n</code> 应用, 记作 <code>apps n f</code>, 它是 <code>f</code> 应用于 <code>e n</code> 的所有 <code>∣ f ∣ᶠ</code> 维组合所得到的那些项所组成的列表.</p>
<pre class="Agda">    <a id="966" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="968" class="Symbol">:</a> <a id="970" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a> <a id="973" href="FOL.Syntax.Base.html#723" class="Datatype">Term</a>
    <a id="982" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="987" class="Symbol">:</a> <a id="989" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="991" class="Symbol">→</a> <a id="993" href="FOL.Language.html#825" class="Field">𝓕</a> <a id="995" class="Symbol">→</a> <a id="997" href="Agda.Builtin.List.html#147" class="Datatype">𝕃</a> <a id="999" href="FOL.Syntax.Base.html#723" class="Datatype">Term</a>
    <a id="1008" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="1013" href="FOL.Syntax.Enumeration.html#1013" class="Bound">n</a> <a id="1015" href="FOL.Syntax.Enumeration.html#1015" class="Bound">f</a> <a id="1017" class="Symbol">=</a> <a id="1019" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1023" class="Symbol">(</a><a id="1024" href="FOL.Syntax.Enumeration.html#1015" class="Bound">f</a> <a id="1026" href="FOL.Syntax.Base.html#755" class="InductiveConstructor Operator">$̇_</a><a id="1029" class="Symbol">)</a> <a id="1031" class="Symbol">(</a><a id="1032" href="Foundation.Function.Enumeration.ListView.Base.html#4342" class="Function">combine</a> <a id="1040" class="Symbol">(</a><a id="1041" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="1043" href="FOL.Syntax.Enumeration.html#1013" class="Bound">n</a><a id="1044" class="Symbol">)</a> <a id="1046" href="FOL.Language.html#845" class="Field Operator">∣</a> <a id="1048" href="FOL.Syntax.Enumeration.html#1015" class="Bound">f</a> <a id="1050" href="FOL.Language.html#845" class="Field Operator">∣ᶠ</a><a id="1052" class="Symbol">)</a>
</pre>
<p>我们递归定义 <code>e</code> 如下: - 输入 <code>zero</code> 时, 输出空列表. - 输入 <code>suc n</code> 时, 输出 <code>e n</code> 并上 <code>[ # n ]</code>, 再并上以<em>一些</em> <code>f : 𝓕</code> 为下标的集族 <code>apps n</code> 的并 (<code>concat</code>). 其中<em>一些</em> <code>f : 𝓕</code> 是指函数符号的枚举函数 <code>enum</code> (由语言的定义, 函数符号集 <code>𝓕</code> 可枚举) 应用于 <code>n</code> 所输出的那些 <code>f</code>.</p>
<p>此定义用传统集合论符号可表述为</p>
<p><span class="math display">
\begin{align*}
e(0) &amp;= \emptyset\\
e(n^+) &amp;= e(n) \cup \{\#n\} \cup \bigcup\{ apps(n, f) \mid f \in enum(n) \}
\end{align*}
</span></p>
<pre class="Agda">    <a id="1422" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="1424" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="1429" class="Symbol">=</a> <a id="1431" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="1438" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="1440" class="Symbol">(</a><a id="1441" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1445" href="FOL.Syntax.Enumeration.html#1445" class="Bound">n</a><a id="1446" class="Symbol">)</a> <a id="1448" class="Symbol">=</a> <a id="1450" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="1452" href="FOL.Syntax.Enumeration.html#1445" class="Bound">n</a> <a id="1454" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="1457" href="FOL.Syntax.Base.html#740" class="InductiveConstructor">#</a> <a id="1459" href="FOL.Syntax.Enumeration.html#1445" class="Bound">n</a> <a id="1461" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1463" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="1470" class="Symbol">(</a><a id="1471" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1475" class="Symbol">(</a><a id="1476" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="1481" href="FOL.Syntax.Enumeration.html#1445" class="Bound">n</a><a id="1482" class="Symbol">)</a> <a id="1484" class="Symbol">(</a><a id="1485" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="1490" href="FOL.Syntax.Enumeration.html#1445" class="Bound">n</a><a id="1491" class="Symbol">))</a>
</pre>
<h3 id="e-的累积-c">2. <code>e</code> 的累积 <code>c</code></h3>
<p>由 <code>e</code> 的定义立即可得其累积.</p>
<pre class="Agda">    <a id="1550" href="FOL.Syntax.Enumeration.html#1550" class="Function">c</a> <a id="1552" class="Symbol">:</a> <a id="1554" href="Foundation.Function.Enumeration.ListView.Base.html#1127" class="Function">Cumulation</a> <a id="1565" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a>
    <a id="1571" href="FOL.Syntax.Enumeration.html#1550" class="Function">c</a> <a id="1573" class="Symbol">_</a> <a id="1575" class="Symbol">=</a> <a id="1577" class="Symbol">_</a> <a id="1579" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="1581" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="命题-w-e-见证了任意项-t">3. 命题 <code>w</code> : <code>e</code> 见证了任意项 <code>t</code></h3>
<p>我们用项的结构归纳法证明 <code>w</code>:</p>
<ul>
<li>要证 <code>e</code> 见证了任意变元. 观察 <code>e</code> 的定义, 显然成立.</li>
<li>要证 <code>e</code> 见证了任意函数应用 <code>f $̇ t⃗</code>, 已知 <code>t⃗</code> 中的项都被 <code>e</code> 见证 (归纳假设).
<ul>
<li>由语言的定义, 函数符号集 <code>𝓕</code> 可枚举; 由元语言的知识, 项的 <code>∣ f ∣ᶠ</code> 维向量可枚举. 由归纳假设和涉及列表组合的引理 <code>combine-wit</code>, 只要构造一个从 <code>f</code> 的见证和 <code>t⃗</code> 的见证到 <code>f $̇ t⃗</code> 的见证的转换函数, 就证明了 <code>e</code> 见证 <code>f $̇ t⃗</code>.
<ul>
<li>分别取 <code>f</code> 和 <code>t⃗</code> 的见证 <code>m</code> 和 <code>n</code>. 由枚举函数的累积性, <code>m + n</code> 也是 <code>f</code> 和 <code>t⃗</code> 的见证. 所以由 <code>e</code> 的定义, <code>suc m + n</code> 见证了 <code>f $̇ t⃗</code>. ∎</li>
</ul></li>
</ul></li>
</ul>
<pre class="Agda">    <a id="2027" href="FOL.Syntax.Enumeration.html#2027" class="Function">w</a> <a id="2029" class="Symbol">:</a> <a id="2031" class="Symbol">∀</a> <a id="2033" href="FOL.Syntax.Enumeration.html#2033" class="Bound">t</a> <a id="2035" class="Symbol">→</a> <a id="2037" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="2039" href="Foundation.Function.Enumeration.ListView.Base.html#2654" class="Function Operator">witness</a> <a id="2047" href="FOL.Syntax.Enumeration.html#2033" class="Bound">t</a>
    <a id="2053" href="FOL.Syntax.Enumeration.html#2027" class="Function">w</a> <a id="2055" class="Symbol">=</a> <a id="2057" href="FOL.Syntax.Base.html#1256" class="Function">term-elim</a> <a id="2067" href="FOL.Syntax.Enumeration.html#2086" class="Function">H#</a> <a id="2070" href="FOL.Syntax.Enumeration.html#2162" class="Function">H$̇</a> <a id="2074" class="Keyword">where</a>
      <a id="2086" href="FOL.Syntax.Enumeration.html#2086" class="Function">H#</a> <a id="2089" class="Symbol">:</a> <a id="2091" class="Symbol">∀</a> <a id="2093" href="FOL.Syntax.Enumeration.html#2093" class="Bound">n</a> <a id="2095" class="Symbol">→</a> <a id="2097" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="2099" href="Foundation.Function.Enumeration.ListView.Base.html#2654" class="Function Operator">witness</a> <a id="2107" href="FOL.Syntax.Base.html#740" class="InductiveConstructor">#</a> <a id="2109" href="FOL.Syntax.Enumeration.html#2093" class="Bound">n</a>
      <a id="2117" href="FOL.Syntax.Enumeration.html#2086" class="Function">H#</a> <a id="2120" href="FOL.Syntax.Enumeration.html#2120" class="Bound">n</a> <a id="2122" class="Symbol">=</a> <a id="2124" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="2127" class="Symbol">(</a><a id="2128" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2132" href="FOL.Syntax.Enumeration.html#2120" class="Bound">n</a><a id="2133" class="Symbol">)</a> <a id="2135" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2137" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="2144" class="Symbol">(</a><a id="2145" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2150" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2154" class="Symbol">)</a>
      <a id="2162" href="FOL.Syntax.Enumeration.html#2162" class="Function">H$̇</a> <a id="2166" class="Symbol">:</a> <a id="2168" class="Symbol">∀</a> <a id="2170" href="FOL.Syntax.Enumeration.html#2170" class="Bound">f</a> <a id="2172" href="FOL.Syntax.Enumeration.html#2172" class="Bound">t⃗</a> <a id="2175" class="Symbol">→</a> <a id="2177" class="Symbol">(∀</a> <a id="2180" href="FOL.Syntax.Enumeration.html#2180" class="Bound">t</a> <a id="2182" class="Symbol">→</a> <a id="2184" href="FOL.Syntax.Enumeration.html#2180" class="Bound">t</a> <a id="2186" href="Foundation.Essential.html#12173" class="Function Operator">∈⃗</a> <a id="2189" href="FOL.Syntax.Enumeration.html#2172" class="Bound">t⃗</a> <a id="2192" class="Symbol">→</a> <a id="2194" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="2196" href="Foundation.Function.Enumeration.ListView.Base.html#2654" class="Function Operator">witness</a> <a id="2204" href="FOL.Syntax.Enumeration.html#2180" class="Bound">t</a><a id="2205" class="Symbol">)</a> <a id="2207" class="Symbol">→</a> <a id="2209" href="FOL.Syntax.Enumeration.html#966" class="Function">e</a> <a id="2211" href="Foundation.Function.Enumeration.ListView.Base.html#2654" class="Function Operator">witness</a> <a id="2219" class="Symbol">(</a><a id="2220" href="FOL.Syntax.Enumeration.html#2170" class="Bound">f</a> <a id="2222" href="FOL.Syntax.Base.html#755" class="InductiveConstructor Operator">$̇</a> <a id="2225" href="FOL.Syntax.Enumeration.html#2172" class="Bound">t⃗</a><a id="2227" class="Symbol">)</a>
      <a id="2235" href="FOL.Syntax.Enumeration.html#2162" class="Function">H$̇</a> <a id="2239" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a> <a id="2241" href="FOL.Syntax.Enumeration.html#2241" class="Bound">t⃗</a> <a id="2244" href="FOL.Syntax.Enumeration.html#2244" class="Bound">IH</a> <a id="2247" class="Symbol">=</a> <a id="2249" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="2256" href="FOL.Syntax.Enumeration.html#2302" class="Function">H</a> <a id="2258" class="Symbol">(</a><a id="2259" href="Foundation.Function.Enumeration.ListView.Base.html#2971" class="Field">wit</a> <a id="2263" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a><a id="2264" class="Symbol">)</a> <a id="2266" class="Symbol">(</a><a id="2267" href="Foundation.Function.Enumeration.ListView.Base.html#5633" class="Function">combine-wit</a> <a id="2279" href="FOL.Syntax.Enumeration.html#1550" class="Function">c</a> <a id="2281" href="FOL.Syntax.Enumeration.html#2241" class="Bound">t⃗</a> <a id="2284" href="FOL.Syntax.Enumeration.html#2244" class="Bound">IH</a><a id="2286" class="Symbol">)</a> <a id="2288" class="Keyword">where</a>
        <a id="2302" href="FOL.Syntax.Enumeration.html#2302" class="Function">H</a> <a id="2304" class="Symbol">:</a> <a id="2306" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="2314" class="Symbol">_</a> <a id="2316" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a> <a id="2318" class="Symbol">→</a> <a id="2320" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="2328" class="Symbol">_</a> <a id="2330" href="FOL.Syntax.Enumeration.html#2241" class="Bound">t⃗</a> <a id="2333" class="Symbol">→</a> <a id="2335" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="2343" class="Symbol">_</a> <a id="2345" class="Symbol">(</a><a id="2346" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a> <a id="2348" href="FOL.Syntax.Base.html#755" class="InductiveConstructor Operator">$̇</a> <a id="2351" href="FOL.Syntax.Enumeration.html#2241" class="Bound">t⃗</a><a id="2353" class="Symbol">)</a>
        <a id="2363" href="FOL.Syntax.Enumeration.html#2302" class="Function">H</a> <a id="2365" class="Symbol">(</a><a id="2366" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2368" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2370" href="FOL.Syntax.Enumeration.html#2370" class="Bound">Hm</a><a id="2372" class="Symbol">)</a> <a id="2374" class="Symbol">(</a><a id="2375" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a> <a id="2377" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2379" href="FOL.Syntax.Enumeration.html#2379" class="Bound">Hn</a><a id="2381" class="Symbol">)</a> <a id="2383" class="Symbol">=</a> <a id="2385" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2389" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2391" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2393" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a> <a id="2395" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="2397" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="2404" class="Symbol">(</a><a id="2405" class="InductiveConstructor">there</a> <a id="2411" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2413" href="Data.List.Membership.Propositional.Properties.html#5225" class="Function">∈-concat⁺′</a> <a id="2424" href="FOL.Syntax.Enumeration.html#2447" class="Function">H1</a> <a id="2427" href="FOL.Syntax.Enumeration.html#2544" class="Function">H2</a><a id="2429" class="Symbol">)</a> <a id="2431" class="Keyword">where</a>
          <a id="2447" href="FOL.Syntax.Enumeration.html#2447" class="Function">H1</a> <a id="2450" class="Symbol">:</a> <a id="2452" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a> <a id="2454" href="FOL.Syntax.Base.html#755" class="InductiveConstructor Operator">$̇</a> <a id="2457" href="FOL.Syntax.Enumeration.html#2241" class="Bound">t⃗</a> <a id="2460" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="2463" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="2468" class="Symbol">(</a><a id="2469" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2471" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2473" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a><a id="2474" class="Symbol">)</a> <a id="2476" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a>
          <a id="2488" href="FOL.Syntax.Enumeration.html#2447" class="Function">H1</a> <a id="2491" class="Symbol">=</a> <a id="2493" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="2504" class="Symbol">(</a><a id="2505" href="Foundation.Function.Enumeration.ListView.Base.html#5245" class="Function">combine-≤→⊆</a> <a id="2517" href="FOL.Syntax.Enumeration.html#1550" class="Function">c</a> <a id="2519" href="Foundation.Data.Nat.AlternativeOrder.html#1884" class="Function">m≤n+m</a> <a id="2525" href="FOL.Syntax.Enumeration.html#2379" class="Bound">Hn</a><a id="2527" class="Symbol">)</a> <a id="2529" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
          <a id="2544" href="FOL.Syntax.Enumeration.html#2544" class="Function">H2</a> <a id="2547" class="Symbol">:</a> <a id="2549" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="2554" class="Symbol">(</a><a id="2555" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2557" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2559" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a><a id="2560" class="Symbol">)</a> <a id="2562" href="FOL.Syntax.Enumeration.html#2239" class="Bound">f</a> <a id="2564" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="2567" href="Data.List.Base.html#1627" class="Function">map</a> <a id="2571" class="Symbol">(</a><a id="2572" href="FOL.Syntax.Enumeration.html#982" class="Function">apps</a> <a id="2577" class="Symbol">(</a><a id="2578" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2580" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2582" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a><a id="2583" class="Symbol">))</a> <a id="2586" class="Symbol">(</a><a id="2587" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="2592" class="Symbol">(</a><a id="2593" href="FOL.Syntax.Enumeration.html#2366" class="Bound">m</a> <a id="2595" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2597" href="FOL.Syntax.Enumeration.html#2375" class="Bound">n</a><a id="2598" class="Symbol">))</a>
          <a id="2611" href="FOL.Syntax.Enumeration.html#2544" class="Function">H2</a> <a id="2614" class="Symbol">=</a> <a id="2616" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="2627" class="Symbol">(</a><a id="2628" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="2636" href="Foundation.Function.Enumeration.ListView.Base.html#2945" class="Field">cum</a> <a id="2640" href="Foundation.Data.Nat.AlternativeOrder.html#1838" class="Function">m≤m+n</a> <a id="2646" href="FOL.Syntax.Enumeration.html#2370" class="Bound">Hm</a><a id="2648" class="Symbol">)</a> <a id="2650" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="公式的枚举">公式的枚举</h2>
<p><strong><u>定义</u></strong> 某关系 <code>R : 𝓡</code> 的所有 <code>n</code>-阶应用, 记作 <code>apps n R</code>, 定义为 <code>R</code> 应用于项的<em>一些</em> <code>∣ R ∣ᴿ</code> 维向量所得到的公式所组成的列表. 其中项的<em>一些</em> <code>∣ R ∣ᴿ</code> 维向量是指项的<code>∣ R ∣ᴿ</code> 维向量枚举函数 <code>enum</code> (由于项可枚举, 所以项的固定维向量也可枚举) 应用于 <code>n</code> 所输出的那些向量.</p>
<pre class="Agda"><a id="2868" class="Keyword">private</a>
  <a id="apps"></a><a id="2878" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="2883" class="Symbol">:</a> <a id="2885" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2887" class="Symbol">→</a> <a id="2889" href="FOL.Language.html#835" class="Field">𝓡</a> <a id="2891" class="Symbol">→</a> <a id="2893" href="Agda.Builtin.List.html#147" class="Datatype">𝕃</a> <a id="2895" href="FOL.Syntax.Base.html#3783" class="Datatype">Formula</a>
  <a id="2905" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="2910" href="FOL.Syntax.Enumeration.html#2910" class="Bound">n</a> <a id="2912" href="FOL.Syntax.Enumeration.html#2912" class="Bound">R</a> <a id="2914" class="Symbol">=</a> <a id="2916" href="Data.List.Base.html#1627" class="Function">map</a> <a id="2920" class="Symbol">(</a><a id="2921" href="FOL.Syntax.Enumeration.html#2912" class="Bound">R</a> <a id="2923" href="FOL.Syntax.Base.html#3881" class="InductiveConstructor Operator">$̇_</a><a id="2926" class="Symbol">)</a> <a id="2928" class="Symbol">(</a><a id="2929" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="2934" href="FOL.Syntax.Enumeration.html#2910" class="Bound">n</a><a id="2935" class="Symbol">)</a>
</pre>
<p><strong><u>实例/构造</u></strong> 公式的枚举由以下 <code>e</code>, <code>c</code>, <code>w</code> 三部分构成:</p>
<pre class="Agda"><a id="2998" class="Keyword">instance</a>
  <a id="enumFormula"></a><a id="3009" href="FOL.Syntax.Enumeration.html#3009" class="Function">enumFormula</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Foundation.Function.Enumeration.ListView.Base.html#2865" class="Record">Enum</a> <a id="3028" href="FOL.Syntax.Base.html#3783" class="Datatype">Formula</a>
  <a id="3038" href="FOL.Syntax.Enumeration.html#3009" class="Function">enumFormula</a> <a id="3050" class="Symbol">=</a> <a id="3052" href="Foundation.Function.Enumeration.ListView.Base.html#2910" class="InductiveConstructor">mkEnum</a> <a id="3059" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3061" href="FOL.Syntax.Enumeration.html#3536" class="Function">c</a> <a id="3063" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3065" class="Keyword">where</a>
</pre>
<h3 id="公式的列表的无穷序列-e">1. 公式的列表的无穷序列 <code>e</code></h3>
<p>递归定义 <code>e</code> 如下:</p>
<ul>
<li>输入 <code>zero</code> 时, 输出 <code>[ ⊥̇ ]</code>.</li>
<li>输入 <code>suc n</code> 时, 输出 <code>e n</code> 并上由 <code>e n</code> 中公式产生的所有全称量化式和所有蕴含式, 以及<em>一些</em> <code>R : 𝓡</code> 的所有 <code>n</code>-阶应用. 其中<em>一些</em> <code>R : 𝓡</code> 是指关系符号的枚举函数 <code>enum</code> (由语言的定义, 关系符号集 <code>𝓡</code> 可枚举) 应用于 <code>n</code> 所输出的那些 <code>R : 𝓡</code>.</li>
</ul>
<pre class="Agda">    <a id="3320" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3322" class="Symbol">:</a> <a id="3324" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a> <a id="3327" href="FOL.Syntax.Base.html#3783" class="Datatype">Formula</a>
    <a id="3339" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3341" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="3346" class="Symbol">=</a> <a id="3348" href="Data.List.Base.html#5240" class="Function Operator">[</a> <a id="3350" href="FOL.Syntax.Base.html#3803" class="InductiveConstructor">⊥̇</a> <a id="3353" href="Data.List.Base.html#5240" class="Function Operator">]</a>
    <a id="3359" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3361" class="Symbol">(</a><a id="3362" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3366" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a><a id="3367" class="Symbol">)</a> <a id="3369" class="Symbol">=</a> <a id="3371" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3373" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a>
      <a id="3381" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3384" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3388" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇_</a> <a id="3392" class="Symbol">(</a><a id="3393" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3395" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a><a id="3396" class="Symbol">)</a>
      <a id="3404" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3407" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3411" class="Symbol">(</a><a id="3412" href="Data.Product.Base.html#3109" class="Function">uncurry</a> <a id="3420" href="FOL.Syntax.Base.html#3818" class="InductiveConstructor Operator">_→̇_</a><a id="3424" class="Symbol">)</a> <a id="3426" class="Symbol">(</a><a id="3427" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3429" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a> <a id="3431" href="Foundation.Data.List.SetTheoretic.html#1702" class="Function Operator">[×]</a> <a id="3435" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3437" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a><a id="3438" class="Symbol">)</a>
      <a id="3446" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3449" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="3456" class="Symbol">(</a><a id="3457" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3461" class="Symbol">(</a><a id="3462" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="3467" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a><a id="3468" class="Symbol">)</a> <a id="3470" class="Symbol">(</a><a id="3471" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="3476" href="FOL.Syntax.Enumeration.html#3366" class="Bound">n</a><a id="3477" class="Symbol">))</a>
</pre>
<h3 id="e-的累积-c-1">2. <code>e</code> 的累积 <code>c</code></h3>
<p>由 <code>e</code> 的定义立即可得其累积.</p>
<pre class="Agda">    <a id="3536" href="FOL.Syntax.Enumeration.html#3536" class="Function">c</a> <a id="3538" class="Symbol">:</a> <a id="3540" href="Foundation.Function.Enumeration.ListView.Base.html#1127" class="Function">Cumulation</a> <a id="3551" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a>
    <a id="3557" href="FOL.Syntax.Enumeration.html#3536" class="Function">c</a> <a id="3559" class="Symbol">_</a> <a id="3561" class="Symbol">=</a> <a id="3563" class="Symbol">_</a> <a id="3565" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3567" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="命题-w-e-见证了任意公式-φ">3. 命题 <code>w</code> : <code>e</code> 见证了任意公式 <code>φ</code></h3>
<p>由 <code>e</code> 的定义, 显然, <code>e</code> 见证了 <code>⊥̇</code>, 以及任意全称量化式和蕴含式. 而对于关系应用, 使用与项的枚举函数见证所有函数应用类似的方法可证. ∎</p>
<pre class="Agda">    <a id="3704" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3706" class="Symbol">:</a> <a id="3708" class="Symbol">∀</a> <a id="3710" href="FOL.Syntax.Enumeration.html#3710" class="Bound">φ</a> <a id="3712" class="Symbol">→</a> <a id="3714" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3716" href="Foundation.Function.Enumeration.ListView.Base.html#2654" class="Function Operator">witness</a> <a id="3724" href="FOL.Syntax.Enumeration.html#3710" class="Bound">φ</a>
    <a id="3730" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3732" href="FOL.Syntax.Base.html#3803" class="InductiveConstructor">⊥̇</a> <a id="3735" class="Symbol">=</a> <a id="3737" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="3740" class="Number">0</a> <a id="3742" class="Symbol">(</a><a id="3743" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="3748" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="3752" class="Symbol">)</a>
    <a id="3758" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3760" class="Symbol">(</a><a id="3761" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇</a> <a id="3764" href="FOL.Syntax.Enumeration.html#3764" class="Bound">φ</a><a id="3765" class="Symbol">)</a> <a id="3767" class="Symbol">=</a> <a id="3769" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="3775" href="FOL.Syntax.Enumeration.html#3795" class="Function">H</a> <a id="3777" class="Symbol">(</a><a id="3778" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3780" href="FOL.Syntax.Enumeration.html#3764" class="Bound">φ</a><a id="3781" class="Symbol">)</a> <a id="3783" class="Keyword">where</a>
      <a id="3795" href="FOL.Syntax.Enumeration.html#3795" class="Function">H</a> <a id="3797" class="Symbol">:</a> <a id="3799" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="3807" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3809" href="FOL.Syntax.Enumeration.html#3764" class="Bound">φ</a> <a id="3811" class="Symbol">→</a> <a id="3813" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="3821" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3823" class="Symbol">(</a><a id="3824" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇</a> <a id="3827" href="FOL.Syntax.Enumeration.html#3764" class="Bound">φ</a><a id="3828" class="Symbol">)</a>
      <a id="3836" href="FOL.Syntax.Enumeration.html#3795" class="Function">H</a> <a id="3838" class="Symbol">(</a><a id="3839" href="FOL.Syntax.Enumeration.html#3839" class="Bound">n</a> <a id="3841" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3843" href="FOL.Syntax.Enumeration.html#3843" class="Bound">Hn</a><a id="3845" class="Symbol">)</a> <a id="3847" class="Symbol">=</a> <a id="3849" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3853" href="FOL.Syntax.Enumeration.html#3839" class="Bound">n</a> <a id="3855" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="3857" class="Symbol">(</a><a id="3858" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="3865" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3867" href="Data.List.Membership.Propositional.Properties.html#4354" class="Function">∈-++⁺ˡ</a> <a id="3874" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3876" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="3887" href="FOL.Syntax.Enumeration.html#3843" class="Bound">Hn</a> <a id="3890" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="3894" class="Symbol">)</a>
    <a id="3900" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3902" class="Symbol">(</a><a id="3903" href="FOL.Syntax.Enumeration.html#3903" class="Bound">φ</a> <a id="3905" href="FOL.Syntax.Base.html#3818" class="InductiveConstructor Operator">→̇</a> <a id="3908" href="FOL.Syntax.Enumeration.html#3908" class="Bound">ψ</a><a id="3909" class="Symbol">)</a> <a id="3911" class="Symbol">=</a> <a id="3913" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="3920" href="FOL.Syntax.Enumeration.html#3946" class="Function">H</a> <a id="3922" class="Symbol">(</a><a id="3923" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3925" href="FOL.Syntax.Enumeration.html#3903" class="Bound">φ</a><a id="3926" class="Symbol">)</a> <a id="3928" class="Symbol">(</a><a id="3929" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="3931" href="FOL.Syntax.Enumeration.html#3908" class="Bound">ψ</a><a id="3932" class="Symbol">)</a> <a id="3934" class="Keyword">where</a>
      <a id="3946" href="FOL.Syntax.Enumeration.html#3946" class="Function">H</a> <a id="3948" class="Symbol">:</a> <a id="3950" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="3958" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3960" href="FOL.Syntax.Enumeration.html#3903" class="Bound">φ</a> <a id="3962" class="Symbol">→</a> <a id="3964" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="3972" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3974" href="FOL.Syntax.Enumeration.html#3908" class="Bound">ψ</a> <a id="3976" class="Symbol">→</a> <a id="3978" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="3986" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="3988" class="Symbol">(</a><a id="3989" href="FOL.Syntax.Enumeration.html#3903" class="Bound">φ</a> <a id="3991" href="FOL.Syntax.Base.html#3818" class="InductiveConstructor Operator">→̇</a> <a id="3994" href="FOL.Syntax.Enumeration.html#3908" class="Bound">ψ</a><a id="3995" class="Symbol">)</a>
      <a id="4003" href="FOL.Syntax.Enumeration.html#3946" class="Function">H</a> <a id="4005" class="Symbol">(</a><a id="4006" href="FOL.Syntax.Enumeration.html#4006" class="Bound">m</a> <a id="4008" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4010" href="FOL.Syntax.Enumeration.html#4010" class="Bound">Hm</a><a id="4012" class="Symbol">)</a> <a id="4014" class="Symbol">(</a><a id="4015" href="FOL.Syntax.Enumeration.html#4015" class="Bound">n</a> <a id="4017" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4019" href="FOL.Syntax.Enumeration.html#4019" class="Bound">Hn</a><a id="4021" class="Symbol">)</a> <a id="4023" class="Symbol">=</a> <a id="4025" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4029" href="FOL.Syntax.Enumeration.html#4006" class="Bound">m</a> <a id="4031" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4033" href="FOL.Syntax.Enumeration.html#4015" class="Bound">n</a> <a id="4035" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4037" class="Symbol">(</a><a id="4038" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="4045" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4047" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="4054" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4056" href="Data.List.Membership.Propositional.Properties.html#4354" class="Function">∈-++⁺ˡ</a> <a id="4063" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4065" href="Foundation.Data.List.SetTheoretic.html#2672" class="Function">∈map[×]-intro</a>
        <a id="4087" class="Symbol">(</a><a id="4088" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4096" href="FOL.Syntax.Enumeration.html#3536" class="Function">c</a> <a id="4098" href="Foundation.Data.Nat.AlternativeOrder.html#1838" class="Function">m≤m+n</a> <a id="4104" href="FOL.Syntax.Enumeration.html#4010" class="Bound">Hm</a><a id="4106" class="Symbol">)</a> <a id="4108" class="Symbol">(</a><a id="4109" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4117" href="FOL.Syntax.Enumeration.html#3536" class="Function">c</a> <a id="4119" href="Foundation.Data.Nat.AlternativeOrder.html#1884" class="Function">m≤n+m</a> <a id="4125" href="FOL.Syntax.Enumeration.html#4019" class="Bound">Hn</a><a id="4127" class="Symbol">))</a>
    <a id="4134" href="FOL.Syntax.Enumeration.html#3704" class="Function">w</a> <a id="4136" class="Symbol">(</a><a id="4137" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a> <a id="4139" href="FOL.Syntax.Base.html#3881" class="InductiveConstructor Operator">$̇</a> <a id="4142" href="FOL.Syntax.Enumeration.html#4142" class="Bound">t⃗</a><a id="4144" class="Symbol">)</a> <a id="4146" class="Symbol">=</a> <a id="4148" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="4155" href="FOL.Syntax.Enumeration.html#4186" class="Function">H</a> <a id="4157" class="Symbol">(</a><a id="4158" href="Foundation.Function.Enumeration.ListView.Base.html#2971" class="Field">wit</a> <a id="4162" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a><a id="4163" class="Symbol">)</a> <a id="4165" class="Symbol">(</a><a id="4166" href="Foundation.Function.Enumeration.ListView.Base.html#2971" class="Field">wit</a> <a id="4170" href="FOL.Syntax.Enumeration.html#4142" class="Bound">t⃗</a><a id="4172" class="Symbol">)</a> <a id="4174" class="Keyword">where</a>
      <a id="4186" href="FOL.Syntax.Enumeration.html#4186" class="Function">H</a> <a id="4188" class="Symbol">:</a> <a id="4190" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="4198" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="4203" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a> <a id="4205" class="Symbol">→</a> <a id="4207" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="4215" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="4220" href="FOL.Syntax.Enumeration.html#4142" class="Bound">t⃗</a> <a id="4223" class="Symbol">→</a> <a id="4225" href="Foundation.Function.Enumeration.ListView.Base.html#2497" class="Function">Witness</a> <a id="4233" href="FOL.Syntax.Enumeration.html#3320" class="Function">e</a> <a id="4235" class="Symbol">(</a><a id="4236" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a> <a id="4238" href="FOL.Syntax.Base.html#3881" class="InductiveConstructor Operator">$̇</a> <a id="4241" href="FOL.Syntax.Enumeration.html#4142" class="Bound">t⃗</a><a id="4243" class="Symbol">)</a>
      <a id="4251" href="FOL.Syntax.Enumeration.html#4186" class="Function">H</a> <a id="4253" class="Symbol">(</a><a id="4254" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4256" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4258" href="FOL.Syntax.Enumeration.html#4258" class="Bound">Hm</a><a id="4260" class="Symbol">)</a> <a id="4262" class="Symbol">(</a><a id="4263" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a> <a id="4265" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4267" href="FOL.Syntax.Enumeration.html#4267" class="Bound">Hn</a><a id="4269" class="Symbol">)</a> <a id="4271" class="Symbol">=</a> <a id="4273" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4277" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4279" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4281" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a> <a id="4283" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="4285" class="Symbol">(</a><a id="4286" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="4293" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4295" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="4302" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4304" href="Foundation.Data.List.SetTheoretic.html#969" class="Function">∈-++⁺ʳ</a> <a id="4311" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4313" href="Data.List.Membership.Propositional.Properties.html#5225" class="Function">∈-concat⁺′</a> <a id="4324" href="FOL.Syntax.Enumeration.html#4347" class="Function">H1</a> <a id="4327" href="FOL.Syntax.Enumeration.html#4442" class="Function">H2</a><a id="4329" class="Symbol">)</a> <a id="4331" class="Keyword">where</a>
          <a id="4347" href="FOL.Syntax.Enumeration.html#4347" class="Function">H1</a> <a id="4350" class="Symbol">:</a> <a id="4352" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a> <a id="4354" href="FOL.Syntax.Base.html#3881" class="InductiveConstructor Operator">$̇</a> <a id="4357" href="FOL.Syntax.Enumeration.html#4142" class="Bound">t⃗</a> <a id="4360" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="4363" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="4368" class="Symbol">(</a><a id="4369" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4371" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4373" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a><a id="4374" class="Symbol">)</a> <a id="4376" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a>
          <a id="4388" href="FOL.Syntax.Enumeration.html#4347" class="Function">H1</a> <a id="4391" class="Symbol">=</a> <a id="4393" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="4404" class="Symbol">(</a><a id="4405" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4413" href="Foundation.Function.Enumeration.ListView.Base.html#2945" class="Field">cum</a> <a id="4417" href="Foundation.Data.Nat.AlternativeOrder.html#1884" class="Function">m≤n+m</a> <a id="4423" href="FOL.Syntax.Enumeration.html#4267" class="Bound">Hn</a><a id="4425" class="Symbol">)</a> <a id="4427" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
          <a id="4442" href="FOL.Syntax.Enumeration.html#4442" class="Function">H2</a> <a id="4445" class="Symbol">:</a> <a id="4447" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="4452" class="Symbol">(</a><a id="4453" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4455" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4457" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a><a id="4458" class="Symbol">)</a> <a id="4460" href="FOL.Syntax.Enumeration.html#4137" class="Bound">R</a> <a id="4462" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="4465" href="Data.List.Base.html#1627" class="Function">map</a> <a id="4469" class="Symbol">(</a><a id="4470" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="4475" class="Symbol">(</a><a id="4476" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4478" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4480" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a><a id="4481" class="Symbol">))</a> <a id="4484" class="Symbol">(</a><a id="4485" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="4490" class="Symbol">(</a><a id="4491" href="FOL.Syntax.Enumeration.html#4254" class="Bound">m</a> <a id="4493" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4495" href="FOL.Syntax.Enumeration.html#4263" class="Bound">n</a><a id="4496" class="Symbol">))</a>
          <a id="4509" href="FOL.Syntax.Enumeration.html#4442" class="Function">H2</a> <a id="4512" class="Symbol">=</a> <a id="4514" href="Foundation.Data.List.SetTheoretic.html#1331" class="Function">∈map-intro</a> <a id="4525" class="Symbol">(</a><a id="4526" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4534" href="Foundation.Function.Enumeration.ListView.Base.html#2945" class="Field">cum</a> <a id="4538" href="Foundation.Data.Nat.AlternativeOrder.html#1838" class="Function">m≤m+n</a> <a id="4544" href="FOL.Syntax.Enumeration.html#4258" class="Bound">Hm</a><a id="4546" class="Symbol">)</a> <a id="4548" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong><u>引理</u></strong> 公式的累积列表是真累积.<br />
<strong><u>证明</u></strong> 观察定义不难看出列表的长度是严格递增的. ∎</p>
<pre class="Agda"><a id="enumFormula-proper"></a><a id="4633" href="FOL.Syntax.Enumeration.html#4633" class="Function">enumFormula-proper</a> <a id="4652" class="Symbol">:</a> <a id="4654" class="Symbol">∀</a> <a id="4656" href="FOL.Syntax.Enumeration.html#4656" class="Bound">n</a> <a id="4658" class="Symbol">→</a> <a id="4660" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4667" class="Symbol">(</a><a id="4668" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="4673" class="Symbol">⦃</a> <a id="4675" href="FOL.Syntax.Enumeration.html#3009" class="Function">enumFormula</a> <a id="4687" class="Symbol">⦄</a> <a id="4689" href="FOL.Syntax.Enumeration.html#4656" class="Bound">n</a><a id="4690" class="Symbol">)</a> <a id="4692" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">&gt;</a> <a id="4694" href="FOL.Syntax.Enumeration.html#4656" class="Bound">n</a>
<a id="4696" href="FOL.Syntax.Enumeration.html#4633" class="Function">enumFormula-proper</a> <a id="4715" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="4720" class="Symbol">=</a> <a id="4722" href="Foundation.Data.Nat.AlternativeOrder.html#325" class="InductiveConstructor">≤-refl</a>
<a id="4729" href="FOL.Syntax.Enumeration.html#4633" class="Function">enumFormula-proper</a> <a id="4748" class="Symbol">(</a><a id="4749" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4753" href="FOL.Syntax.Enumeration.html#4753" class="Bound">n</a><a id="4754" class="Symbol">)</a> <a id="4756" class="Symbol">=</a> <a id="4758" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="4764" class="Symbol">(</a><a id="4765" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">_&gt;</a> <a id="4768" class="Symbol">_)</a> <a id="4771" class="Symbol">(</a><a id="4772" href="Foundation.Data.List.html#1234" class="Function">length-++-++</a> <a id="4785" class="Symbol">_</a> <a id="4787" class="Symbol">_)</a> <a id="4790" class="Symbol">(</a><a id="4791" href="Foundation.Data.Nat.AlternativeOrder.html#1540" class="Function">&lt;-≤-trans</a> <a id="4801" href="FOL.Syntax.Enumeration.html#4818" class="Function">H</a> <a id="4803" href="Foundation.Data.Nat.AlternativeOrder.html#1838" class="Function">m≤m+n</a><a id="4808" class="Symbol">)</a> <a id="4810" class="Keyword">where</a>
  <a id="4818" href="FOL.Syntax.Enumeration.html#4818" class="Function">H</a> <a id="4820" class="Symbol">:</a> <a id="4822" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4829" class="Symbol">(</a><a id="4830" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="4835" href="FOL.Syntax.Enumeration.html#4753" class="Bound">n</a><a id="4836" class="Symbol">)</a> <a id="4838" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4840" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4847" class="Symbol">(</a><a id="4848" href="Data.List.Base.html#1627" class="Function">map</a> <a id="4852" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇_</a> <a id="4856" class="Symbol">_)</a> <a id="4859" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">&gt;</a> <a id="4861" class="Number">1</a> <a id="4863" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4865" href="FOL.Syntax.Enumeration.html#4753" class="Bound">n</a>
  <a id="4869" href="FOL.Syntax.Enumeration.html#4818" class="Function">H</a> <a id="4871" class="Symbol">=</a> <a id="4873" href="Foundation.Data.Nat.AlternativeOrder.html#3071" class="Function">+-mono-≤-&lt;</a> <a id="4884" class="Symbol">(</a><a id="4885" href="Foundation.Function.Enumeration.ListView.Base.html#2087" class="Function">cum-length</a> <a id="4896" href="Foundation.Function.Enumeration.ListView.Base.html#2945" class="Field">cum</a> <a id="4900" href="Data.Nat.Properties.html#61866" class="Function">z≤n</a><a id="4903" class="Symbol">)</a> <a id="4905" class="Symbol">(</a><a id="4906" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="4912" class="Symbol">(_</a> <a id="4915" href="Foundation.Data.Nat.AlternativeOrder.html#397" class="Function Operator">&lt;_</a><a id="4917" class="Symbol">)</a> <a id="4919" class="Symbol">(</a><a id="4920" href="Data.List.Properties.html#4003" class="Function">length-map</a> <a id="4931" class="Symbol">_</a> <a id="4933" class="Symbol">_)</a> <a id="4936" class="Symbol">(</a><a id="4937" href="FOL.Syntax.Enumeration.html#4633" class="Function">enumFormula-proper</a> <a id="4956" href="FOL.Syntax.Enumeration.html#4753" class="Bound">n</a><a id="4957" class="Symbol">))</a>
</pre>
<p><strong><u>定理</u></strong> 存在公式的枚举函数 <code>Ψ : ℕ → Formula</code>, 满足对任意 <code>φ : Formula</code> 都存在 <code>n : ℕ</code> 使得 <code>Ψ n ≡ φ</code>.<br />
<strong><u>证明</u></strong> 由于公式类型 <code>Formula</code> 是离散集且可枚举, 且其中的累积列表是真累积, 符合普通视角枚举函数 <code>Plain.enum</code> 的要求, 按其定义构造即得符合要求的 <code>Ψ : ℕ → Formula</code>. ∎</p>
<pre class="Agda"><a id="5184" class="Keyword">module</a> <a id="Plain"></a><a id="5191" href="FOL.Syntax.Enumeration.html#5191" class="Module">Plain</a> <a id="5197" class="Symbol">=</a> <a id="5199" href="Foundation.Function.Enumeration.PlainView.html#986" class="Module">PlainEnum</a> <a id="5209" href="FOL.Syntax.Enumeration.html#4633" class="Function">enumFormula-proper</a>

<a id="Ψ"></a><a id="5229" href="FOL.Syntax.Enumeration.html#5229" class="Function">Ψ</a> <a id="5231" class="Symbol">:</a> <a id="5233" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5235" class="Symbol">→</a> <a id="5237" href="FOL.Syntax.Base.html#3783" class="Datatype">Formula</a>
<a id="5245" href="FOL.Syntax.Enumeration.html#5229" class="Function">Ψ</a> <a id="5247" class="Symbol">=</a> <a id="5249" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">Plain.enum</a>

<a id="Ψ-wit"></a><a id="5261" href="FOL.Syntax.Enumeration.html#5261" class="Function">Ψ-wit</a> <a id="5267" class="Symbol">:</a> <a id="5269" class="Symbol">∀</a> <a id="5271" href="FOL.Syntax.Enumeration.html#5271" class="Bound">φ</a> <a id="5273" class="Symbol">→</a> <a id="5275" href="Foundation.Prop.Logic.html#736" class="Function">∃</a> <a id="5277" href="FOL.Syntax.Enumeration.html#5277" class="Bound">n</a> <a id="5279" href="Foundation.Prop.Logic.html#736" class="Function">，</a> <a id="5281" href="FOL.Syntax.Enumeration.html#5229" class="Function">Ψ</a> <a id="5283" href="FOL.Syntax.Enumeration.html#5277" class="Bound">n</a> <a id="5285" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5287" href="FOL.Syntax.Enumeration.html#5271" class="Bound">φ</a>
<a id="5289" href="FOL.Syntax.Enumeration.html#5261" class="Function">Ψ-wit</a> <a id="5295" class="Symbol">=</a> <a id="5297" href="Foundation.Function.Enumeration.PlainView.html#1988" class="Function">Plain.wit</a>
</pre>
<h2 id="枚举物的新变元">枚举物的新变元</h2>
<p>公式的枚举函数 <code>Ψ</code> 有一个非常显然的性质: 对任意 <code>m ≤ n</code>, <code># n</code> 是 <code>Ψ m</code> 的新变元 (<code>Ψ-fresh</code>). 因为变元的数量是无限的, 而任一时刻只有有限个被枚举出来. 然而完整地写出其形式化证明却相当冗长且乏味, 因为必须对枚举函数的结构一步步地归纳. 比较适合处理这种情况的是 Coq 和 Lean 等自带 tactic 的证明助理. 虽然 Agda 也可以使用反射机制实现 tactic, 但毕竟需要额外去实现, 除非后面经常出现这种情况, 否则暂不考虑.</p>
<pre class="Agda"><a id="termEnum-fresh"></a><a id="5579" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="5594" class="Symbol">:</a> <a id="5596" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="5598" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="5600" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="5602" class="Symbol">→</a> <a id="5604" href="FOL.Syntax.Base.html#5210" class="Generalizable">t</a> <a id="5606" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="5609" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="5614" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="5616" class="Symbol">→</a> <a id="5618" href="FOL.Syntax.FreshVariables.html#523" class="Datatype">freshₜ</a> <a id="5625" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="5627" href="FOL.Syntax.Base.html#5210" class="Generalizable">t</a>
<a id="5629" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="5644" class="Symbol">{</a><a id="5645" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5649" href="FOL.Syntax.Enumeration.html#5649" class="Bound">m</a><a id="5650" class="Symbol">}</a> <a id="5652" href="FOL.Syntax.Enumeration.html#5652" class="Bound">le</a> <a id="5655" href="FOL.Syntax.Enumeration.html#5655" class="Bound">t∈</a> <a id="5658" class="Keyword">with</a> <a id="5663" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="5669" class="Symbol">_</a> <a id="5671" href="FOL.Syntax.Enumeration.html#5655" class="Bound">t∈</a>
<a id="5674" class="Symbol">...</a> <a id="5678" class="Symbol">|</a> <a id="5680" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="5685" href="FOL.Syntax.Enumeration.html#5685" class="Bound">t∈</a> <a id="5688" class="Symbol">=</a> <a id="5690" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="5705" class="Symbol">(</a><a id="5706" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="5716" class="Number">1</a> <a id="5718" class="Bound">le</a><a id="5720" class="Symbol">)</a> <a id="5722" href="FOL.Syntax.Enumeration.html#5685" class="Bound">t∈</a>
<a id="5725" class="Symbol">...</a> <a id="5729" class="Symbol">|</a> <a id="5731" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5736" class="Symbol">(</a><a id="5737" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="5742" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="5746" class="Symbol">)</a> <a id="5748" class="Symbol">=</a> <a id="5750" href="FOL.Syntax.FreshVariables.html#557" class="InductiveConstructor">fresh#</a> <a id="5757" class="Symbol">λ</a> <a id="5759" class="Symbol">{</a> <a id="5761" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="5766" class="Symbol">→</a> <a id="5768" href="Foundation.Data.Nat.AlternativeOrder.html#1159" class="Function">1+n≰n</a> <a id="5774" class="Bound">le</a> <a id="5777" class="Symbol">}</a>
<a id="5779" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="5794" class="Symbol">{</a><a id="5795" class="Argument">t</a> <a id="5797" class="Symbol">=</a> <a id="5799" href="FOL.Syntax.Base.html#740" class="InductiveConstructor">#</a> <a id="5801" href="FOL.Syntax.Enumeration.html#5801" class="Bound">o</a><a id="5802" class="Symbol">}</a> <a id="5804" class="Symbol">_</a> <a id="5806" class="Symbol">_</a>
    <a id="5812" class="Symbol">|</a> <a id="5814" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5819" class="Symbol">(</a><a id="5820" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="5826" href="FOL.Syntax.Enumeration.html#5826" class="Bound">t∈</a><a id="5828" class="Symbol">)</a> <a id="5830" class="Keyword">with</a> <a id="5835" href="Data.List.Membership.Propositional.Properties.html#5382" class="Function">∈-concat⁻′</a> <a id="5846" class="Symbol">_</a> <a id="5848" href="FOL.Syntax.Enumeration.html#5826" class="Bound">t∈</a>
<a id="5851" class="Symbol">...</a>   <a id="5857" class="Symbol">|</a> <a id="5859" class="Symbol">_</a> <a id="5861" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5863" href="FOL.Syntax.Enumeration.html#5863" class="Bound">t∈ts</a> <a id="5868" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5870" href="FOL.Syntax.Enumeration.html#5870" class="Bound">ts∈</a> <a id="5874" class="Keyword">with</a> <a id="5879" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="5889" href="FOL.Syntax.Enumeration.html#5870" class="Bound">ts∈</a>
<a id="5893" class="Symbol">...</a>     <a id="5901" class="Symbol">|</a> <a id="5903" class="Symbol">_</a> <a id="5905" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5907" class="Symbol">_</a> <a id="5909" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5911" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="5916" class="Keyword">with</a> <a id="5921" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="5931" class="Bound">t∈ts</a>
<a id="5936" class="Symbol">...</a>       <a id="5946" class="Symbol">|</a> <a id="5948" class="Symbol">_</a> <a id="5950" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5952" class="Symbol">_</a> <a id="5954" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="5956" class="Symbol">()</a>
<a id="5959" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="5974" class="Symbol">{</a><a id="5975" class="Argument">t</a> <a id="5977" class="Symbol">=</a> <a id="5979" href="FOL.Syntax.Enumeration.html#5979" class="Bound">f</a> <a id="5981" href="FOL.Syntax.Base.html#755" class="InductiveConstructor Operator">$̇</a> <a id="5984" href="FOL.Syntax.Enumeration.html#5984" class="Bound">t⃗</a><a id="5986" class="Symbol">}</a> <a id="5988" href="FOL.Syntax.Enumeration.html#5988" class="Bound">le</a> <a id="5991" class="Symbol">_</a>
    <a id="5997" class="Symbol">|</a> <a id="5999" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6004" class="Symbol">(</a><a id="6005" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="6011" href="FOL.Syntax.Enumeration.html#6011" class="Bound">t∈</a><a id="6013" class="Symbol">)</a> <a id="6015" class="Keyword">with</a> <a id="6020" href="Data.List.Membership.Propositional.Properties.html#5382" class="Function">∈-concat⁻′</a> <a id="6031" class="Symbol">_</a> <a id="6033" href="FOL.Syntax.Enumeration.html#6011" class="Bound">t∈</a>
<a id="6036" class="Symbol">...</a>   <a id="6042" class="Symbol">|</a> <a id="6044" class="Symbol">_</a> <a id="6046" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6048" href="FOL.Syntax.Enumeration.html#6048" class="Bound">t∈ts</a> <a id="6053" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6055" href="FOL.Syntax.Enumeration.html#6055" class="Bound">ts∈</a> <a id="6059" class="Keyword">with</a> <a id="6064" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="6074" href="FOL.Syntax.Enumeration.html#6055" class="Bound">ts∈</a>
<a id="6078" class="Symbol">...</a>     <a id="6086" class="Symbol">|</a> <a id="6088" class="Symbol">_</a> <a id="6090" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6092" class="Symbol">_</a> <a id="6094" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6096" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6101" class="Keyword">with</a> <a id="6106" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="6116" class="Bound">t∈ts</a>
<a id="6121" class="Symbol">...</a>       <a id="6131" class="Symbol">|</a> <a id="6133" class="Symbol">_</a> <a id="6135" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6137" href="FOL.Syntax.Enumeration.html#6137" class="Bound">t⃗∈</a> <a id="6141" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6143" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6148" class="Keyword">with</a> <a id="6153" href="Foundation.Function.Enumeration.ListView.Base.html#4800" class="Function">∈combine-elim</a> <a id="6167" href="FOL.Syntax.Enumeration.html#6137" class="Bound">t⃗∈</a>
<a id="6171" class="Symbol">...</a>         <a id="6183" class="Symbol">|</a> <a id="6185" href="FOL.Syntax.Enumeration.html#6185" class="Bound">H</a> <a id="6187" class="Symbol">=</a> <a id="6189" href="FOL.Syntax.FreshVariables.html#599" class="InductiveConstructor">fresh$̇</a> <a id="6197" class="Symbol">λ</a> <a id="6199" href="FOL.Syntax.Enumeration.html#6199" class="Bound">t</a> <a id="6201" href="FOL.Syntax.Enumeration.html#6201" class="Bound">t∈t⃗</a> <a id="6206" class="Symbol">→</a> <a id="6208" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="6223" class="Symbol">(</a><a id="6224" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="6234" class="Number">1</a> <a id="6236" class="Bound">le</a><a id="6238" class="Symbol">)</a> <a id="6240" class="Symbol">(</a><a id="6241" href="FOL.Syntax.Enumeration.html#6185" class="Bound">H</a> <a id="6243" href="FOL.Syntax.Enumeration.html#6201" class="Bound">t∈t⃗</a><a id="6247" class="Symbol">)</a>

<a id="termEnum-fresh-vec"></a><a id="6250" href="FOL.Syntax.Enumeration.html#6250" class="Function">termEnum-fresh-vec</a> <a id="6269" class="Symbol">:</a> <a id="6271" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="6273" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="6275" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="6277" class="Symbol">→</a> <a id="6279" class="Symbol">{</a><a id="6280" href="FOL.Syntax.Enumeration.html#6280" class="Bound">t⃗</a> <a id="6283" class="Symbol">:</a> <a id="6285" href="Data.Vec.Base.html#1107" class="Datatype">𝕍</a> <a id="6287" href="FOL.Syntax.Base.html#723" class="Datatype">Term</a> <a id="6292" href="FOL.Syntax.Enumeration.html#687" class="Generalizable">o</a><a id="6293" class="Symbol">}</a> <a id="6295" class="Symbol">→</a> <a id="6297" href="FOL.Syntax.Enumeration.html#6280" class="Bound">t⃗</a> <a id="6300" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="6303" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="6308" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="6310" class="Symbol">→</a> <a id="6312" class="Symbol">∀</a> <a id="6314" class="Symbol">{</a><a id="6315" href="FOL.Syntax.Enumeration.html#6315" class="Bound">t</a><a id="6316" class="Symbol">}</a> <a id="6318" class="Symbol">→</a> <a id="6320" href="FOL.Syntax.Enumeration.html#6315" class="Bound">t</a> <a id="6322" href="Foundation.Essential.html#12173" class="Function Operator">∈⃗</a> <a id="6325" href="FOL.Syntax.Enumeration.html#6280" class="Bound">t⃗</a> <a id="6328" class="Symbol">→</a> <a id="6330" href="FOL.Syntax.FreshVariables.html#523" class="Datatype">freshₜ</a> <a id="6337" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="6339" href="FOL.Syntax.Enumeration.html#6315" class="Bound">t</a>
<a id="6341" href="FOL.Syntax.Enumeration.html#6250" class="Function">termEnum-fresh-vec</a> <a id="6360" class="Symbol">{</a><a id="6361" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6365" href="FOL.Syntax.Enumeration.html#6365" class="Bound">m</a><a id="6366" class="Symbol">}</a> <a id="6368" href="FOL.Syntax.Enumeration.html#6368" class="Bound">le</a> <a id="6371" href="FOL.Syntax.Enumeration.html#6371" class="Bound">t⃗∈ᴸ</a> <a id="6376" href="FOL.Syntax.Enumeration.html#6376" class="Bound">t∈⃗</a> <a id="6380" class="Keyword">with</a> <a id="6385" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="6391" class="Symbol">_</a> <a id="6393" href="FOL.Syntax.Enumeration.html#6371" class="Bound">t⃗∈ᴸ</a>
<a id="6398" class="Symbol">...</a> <a id="6402" class="Symbol">|</a> <a id="6404" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6409" href="FOL.Syntax.Enumeration.html#6409" class="Bound">t⃗∈ᴸ</a> <a id="6414" class="Symbol">=</a> <a id="6416" href="FOL.Syntax.Enumeration.html#6250" class="Function">termEnum-fresh-vec</a> <a id="6435" class="Symbol">(</a><a id="6436" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="6446" class="Number">1</a> <a id="6448" class="Bound">le</a><a id="6450" class="Symbol">)</a> <a id="6452" href="FOL.Syntax.Enumeration.html#6409" class="Bound">t⃗∈ᴸ</a> <a id="6457" class="Bound">t∈⃗</a>
<a id="6461" class="Symbol">...</a> <a id="6465" class="Symbol">|</a> <a id="6467" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6472" href="FOL.Syntax.Enumeration.html#6472" class="Bound">t⃗∈ᴸ</a> <a id="6477" class="Symbol">=</a> <a id="6479" href="FOL.Syntax.Enumeration.html#5579" class="Function">termEnum-fresh</a> <a id="6494" class="Symbol">(</a><a id="6495" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="6505" class="Number">1</a> <a id="6507" class="Bound">le</a><a id="6509" class="Symbol">)</a> <a id="6511" class="Symbol">(</a><a id="6512" href="Foundation.Function.Enumeration.ListView.Base.html#4800" class="Function">∈combine-elim</a> <a id="6526" href="FOL.Syntax.Enumeration.html#6472" class="Bound">t⃗∈ᴸ</a> <a id="6531" class="Bound">t∈⃗</a><a id="6534" class="Symbol">)</a>

<a id="formulaEnum-fresh"></a><a id="6537" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6555" class="Symbol">:</a> <a id="6557" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="6559" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="6561" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="6563" class="Symbol">→</a> <a id="6565" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a> <a id="6567" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="6570" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="6575" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="6577" class="Symbol">→</a> <a id="6579" href="FOL.Syntax.FreshVariables.html#915" class="Datatype">freshᵩ</a> <a id="6586" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="6588" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a>
<a id="6590" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6608" class="Symbol">{(</a><a id="6610" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="6614" class="Symbol">)}</a> <a id="6617" class="Symbol">_</a> <a id="6619" class="Symbol">(</a><a id="6620" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="6625" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="6629" class="Symbol">)</a> <a id="6631" class="Symbol">=</a> <a id="6633" href="FOL.Syntax.FreshVariables.html#952" class="InductiveConstructor">fresh⊥̇</a>
<a id="6641" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6659" class="Symbol">{</a><a id="6660" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6664" href="FOL.Syntax.Enumeration.html#6664" class="Bound">m</a><a id="6665" class="Symbol">}</a> <a id="6667" class="Symbol">{</a><a id="6668" class="Argument">φ</a> <a id="6670" class="Symbol">=</a> <a id="6672" href="FOL.Syntax.Base.html#3803" class="InductiveConstructor">⊥̇</a><a id="6674" class="Symbol">}</a> <a id="6676" href="FOL.Syntax.Enumeration.html#6676" class="Bound">le</a> <a id="6679" href="FOL.Syntax.Enumeration.html#6679" class="Bound">φ∈</a> <a id="6682" class="Symbol">=</a> <a id="6684" href="FOL.Syntax.FreshVariables.html#952" class="InductiveConstructor">fresh⊥̇</a>

<a id="6693" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6711" class="Symbol">{</a><a id="6712" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6716" href="FOL.Syntax.Enumeration.html#6716" class="Bound">m</a><a id="6717" class="Symbol">}</a> <a id="6719" class="Symbol">{</a><a id="6720" class="Argument">φ</a> <a id="6722" class="Symbol">=</a> <a id="6724" href="FOL.Syntax.Base.html#3855" class="InductiveConstructor Operator">∀̇</a> <a id="6727" href="FOL.Syntax.Enumeration.html#6727" class="Bound">φ</a><a id="6728" class="Symbol">}</a> <a id="6730" href="FOL.Syntax.Enumeration.html#6730" class="Bound">le</a> <a id="6733" href="FOL.Syntax.Enumeration.html#6733" class="Bound">φ∈</a> <a id="6736" class="Keyword">with</a> <a id="6741" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="6747" class="Symbol">_</a> <a id="6749" href="FOL.Syntax.Enumeration.html#6733" class="Bound">φ∈</a>
<a id="6752" class="Symbol">...</a> <a id="6756" class="Symbol">|</a> <a id="6758" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6763" href="FOL.Syntax.Enumeration.html#6763" class="Bound">φ∈e</a> <a id="6767" class="Symbol">=</a> <a id="6769" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6787" class="Symbol">(</a><a id="6788" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="6798" class="Number">1</a> <a id="6800" class="Bound">le</a><a id="6802" class="Symbol">)</a> <a id="6804" href="FOL.Syntax.Enumeration.html#6763" class="Bound">φ∈e</a>
<a id="6808" class="Symbol">...</a> <a id="6812" class="Symbol">|</a> <a id="6814" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6819" href="FOL.Syntax.Enumeration.html#6819" class="Bound">φ∈++</a> <a id="6824" class="Keyword">with</a> <a id="6829" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="6835" class="Symbol">_</a> <a id="6837" href="FOL.Syntax.Enumeration.html#6819" class="Bound">φ∈++</a>
<a id="6842" class="Symbol">...</a>   <a id="6848" class="Symbol">|</a> <a id="6850" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6855" href="FOL.Syntax.Enumeration.html#6855" class="Bound">φ∈∀̇</a> <a id="6860" class="Keyword">with</a> <a id="6865" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="6875" href="FOL.Syntax.Enumeration.html#6855" class="Bound">φ∈∀̇</a>
<a id="6880" class="Symbol">...</a>     <a id="6888" class="Symbol">|</a> <a id="6890" class="Symbol">_</a> <a id="6892" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6894" href="FOL.Syntax.Enumeration.html#6894" class="Bound">φ∈e</a> <a id="6898" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="6900" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6905" class="Symbol">=</a> <a id="6907" href="FOL.Syntax.FreshVariables.html#1042" class="InductiveConstructor">fresh∀̇</a> <a id="6915" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6917" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6935" class="Symbol">(</a><a id="6936" href="Foundation.Data.Nat.AlternativeOrder.html#979" class="Function">≤-trans</a> <a id="6944" class="Symbol">(</a><a id="6945" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="6955" class="Number">1</a> <a id="6957" class="Bound">le</a><a id="6959" class="Symbol">)</a> <a id="6961" href="Foundation.Data.Nat.AlternativeOrder.html#1884" class="Function">m≤n+m</a><a id="6966" class="Symbol">)</a> <a id="6968" href="FOL.Syntax.Enumeration.html#6894" class="Bound">φ∈e</a>
<a id="6972" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="6990" class="Symbol">_</a> <a id="6992" class="Symbol">_</a> <a id="6994" class="Symbol">|</a> <a id="6996" class="Symbol">_</a>
      <a id="7004" class="Symbol">|</a> <a id="7006" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7011" href="FOL.Syntax.Enumeration.html#7011" class="Bound">φ∈++</a> <a id="7016" class="Keyword">with</a> <a id="7021" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="7027" class="Symbol">_</a> <a id="7029" href="FOL.Syntax.Enumeration.html#7011" class="Bound">φ∈++</a>
<a id="7034" class="Symbol">...</a>     <a id="7042" class="Symbol">|</a> <a id="7044" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7049" href="FOL.Syntax.Enumeration.html#7049" class="Bound">φ∈→̇</a> <a id="7054" class="Keyword">with</a> <a id="7059" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7069" href="FOL.Syntax.Enumeration.html#7049" class="Bound">φ∈→̇</a>
<a id="7074" class="Symbol">...</a>       <a id="7084" class="Symbol">|</a> <a id="7086" class="Symbol">_</a> <a id="7088" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7090" class="Symbol">_</a> <a id="7092" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7094" class="Symbol">()</a>
<a id="7097" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7115" class="Symbol">_</a> <a id="7117" class="Symbol">_</a> <a id="7119" class="Symbol">|</a> <a id="7121" class="Symbol">_</a> <a id="7123" class="Symbol">|</a> <a id="7125" class="Symbol">_</a>
        <a id="7135" class="Symbol">|</a> <a id="7137" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7142" href="FOL.Syntax.Enumeration.html#7142" class="Bound">φ∈$̇</a> <a id="7147" class="Keyword">with</a> <a id="7152" href="Data.List.Membership.Propositional.Properties.html#5382" class="Function">∈-concat⁻′</a> <a id="7163" class="Symbol">_</a> <a id="7165" href="FOL.Syntax.Enumeration.html#7142" class="Bound">φ∈$̇</a>
<a id="7170" class="Symbol">...</a>       <a id="7180" class="Symbol">|</a> <a id="7182" class="Symbol">_</a> <a id="7184" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7186" href="FOL.Syntax.Enumeration.html#7186" class="Bound">φ∈φs</a> <a id="7191" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7193" href="FOL.Syntax.Enumeration.html#7193" class="Bound">φs∈</a> <a id="7197" class="Keyword">with</a> <a id="7202" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7212" href="FOL.Syntax.Enumeration.html#7193" class="Bound">φs∈</a>
<a id="7216" class="Symbol">...</a>         <a id="7228" class="Symbol">|</a> <a id="7230" class="Symbol">_</a> <a id="7232" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7234" class="Symbol">_</a> <a id="7236" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7238" href="FOL.Syntax.Enumeration.html#7238" class="Bound">eq</a> <a id="7241" class="Keyword">with</a> <a id="7246" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7256" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="7258" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="7264" class="Symbol">(_</a> <a id="7267" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ_</a><a id="7270" class="Symbol">)</a> <a id="7272" class="Symbol">(</a><a id="7273" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="7277" href="FOL.Syntax.Enumeration.html#7238" class="Bound">eq</a><a id="7279" class="Symbol">)</a> <a id="7281" class="Bound">φ∈φs</a>
<a id="7286" class="Symbol">...</a>           <a id="7300" class="Symbol">|</a> <a id="7302" class="Symbol">_</a> <a id="7304" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7306" class="Symbol">_</a> <a id="7308" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7310" class="Symbol">()</a>

<a id="7314" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7332" class="Symbol">{</a><a id="7333" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7337" href="FOL.Syntax.Enumeration.html#7337" class="Bound">m</a><a id="7338" class="Symbol">}</a> <a id="7340" class="Symbol">{</a><a id="7341" class="Argument">φ</a> <a id="7343" class="Symbol">=</a> <a id="7345" href="FOL.Syntax.Enumeration.html#7345" class="Bound">φ</a> <a id="7347" href="FOL.Syntax.Base.html#3818" class="InductiveConstructor Operator">→̇</a> <a id="7350" href="FOL.Syntax.Enumeration.html#7350" class="Bound">ψ</a><a id="7351" class="Symbol">}</a> <a id="7353" href="FOL.Syntax.Enumeration.html#7353" class="Bound">le</a> <a id="7356" href="FOL.Syntax.Enumeration.html#7356" class="Bound">φ∈</a> <a id="7359" class="Keyword">with</a> <a id="7364" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="7370" class="Symbol">_</a> <a id="7372" href="FOL.Syntax.Enumeration.html#7356" class="Bound">φ∈</a>
<a id="7375" class="Symbol">...</a> <a id="7379" class="Symbol">|</a> <a id="7381" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7386" href="FOL.Syntax.Enumeration.html#7386" class="Bound">φ∈e</a> <a id="7390" class="Symbol">=</a> <a id="7392" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7410" class="Symbol">(</a><a id="7411" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="7421" class="Number">1</a> <a id="7423" class="Bound">le</a><a id="7425" class="Symbol">)</a> <a id="7427" href="FOL.Syntax.Enumeration.html#7386" class="Bound">φ∈e</a>
<a id="7431" class="Symbol">...</a> <a id="7435" class="Symbol">|</a> <a id="7437" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7442" href="FOL.Syntax.Enumeration.html#7442" class="Bound">φ∈++</a> <a id="7447" class="Keyword">with</a> <a id="7452" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="7458" class="Symbol">_</a> <a id="7460" href="FOL.Syntax.Enumeration.html#7442" class="Bound">φ∈++</a>
<a id="7465" class="Symbol">...</a>   <a id="7471" class="Symbol">|</a> <a id="7473" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7478" href="FOL.Syntax.Enumeration.html#7478" class="Bound">φ∈∀̇</a> <a id="7483" class="Keyword">with</a> <a id="7488" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7498" href="FOL.Syntax.Enumeration.html#7478" class="Bound">φ∈∀̇</a>
<a id="7503" class="Symbol">...</a>     <a id="7511" class="Symbol">|</a> <a id="7513" class="Symbol">_</a> <a id="7515" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7517" class="Symbol">_</a> <a id="7519" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7521" class="Symbol">()</a>
<a id="7524" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7542" href="FOL.Syntax.Enumeration.html#7542" class="Bound">le</a> <a id="7545" class="Symbol">_</a> <a id="7547" class="Symbol">|</a> <a id="7549" class="Symbol">_</a>
      <a id="7557" class="Symbol">|</a> <a id="7559" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7564" href="FOL.Syntax.Enumeration.html#7564" class="Bound">φ∈++</a> <a id="7569" class="Keyword">with</a> <a id="7574" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="7580" class="Symbol">_</a> <a id="7582" href="FOL.Syntax.Enumeration.html#7564" class="Bound">φ∈++</a>
<a id="7587" class="Symbol">...</a>     <a id="7595" class="Symbol">|</a> <a id="7597" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7602" href="FOL.Syntax.Enumeration.html#7602" class="Bound">φ∈→̇</a> <a id="7607" class="Keyword">with</a> <a id="7612" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7622" href="FOL.Syntax.Enumeration.html#7602" class="Bound">φ∈→̇</a>
<a id="7627" class="Symbol">...</a>       <a id="7637" class="Symbol">|</a> <a id="7639" class="Symbol">_</a> <a id="7641" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7643" href="FOL.Syntax.Enumeration.html#7643" class="Bound">φ∈×</a> <a id="7647" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7649" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="7654" class="Keyword">with</a> <a id="7659" href="Foundation.Data.List.SetTheoretic.html#1983" class="Function">∈[×]-elim</a> <a id="7669" href="FOL.Syntax.Enumeration.html#7643" class="Bound">φ∈×</a>
<a id="7673" class="Symbol">...</a>         <a id="7685" class="Symbol">|</a> <a id="7687" href="FOL.Syntax.Enumeration.html#7687" class="Bound">φ∈e₁</a> <a id="7692" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7694" href="FOL.Syntax.Enumeration.html#7694" class="Bound">φ∈e₂</a> <a id="7699" class="Symbol">=</a> <a id="7701" class="Keyword">let</a> <a id="7705" href="FOL.Syntax.Enumeration.html#7705" class="Bound">H</a> <a id="7707" class="Symbol">=</a> <a id="7709" href="Foundation.Data.Nat.AlternativeOrder.html#979" class="Function">≤-trans</a> <a id="7717" class="Symbol">(</a><a id="7718" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="7728" class="Number">1</a> <a id="7730" class="Bound">le</a><a id="7732" class="Symbol">)</a> <a id="7734" href="Foundation.Data.Nat.AlternativeOrder.html#1884" class="Function">m≤n+m</a> <a id="7740" class="Keyword">in</a>
              <a id="7757" href="FOL.Syntax.FreshVariables.html#976" class="InductiveConstructor">fresh→̇</a> <a id="7765" class="Symbol">(</a><a id="7766" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7784" href="FOL.Syntax.Enumeration.html#7705" class="Bound">H</a> <a id="7786" href="FOL.Syntax.Enumeration.html#7687" class="Bound">φ∈e₁</a><a id="7790" class="Symbol">)</a> <a id="7792" class="Symbol">(</a><a id="7793" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7811" href="FOL.Syntax.Enumeration.html#7705" class="Bound">H</a> <a id="7813" href="FOL.Syntax.Enumeration.html#7694" class="Bound">φ∈e₂</a><a id="7817" class="Symbol">)</a>
<a id="7819" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="7837" class="Symbol">_</a> <a id="7839" class="Symbol">_</a> <a id="7841" class="Symbol">|</a> <a id="7843" class="Symbol">_</a> <a id="7845" class="Symbol">|</a> <a id="7847" class="Symbol">_</a>
        <a id="7857" class="Symbol">|</a> <a id="7859" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7864" href="FOL.Syntax.Enumeration.html#7864" class="Bound">φ∈$̇</a> <a id="7869" class="Keyword">with</a> <a id="7874" href="Data.List.Membership.Propositional.Properties.html#5382" class="Function">∈-concat⁻′</a> <a id="7885" class="Symbol">_</a> <a id="7887" href="FOL.Syntax.Enumeration.html#7864" class="Bound">φ∈$̇</a>
<a id="7892" class="Symbol">...</a>       <a id="7902" class="Symbol">|</a> <a id="7904" class="Symbol">_</a> <a id="7906" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7908" href="FOL.Syntax.Enumeration.html#7908" class="Bound">φ∈φs</a> <a id="7913" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7915" href="FOL.Syntax.Enumeration.html#7915" class="Bound">φs∈</a> <a id="7919" class="Keyword">with</a> <a id="7924" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7934" href="FOL.Syntax.Enumeration.html#7915" class="Bound">φs∈</a>
<a id="7938" class="Symbol">...</a>         <a id="7950" class="Symbol">|</a> <a id="7952" class="Symbol">_</a> <a id="7954" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7956" class="Symbol">_</a> <a id="7958" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="7960" href="FOL.Syntax.Enumeration.html#7960" class="Bound">eq</a> <a id="7963" class="Keyword">with</a> <a id="7968" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="7978" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="7980" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="7986" class="Symbol">(_</a> <a id="7989" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ_</a><a id="7992" class="Symbol">)</a> <a id="7994" class="Symbol">(</a><a id="7995" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="7999" href="FOL.Syntax.Enumeration.html#7960" class="Bound">eq</a><a id="8001" class="Symbol">)</a> <a id="8003" class="Bound">φ∈φs</a>
<a id="8008" class="Symbol">...</a>           <a id="8022" class="Symbol">|</a> <a id="8024" class="Symbol">_</a> <a id="8026" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8028" class="Symbol">_</a> <a id="8030" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8032" class="Symbol">()</a>

<a id="8036" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="8054" class="Symbol">{</a><a id="8055" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8059" href="FOL.Syntax.Enumeration.html#8059" class="Bound">m</a><a id="8060" class="Symbol">}</a> <a id="8062" class="Symbol">{</a><a id="8063" class="Argument">φ</a> <a id="8065" class="Symbol">=</a> <a id="8067" href="FOL.Syntax.Enumeration.html#8067" class="Bound">R</a> <a id="8069" href="FOL.Syntax.Base.html#3881" class="InductiveConstructor Operator">$̇</a> <a id="8072" href="FOL.Syntax.Enumeration.html#8072" class="Bound">t⃗</a><a id="8074" class="Symbol">}</a> <a id="8076" href="FOL.Syntax.Enumeration.html#8076" class="Bound">le</a> <a id="8079" href="FOL.Syntax.Enumeration.html#8079" class="Bound">φ∈</a> <a id="8082" class="Keyword">with</a> <a id="8087" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="8093" class="Symbol">_</a> <a id="8095" href="FOL.Syntax.Enumeration.html#8079" class="Bound">φ∈</a>
<a id="8098" class="Symbol">...</a> <a id="8102" class="Symbol">|</a> <a id="8104" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8109" href="FOL.Syntax.Enumeration.html#8109" class="Bound">φ∈e</a> <a id="8113" class="Symbol">=</a> <a id="8115" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="8133" class="Symbol">(</a><a id="8134" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="8144" class="Number">1</a> <a id="8146" class="Bound">le</a><a id="8148" class="Symbol">)</a> <a id="8150" href="FOL.Syntax.Enumeration.html#8109" class="Bound">φ∈e</a>
<a id="8154" class="Symbol">...</a> <a id="8158" class="Symbol">|</a> <a id="8160" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8165" href="FOL.Syntax.Enumeration.html#8165" class="Bound">φ∈++</a> <a id="8170" class="Keyword">with</a> <a id="8175" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="8181" class="Symbol">_</a> <a id="8183" href="FOL.Syntax.Enumeration.html#8165" class="Bound">φ∈++</a>
<a id="8188" class="Symbol">...</a>   <a id="8194" class="Symbol">|</a> <a id="8196" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8201" href="FOL.Syntax.Enumeration.html#8201" class="Bound">φ∈∀̇</a> <a id="8206" class="Keyword">with</a> <a id="8211" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="8221" href="FOL.Syntax.Enumeration.html#8201" class="Bound">φ∈∀̇</a>
<a id="8226" class="Symbol">...</a>     <a id="8234" class="Symbol">|</a> <a id="8236" class="Symbol">_</a> <a id="8238" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8240" class="Symbol">_</a> <a id="8242" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8244" class="Symbol">()</a>
<a id="8247" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="8265" href="FOL.Syntax.Enumeration.html#8265" class="Bound">le</a> <a id="8268" class="Symbol">_</a> <a id="8270" class="Symbol">|</a> <a id="8272" class="Symbol">_</a>
      <a id="8280" class="Symbol">|</a> <a id="8282" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8287" href="FOL.Syntax.Enumeration.html#8287" class="Bound">φ∈++</a> <a id="8292" class="Keyword">with</a> <a id="8297" href="Data.List.Membership.Propositional.Properties.html#4532" class="Function">∈-++⁻</a> <a id="8303" class="Symbol">_</a> <a id="8305" href="FOL.Syntax.Enumeration.html#8287" class="Bound">φ∈++</a>
<a id="8310" class="Symbol">...</a>     <a id="8318" class="Symbol">|</a> <a id="8320" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8325" href="FOL.Syntax.Enumeration.html#8325" class="Bound">φ∈→̇</a> <a id="8330" class="Keyword">with</a> <a id="8335" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="8345" href="FOL.Syntax.Enumeration.html#8325" class="Bound">φ∈→̇</a>
<a id="8350" class="Symbol">...</a>       <a id="8360" class="Symbol">|</a> <a id="8362" class="Symbol">_</a> <a id="8364" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8366" class="Symbol">_</a> <a id="8368" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8370" class="Symbol">()</a>
<a id="8373" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="8391" class="Symbol">{</a><a id="8392" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8396" href="FOL.Syntax.Enumeration.html#8396" class="Bound">m</a><a id="8397" class="Symbol">}</a> <a id="8399" class="Symbol">{</a><a id="8400" class="Argument">φ</a> <a id="8402" class="Symbol">=</a> <a id="8404" href="FOL.Syntax.Enumeration.html#8404" class="Bound">R</a> <a id="8406" class="InductiveConstructor Operator">$̇</a> <a id="8409" href="FOL.Syntax.Enumeration.html#8409" class="Bound">t⃗</a><a id="8411" class="Symbol">}</a> <a id="8413" href="FOL.Syntax.Enumeration.html#8413" class="Bound">le</a> <a id="8416" class="Symbol">_</a> <a id="8418" class="Symbol">|</a> <a id="8420" class="Symbol">_</a> <a id="8422" class="Symbol">|</a> <a id="8424" class="Symbol">_</a>
        <a id="8434" class="Symbol">|</a> <a id="8436" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8441" href="FOL.Syntax.Enumeration.html#8441" class="Bound">φ∈$̇</a> <a id="8446" class="Symbol">=</a> <a id="8448" href="FOL.Syntax.Enumeration.html#8480" class="Function">H</a> <a id="8450" class="Symbol">(</a><a id="8451" href="Foundation.Data.Nat.AlternativeOrder.html#2072" class="Function">m+n≤o⇒n≤o</a> <a id="8461" class="Number">1</a> <a id="8463" href="FOL.Syntax.Enumeration.html#8413" class="Bound">le</a><a id="8465" class="Symbol">)</a> <a id="8467" href="FOL.Syntax.Enumeration.html#8441" class="Bound">φ∈$̇</a> <a id="8472" class="Keyword">where</a>
  <a id="8480" href="FOL.Syntax.Enumeration.html#8480" class="Function">H</a> <a id="8482" class="Symbol">:</a> <a id="8484" href="FOL.Syntax.Enumeration.html#8396" class="Bound">m</a> <a id="8486" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="8488" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="8490" class="Symbol">→</a> <a id="8492" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a> <a id="8494" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="8497" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="8504" class="Symbol">(</a><a id="8505" href="Data.List.Base.html#1627" class="Function">map</a> <a id="8509" class="Symbol">(</a><a id="8510" href="FOL.Syntax.Enumeration.html#2878" class="Function">apps</a> <a id="8515" href="FOL.Syntax.Enumeration.html#8396" class="Bound">m</a><a id="8516" class="Symbol">)</a> <a id="8518" class="Symbol">(</a><a id="8519" href="Foundation.Function.Enumeration.ListView.Base.html#2929" class="Field">enum</a> <a id="8524" href="FOL.Syntax.Enumeration.html#8396" class="Bound">m</a><a id="8525" class="Symbol">))</a> <a id="8528" class="Symbol">→</a> <a id="8530" href="FOL.Syntax.FreshVariables.html#915" class="Datatype">freshᵩ</a> <a id="8537" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="8539" href="FOL.Syntax.Base.html#5221" class="Generalizable">φ</a>
  <a id="8543" href="FOL.Syntax.Enumeration.html#8480" class="Function">H</a> <a id="8545" href="FOL.Syntax.Enumeration.html#8545" class="Bound">le</a> <a id="8548" href="FOL.Syntax.Enumeration.html#8548" class="Bound">φ∈$̇</a> <a id="8553" class="Keyword">with</a> <a id="8558" href="Data.List.Membership.Propositional.Properties.html#5382" class="Function">∈-concat⁻′</a> <a id="8569" class="Symbol">_</a> <a id="8571" href="FOL.Syntax.Enumeration.html#8548" class="Bound">φ∈$̇</a>
  <a id="8578" class="Symbol">...</a> <a id="8582" class="Symbol">|</a> <a id="8584" class="Symbol">_</a> <a id="8586" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8588" href="FOL.Syntax.Enumeration.html#8588" class="Bound">φ∈φs</a> <a id="8593" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8595" href="FOL.Syntax.Enumeration.html#8595" class="Bound">φs∈</a> <a id="8599" class="Keyword">with</a> <a id="8604" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="8614" href="FOL.Syntax.Enumeration.html#8595" class="Bound">φs∈</a>
  <a id="8620" class="Symbol">...</a>   <a id="8626" class="Symbol">|</a> <a id="8628" class="Symbol">_</a> <a id="8630" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8632" class="Symbol">_</a> <a id="8634" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8636" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8641" class="Keyword">with</a> <a id="8646" href="Foundation.Data.List.SetTheoretic.html#1436" class="Function">∈map-elim</a> <a id="8656" class="Bound">φ∈φs</a>
  <a id="8663" class="Symbol">...</a>     <a id="8671" class="Symbol">|</a> <a id="8673" class="Symbol">_</a> <a id="8675" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8677" href="FOL.Syntax.Enumeration.html#8677" class="Bound">t⃗∈</a> <a id="8681" href="Foundation.Prelude.Builtin.html#779" class="InductiveConstructor Operator">,</a> <a id="8683" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8688" class="Symbol">=</a> <a id="8690" href="FOL.Syntax.FreshVariables.html#1097" class="InductiveConstructor">fresh$̇</a> <a id="8698" class="Symbol">λ</a> <a id="8700" href="FOL.Syntax.Enumeration.html#8700" class="Bound">_</a> <a id="8702" href="FOL.Syntax.Enumeration.html#8702" class="Bound">t∈t⃗</a> <a id="8707" class="Symbol">→</a> <a id="8709" href="FOL.Syntax.Enumeration.html#6250" class="Function">termEnum-fresh-vec</a> <a id="8728" class="Bound">le</a> <a id="8731" href="FOL.Syntax.Enumeration.html#8677" class="Bound">t⃗∈</a> <a id="8735" href="FOL.Syntax.Enumeration.html#8702" class="Bound">t∈t⃗</a>

<a id="Ψ-fresh"></a><a id="8741" href="FOL.Syntax.Enumeration.html#8741" class="Function">Ψ-fresh</a> <a id="8749" class="Symbol">:</a> <a id="8751" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a> <a id="8753" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="8755" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="8757" class="Symbol">→</a> <a id="8759" href="FOL.Syntax.FreshVariables.html#915" class="Datatype">freshᵩ</a> <a id="8766" href="FOL.Syntax.Enumeration.html#685" class="Generalizable">n</a> <a id="8768" class="Symbol">(</a><a id="8769" href="FOL.Syntax.Enumeration.html#5229" class="Function">Ψ</a> <a id="8771" href="FOL.Syntax.Enumeration.html#683" class="Generalizable">m</a><a id="8772" class="Symbol">)</a>
<a id="8774" href="FOL.Syntax.Enumeration.html#8741" class="Function">Ψ-fresh</a> <a id="8782" href="FOL.Syntax.Enumeration.html#8782" class="Bound">le</a> <a id="8785" class="Symbol">=</a> <a id="8787" href="FOL.Syntax.Enumeration.html#6537" class="Function">formulaEnum-fresh</a> <a id="8805" href="FOL.Syntax.Enumeration.html#8782" class="Bound">le</a> <a id="8808" href="Foundation.Function.Enumeration.PlainView.html#1329" class="Function">Plain.cum</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Syntax/Enumeration.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Syntax.Enumeration.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.syntax.enumeration">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
