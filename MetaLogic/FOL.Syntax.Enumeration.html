<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FOL.Syntax.Enumeration</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#一阶逻辑-语法-公式的枚举" id="toc-一阶逻辑-语法-公式的枚举">一阶逻辑 ▸ 语法 ▸ 公式的枚举</a>
  <ul>
  <li><a href="#项的枚举" id="toc-项的枚举">项的枚举</a>
  <ul>
  <li><a href="#项的列表的无穷序列-e" id="toc-项的列表的无穷序列-e">1. 项的列表的无穷序列 <code>e</code></a></li>
  <li><a href="#e-的累积-c" id="toc-e-的累积-c">2. <code>e</code> 的累积 <code>c</code></a></li>
  <li><a href="#命题-w-e-见证了任意项-t" id="toc-命题-w-e-见证了任意项-t">3. 命题 <code>w</code> : <code>e</code> 见证了任意项 <code>t</code></a></li>
  </ul></li>
  <li><a href="#公式的枚举" id="toc-公式的枚举">公式的枚举</a>
  <ul>
  <li><a href="#公式的列表的无穷序列-e" id="toc-公式的列表的无穷序列-e">1. 公式的列表的无穷序列 <code>e</code></a></li>
  <li><a href="#e-的累积-c-1" id="toc-e-的累积-c-1">2. <code>e</code> 的累积 <code>c</code></a></li>
  <li><a href="#命题-w-e-见证了任意公式-φ" id="toc-命题-w-e-见证了任意公式-φ">3. 命题 <code>w</code> : <code>e</code> 见证了任意公式 <code>φ</code></a></li>
  </ul></li>
  <li><a href="#枚举物的新变元" id="toc-枚举物的新变元">枚举物的新变元</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="一阶逻辑-语法-公式的枚举">一阶逻辑 ▸ 语法 ▸ 公式的枚举</h1>
<p>本篇的目标是构造公式的<a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.plainview">普通视角枚举函数</a> <code>Ψ : ℕ → Formula</code>, 满足对任意 <code>φ : Formula</code> 都存在 <code>n : ℕ</code> 使得 <code>Ψ n ≡ φ</code>.</p>
<pre class="Agda"><a id="226" class="Symbol">{-#</a> <a id="230" class="Keyword">OPTIONS</a> <a id="238" class="Pragma">--lossy-unification</a> <a id="258" class="Symbol">#-}</a>
<a id="262" class="Keyword">open</a> <a id="267" class="Keyword">import</a> <a id="274" href="Foundation.Essential.html" class="Module">Foundation.Essential</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Foundation.Data.Nat.AlternativeOrder.html" class="Module">Foundation.Data.Nat.AlternativeOrder</a>
<a id="344" class="Keyword">open</a> <a id="349" class="Keyword">import</a> <a id="356" href="Foundation.Data.List.SetTheoretic.html" class="Module">Foundation.Data.List.SetTheoretic</a> <a id="390" class="Keyword">renaming</a> <a id="399" class="Symbol">(</a><a id="400" href="Data.List.Membership.Setoid.html#943" class="Function Operator">_∈_</a> <a id="404" class="Symbol">to</a> <a id="407" class="Function Operator">_∈ᴸ_</a><a id="411" class="Symbol">)</a>
<a id="413" class="Keyword">open</a> <a id="418" class="Keyword">import</a> <a id="425" href="Foundation.Function.Enumeration.PlainView.html" class="Module">Foundation.Function.Enumeration.PlainView</a>

<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="FOL.Language.Base.html" class="Module">FOL.Language.Base</a>
<a id="498" class="Keyword">module</a> <a id="505" href="FOL.Syntax.Enumeration.html" class="Module">FOL.Syntax.Enumeration</a> <a id="528" class="Symbol">(</a><a id="529" href="FOL.Syntax.Enumeration.html#529" class="Bound">ℒ</a> <a id="531" class="Symbol">:</a> <a id="533" href="FOL.Language.Base.html#786" class="Record">Language</a><a id="541" class="Symbol">)</a> <a id="543" class="Keyword">where</a>
<a id="549" class="Keyword">open</a> <a id="554" class="Keyword">import</a> <a id="561" href="FOL.Syntax.Base.html" class="Module">FOL.Syntax.Base</a> <a id="577" href="FOL.Syntax.Enumeration.html#529" class="Bound">ℒ</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="FOL.Syntax.Discrete.html" class="Module">FOL.Syntax.Discrete</a> <a id="611" href="FOL.Syntax.Enumeration.html#529" class="Bound">ℒ</a>
<a id="613" class="Keyword">open</a> <a id="618" class="Keyword">import</a> <a id="625" href="FOL.Syntax.FreshVariables.html" class="Module">FOL.Syntax.FreshVariables</a> <a id="651" href="FOL.Syntax.Enumeration.html#529" class="Bound">ℒ</a>
<a id="653" class="Keyword">instance</a> <a id="662" href="FOL.Syntax.Enumeration.html#662" class="Function">_</a> <a id="664" class="Symbol">=</a> <a id="666" href="FOL.Syntax.Enumeration.html#529" class="Bound">ℒ</a>

<a id="669" class="Keyword">private</a> <a id="677" class="Keyword">variable</a>
  <a id="688" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="690" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="692" href="FOL.Syntax.Enumeration.html#692" class="Generalizable">o</a> <a id="694" class="Symbol">:</a> <a id="696" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
</pre>
<h2 id="项的枚举">项的枚举</h2>
<p><strong><u>实例/构造</u></strong> 项的枚举由以下 <code>e</code>, <code>c</code>, <code>w</code> 三部分构成:</p>
<pre class="Agda"><a id="767" class="Keyword">instance</a>
  <a id="enumTerm"></a><a id="778" href="FOL.Syntax.Enumeration.html#778" class="Function">enumTerm</a> <a id="787" class="Symbol">:</a> <a id="789" href="Foundation.Function.Enumeration.ListView.Base.html#2869" class="Record">Enum</a> <a id="794" href="FOL.Syntax.Base.html#731" class="Datatype">Term</a>
  <a id="801" href="FOL.Syntax.Enumeration.html#778" class="Function">enumTerm</a> <a id="810" class="Symbol">=</a> <a id="812" href="Foundation.Function.Enumeration.ListView.Base.html#2914" class="InductiveConstructor">mkEnum</a> <a id="819" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="821" href="FOL.Syntax.Enumeration.html#1555" class="Function">c</a> <a id="823" href="FOL.Syntax.Enumeration.html#2032" class="Function">w</a> <a id="825" class="Keyword">where</a>
</pre>
<h3 id="项的列表的无穷序列-e">1. 项的列表的无穷序列 <code>e</code></h3>
<p>我们需要同时互递归构造某函数 <code>f : 𝓕</code> 的所有 <code>e n</code> 应用, 记作 <code>apps n f</code>, 它是 <code>f</code> 应用于 <code>e n</code> 的所有 <code>∣ f ∣ᶠ</code> 维组合所得到的那些项所组成的列表.</p>
<pre class="Agda">    <a id="971" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="973" class="Symbol">:</a> <a id="975" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a> <a id="978" href="FOL.Syntax.Base.html#731" class="Datatype">Term</a>
    <a id="987" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="992" class="Symbol">:</a> <a id="994" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="996" class="Symbol">→</a> <a id="998" href="FOL.Language.Base.html#839" class="Field">𝓕</a> <a id="1000" class="Symbol">→</a> <a id="1002" href="Agda.Builtin.List.html#147" class="Datatype">𝕃</a> <a id="1004" href="FOL.Syntax.Base.html#731" class="Datatype">Term</a>
    <a id="1013" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="1018" href="FOL.Syntax.Enumeration.html#1018" class="Bound">n</a> <a id="1020" href="FOL.Syntax.Enumeration.html#1020" class="Bound">f</a> <a id="1022" class="Symbol">=</a> <a id="1024" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1028" class="Symbol">(</a><a id="1029" href="FOL.Syntax.Enumeration.html#1020" class="Bound">f</a> <a id="1031" href="FOL.Syntax.Base.html#763" class="InductiveConstructor Operator">$̇_</a><a id="1034" class="Symbol">)</a> <a id="1036" class="Symbol">(</a><a id="1037" href="Foundation.Function.Enumeration.ListView.Base.html#4346" class="Function">combine</a> <a id="1045" class="Symbol">(</a><a id="1046" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="1048" href="FOL.Syntax.Enumeration.html#1018" class="Bound">n</a><a id="1049" class="Symbol">)</a> <a id="1051" href="FOL.Language.Base.html#859" class="Field Operator">∣</a> <a id="1053" href="FOL.Syntax.Enumeration.html#1020" class="Bound">f</a> <a id="1055" href="FOL.Language.Base.html#859" class="Field Operator">∣ᶠ</a><a id="1057" class="Symbol">)</a>
</pre>
<p>我们递归定义 <code>e</code> 如下: - 输入 <code>zero</code> 时, 输出空列表. - 输入 <code>suc n</code> 时, 输出 <code>e n</code> 并上 <code>[ # n ]</code>, 再并上以<em>一些</em> <code>f : 𝓕</code> 为下标的集族 <code>apps n</code> 的并 (<code>concat</code>). 其中<em>一些</em> <code>f : 𝓕</code> 是指函数符号的枚举函数 <code>enum</code> (由语言的定义, 函数符号集 <code>𝓕</code> 可枚举) 应用于 <code>n</code> 所输出的那些 <code>f</code>.</p>
<p>此定义用传统集合论符号可表述为</p>
<p><span class="math display">
\begin{align*}
e(0) &amp;= \emptyset\\
e(n^+) &amp;= e(n) \cup \{\#n\} \cup \bigcup\{ apps(n, f) \mid f \in enum(n) \}
\end{align*}
</span></p>
<pre class="Agda">    <a id="1427" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="1429" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="1434" class="Symbol">=</a> <a id="1436" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="1443" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="1445" class="Symbol">(</a><a id="1446" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1450" href="FOL.Syntax.Enumeration.html#1450" class="Bound">n</a><a id="1451" class="Symbol">)</a> <a id="1453" class="Symbol">=</a> <a id="1455" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="1457" href="FOL.Syntax.Enumeration.html#1450" class="Bound">n</a> <a id="1459" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="1462" href="FOL.Syntax.Base.html#748" class="InductiveConstructor">#</a> <a id="1464" href="FOL.Syntax.Enumeration.html#1450" class="Bound">n</a> <a id="1466" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1468" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="1475" class="Symbol">(</a><a id="1476" href="Data.List.Base.html#1627" class="Function">map</a> <a id="1480" class="Symbol">(</a><a id="1481" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="1486" href="FOL.Syntax.Enumeration.html#1450" class="Bound">n</a><a id="1487" class="Symbol">)</a> <a id="1489" class="Symbol">(</a><a id="1490" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="1495" href="FOL.Syntax.Enumeration.html#1450" class="Bound">n</a><a id="1496" class="Symbol">))</a>
</pre>
<h3 id="e-的累积-c">2. <code>e</code> 的累积 <code>c</code></h3>
<p>由 <code>e</code> 的定义立即可得其累积.</p>
<pre class="Agda">    <a id="1555" href="FOL.Syntax.Enumeration.html#1555" class="Function">c</a> <a id="1557" class="Symbol">:</a> <a id="1559" href="Foundation.Function.Enumeration.ListView.Base.html#1127" class="Function">Cumulation</a> <a id="1570" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a>
    <a id="1576" href="FOL.Syntax.Enumeration.html#1555" class="Function">c</a> <a id="1578" class="Symbol">_</a> <a id="1580" class="Symbol">=</a> <a id="1582" class="Symbol">_</a> <a id="1584" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="1586" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="命题-w-e-见证了任意项-t">3. 命题 <code>w</code> : <code>e</code> 见证了任意项 <code>t</code></h3>
<p>我们用项的结构归纳法证明 <code>w</code>:</p>
<ul>
<li>要证 <code>e</code> 见证了任意变元. 观察 <code>e</code> 的定义, 显然成立.</li>
<li>要证 <code>e</code> 见证了任意函数应用 <code>f $̇ t⃗</code>, 已知 <code>t⃗</code> 中的项都被 <code>e</code> 见证 (归纳假设).
<ul>
<li>由语言的定义, 函数符号集 <code>𝓕</code> 可枚举; 由元语言的知识, 项的 <code>∣ f ∣ᶠ</code> 维向量可枚举. 由归纳假设和涉及列表组合的引理 <code>combine-wit</code>, 只要构造一个从 <code>f</code> 的见证和 <code>t⃗</code> 的见证到 <code>f $̇ t⃗</code> 的见证的转换函数, 就证明了 <code>e</code> 见证 <code>f $̇ t⃗</code>.
<ul>
<li>分别取 <code>f</code> 和 <code>t⃗</code> 的见证 <code>m</code> 和 <code>n</code>. 由枚举函数的累积性, <code>m + n</code> 也是 <code>f</code> 和 <code>t⃗</code> 的见证. 所以由 <code>e</code> 的定义, <code>suc m + n</code> 见证了 <code>f $̇ t⃗</code>. ∎</li>
</ul></li>
</ul></li>
</ul>
<pre class="Agda">    <a id="2032" href="FOL.Syntax.Enumeration.html#2032" class="Function">w</a> <a id="2034" class="Symbol">:</a> <a id="2036" class="Symbol">∀</a> <a id="2038" href="FOL.Syntax.Enumeration.html#2038" class="Bound">t</a> <a id="2040" class="Symbol">→</a> <a id="2042" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="2044" href="Foundation.Function.Enumeration.ListView.Base.html#2658" class="Function Operator">witness</a> <a id="2052" href="FOL.Syntax.Enumeration.html#2038" class="Bound">t</a>
    <a id="2058" href="FOL.Syntax.Enumeration.html#2032" class="Function">w</a> <a id="2060" class="Symbol">=</a> <a id="2062" href="FOL.Syntax.Base.html#1264" class="Function">term-elim</a> <a id="2072" href="FOL.Syntax.Enumeration.html#2091" class="Function">H#</a> <a id="2075" href="FOL.Syntax.Enumeration.html#2171" class="Function">H$̇</a> <a id="2079" class="Keyword">where</a>
      <a id="2091" href="FOL.Syntax.Enumeration.html#2091" class="Function">H#</a> <a id="2094" class="Symbol">:</a> <a id="2096" class="Symbol">∀</a> <a id="2098" href="FOL.Syntax.Enumeration.html#2098" class="Bound">n</a> <a id="2100" class="Symbol">→</a> <a id="2102" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="2104" href="Foundation.Function.Enumeration.ListView.Base.html#2658" class="Function Operator">witness</a> <a id="2112" href="FOL.Syntax.Base.html#748" class="InductiveConstructor">#</a> <a id="2114" href="FOL.Syntax.Enumeration.html#2098" class="Bound">n</a>
      <a id="2122" href="FOL.Syntax.Enumeration.html#2091" class="Function">H#</a> <a id="2125" href="FOL.Syntax.Enumeration.html#2125" class="Bound">n</a> <a id="2127" class="Symbol">=</a> <a id="2129" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="2132" class="Symbol">(</a><a id="2133" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2137" href="FOL.Syntax.Enumeration.html#2125" class="Bound">n</a><a id="2138" class="Symbol">)</a> <a id="2140" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2142" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="2153" class="Symbol">(</a><a id="2154" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="2159" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="2163" class="Symbol">)</a>
      <a id="2171" href="FOL.Syntax.Enumeration.html#2171" class="Function">H$̇</a> <a id="2175" class="Symbol">:</a> <a id="2177" class="Symbol">∀</a> <a id="2179" href="FOL.Syntax.Enumeration.html#2179" class="Bound">f</a> <a id="2181" href="FOL.Syntax.Enumeration.html#2181" class="Bound">t⃗</a> <a id="2184" class="Symbol">→</a> <a id="2186" class="Symbol">(∀</a> <a id="2189" href="FOL.Syntax.Enumeration.html#2189" class="Bound">t</a> <a id="2191" class="Symbol">→</a> <a id="2193" href="FOL.Syntax.Enumeration.html#2189" class="Bound">t</a> <a id="2195" href="Foundation.Essential.html#12199" class="Function Operator">∈⃗</a> <a id="2198" href="FOL.Syntax.Enumeration.html#2181" class="Bound">t⃗</a> <a id="2201" class="Symbol">→</a> <a id="2203" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="2205" href="Foundation.Function.Enumeration.ListView.Base.html#2658" class="Function Operator">witness</a> <a id="2213" href="FOL.Syntax.Enumeration.html#2189" class="Bound">t</a><a id="2214" class="Symbol">)</a> <a id="2216" class="Symbol">→</a> <a id="2218" href="FOL.Syntax.Enumeration.html#971" class="Function">e</a> <a id="2220" href="Foundation.Function.Enumeration.ListView.Base.html#2658" class="Function Operator">witness</a> <a id="2228" class="Symbol">(</a><a id="2229" href="FOL.Syntax.Enumeration.html#2179" class="Bound">f</a> <a id="2231" href="FOL.Syntax.Base.html#763" class="InductiveConstructor Operator">$̇</a> <a id="2234" href="FOL.Syntax.Enumeration.html#2181" class="Bound">t⃗</a><a id="2236" class="Symbol">)</a>
      <a id="2244" href="FOL.Syntax.Enumeration.html#2171" class="Function">H$̇</a> <a id="2248" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a> <a id="2250" href="FOL.Syntax.Enumeration.html#2250" class="Bound">t⃗</a> <a id="2253" href="FOL.Syntax.Enumeration.html#2253" class="Bound">IH</a> <a id="2256" class="Symbol">=</a> <a id="2258" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="2265" href="FOL.Syntax.Enumeration.html#2311" class="Function">H</a> <a id="2267" class="Symbol">(</a><a id="2268" href="Foundation.Function.Enumeration.ListView.Base.html#2975" class="Field">wit</a> <a id="2272" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a><a id="2273" class="Symbol">)</a> <a id="2275" class="Symbol">(</a><a id="2276" href="Foundation.Function.Enumeration.ListView.Base.html#5635" class="Function">combine-wit</a> <a id="2288" href="FOL.Syntax.Enumeration.html#1555" class="Function">c</a> <a id="2290" href="FOL.Syntax.Enumeration.html#2250" class="Bound">t⃗</a> <a id="2293" href="FOL.Syntax.Enumeration.html#2253" class="Bound">IH</a><a id="2295" class="Symbol">)</a> <a id="2297" class="Keyword">where</a>
        <a id="2311" href="FOL.Syntax.Enumeration.html#2311" class="Function">H</a> <a id="2313" class="Symbol">:</a> <a id="2315" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="2323" class="Symbol">_</a> <a id="2325" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a> <a id="2327" class="Symbol">→</a> <a id="2329" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="2337" class="Symbol">_</a> <a id="2339" href="FOL.Syntax.Enumeration.html#2250" class="Bound">t⃗</a> <a id="2342" class="Symbol">→</a> <a id="2344" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="2352" class="Symbol">_</a> <a id="2354" class="Symbol">(</a><a id="2355" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a> <a id="2357" href="FOL.Syntax.Base.html#763" class="InductiveConstructor Operator">$̇</a> <a id="2360" href="FOL.Syntax.Enumeration.html#2250" class="Bound">t⃗</a><a id="2362" class="Symbol">)</a>
        <a id="2372" href="FOL.Syntax.Enumeration.html#2311" class="Function">H</a> <a id="2374" class="Symbol">(</a><a id="2375" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2377" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2379" href="FOL.Syntax.Enumeration.html#2379" class="Bound">Hm</a><a id="2381" class="Symbol">)</a> <a id="2383" class="Symbol">(</a><a id="2384" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a> <a id="2386" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2388" href="FOL.Syntax.Enumeration.html#2388" class="Bound">Hn</a><a id="2390" class="Symbol">)</a> <a id="2392" class="Symbol">=</a> <a id="2394" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2398" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2400" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2402" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a> <a id="2404" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2406" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="2417" class="Symbol">(</a><a id="2418" class="InductiveConstructor">there</a> <a id="2424" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2426" href="Foundation.Data.List.SetTheoretic.html#633" class="Function">∈concat-intro</a> <a id="2440" href="FOL.Syntax.Enumeration.html#2463" class="Function">H1</a> <a id="2443" href="FOL.Syntax.Enumeration.html#2560" class="Function">H2</a><a id="2445" class="Symbol">)</a> <a id="2447" class="Keyword">where</a>
          <a id="2463" href="FOL.Syntax.Enumeration.html#2463" class="Function">H1</a> <a id="2466" class="Symbol">:</a> <a id="2468" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a> <a id="2470" href="FOL.Syntax.Base.html#763" class="InductiveConstructor Operator">$̇</a> <a id="2473" href="FOL.Syntax.Enumeration.html#2250" class="Bound">t⃗</a> <a id="2476" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="2479" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="2484" class="Symbol">(</a><a id="2485" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2487" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2489" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a><a id="2490" class="Symbol">)</a> <a id="2492" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a>
          <a id="2504" href="FOL.Syntax.Enumeration.html#2463" class="Function">H1</a> <a id="2507" class="Symbol">=</a> <a id="2509" href="Foundation.Data.List.SetTheoretic.html#1698" class="Function">∈map-intro</a> <a id="2520" class="Symbol">(</a><a id="2521" href="Foundation.Function.Enumeration.ListView.Base.html#5247" class="Function">combine-≤→⊆</a> <a id="2533" href="FOL.Syntax.Enumeration.html#1555" class="Function">c</a> <a id="2535" href="Foundation.Data.Nat.AlternativeOrder.html#2009" class="Function">m≤n+m</a> <a id="2541" href="FOL.Syntax.Enumeration.html#2388" class="Bound">Hn</a><a id="2543" class="Symbol">)</a> <a id="2545" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
          <a id="2560" href="FOL.Syntax.Enumeration.html#2560" class="Function">H2</a> <a id="2563" class="Symbol">:</a> <a id="2565" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="2570" class="Symbol">(</a><a id="2571" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2573" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2575" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a><a id="2576" class="Symbol">)</a> <a id="2578" href="FOL.Syntax.Enumeration.html#2248" class="Bound">f</a> <a id="2580" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="2583" href="Data.List.Base.html#1627" class="Function">map</a> <a id="2587" class="Symbol">(</a><a id="2588" href="FOL.Syntax.Enumeration.html#987" class="Function">apps</a> <a id="2593" class="Symbol">(</a><a id="2594" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2596" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2598" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a><a id="2599" class="Symbol">))</a> <a id="2602" class="Symbol">(</a><a id="2603" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="2608" class="Symbol">(</a><a id="2609" href="FOL.Syntax.Enumeration.html#2375" class="Bound">m</a> <a id="2611" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2613" href="FOL.Syntax.Enumeration.html#2384" class="Bound">n</a><a id="2614" class="Symbol">))</a>
          <a id="2627" href="FOL.Syntax.Enumeration.html#2560" class="Function">H2</a> <a id="2630" class="Symbol">=</a> <a id="2632" href="Foundation.Data.List.SetTheoretic.html#1698" class="Function">∈map-intro</a> <a id="2643" class="Symbol">(</a><a id="2644" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="2652" href="Foundation.Function.Enumeration.ListView.Base.html#2949" class="Field">cum</a> <a id="2656" href="Foundation.Data.Nat.AlternativeOrder.html#1963" class="Function">m≤m+n</a> <a id="2662" href="FOL.Syntax.Enumeration.html#2379" class="Bound">Hm</a><a id="2664" class="Symbol">)</a> <a id="2666" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h2 id="公式的枚举">公式的枚举</h2>
<p><strong><u>定义</u></strong> 某关系 <code>R : 𝓡</code> 的所有 <code>n</code>-阶应用, 记作 <code>apps n R</code>, 定义为 <code>R</code> 应用于项的<em>一些</em> <code>∣ R ∣ᴿ</code> 维向量所得到的公式所组成的列表. 其中项的<em>一些</em> <code>∣ R ∣ᴿ</code> 维向量是指项的<code>∣ R ∣ᴿ</code> 维向量枚举函数 <code>enum</code> (由于项可枚举, 所以项的固定维向量也可枚举) 应用于 <code>n</code> 所输出的那些向量.</p>
<pre class="Agda"><a id="2884" class="Keyword">private</a>
  <a id="apps"></a><a id="2894" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="2899" class="Symbol">:</a> <a id="2901" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2903" class="Symbol">→</a> <a id="2905" href="FOL.Language.Base.html#849" class="Field">𝓡</a> <a id="2907" class="Symbol">→</a> <a id="2909" href="Agda.Builtin.List.html#147" class="Datatype">𝕃</a> <a id="2911" href="FOL.Syntax.Base.html#3791" class="Datatype">Formula</a>
  <a id="2921" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="2926" href="FOL.Syntax.Enumeration.html#2926" class="Bound">n</a> <a id="2928" href="FOL.Syntax.Enumeration.html#2928" class="Bound">R</a> <a id="2930" class="Symbol">=</a> <a id="2932" href="Data.List.Base.html#1627" class="Function">map</a> <a id="2936" class="Symbol">(</a><a id="2937" href="FOL.Syntax.Enumeration.html#2928" class="Bound">R</a> <a id="2939" href="FOL.Syntax.Base.html#3889" class="InductiveConstructor Operator">$̇_</a><a id="2942" class="Symbol">)</a> <a id="2944" class="Symbol">(</a><a id="2945" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="2950" href="FOL.Syntax.Enumeration.html#2926" class="Bound">n</a><a id="2951" class="Symbol">)</a>
</pre>
<p><strong><u>实例/构造</u></strong> 公式的枚举由以下 <code>e</code>, <code>c</code>, <code>w</code> 三部分构成:</p>
<pre class="Agda"><a id="3014" class="Keyword">instance</a>
  <a id="enumFormula"></a><a id="3025" href="FOL.Syntax.Enumeration.html#3025" class="Function">enumFormula</a> <a id="3037" class="Symbol">:</a> <a id="3039" href="Foundation.Function.Enumeration.ListView.Base.html#2869" class="Record">Enum</a> <a id="3044" href="FOL.Syntax.Base.html#3791" class="Datatype">Formula</a>
  <a id="3054" href="FOL.Syntax.Enumeration.html#3025" class="Function">enumFormula</a> <a id="3066" class="Symbol">=</a> <a id="3068" href="Foundation.Function.Enumeration.ListView.Base.html#2914" class="InductiveConstructor">mkEnum</a> <a id="3075" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3077" href="FOL.Syntax.Enumeration.html#3552" class="Function">c</a> <a id="3079" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3081" class="Keyword">where</a>
</pre>
<h3 id="公式的列表的无穷序列-e">1. 公式的列表的无穷序列 <code>e</code></h3>
<p>递归定义 <code>e</code> 如下:</p>
<ul>
<li>输入 <code>zero</code> 时, 输出 <code>[ ⊥̇ ]</code>.</li>
<li>输入 <code>suc n</code> 时, 输出 <code>e n</code> 并上由 <code>e n</code> 中公式产生的所有全称量化式和所有蕴含式, 以及<em>一些</em> <code>R : 𝓡</code> 的所有 <code>n</code>-阶应用. 其中<em>一些</em> <code>R : 𝓡</code> 是指关系符号的枚举函数 <code>enum</code> (由语言的定义, 关系符号集 <code>𝓡</code> 可枚举) 应用于 <code>n</code> 所输出的那些 <code>R : 𝓡</code>.</li>
</ul>
<pre class="Agda">    <a id="3336" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3338" class="Symbol">:</a> <a id="3340" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a> <a id="3343" href="FOL.Syntax.Base.html#3791" class="Datatype">Formula</a>
    <a id="3355" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3357" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="3362" class="Symbol">=</a> <a id="3364" href="Data.List.Base.html#5240" class="Function Operator">[</a> <a id="3366" href="FOL.Syntax.Base.html#3811" class="InductiveConstructor">⊥̇</a> <a id="3369" href="Data.List.Base.html#5240" class="Function Operator">]</a>
    <a id="3375" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3377" class="Symbol">(</a><a id="3378" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3382" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a><a id="3383" class="Symbol">)</a> <a id="3385" class="Symbol">=</a> <a id="3387" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3389" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a>
      <a id="3397" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3400" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3404" href="FOL.Syntax.Base.html#3863" class="InductiveConstructor Operator">∀̇_</a> <a id="3408" class="Symbol">(</a><a id="3409" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3411" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a><a id="3412" class="Symbol">)</a>
      <a id="3420" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3423" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3427" class="Symbol">(</a><a id="3428" href="Data.Product.Base.html#3109" class="Function">uncurry</a> <a id="3436" href="FOL.Syntax.Base.html#3826" class="InductiveConstructor Operator">_→̇_</a><a id="3440" class="Symbol">)</a> <a id="3442" class="Symbol">(</a><a id="3443" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3445" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a> <a id="3447" href="Foundation.Data.List.SetTheoretic.html#2055" class="Function Operator">[×]</a> <a id="3451" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3453" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a><a id="3454" class="Symbol">)</a>
      <a id="3462" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="3465" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="3472" class="Symbol">(</a><a id="3473" href="Data.List.Base.html#1627" class="Function">map</a> <a id="3477" class="Symbol">(</a><a id="3478" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="3483" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a><a id="3484" class="Symbol">)</a> <a id="3486" class="Symbol">(</a><a id="3487" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="3492" href="FOL.Syntax.Enumeration.html#3382" class="Bound">n</a><a id="3493" class="Symbol">))</a>
</pre>
<h3 id="e-的累积-c-1">2. <code>e</code> 的累积 <code>c</code></h3>
<p>由 <code>e</code> 的定义立即可得其累积.</p>
<pre class="Agda">    <a id="3552" href="FOL.Syntax.Enumeration.html#3552" class="Function">c</a> <a id="3554" class="Symbol">:</a> <a id="3556" href="Foundation.Function.Enumeration.ListView.Base.html#1127" class="Function">Cumulation</a> <a id="3567" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a>
    <a id="3573" href="FOL.Syntax.Enumeration.html#3552" class="Function">c</a> <a id="3575" class="Symbol">_</a> <a id="3577" class="Symbol">=</a> <a id="3579" class="Symbol">_</a> <a id="3581" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="3583" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<h3 id="命题-w-e-见证了任意公式-φ">3. 命题 <code>w</code> : <code>e</code> 见证了任意公式 <code>φ</code></h3>
<p>由 <code>e</code> 的定义, 显然, <code>e</code> 见证了 <code>⊥̇</code>, 以及任意全称量化式和蕴含式. 而对于关系应用, 使用与项的枚举函数见证所有函数应用类似的方法可证. ∎</p>
<pre class="Agda">    <a id="3720" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3722" class="Symbol">:</a> <a id="3724" class="Symbol">∀</a> <a id="3726" href="FOL.Syntax.Enumeration.html#3726" class="Bound">φ</a> <a id="3728" class="Symbol">→</a> <a id="3730" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3732" href="Foundation.Function.Enumeration.ListView.Base.html#2658" class="Function Operator">witness</a> <a id="3740" href="FOL.Syntax.Enumeration.html#3726" class="Bound">φ</a>
    <a id="3746" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3748" href="FOL.Syntax.Base.html#3811" class="InductiveConstructor">⊥̇</a> <a id="3751" class="Symbol">=</a> <a id="3753" href="Foundation.Prop.Logic.html#859" class="Function">ex</a> <a id="3756" class="Number">0</a> <a id="3758" class="Symbol">(</a><a id="3759" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="3764" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="3768" class="Symbol">)</a>
    <a id="3774" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3776" class="Symbol">(</a><a id="3777" href="FOL.Syntax.Base.html#3863" class="InductiveConstructor Operator">∀̇</a> <a id="3780" href="FOL.Syntax.Enumeration.html#3780" class="Bound">φ</a><a id="3781" class="Symbol">)</a> <a id="3783" class="Symbol">=</a> <a id="3785" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="3791" href="FOL.Syntax.Enumeration.html#3811" class="Function">H</a> <a id="3793" class="Symbol">(</a><a id="3794" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3796" href="FOL.Syntax.Enumeration.html#3780" class="Bound">φ</a><a id="3797" class="Symbol">)</a> <a id="3799" class="Keyword">where</a>
      <a id="3811" href="FOL.Syntax.Enumeration.html#3811" class="Function">H</a> <a id="3813" class="Symbol">:</a> <a id="3815" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="3823" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3825" href="FOL.Syntax.Enumeration.html#3780" class="Bound">φ</a> <a id="3827" class="Symbol">→</a> <a id="3829" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="3837" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3839" class="Symbol">(</a><a id="3840" href="FOL.Syntax.Base.html#3863" class="InductiveConstructor Operator">∀̇</a> <a id="3843" href="FOL.Syntax.Enumeration.html#3780" class="Bound">φ</a><a id="3844" class="Symbol">)</a>
      <a id="3852" href="FOL.Syntax.Enumeration.html#3811" class="Function">H</a> <a id="3854" class="Symbol">(</a><a id="3855" href="FOL.Syntax.Enumeration.html#3855" class="Bound">n</a> <a id="3857" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="3859" href="FOL.Syntax.Enumeration.html#3859" class="Bound">Hn</a><a id="3861" class="Symbol">)</a> <a id="3863" class="Symbol">=</a> <a id="3865" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3869" href="FOL.Syntax.Enumeration.html#3855" class="Bound">n</a> <a id="3871" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="3873" class="Symbol">(</a><a id="3874" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="3885" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3887" href="Foundation.Data.List.SetTheoretic.html#576" class="Function">∈++-introˡ</a> <a id="3898" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3900" href="Foundation.Data.List.SetTheoretic.html#1698" class="Function">∈map-intro</a> <a id="3911" href="FOL.Syntax.Enumeration.html#3859" class="Bound">Hn</a> <a id="3914" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="3918" class="Symbol">)</a>
    <a id="3924" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3926" class="Symbol">(</a><a id="3927" href="FOL.Syntax.Enumeration.html#3927" class="Bound">φ</a> <a id="3929" href="FOL.Syntax.Base.html#3826" class="InductiveConstructor Operator">→̇</a> <a id="3932" href="FOL.Syntax.Enumeration.html#3932" class="Bound">ψ</a><a id="3933" class="Symbol">)</a> <a id="3935" class="Symbol">=</a> <a id="3937" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="3944" href="FOL.Syntax.Enumeration.html#3970" class="Function">H</a> <a id="3946" class="Symbol">(</a><a id="3947" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3949" href="FOL.Syntax.Enumeration.html#3927" class="Bound">φ</a><a id="3950" class="Symbol">)</a> <a id="3952" class="Symbol">(</a><a id="3953" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="3955" href="FOL.Syntax.Enumeration.html#3932" class="Bound">ψ</a><a id="3956" class="Symbol">)</a> <a id="3958" class="Keyword">where</a>
      <a id="3970" href="FOL.Syntax.Enumeration.html#3970" class="Function">H</a> <a id="3972" class="Symbol">:</a> <a id="3974" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="3982" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3984" href="FOL.Syntax.Enumeration.html#3927" class="Bound">φ</a> <a id="3986" class="Symbol">→</a> <a id="3988" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="3996" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="3998" href="FOL.Syntax.Enumeration.html#3932" class="Bound">ψ</a> <a id="4000" class="Symbol">→</a> <a id="4002" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="4010" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="4012" class="Symbol">(</a><a id="4013" href="FOL.Syntax.Enumeration.html#3927" class="Bound">φ</a> <a id="4015" href="FOL.Syntax.Base.html#3826" class="InductiveConstructor Operator">→̇</a> <a id="4018" href="FOL.Syntax.Enumeration.html#3932" class="Bound">ψ</a><a id="4019" class="Symbol">)</a>
      <a id="4027" href="FOL.Syntax.Enumeration.html#3970" class="Function">H</a> <a id="4029" class="Symbol">(</a><a id="4030" href="FOL.Syntax.Enumeration.html#4030" class="Bound">m</a> <a id="4032" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4034" href="FOL.Syntax.Enumeration.html#4034" class="Bound">Hm</a><a id="4036" class="Symbol">)</a> <a id="4038" class="Symbol">(</a><a id="4039" href="FOL.Syntax.Enumeration.html#4039" class="Bound">n</a> <a id="4041" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4043" href="FOL.Syntax.Enumeration.html#4043" class="Bound">Hn</a><a id="4045" class="Symbol">)</a> <a id="4047" class="Symbol">=</a> <a id="4049" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4053" href="FOL.Syntax.Enumeration.html#4030" class="Bound">m</a> <a id="4055" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4057" href="FOL.Syntax.Enumeration.html#4039" class="Bound">n</a> <a id="4059" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4061" class="Symbol">(</a><a id="4062" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="4073" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4075" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="4086" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4088" href="Foundation.Data.List.SetTheoretic.html#576" class="Function">∈++-introˡ</a> <a id="4099" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4101" href="Foundation.Data.List.SetTheoretic.html#3036" class="Function">∈map[×]-intro</a>
        <a id="4123" class="Symbol">(</a><a id="4124" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4132" href="FOL.Syntax.Enumeration.html#3552" class="Function">c</a> <a id="4134" href="Foundation.Data.Nat.AlternativeOrder.html#1963" class="Function">m≤m+n</a> <a id="4140" href="FOL.Syntax.Enumeration.html#4034" class="Bound">Hm</a><a id="4142" class="Symbol">)</a> <a id="4144" class="Symbol">(</a><a id="4145" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4153" href="FOL.Syntax.Enumeration.html#3552" class="Function">c</a> <a id="4155" href="Foundation.Data.Nat.AlternativeOrder.html#2009" class="Function">m≤n+m</a> <a id="4161" href="FOL.Syntax.Enumeration.html#4043" class="Bound">Hn</a><a id="4163" class="Symbol">))</a>
    <a id="4170" href="FOL.Syntax.Enumeration.html#3720" class="Function">w</a> <a id="4172" class="Symbol">(</a><a id="4173" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a> <a id="4175" href="FOL.Syntax.Base.html#3889" class="InductiveConstructor Operator">$̇</a> <a id="4178" href="FOL.Syntax.Enumeration.html#4178" class="Bound">t⃗</a><a id="4180" class="Symbol">)</a> <a id="4182" class="Symbol">=</a> <a id="4184" href="Cubical.HITs.PropositionalTruncation.Properties.html#6585" class="Function">𝟙.map2</a> <a id="4191" href="FOL.Syntax.Enumeration.html#4222" class="Function">H</a> <a id="4193" class="Symbol">(</a><a id="4194" href="Foundation.Function.Enumeration.ListView.Base.html#2975" class="Field">wit</a> <a id="4198" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a><a id="4199" class="Symbol">)</a> <a id="4201" class="Symbol">(</a><a id="4202" href="Foundation.Function.Enumeration.ListView.Base.html#2975" class="Field">wit</a> <a id="4206" href="FOL.Syntax.Enumeration.html#4178" class="Bound">t⃗</a><a id="4208" class="Symbol">)</a> <a id="4210" class="Keyword">where</a>
      <a id="4222" href="FOL.Syntax.Enumeration.html#4222" class="Function">H</a> <a id="4224" class="Symbol">:</a> <a id="4226" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="4234" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="4239" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a> <a id="4241" class="Symbol">→</a> <a id="4243" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="4251" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="4256" href="FOL.Syntax.Enumeration.html#4178" class="Bound">t⃗</a> <a id="4259" class="Symbol">→</a> <a id="4261" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Witness</a> <a id="4269" href="FOL.Syntax.Enumeration.html#3336" class="Function">e</a> <a id="4271" class="Symbol">(</a><a id="4272" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a> <a id="4274" href="FOL.Syntax.Base.html#3889" class="InductiveConstructor Operator">$̇</a> <a id="4277" href="FOL.Syntax.Enumeration.html#4178" class="Bound">t⃗</a><a id="4279" class="Symbol">)</a>
      <a id="4287" href="FOL.Syntax.Enumeration.html#4222" class="Function">H</a> <a id="4289" class="Symbol">(</a><a id="4290" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4292" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4294" href="FOL.Syntax.Enumeration.html#4294" class="Bound">Hm</a><a id="4296" class="Symbol">)</a> <a id="4298" class="Symbol">(</a><a id="4299" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a> <a id="4301" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4303" href="FOL.Syntax.Enumeration.html#4303" class="Bound">Hn</a><a id="4305" class="Symbol">)</a> <a id="4307" class="Symbol">=</a> <a id="4309" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4313" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4315" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4317" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a> <a id="4319" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="4321" class="Symbol">(</a><a id="4322" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="4333" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4335" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="4346" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4348" href="Foundation.Data.List.SetTheoretic.html#1328" class="Function">∈++-introʳ</a> <a id="4359" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="4361" href="Foundation.Data.List.SetTheoretic.html#633" class="Function">∈concat-intro</a> <a id="4375" href="FOL.Syntax.Enumeration.html#4398" class="Function">H1</a> <a id="4378" href="FOL.Syntax.Enumeration.html#4493" class="Function">H2</a><a id="4380" class="Symbol">)</a> <a id="4382" class="Keyword">where</a>
          <a id="4398" href="FOL.Syntax.Enumeration.html#4398" class="Function">H1</a> <a id="4401" class="Symbol">:</a> <a id="4403" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a> <a id="4405" href="FOL.Syntax.Base.html#3889" class="InductiveConstructor Operator">$̇</a> <a id="4408" href="FOL.Syntax.Enumeration.html#4178" class="Bound">t⃗</a> <a id="4411" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="4414" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="4419" class="Symbol">(</a><a id="4420" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4422" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4424" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a><a id="4425" class="Symbol">)</a> <a id="4427" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a>
          <a id="4439" href="FOL.Syntax.Enumeration.html#4398" class="Function">H1</a> <a id="4442" class="Symbol">=</a> <a id="4444" href="Foundation.Data.List.SetTheoretic.html#1698" class="Function">∈map-intro</a> <a id="4455" class="Symbol">(</a><a id="4456" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4464" href="Foundation.Function.Enumeration.ListView.Base.html#2949" class="Field">cum</a> <a id="4468" href="Foundation.Data.Nat.AlternativeOrder.html#2009" class="Function">m≤n+m</a> <a id="4474" href="FOL.Syntax.Enumeration.html#4303" class="Bound">Hn</a><a id="4476" class="Symbol">)</a> <a id="4478" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
          <a id="4493" href="FOL.Syntax.Enumeration.html#4493" class="Function">H2</a> <a id="4496" class="Symbol">:</a> <a id="4498" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="4503" class="Symbol">(</a><a id="4504" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4506" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4508" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a><a id="4509" class="Symbol">)</a> <a id="4511" href="FOL.Syntax.Enumeration.html#4173" class="Bound">R</a> <a id="4513" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="4516" href="Data.List.Base.html#1627" class="Function">map</a> <a id="4520" class="Symbol">(</a><a id="4521" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="4526" class="Symbol">(</a><a id="4527" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4529" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4531" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a><a id="4532" class="Symbol">))</a> <a id="4535" class="Symbol">(</a><a id="4536" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="4541" class="Symbol">(</a><a id="4542" href="FOL.Syntax.Enumeration.html#4290" class="Bound">m</a> <a id="4544" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4546" href="FOL.Syntax.Enumeration.html#4299" class="Bound">n</a><a id="4547" class="Symbol">))</a>
          <a id="4560" href="FOL.Syntax.Enumeration.html#4493" class="Function">H2</a> <a id="4563" class="Symbol">=</a> <a id="4565" href="Foundation.Data.List.SetTheoretic.html#1698" class="Function">∈map-intro</a> <a id="4576" class="Symbol">(</a><a id="4577" href="Foundation.Function.Enumeration.ListView.Base.html#1915" class="Function">cum-≤→⊆</a> <a id="4585" href="Foundation.Function.Enumeration.ListView.Base.html#2949" class="Field">cum</a> <a id="4589" href="Foundation.Data.Nat.AlternativeOrder.html#1963" class="Function">m≤m+n</a> <a id="4595" href="FOL.Syntax.Enumeration.html#4294" class="Bound">Hm</a><a id="4597" class="Symbol">)</a> <a id="4599" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>
<p><strong><u>引理</u></strong> 公式的累积列表是真累积.<br />
<strong><u>证明</u></strong> 观察定义不难看出列表的长度是严格递增的. ∎</p>
<pre class="Agda"><a id="enumFormula-proper"></a><a id="4684" href="FOL.Syntax.Enumeration.html#4684" class="Function">enumFormula-proper</a> <a id="4703" class="Symbol">:</a> <a id="4705" class="Symbol">∀</a> <a id="4707" href="FOL.Syntax.Enumeration.html#4707" class="Bound">n</a> <a id="4709" class="Symbol">→</a> <a id="4711" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4718" class="Symbol">(</a><a id="4719" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="4724" class="Symbol">⦃</a> <a id="4726" href="FOL.Syntax.Enumeration.html#3025" class="Function">enumFormula</a> <a id="4738" class="Symbol">⦄</a> <a id="4740" href="FOL.Syntax.Enumeration.html#4707" class="Bound">n</a><a id="4741" class="Symbol">)</a> <a id="4743" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">&gt;</a> <a id="4745" href="FOL.Syntax.Enumeration.html#4707" class="Bound">n</a>
<a id="4747" href="FOL.Syntax.Enumeration.html#4684" class="Function">enumFormula-proper</a> <a id="4766" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="4771" class="Symbol">=</a> <a id="4773" href="Foundation.Data.Nat.AlternativeOrder.html#325" class="InductiveConstructor">≤-refl</a>
<a id="4780" href="FOL.Syntax.Enumeration.html#4684" class="Function">enumFormula-proper</a> <a id="4799" class="Symbol">(</a><a id="4800" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4804" href="FOL.Syntax.Enumeration.html#4804" class="Bound">n</a><a id="4805" class="Symbol">)</a> <a id="4807" class="Symbol">=</a> <a id="4809" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="4815" class="Symbol">(</a><a id="4816" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">_&gt;</a> <a id="4819" class="Symbol">_)</a> <a id="4822" class="Symbol">(</a><a id="4823" href="Foundation.Data.List.html#1553" class="Function">length-++-++</a> <a id="4836" class="Symbol">_</a> <a id="4838" class="Symbol">_)</a> <a id="4841" class="Symbol">(</a><a id="4842" href="Foundation.Data.Nat.AlternativeOrder.html#1534" class="Function">&lt;-≤-trans</a> <a id="4852" href="FOL.Syntax.Enumeration.html#4869" class="Function">H</a> <a id="4854" href="Foundation.Data.Nat.AlternativeOrder.html#1963" class="Function">m≤m+n</a><a id="4859" class="Symbol">)</a> <a id="4861" class="Keyword">where</a>
  <a id="4869" href="FOL.Syntax.Enumeration.html#4869" class="Function">H</a> <a id="4871" class="Symbol">:</a> <a id="4873" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4880" class="Symbol">(</a><a id="4881" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="4886" href="FOL.Syntax.Enumeration.html#4804" class="Bound">n</a><a id="4887" class="Symbol">)</a> <a id="4889" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4891" href="Data.List.Base.html#5079" class="Function">length</a> <a id="4898" class="Symbol">(</a><a id="4899" href="Data.List.Base.html#1627" class="Function">map</a> <a id="4903" href="FOL.Syntax.Base.html#3863" class="InductiveConstructor Operator">∀̇_</a> <a id="4907" class="Symbol">_)</a> <a id="4910" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">&gt;</a> <a id="4912" class="Number">1</a> <a id="4914" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4916" href="FOL.Syntax.Enumeration.html#4804" class="Bound">n</a>
  <a id="4920" href="FOL.Syntax.Enumeration.html#4869" class="Function">H</a> <a id="4922" class="Symbol">=</a> <a id="4924" href="Foundation.Data.Nat.AlternativeOrder.html#3196" class="Function">+-mono-≤-&lt;</a> <a id="4935" class="Symbol">(</a><a id="4936" href="Foundation.Function.Enumeration.ListView.Base.html#2091" class="Function">cum-length</a> <a id="4947" href="Foundation.Function.Enumeration.ListView.Base.html#2949" class="Field">cum</a> <a id="4951" href="Data.Nat.Properties.html#61866" class="Function">z≤n</a><a id="4954" class="Symbol">)</a> <a id="4956" class="Symbol">(</a><a id="4957" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="4963" class="Symbol">(_</a> <a id="4966" href="Foundation.Data.Nat.AlternativeOrder.html#397" class="Function Operator">&lt;_</a><a id="4968" class="Symbol">)</a> <a id="4970" class="Symbol">(</a><a id="4971" href="Data.List.Properties.html#4003" class="Function">length-map</a> <a id="4982" class="Symbol">_</a> <a id="4984" class="Symbol">_)</a> <a id="4987" class="Symbol">(</a><a id="4988" href="FOL.Syntax.Enumeration.html#4684" class="Function">enumFormula-proper</a> <a id="5007" href="FOL.Syntax.Enumeration.html#4804" class="Bound">n</a><a id="5008" class="Symbol">))</a>
</pre>
<p><strong><u>定理</u></strong> 存在公式的枚举函数 <code>Ψ : ℕ → Formula</code>, 满足对任意 <code>φ : Formula</code> 都存在 <code>n : ℕ</code> 使得 <code>Ψ n ≡ φ</code>.<br />
<strong><u>证明</u></strong> 由于公式类型 <code>Formula</code> 是离散集且可枚举, 且其中的累积列表是真累积, 符合普通视角枚举函数 <code>Plain.enum</code> 的要求, 按其定义构造即得符合要求的 <code>Ψ : ℕ → Formula</code>. ∎</p>
<pre class="Agda"><a id="5235" class="Keyword">module</a> <a id="Plain"></a><a id="5242" href="FOL.Syntax.Enumeration.html#5242" class="Module">Plain</a> <a id="5248" class="Symbol">=</a> <a id="5250" href="Foundation.Function.Enumeration.PlainView.html#986" class="Module">PlainEnum</a> <a id="5260" href="FOL.Syntax.Enumeration.html#4684" class="Function">enumFormula-proper</a>

<a id="Ψ"></a><a id="5280" href="FOL.Syntax.Enumeration.html#5280" class="Function">Ψ</a> <a id="5282" class="Symbol">:</a> <a id="5284" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5286" class="Symbol">→</a> <a id="5288" href="FOL.Syntax.Base.html#3791" class="Datatype">Formula</a>
<a id="5296" href="FOL.Syntax.Enumeration.html#5280" class="Function">Ψ</a> <a id="5298" class="Symbol">=</a> <a id="5300" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">Plain.enum</a>

<a id="Ψ-wit"></a><a id="5312" href="FOL.Syntax.Enumeration.html#5312" class="Function">Ψ-wit</a> <a id="5318" class="Symbol">:</a> <a id="5320" class="Symbol">∀</a> <a id="5322" href="FOL.Syntax.Enumeration.html#5322" class="Bound">φ</a> <a id="5324" class="Symbol">→</a> <a id="5326" href="Foundation.Prop.Logic.html#736" class="Function">∃</a> <a id="5328" href="FOL.Syntax.Enumeration.html#5328" class="Bound">n</a> <a id="5330" href="Foundation.Prop.Logic.html#736" class="Function">，</a> <a id="5332" href="FOL.Syntax.Enumeration.html#5280" class="Function">Ψ</a> <a id="5334" href="FOL.Syntax.Enumeration.html#5328" class="Bound">n</a> <a id="5336" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5338" href="FOL.Syntax.Enumeration.html#5322" class="Bound">φ</a>
<a id="5340" href="FOL.Syntax.Enumeration.html#5312" class="Function">Ψ-wit</a> <a id="5346" class="Symbol">=</a> <a id="5348" href="Foundation.Function.Enumeration.PlainView.html#1988" class="Function">Plain.wit</a>
</pre>
<h2 id="枚举物的新变元">枚举物的新变元</h2>
<p>公式的枚举函数 <code>Ψ</code> 有一个非常显然的性质: 对任意 <code>m ≤ n</code>, <code># n</code> 是 <code>Ψ m</code> 的新变元 (<code>Ψ-fresh</code>). 因为变元的数量是无限的, 而任一时刻只有有限个被枚举出来. 然而完整地写出其形式化证明却相当冗长且乏味, 因为必须对枚举函数的结构一步步地归纳. 比较适合处理这种情况的是 Coq 和 Lean 等自带 tactic 的证明助理. 虽然 Agda 也可以使用反射机制实现 tactic, 但毕竟需要额外去实现, 除非后面经常出现这种情况, 否则暂不考虑.</p>
<pre class="Agda"><a id="termEnum-fresh"></a><a id="5630" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="5645" class="Symbol">:</a> <a id="5647" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="5649" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="5651" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="5653" class="Symbol">→</a> <a id="5655" href="FOL.Syntax.Base.html#5221" class="Generalizable">t</a> <a id="5657" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="5660" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="5665" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="5667" class="Symbol">→</a> <a id="5669" href="FOL.Syntax.FreshVariables.html#528" class="Datatype">freshₜ</a> <a id="5676" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="5678" href="FOL.Syntax.Base.html#5221" class="Generalizable">t</a>
<a id="5680" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="5695" class="Symbol">{</a><a id="5696" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5700" href="FOL.Syntax.Enumeration.html#5700" class="Bound">m</a><a id="5701" class="Symbol">}</a> <a id="5703" href="FOL.Syntax.Enumeration.html#5703" class="Bound">le</a> <a id="5706" href="FOL.Syntax.Enumeration.html#5706" class="Bound">t∈</a> <a id="5709" class="Keyword">with</a> <a id="5714" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="5723" class="Symbol">_</a> <a id="5725" href="FOL.Syntax.Enumeration.html#5706" class="Bound">t∈</a>
<a id="5728" class="Symbol">...</a> <a id="5732" class="Symbol">|</a> <a id="5734" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="5739" href="FOL.Syntax.Enumeration.html#5739" class="Bound">t∈</a> <a id="5742" class="Symbol">=</a> <a id="5744" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="5759" class="Symbol">(</a><a id="5760" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="5770" class="Number">1</a> <a id="5772" class="Bound">le</a><a id="5774" class="Symbol">)</a> <a id="5776" href="FOL.Syntax.Enumeration.html#5739" class="Bound">t∈</a>
<a id="5779" class="Symbol">...</a> <a id="5783" class="Symbol">|</a> <a id="5785" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5790" class="Symbol">(</a><a id="5791" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="5796" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="5800" class="Symbol">)</a> <a id="5802" class="Symbol">=</a> <a id="5804" href="FOL.Syntax.FreshVariables.html#562" class="InductiveConstructor">fresh#</a> <a id="5811" class="Symbol">λ</a> <a id="5813" class="Symbol">{</a> <a id="5815" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="5820" class="Symbol">→</a> <a id="5822" href="Foundation.Data.Nat.AlternativeOrder.html#1116" class="Function">1+n≰n</a> <a id="5828" class="Bound">le</a> <a id="5831" class="Symbol">}</a>
<a id="5833" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="5848" class="Symbol">{</a><a id="5849" class="Argument">t</a> <a id="5851" class="Symbol">=</a> <a id="5853" href="FOL.Syntax.Base.html#748" class="InductiveConstructor">#</a> <a id="5855" href="FOL.Syntax.Enumeration.html#5855" class="Bound">o</a><a id="5856" class="Symbol">}</a> <a id="5858" class="Symbol">_</a> <a id="5860" class="Symbol">_</a>
    <a id="5866" class="Symbol">|</a> <a id="5868" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="5873" class="Symbol">(</a><a id="5874" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="5880" href="FOL.Syntax.Enumeration.html#5880" class="Bound">t∈</a><a id="5882" class="Symbol">)</a> <a id="5884" class="Keyword">with</a> <a id="5889" href="Foundation.Data.List.SetTheoretic.html#662" class="Function">∈concat-elim</a> <a id="5902" class="Symbol">_</a> <a id="5904" href="FOL.Syntax.Enumeration.html#5880" class="Bound">t∈</a>
<a id="5907" class="Symbol">...</a>   <a id="5913" class="Symbol">|</a> <a id="5915" class="Symbol">_</a> <a id="5917" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="5919" href="FOL.Syntax.Enumeration.html#5919" class="Bound">t∈ts</a> <a id="5924" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="5926" href="FOL.Syntax.Enumeration.html#5926" class="Bound">ts∈</a> <a id="5930" class="Keyword">with</a> <a id="5935" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="5945" href="FOL.Syntax.Enumeration.html#5926" class="Bound">ts∈</a>
<a id="5949" class="Symbol">...</a>     <a id="5957" class="Symbol">|</a> <a id="5959" class="Symbol">_</a> <a id="5961" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="5963" class="Symbol">_</a> <a id="5965" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="5967" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="5972" class="Keyword">with</a> <a id="5977" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="5987" class="Bound">t∈ts</a>
<a id="5992" class="Symbol">...</a>       <a id="6002" class="Symbol">|</a> <a id="6004" class="Symbol">_</a> <a id="6006" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6008" class="Symbol">_</a> <a id="6010" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6012" class="Symbol">()</a>
<a id="6015" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="6030" class="Symbol">{</a><a id="6031" class="Argument">t</a> <a id="6033" class="Symbol">=</a> <a id="6035" href="FOL.Syntax.Enumeration.html#6035" class="Bound">f</a> <a id="6037" href="FOL.Syntax.Base.html#763" class="InductiveConstructor Operator">$̇</a> <a id="6040" href="FOL.Syntax.Enumeration.html#6040" class="Bound">t⃗</a><a id="6042" class="Symbol">}</a> <a id="6044" href="FOL.Syntax.Enumeration.html#6044" class="Bound">le</a> <a id="6047" class="Symbol">_</a>
    <a id="6053" class="Symbol">|</a> <a id="6055" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6060" class="Symbol">(</a><a id="6061" href="Data.List.Relation.Unary.Any.html#1279" class="InductiveConstructor">there</a> <a id="6067" href="FOL.Syntax.Enumeration.html#6067" class="Bound">t∈</a><a id="6069" class="Symbol">)</a> <a id="6071" class="Keyword">with</a> <a id="6076" href="Foundation.Data.List.SetTheoretic.html#662" class="Function">∈concat-elim</a> <a id="6089" class="Symbol">_</a> <a id="6091" href="FOL.Syntax.Enumeration.html#6067" class="Bound">t∈</a>
<a id="6094" class="Symbol">...</a>   <a id="6100" class="Symbol">|</a> <a id="6102" class="Symbol">_</a> <a id="6104" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6106" href="FOL.Syntax.Enumeration.html#6106" class="Bound">t∈ts</a> <a id="6111" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6113" href="FOL.Syntax.Enumeration.html#6113" class="Bound">ts∈</a> <a id="6117" class="Keyword">with</a> <a id="6122" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="6132" href="FOL.Syntax.Enumeration.html#6113" class="Bound">ts∈</a>
<a id="6136" class="Symbol">...</a>     <a id="6144" class="Symbol">|</a> <a id="6146" class="Symbol">_</a> <a id="6148" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6150" class="Symbol">_</a> <a id="6152" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6154" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6159" class="Keyword">with</a> <a id="6164" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="6174" class="Bound">t∈ts</a>
<a id="6179" class="Symbol">...</a>       <a id="6189" class="Symbol">|</a> <a id="6191" class="Symbol">_</a> <a id="6193" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6195" href="FOL.Syntax.Enumeration.html#6195" class="Bound">t⃗∈</a> <a id="6199" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6201" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6206" class="Keyword">with</a> <a id="6211" href="Foundation.Function.Enumeration.ListView.Base.html#4802" class="Function">∈combine-elim</a> <a id="6225" href="FOL.Syntax.Enumeration.html#6195" class="Bound">t⃗∈</a>
<a id="6229" class="Symbol">...</a>         <a id="6241" class="Symbol">|</a> <a id="6243" href="FOL.Syntax.Enumeration.html#6243" class="Bound">H</a> <a id="6245" class="Symbol">=</a> <a id="6247" href="FOL.Syntax.FreshVariables.html#604" class="InductiveConstructor">fresh$̇</a> <a id="6255" class="Symbol">λ</a> <a id="6257" href="FOL.Syntax.Enumeration.html#6257" class="Bound">t</a> <a id="6259" href="FOL.Syntax.Enumeration.html#6259" class="Bound">t∈t⃗</a> <a id="6264" class="Symbol">→</a> <a id="6266" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="6281" class="Symbol">(</a><a id="6282" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="6292" class="Number">1</a> <a id="6294" class="Bound">le</a><a id="6296" class="Symbol">)</a> <a id="6298" class="Symbol">(</a><a id="6299" href="FOL.Syntax.Enumeration.html#6243" class="Bound">H</a> <a id="6301" href="FOL.Syntax.Enumeration.html#6259" class="Bound">t∈t⃗</a><a id="6305" class="Symbol">)</a>

<a id="termEnum-fresh-vec"></a><a id="6308" href="FOL.Syntax.Enumeration.html#6308" class="Function">termEnum-fresh-vec</a> <a id="6327" class="Symbol">:</a> <a id="6329" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="6331" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="6333" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="6335" class="Symbol">→</a> <a id="6337" class="Symbol">{</a><a id="6338" href="FOL.Syntax.Enumeration.html#6338" class="Bound">t⃗</a> <a id="6341" class="Symbol">:</a> <a id="6343" href="Data.Vec.Base.html#1107" class="Datatype">𝕍</a> <a id="6345" href="FOL.Syntax.Base.html#731" class="Datatype">Term</a> <a id="6350" href="FOL.Syntax.Enumeration.html#692" class="Generalizable">o</a><a id="6351" class="Symbol">}</a> <a id="6353" class="Symbol">→</a> <a id="6355" href="FOL.Syntax.Enumeration.html#6338" class="Bound">t⃗</a> <a id="6358" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="6361" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="6366" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="6368" class="Symbol">→</a> <a id="6370" class="Symbol">∀</a> <a id="6372" class="Symbol">{</a><a id="6373" href="FOL.Syntax.Enumeration.html#6373" class="Bound">t</a><a id="6374" class="Symbol">}</a> <a id="6376" class="Symbol">→</a> <a id="6378" href="FOL.Syntax.Enumeration.html#6373" class="Bound">t</a> <a id="6380" href="Foundation.Essential.html#12199" class="Function Operator">∈⃗</a> <a id="6383" href="FOL.Syntax.Enumeration.html#6338" class="Bound">t⃗</a> <a id="6386" class="Symbol">→</a> <a id="6388" href="FOL.Syntax.FreshVariables.html#528" class="Datatype">freshₜ</a> <a id="6395" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="6397" href="FOL.Syntax.Enumeration.html#6373" class="Bound">t</a>
<a id="6399" href="FOL.Syntax.Enumeration.html#6308" class="Function">termEnum-fresh-vec</a> <a id="6418" class="Symbol">{</a><a id="6419" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6423" href="FOL.Syntax.Enumeration.html#6423" class="Bound">m</a><a id="6424" class="Symbol">}</a> <a id="6426" href="FOL.Syntax.Enumeration.html#6426" class="Bound">le</a> <a id="6429" href="FOL.Syntax.Enumeration.html#6429" class="Bound">t⃗∈ᴸ</a> <a id="6434" href="FOL.Syntax.Enumeration.html#6434" class="Bound">t∈⃗</a> <a id="6438" class="Keyword">with</a> <a id="6443" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="6452" class="Symbol">_</a> <a id="6454" href="FOL.Syntax.Enumeration.html#6429" class="Bound">t⃗∈ᴸ</a>
<a id="6459" class="Symbol">...</a> <a id="6463" class="Symbol">|</a> <a id="6465" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6470" href="FOL.Syntax.Enumeration.html#6470" class="Bound">t⃗∈ᴸ</a> <a id="6475" class="Symbol">=</a> <a id="6477" href="FOL.Syntax.Enumeration.html#6308" class="Function">termEnum-fresh-vec</a> <a id="6496" class="Symbol">(</a><a id="6497" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="6507" class="Number">1</a> <a id="6509" class="Bound">le</a><a id="6511" class="Symbol">)</a> <a id="6513" href="FOL.Syntax.Enumeration.html#6470" class="Bound">t⃗∈ᴸ</a> <a id="6518" class="Bound">t∈⃗</a>
<a id="6522" class="Symbol">...</a> <a id="6526" class="Symbol">|</a> <a id="6528" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6533" href="FOL.Syntax.Enumeration.html#6533" class="Bound">t⃗∈ᴸ</a> <a id="6538" class="Symbol">=</a> <a id="6540" href="FOL.Syntax.Enumeration.html#5630" class="Function">termEnum-fresh</a> <a id="6555" class="Symbol">(</a><a id="6556" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="6566" class="Number">1</a> <a id="6568" class="Bound">le</a><a id="6570" class="Symbol">)</a> <a id="6572" class="Symbol">(</a><a id="6573" href="Foundation.Function.Enumeration.ListView.Base.html#4802" class="Function">∈combine-elim</a> <a id="6587" href="FOL.Syntax.Enumeration.html#6533" class="Bound">t⃗∈ᴸ</a> <a id="6592" class="Bound">t∈⃗</a><a id="6595" class="Symbol">)</a>

<a id="formulaEnum-fresh"></a><a id="6598" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="6616" class="Symbol">:</a> <a id="6618" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="6620" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="6622" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="6624" class="Symbol">→</a> <a id="6626" href="FOL.Syntax.Base.html#5232" class="Generalizable">φ</a> <a id="6628" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="6631" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="6636" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="6638" class="Symbol">→</a> <a id="6640" href="FOL.Syntax.FreshVariables.html#1103" class="Datatype">freshᵩ</a> <a id="6647" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="6649" href="FOL.Syntax.Base.html#5232" class="Generalizable">φ</a>
<a id="6651" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="6669" class="Symbol">{(</a><a id="6671" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="6675" class="Symbol">)}</a> <a id="6678" class="Symbol">_</a> <a id="6680" class="Symbol">(</a><a id="6681" href="Data.List.Relation.Unary.Any.html#1226" class="InductiveConstructor">here</a> <a id="6686" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="6690" class="Symbol">)</a> <a id="6692" class="Symbol">=</a> <a id="6694" href="FOL.Syntax.FreshVariables.html#1140" class="InductiveConstructor">fresh⊥̇</a>
<a id="6702" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="6720" class="Symbol">{</a><a id="6721" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6725" href="FOL.Syntax.Enumeration.html#6725" class="Bound">m</a><a id="6726" class="Symbol">}</a> <a id="6728" class="Symbol">{</a><a id="6729" class="Argument">φ</a> <a id="6731" class="Symbol">=</a> <a id="6733" href="FOL.Syntax.Base.html#3811" class="InductiveConstructor">⊥̇</a><a id="6735" class="Symbol">}</a> <a id="6737" href="FOL.Syntax.Enumeration.html#6737" class="Bound">le</a> <a id="6740" href="FOL.Syntax.Enumeration.html#6740" class="Bound">φ∈</a> <a id="6743" class="Symbol">=</a> <a id="6745" href="FOL.Syntax.FreshVariables.html#1140" class="InductiveConstructor">fresh⊥̇</a>

<a id="6754" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="6772" class="Symbol">{</a><a id="6773" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6777" href="FOL.Syntax.Enumeration.html#6777" class="Bound">m</a><a id="6778" class="Symbol">}</a> <a id="6780" class="Symbol">{</a><a id="6781" class="Argument">φ</a> <a id="6783" class="Symbol">=</a> <a id="6785" href="FOL.Syntax.Base.html#3863" class="InductiveConstructor Operator">∀̇</a> <a id="6788" href="FOL.Syntax.Enumeration.html#6788" class="Bound">φ</a><a id="6789" class="Symbol">}</a> <a id="6791" href="FOL.Syntax.Enumeration.html#6791" class="Bound">le</a> <a id="6794" href="FOL.Syntax.Enumeration.html#6794" class="Bound">φ∈</a> <a id="6797" class="Keyword">with</a> <a id="6802" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="6811" class="Symbol">_</a> <a id="6813" href="FOL.Syntax.Enumeration.html#6794" class="Bound">φ∈</a>
<a id="6816" class="Symbol">...</a> <a id="6820" class="Symbol">|</a> <a id="6822" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6827" href="FOL.Syntax.Enumeration.html#6827" class="Bound">φ∈e</a> <a id="6831" class="Symbol">=</a> <a id="6833" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="6851" class="Symbol">(</a><a id="6852" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="6862" class="Number">1</a> <a id="6864" class="Bound">le</a><a id="6866" class="Symbol">)</a> <a id="6868" href="FOL.Syntax.Enumeration.html#6827" class="Bound">φ∈e</a>
<a id="6872" class="Symbol">...</a> <a id="6876" class="Symbol">|</a> <a id="6878" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="6883" href="FOL.Syntax.Enumeration.html#6883" class="Bound">φ∈++</a> <a id="6888" class="Keyword">with</a> <a id="6893" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="6902" class="Symbol">_</a> <a id="6904" href="FOL.Syntax.Enumeration.html#6883" class="Bound">φ∈++</a>
<a id="6909" class="Symbol">...</a>   <a id="6915" class="Symbol">|</a> <a id="6917" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="6922" href="FOL.Syntax.Enumeration.html#6922" class="Bound">φ∈∀̇</a> <a id="6927" class="Keyword">with</a> <a id="6932" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="6942" href="FOL.Syntax.Enumeration.html#6922" class="Bound">φ∈∀̇</a>
<a id="6947" class="Symbol">...</a>     <a id="6955" class="Symbol">|</a> <a id="6957" class="Symbol">_</a> <a id="6959" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6961" href="FOL.Syntax.Enumeration.html#6961" class="Bound">φ∈e</a> <a id="6965" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="6967" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6972" class="Symbol">=</a> <a id="6974" href="FOL.Syntax.FreshVariables.html#1230" class="InductiveConstructor">fresh∀̇</a> <a id="6982" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6984" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7002" class="Symbol">(</a><a id="7003" href="Foundation.Data.Nat.AlternativeOrder.html#936" class="Function">≤-trans</a> <a id="7011" class="Symbol">(</a><a id="7012" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="7022" class="Number">1</a> <a id="7024" class="Bound">le</a><a id="7026" class="Symbol">)</a> <a id="7028" href="Foundation.Data.Nat.AlternativeOrder.html#2009" class="Function">m≤n+m</a><a id="7033" class="Symbol">)</a> <a id="7035" href="FOL.Syntax.Enumeration.html#6961" class="Bound">φ∈e</a>
<a id="7039" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7057" class="Symbol">_</a> <a id="7059" class="Symbol">_</a> <a id="7061" class="Symbol">|</a> <a id="7063" class="Symbol">_</a>
      <a id="7071" class="Symbol">|</a> <a id="7073" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7078" href="FOL.Syntax.Enumeration.html#7078" class="Bound">φ∈++</a> <a id="7083" class="Keyword">with</a> <a id="7088" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="7097" class="Symbol">_</a> <a id="7099" href="FOL.Syntax.Enumeration.html#7078" class="Bound">φ∈++</a>
<a id="7104" class="Symbol">...</a>     <a id="7112" class="Symbol">|</a> <a id="7114" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7119" href="FOL.Syntax.Enumeration.html#7119" class="Bound">φ∈→̇</a> <a id="7124" class="Keyword">with</a> <a id="7129" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="7139" href="FOL.Syntax.Enumeration.html#7119" class="Bound">φ∈→̇</a>
<a id="7144" class="Symbol">...</a>       <a id="7154" class="Symbol">|</a> <a id="7156" class="Symbol">_</a> <a id="7158" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7160" class="Symbol">_</a> <a id="7162" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7164" class="Symbol">()</a>
<a id="7167" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7185" class="Symbol">_</a> <a id="7187" class="Symbol">_</a> <a id="7189" class="Symbol">|</a> <a id="7191" class="Symbol">_</a> <a id="7193" class="Symbol">|</a> <a id="7195" class="Symbol">_</a>
        <a id="7205" class="Symbol">|</a> <a id="7207" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7212" href="FOL.Syntax.Enumeration.html#7212" class="Bound">φ∈$̇</a> <a id="7217" class="Keyword">with</a> <a id="7222" href="Foundation.Data.List.SetTheoretic.html#662" class="Function">∈concat-elim</a> <a id="7235" class="Symbol">_</a> <a id="7237" href="FOL.Syntax.Enumeration.html#7212" class="Bound">φ∈$̇</a>
<a id="7242" class="Symbol">...</a>       <a id="7252" class="Symbol">|</a> <a id="7254" class="Symbol">_</a> <a id="7256" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7258" href="FOL.Syntax.Enumeration.html#7258" class="Bound">φ∈φs</a> <a id="7263" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7265" href="FOL.Syntax.Enumeration.html#7265" class="Bound">φs∈</a> <a id="7269" class="Keyword">with</a> <a id="7274" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="7284" href="FOL.Syntax.Enumeration.html#7265" class="Bound">φs∈</a>
<a id="7288" class="Symbol">...</a>         <a id="7300" class="Symbol">|</a> <a id="7302" class="Symbol">_</a> <a id="7304" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7306" class="Symbol">_</a> <a id="7308" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7310" href="FOL.Syntax.Enumeration.html#7310" class="Bound">eq</a> <a id="7313" class="Keyword">with</a> <a id="7318" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="7328" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="7330" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="7336" class="Symbol">(_</a> <a id="7339" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ_</a><a id="7342" class="Symbol">)</a> <a id="7344" class="Symbol">(</a><a id="7345" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="7349" href="FOL.Syntax.Enumeration.html#7310" class="Bound">eq</a><a id="7351" class="Symbol">)</a> <a id="7353" class="Bound">φ∈φs</a>
<a id="7358" class="Symbol">...</a>           <a id="7372" class="Symbol">|</a> <a id="7374" class="Symbol">_</a> <a id="7376" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7378" class="Symbol">_</a> <a id="7380" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7382" class="Symbol">()</a>

<a id="7386" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7404" class="Symbol">{</a><a id="7405" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7409" href="FOL.Syntax.Enumeration.html#7409" class="Bound">m</a><a id="7410" class="Symbol">}</a> <a id="7412" class="Symbol">{</a><a id="7413" class="Argument">φ</a> <a id="7415" class="Symbol">=</a> <a id="7417" href="FOL.Syntax.Enumeration.html#7417" class="Bound">φ</a> <a id="7419" href="FOL.Syntax.Base.html#3826" class="InductiveConstructor Operator">→̇</a> <a id="7422" href="FOL.Syntax.Enumeration.html#7422" class="Bound">ψ</a><a id="7423" class="Symbol">}</a> <a id="7425" href="FOL.Syntax.Enumeration.html#7425" class="Bound">le</a> <a id="7428" href="FOL.Syntax.Enumeration.html#7428" class="Bound">φ∈</a> <a id="7431" class="Keyword">with</a> <a id="7436" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="7445" class="Symbol">_</a> <a id="7447" href="FOL.Syntax.Enumeration.html#7428" class="Bound">φ∈</a>
<a id="7450" class="Symbol">...</a> <a id="7454" class="Symbol">|</a> <a id="7456" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7461" href="FOL.Syntax.Enumeration.html#7461" class="Bound">φ∈e</a> <a id="7465" class="Symbol">=</a> <a id="7467" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7485" class="Symbol">(</a><a id="7486" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="7496" class="Number">1</a> <a id="7498" class="Bound">le</a><a id="7500" class="Symbol">)</a> <a id="7502" href="FOL.Syntax.Enumeration.html#7461" class="Bound">φ∈e</a>
<a id="7506" class="Symbol">...</a> <a id="7510" class="Symbol">|</a> <a id="7512" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7517" href="FOL.Syntax.Enumeration.html#7517" class="Bound">φ∈++</a> <a id="7522" class="Keyword">with</a> <a id="7527" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="7536" class="Symbol">_</a> <a id="7538" href="FOL.Syntax.Enumeration.html#7517" class="Bound">φ∈++</a>
<a id="7543" class="Symbol">...</a>   <a id="7549" class="Symbol">|</a> <a id="7551" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7556" href="FOL.Syntax.Enumeration.html#7556" class="Bound">φ∈∀̇</a> <a id="7561" class="Keyword">with</a> <a id="7566" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="7576" href="FOL.Syntax.Enumeration.html#7556" class="Bound">φ∈∀̇</a>
<a id="7581" class="Symbol">...</a>     <a id="7589" class="Symbol">|</a> <a id="7591" class="Symbol">_</a> <a id="7593" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7595" class="Symbol">_</a> <a id="7597" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7599" class="Symbol">()</a>
<a id="7602" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7620" href="FOL.Syntax.Enumeration.html#7620" class="Bound">le</a> <a id="7623" class="Symbol">_</a> <a id="7625" class="Symbol">|</a> <a id="7627" class="Symbol">_</a>
      <a id="7635" class="Symbol">|</a> <a id="7637" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7642" href="FOL.Syntax.Enumeration.html#7642" class="Bound">φ∈++</a> <a id="7647" class="Keyword">with</a> <a id="7652" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="7661" class="Symbol">_</a> <a id="7663" href="FOL.Syntax.Enumeration.html#7642" class="Bound">φ∈++</a>
<a id="7668" class="Symbol">...</a>     <a id="7676" class="Symbol">|</a> <a id="7678" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="7683" href="FOL.Syntax.Enumeration.html#7683" class="Bound">φ∈→̇</a> <a id="7688" class="Keyword">with</a> <a id="7693" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="7703" href="FOL.Syntax.Enumeration.html#7683" class="Bound">φ∈→̇</a>
<a id="7708" class="Symbol">...</a>       <a id="7718" class="Symbol">|</a> <a id="7720" class="Symbol">_</a> <a id="7722" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7724" href="FOL.Syntax.Enumeration.html#7724" class="Bound">φ∈×</a> <a id="7728" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7730" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="7735" class="Keyword">with</a> <a id="7740" href="Foundation.Data.List.SetTheoretic.html#2344" class="Function">∈[×]-elim</a> <a id="7750" href="FOL.Syntax.Enumeration.html#7724" class="Bound">φ∈×</a>
<a id="7754" class="Symbol">...</a>         <a id="7766" class="Symbol">|</a> <a id="7768" href="FOL.Syntax.Enumeration.html#7768" class="Bound">φ∈e₁</a> <a id="7773" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7775" href="FOL.Syntax.Enumeration.html#7775" class="Bound">φ∈e₂</a> <a id="7780" class="Symbol">=</a> <a id="7782" class="Keyword">let</a> <a id="7786" href="FOL.Syntax.Enumeration.html#7786" class="Bound">H</a> <a id="7788" class="Symbol">=</a> <a id="7790" href="Foundation.Data.Nat.AlternativeOrder.html#936" class="Function">≤-trans</a> <a id="7798" class="Symbol">(</a><a id="7799" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="7809" class="Number">1</a> <a id="7811" class="Bound">le</a><a id="7813" class="Symbol">)</a> <a id="7815" href="Foundation.Data.Nat.AlternativeOrder.html#2009" class="Function">m≤n+m</a> <a id="7821" class="Keyword">in</a>
              <a id="7838" href="FOL.Syntax.FreshVariables.html#1164" class="InductiveConstructor">fresh→̇</a> <a id="7846" class="Symbol">(</a><a id="7847" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7865" href="FOL.Syntax.Enumeration.html#7786" class="Bound">H</a> <a id="7867" href="FOL.Syntax.Enumeration.html#7768" class="Bound">φ∈e₁</a><a id="7871" class="Symbol">)</a> <a id="7873" class="Symbol">(</a><a id="7874" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7892" href="FOL.Syntax.Enumeration.html#7786" class="Bound">H</a> <a id="7894" href="FOL.Syntax.Enumeration.html#7775" class="Bound">φ∈e₂</a><a id="7898" class="Symbol">)</a>
<a id="7900" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="7918" class="Symbol">_</a> <a id="7920" class="Symbol">_</a> <a id="7922" class="Symbol">|</a> <a id="7924" class="Symbol">_</a> <a id="7926" class="Symbol">|</a> <a id="7928" class="Symbol">_</a>
        <a id="7938" class="Symbol">|</a> <a id="7940" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="7945" href="FOL.Syntax.Enumeration.html#7945" class="Bound">φ∈$̇</a> <a id="7950" class="Keyword">with</a> <a id="7955" href="Foundation.Data.List.SetTheoretic.html#662" class="Function">∈concat-elim</a> <a id="7968" class="Symbol">_</a> <a id="7970" href="FOL.Syntax.Enumeration.html#7945" class="Bound">φ∈$̇</a>
<a id="7975" class="Symbol">...</a>       <a id="7985" class="Symbol">|</a> <a id="7987" class="Symbol">_</a> <a id="7989" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7991" href="FOL.Syntax.Enumeration.html#7991" class="Bound">φ∈φs</a> <a id="7996" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="7998" href="FOL.Syntax.Enumeration.html#7998" class="Bound">φs∈</a> <a id="8002" class="Keyword">with</a> <a id="8007" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8017" href="FOL.Syntax.Enumeration.html#7998" class="Bound">φs∈</a>
<a id="8021" class="Symbol">...</a>         <a id="8033" class="Symbol">|</a> <a id="8035" class="Symbol">_</a> <a id="8037" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8039" class="Symbol">_</a> <a id="8041" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8043" href="FOL.Syntax.Enumeration.html#8043" class="Bound">eq</a> <a id="8046" class="Keyword">with</a> <a id="8051" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8061" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="8063" href="Foundation.Prelude.Equality.html#1375" class="Function">subst</a> <a id="8069" class="Symbol">(_</a> <a id="8072" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ_</a><a id="8075" class="Symbol">)</a> <a id="8077" class="Symbol">(</a><a id="8078" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="8082" href="FOL.Syntax.Enumeration.html#8043" class="Bound">eq</a><a id="8084" class="Symbol">)</a> <a id="8086" class="Bound">φ∈φs</a>
<a id="8091" class="Symbol">...</a>           <a id="8105" class="Symbol">|</a> <a id="8107" class="Symbol">_</a> <a id="8109" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8111" class="Symbol">_</a> <a id="8113" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8115" class="Symbol">()</a>

<a id="8119" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="8137" class="Symbol">{</a><a id="8138" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8142" href="FOL.Syntax.Enumeration.html#8142" class="Bound">m</a><a id="8143" class="Symbol">}</a> <a id="8145" class="Symbol">{</a><a id="8146" class="Argument">φ</a> <a id="8148" class="Symbol">=</a> <a id="8150" href="FOL.Syntax.Enumeration.html#8150" class="Bound">R</a> <a id="8152" href="FOL.Syntax.Base.html#3889" class="InductiveConstructor Operator">$̇</a> <a id="8155" href="FOL.Syntax.Enumeration.html#8155" class="Bound">t⃗</a><a id="8157" class="Symbol">}</a> <a id="8159" href="FOL.Syntax.Enumeration.html#8159" class="Bound">le</a> <a id="8162" href="FOL.Syntax.Enumeration.html#8162" class="Bound">φ∈</a> <a id="8165" class="Keyword">with</a> <a id="8170" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="8179" class="Symbol">_</a> <a id="8181" href="FOL.Syntax.Enumeration.html#8162" class="Bound">φ∈</a>
<a id="8184" class="Symbol">...</a> <a id="8188" class="Symbol">|</a> <a id="8190" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8195" href="FOL.Syntax.Enumeration.html#8195" class="Bound">φ∈e</a> <a id="8199" class="Symbol">=</a> <a id="8201" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="8219" class="Symbol">(</a><a id="8220" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="8230" class="Number">1</a> <a id="8232" class="Bound">le</a><a id="8234" class="Symbol">)</a> <a id="8236" href="FOL.Syntax.Enumeration.html#8195" class="Bound">φ∈e</a>
<a id="8240" class="Symbol">...</a> <a id="8244" class="Symbol">|</a> <a id="8246" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8251" href="FOL.Syntax.Enumeration.html#8251" class="Bound">φ∈++</a> <a id="8256" class="Keyword">with</a> <a id="8261" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="8270" class="Symbol">_</a> <a id="8272" href="FOL.Syntax.Enumeration.html#8251" class="Bound">φ∈++</a>
<a id="8277" class="Symbol">...</a>   <a id="8283" class="Symbol">|</a> <a id="8285" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8290" href="FOL.Syntax.Enumeration.html#8290" class="Bound">φ∈∀̇</a> <a id="8295" class="Keyword">with</a> <a id="8300" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8310" href="FOL.Syntax.Enumeration.html#8290" class="Bound">φ∈∀̇</a>
<a id="8315" class="Symbol">...</a>     <a id="8323" class="Symbol">|</a> <a id="8325" class="Symbol">_</a> <a id="8327" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8329" class="Symbol">_</a> <a id="8331" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8333" class="Symbol">()</a>
<a id="8336" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="8354" href="FOL.Syntax.Enumeration.html#8354" class="Bound">le</a> <a id="8357" class="Symbol">_</a> <a id="8359" class="Symbol">|</a> <a id="8361" class="Symbol">_</a>
      <a id="8369" class="Symbol">|</a> <a id="8371" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8376" href="FOL.Syntax.Enumeration.html#8376" class="Bound">φ∈++</a> <a id="8381" class="Keyword">with</a> <a id="8386" href="Foundation.Data.List.SetTheoretic.html#605" class="Function">∈++-elim</a> <a id="8395" class="Symbol">_</a> <a id="8397" href="FOL.Syntax.Enumeration.html#8376" class="Bound">φ∈++</a>
<a id="8402" class="Symbol">...</a>     <a id="8410" class="Symbol">|</a> <a id="8412" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="8417" href="FOL.Syntax.Enumeration.html#8417" class="Bound">φ∈→̇</a> <a id="8422" class="Keyword">with</a> <a id="8427" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8437" href="FOL.Syntax.Enumeration.html#8417" class="Bound">φ∈→̇</a>
<a id="8442" class="Symbol">...</a>       <a id="8452" class="Symbol">|</a> <a id="8454" class="Symbol">_</a> <a id="8456" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8458" class="Symbol">_</a> <a id="8460" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8462" class="Symbol">()</a>
<a id="8465" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="8483" class="Symbol">{</a><a id="8484" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8488" href="FOL.Syntax.Enumeration.html#8488" class="Bound">m</a><a id="8489" class="Symbol">}</a> <a id="8491" class="Symbol">{</a><a id="8492" class="Argument">φ</a> <a id="8494" class="Symbol">=</a> <a id="8496" href="FOL.Syntax.Enumeration.html#8496" class="Bound">R</a> <a id="8498" class="InductiveConstructor Operator">$̇</a> <a id="8501" href="FOL.Syntax.Enumeration.html#8501" class="Bound">t⃗</a><a id="8503" class="Symbol">}</a> <a id="8505" href="FOL.Syntax.Enumeration.html#8505" class="Bound">le</a> <a id="8508" class="Symbol">_</a> <a id="8510" class="Symbol">|</a> <a id="8512" class="Symbol">_</a> <a id="8514" class="Symbol">|</a> <a id="8516" class="Symbol">_</a>
        <a id="8526" class="Symbol">|</a> <a id="8528" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="8533" href="FOL.Syntax.Enumeration.html#8533" class="Bound">φ∈$̇</a> <a id="8538" class="Symbol">=</a> <a id="8540" href="FOL.Syntax.Enumeration.html#8572" class="Function">H</a> <a id="8542" class="Symbol">(</a><a id="8543" href="Foundation.Data.Nat.AlternativeOrder.html#2197" class="Function">m+n≤o⇒n≤o</a> <a id="8553" class="Number">1</a> <a id="8555" href="FOL.Syntax.Enumeration.html#8505" class="Bound">le</a><a id="8557" class="Symbol">)</a> <a id="8559" href="FOL.Syntax.Enumeration.html#8533" class="Bound">φ∈$̇</a> <a id="8564" class="Keyword">where</a>
  <a id="8572" href="FOL.Syntax.Enumeration.html#8572" class="Function">H</a> <a id="8574" class="Symbol">:</a> <a id="8576" href="FOL.Syntax.Enumeration.html#8488" class="Bound">m</a> <a id="8578" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="8580" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="8582" class="Symbol">→</a> <a id="8584" href="FOL.Syntax.Base.html#5232" class="Generalizable">φ</a> <a id="8586" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈ᴸ</a> <a id="8589" href="Data.List.Base.html#4534" class="Function">concat</a> <a id="8596" class="Symbol">(</a><a id="8597" href="Data.List.Base.html#1627" class="Function">map</a> <a id="8601" class="Symbol">(</a><a id="8602" href="FOL.Syntax.Enumeration.html#2894" class="Function">apps</a> <a id="8607" href="FOL.Syntax.Enumeration.html#8488" class="Bound">m</a><a id="8608" class="Symbol">)</a> <a id="8610" class="Symbol">(</a><a id="8611" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">enum</a> <a id="8616" href="FOL.Syntax.Enumeration.html#8488" class="Bound">m</a><a id="8617" class="Symbol">))</a> <a id="8620" class="Symbol">→</a> <a id="8622" href="FOL.Syntax.FreshVariables.html#1103" class="Datatype">freshᵩ</a> <a id="8629" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="8631" href="FOL.Syntax.Base.html#5232" class="Generalizable">φ</a>
  <a id="8635" href="FOL.Syntax.Enumeration.html#8572" class="Function">H</a> <a id="8637" href="FOL.Syntax.Enumeration.html#8637" class="Bound">le</a> <a id="8640" href="FOL.Syntax.Enumeration.html#8640" class="Bound">φ∈$̇</a> <a id="8645" class="Keyword">with</a> <a id="8650" href="Foundation.Data.List.SetTheoretic.html#662" class="Function">∈concat-elim</a> <a id="8663" class="Symbol">_</a> <a id="8665" href="FOL.Syntax.Enumeration.html#8640" class="Bound">φ∈$̇</a>
  <a id="8672" class="Symbol">...</a> <a id="8676" class="Symbol">|</a> <a id="8678" class="Symbol">_</a> <a id="8680" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8682" href="FOL.Syntax.Enumeration.html#8682" class="Bound">φ∈φs</a> <a id="8687" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8689" href="FOL.Syntax.Enumeration.html#8689" class="Bound">φs∈</a> <a id="8693" class="Keyword">with</a> <a id="8698" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8708" href="FOL.Syntax.Enumeration.html#8689" class="Bound">φs∈</a>
  <a id="8714" class="Symbol">...</a>   <a id="8720" class="Symbol">|</a> <a id="8722" class="Symbol">_</a> <a id="8724" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8726" class="Symbol">_</a> <a id="8728" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8730" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8735" class="Keyword">with</a> <a id="8740" href="Foundation.Data.List.SetTheoretic.html#1805" class="Function">∈map-elim</a> <a id="8750" class="Bound">φ∈φs</a>
  <a id="8757" class="Symbol">...</a>     <a id="8765" class="Symbol">|</a> <a id="8767" class="Symbol">_</a> <a id="8769" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8771" href="FOL.Syntax.Enumeration.html#8771" class="Bound">t⃗∈</a> <a id="8775" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="8777" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="8782" class="Symbol">=</a> <a id="8784" href="FOL.Syntax.FreshVariables.html#1285" class="InductiveConstructor">fresh$̇</a> <a id="8792" class="Symbol">λ</a> <a id="8794" href="FOL.Syntax.Enumeration.html#8794" class="Bound">_</a> <a id="8796" href="FOL.Syntax.Enumeration.html#8796" class="Bound">t∈t⃗</a> <a id="8801" class="Symbol">→</a> <a id="8803" href="FOL.Syntax.Enumeration.html#6308" class="Function">termEnum-fresh-vec</a> <a id="8822" class="Bound">le</a> <a id="8825" href="FOL.Syntax.Enumeration.html#8771" class="Bound">t⃗∈</a> <a id="8829" href="FOL.Syntax.Enumeration.html#8796" class="Bound">t∈t⃗</a>

<a id="Ψ-fresh"></a><a id="8835" href="FOL.Syntax.Enumeration.html#8835" class="Function">Ψ-fresh</a> <a id="8843" class="Symbol">:</a> <a id="8845" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a> <a id="8847" href="Foundation.Data.Nat.AlternativeOrder.html#309" class="Datatype Operator">≤</a> <a id="8849" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="8851" class="Symbol">→</a> <a id="8853" href="FOL.Syntax.FreshVariables.html#1103" class="Datatype">freshᵩ</a> <a id="8860" href="FOL.Syntax.Enumeration.html#690" class="Generalizable">n</a> <a id="8862" class="Symbol">(</a><a id="8863" href="FOL.Syntax.Enumeration.html#5280" class="Function">Ψ</a> <a id="8865" href="FOL.Syntax.Enumeration.html#688" class="Generalizable">m</a><a id="8866" class="Symbol">)</a>
<a id="8868" href="FOL.Syntax.Enumeration.html#8835" class="Function">Ψ-fresh</a> <a id="8876" href="FOL.Syntax.Enumeration.html#8876" class="Bound">le</a> <a id="8879" class="Symbol">=</a> <a id="8881" href="FOL.Syntax.Enumeration.html#6598" class="Function">formulaEnum-fresh</a> <a id="8899" href="FOL.Syntax.Enumeration.html#8876" class="Bound">le</a> <a id="8902" href="Foundation.Function.Enumeration.PlainView.html#1329" class="Function">Plain.cum</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/FOL/Syntax/Enumeration.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/FOL.Syntax.Enumeration.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/fol.syntax.enumeration">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
