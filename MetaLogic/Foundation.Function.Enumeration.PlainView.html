<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Foundation.Function.Enumeration.PlainView</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#元语言-可枚举性-普通视角" id="toc-元语言-可枚举性-普通视角">元语言 ▸ 可枚举性 ▸ 普通视角</a></li>
  </ul>
</nav>

<main>
<h1 id="元语言-可枚举性-普通视角">元语言 ▸ 可枚举性 ▸ 普通视角</h1>
<p>前篇介绍了可枚举性的累积列表视角. 由于其累积的形式, 虽然方便构造, 但是不方便使用. 本篇介绍可枚举性的第3种视角, 叫做普通视角, 它方便直接使用. 为了防止命名冲突, 本章把累积列表视角的相关概念都加上 <code>Ⓛ.</code> 前缀.</p>
<pre class="Agda"><a id="193" class="Keyword">module</a> <a id="200" href="Foundation.Function.Enumeration.PlainView.html" class="Module">Foundation.Function.Enumeration.PlainView</a> <a id="242" class="Keyword">where</a>
<a id="248" class="Keyword">open</a> <a id="253" class="Keyword">import</a> <a id="260" href="Foundation.Function.Enumeration.ListView.Base.html" class="Module">Foundation.Function.Enumeration.ListView.Base</a> <a id="306" class="Symbol">as</a> <a id="309" class="Module">Ⓛ</a>
  <a id="313" class="Keyword">using</a> <a id="319" class="Symbol">(</a><a id="320" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a><a id="322" class="Symbol">;</a> <a id="324" href="Foundation.Function.Enumeration.ListView.Base.html#1681" class="Function">cum-total</a><a id="333" class="Symbol">)</a>

<a id="336" class="Keyword">open</a> <a id="341" class="Keyword">import</a> <a id="348" href="Foundation.Prelude.html" class="Module">Foundation.Prelude</a>
<a id="367" class="Keyword">open</a> <a id="372" class="Keyword">import</a> <a id="379" href="Foundation.Prop.Logic.html" class="Module">Foundation.Prop.Logic</a>
<a id="401" class="Keyword">open</a> <a id="406" class="Keyword">import</a> <a id="413" href="Foundation.Prop.Truncation.html" class="Module">Foundation.Prop.Truncation</a>

<a id="441" class="Keyword">open</a> <a id="446" class="Keyword">import</a> <a id="453" href="Foundation.Data.Maybe.html" class="Module">Foundation.Data.Maybe</a>
<a id="475" class="Keyword">open</a> <a id="480" class="Keyword">import</a> <a id="487" href="Foundation.Data.Nat.AlternativeOrder.html" class="Module">Foundation.Data.Nat.AlternativeOrder</a>
<a id="524" class="Keyword">open</a> <a id="529" class="Keyword">import</a> <a id="536" href="Foundation.Data.Sum.html" class="Module">Foundation.Data.Sum</a>
<a id="556" class="Keyword">open</a> <a id="561" class="Keyword">import</a> <a id="568" href="Foundation.Data.List.html" class="Module">Foundation.Data.List</a>
<a id="589" class="Keyword">open</a> <a id="594" class="Keyword">import</a> <a id="601" href="Foundation.Data.List.SetTheoretic.html" class="Module">Foundation.Data.List.SetTheoretic</a>

<a id="636" class="Keyword">open</a> <a id="641" class="Keyword">import</a> <a id="648" href="Foundation.Relation.Nullary.Discrete.Base.html" class="Module">Foundation.Relation.Nullary.Discrete.Base</a>
<a id="690" class="Keyword">open</a> <a id="695" class="Keyword">import</a> <a id="702" href="Foundation.Relation.Nullary.Discrete.List.html" class="Module">Foundation.Relation.Nullary.Discrete.List</a>
</pre>
<p>为了得到普通视角, 还需要追加两个条件.</p>
<ol type="1">
<li>枚举的类型必须是离散的.</li>
<li>累积列表的长度必须是严格递增的, 也叫真累积. 当然, 这样的话, 有限类型将不会有普通视角. 不过我们关心的都是可数无穷类型, 所以这个条件是可以满足的.</li>
</ol>
<pre class="Agda"><a id="proper"></a><a id="878" href="Foundation.Function.Enumeration.PlainView.html#878" class="Function">proper</a> <a id="885" class="Symbol">:</a> <a id="887" href="Foundation.Function.Enumeration.ListView.Base.html#817" class="Function">𝕃ₙ</a> <a id="890" href="Foundation.Prelude.Builtin.html#926" class="Generalizable">A</a> <a id="892" class="Symbol">→</a> <a id="894" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="896" class="Symbol">_</a>
<a id="898" href="Foundation.Function.Enumeration.PlainView.html#878" class="Function">proper</a> <a id="905" href="Foundation.Function.Enumeration.PlainView.html#905" class="Bound">f</a> <a id="907" class="Symbol">=</a> <a id="909" class="Symbol">∀</a> <a id="911" href="Foundation.Function.Enumeration.PlainView.html#911" class="Bound">n</a> <a id="913" class="Symbol">→</a> <a id="915" href="Data.List.Base.html#5079" class="Function">length</a> <a id="922" class="Symbol">(</a><a id="923" href="Foundation.Function.Enumeration.PlainView.html#905" class="Bound">f</a> <a id="925" href="Foundation.Function.Enumeration.PlainView.html#911" class="Bound">n</a><a id="926" class="Symbol">)</a> <a id="928" href="Foundation.Data.Nat.AlternativeOrder.html#422" class="Function Operator">&gt;</a> <a id="930" href="Foundation.Function.Enumeration.PlainView.html#911" class="Bound">n</a>
</pre>
<p>现在, 给定离散集 <code>A</code> 和它枚举, 其中的累积列表是真累积.</p>
<pre class="Agda"><a id="979" class="Keyword">module</a> <a id="PlainEnum"></a><a id="986" href="Foundation.Function.Enumeration.PlainView.html#986" class="Module">PlainEnum</a> <a id="996" class="Symbol">⦃</a> <a id="998" href="Foundation.Function.Enumeration.PlainView.html#998" class="Bound">_</a> <a id="1000" class="Symbol">:</a> <a id="1002" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1011" href="Foundation.Prelude.Builtin.html#926" class="Generalizable">A</a> <a id="1013" class="Symbol">⦄</a> <a id="1015" class="Symbol">⦃</a> <a id="1017" href="Foundation.Function.Enumeration.PlainView.html#1017" class="Bound">_</a> <a id="1019" class="Symbol">:</a> <a id="1021" href="Foundation.Function.Enumeration.ListView.Base.html#2869" class="Record">Ⓛ.Enum</a> <a id="1028" href="Foundation.Prelude.Builtin.html#926" class="Generalizable">A</a> <a id="1030" class="Symbol">⦄</a> <a id="1032" class="Symbol">(</a><a id="1033" href="Foundation.Function.Enumeration.PlainView.html#1033" class="Bound Operator">l&gt;_</a> <a id="1037" class="Symbol">:</a> <a id="1039" href="Foundation.Function.Enumeration.PlainView.html#878" class="Function">proper</a> <a id="1046" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a><a id="1052" class="Symbol">)</a> <a id="1054" class="Keyword">where</a>
</pre>
<p><strong><u>定义</u></strong> 由于 <code>Ⓛ.enum n</code> 的长度大于 <code>n</code>, 它必然在索引 <code>n</code> 处有值, 我们就取这个值, 作为 <code>A</code> 的普通视角枚举函数 <code>enum : ℕ → A</code> 在 <code>n</code> 处的值.</p>
<pre class="Agda">  <a id="PlainEnum.enum"></a><a id="1183" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="1188" class="Symbol">:</a> <a id="1190" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1192" class="Symbol">→</a> <a id="1194" href="Foundation.Function.Enumeration.PlainView.html#1011" class="Bound">A</a>
  <a id="1198" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="1203" href="Foundation.Function.Enumeration.PlainView.html#1203" class="Bound">n</a> <a id="1205" class="Symbol">=</a> <a id="1207" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="1214" href="Foundation.Function.Enumeration.PlainView.html#1203" class="Bound">n</a> <a id="1216" href="Foundation.Data.List.html#1250" class="Function Operator">[</a> <a id="1218" href="Foundation.Function.Enumeration.PlainView.html#1033" class="Bound Operator">l&gt;</a> <a id="1221" href="Foundation.Function.Enumeration.PlainView.html#1203" class="Bound">n</a> <a id="1223" href="Foundation.Data.List.html#1250" class="Function Operator">]⁻¹!</a>
</pre>
<p><strong><u>引理</u></strong> <code>enum n</code> 的值必然等于列表 <code>Ⓛ.enum n</code> 中的某个元素.<br />
<strong><u>证明</u></strong> 由 <code>enum</code> 的定义即得. ∎</p>
<pre class="Agda">  <a id="PlainEnum.cum"></a><a id="1329" href="Foundation.Function.Enumeration.PlainView.html#1329" class="Function">cum</a> <a id="1333" class="Symbol">:</a> <a id="1335" class="Symbol">∀</a> <a id="1337" class="Symbol">{</a><a id="1338" href="Foundation.Function.Enumeration.PlainView.html#1338" class="Bound">n</a><a id="1339" class="Symbol">}</a> <a id="1341" class="Symbol">→</a> <a id="1343" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="1348" href="Foundation.Function.Enumeration.PlainView.html#1338" class="Bound">n</a> <a id="1350" href="Data.List.Membership.Setoid.html#943" class="Function Operator">∈</a> <a id="1352" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="1359" href="Foundation.Function.Enumeration.PlainView.html#1338" class="Bound">n</a>
  <a id="1363" href="Foundation.Function.Enumeration.PlainView.html#1329" class="Function">cum</a> <a id="1367" class="Symbol">{</a><a id="1368" href="Foundation.Function.Enumeration.PlainView.html#1368" class="Bound">n</a><a id="1369" class="Symbol">}</a> <a id="1371" class="Symbol">=</a> <a id="1373" href="Foundation.Data.List.SetTheoretic.html#1551" class="Function">[]?→∈</a> <a id="1379" class="Symbol">_</a> <a id="1381" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1383" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="1390" href="Foundation.Function.Enumeration.PlainView.html#1368" class="Bound">n</a> <a id="1392" href="Foundation.Data.List.html#1338" class="Function Operator">[</a> <a id="1394" href="Foundation.Function.Enumeration.PlainView.html#1033" class="Bound Operator">l&gt;</a> <a id="1397" href="Foundation.Function.Enumeration.PlainView.html#1368" class="Bound">n</a> <a id="1399" href="Foundation.Data.List.html#1338" class="Function Operator">]⁻¹!≡</a>
</pre>
<p><strong><u>引理</u></strong> <code>enum</code> 见证了每一个 <code>x : A</code>.<br />
<strong><u>证明</u></strong> 我们有 <code>x</code> 在 <code>Ⓛ.enum</code> 中的见证 <code>m</code>, 需要将它转化成 <code>x</code> 在 <code>enum</code> 中的见证.</p>
<p>一方面, 由 <code>x ∈ Ⓛ.enum m</code>, 可以找到 <code>n</code> 满足 <code>Ⓛ.enum m [ x ]⁻¹? ≡ some n</code>, 也即 <code>Ⓛ.enum m [ n ]? ≡ some x</code>.</p>
<p>另一方面, 由 <code>enum</code> 的定义有 <code>Ⓛ.enum n [ n ]? ≡ some (enum n)</code>.</p>
<p>由累积列表的性质, 有以下两种情况:</p>
<ul>
<li>若 <code>Ⓛ.enum n ≡ Ⓛ.enum m ++ xs</code>, 那么 <code>some (enum n) ≡ Ⓛ.enum n [ n ]? ≡ (Ⓛ.enum m ++ xs) [ n ]? ≡ some x</code>.</li>
<li>若 <code>Ⓛ.enum m ≡ Ⓛ.enum n ++ xs</code>, 那么 <code>some (enum n) ≡ (Ⓛ.enum n ++ xs) [ n ]? ≡ Ⓛ.enum m [ n ]? ≡ some x</code>.</li>
</ul>
<p>不管怎样, 都有 <code>some (enum n) ≡ some x</code>. 由 <code>some</code> 的单射性即得 <code>enum n ≡ x</code>. ∎</p>
<pre class="Agda">  <a id="PlainEnum.wit"></a><a id="1988" href="Foundation.Function.Enumeration.PlainView.html#1988" class="Function">wit</a> <a id="1992" class="Symbol">:</a> <a id="1994" class="Symbol">∀</a> <a id="1996" href="Foundation.Function.Enumeration.PlainView.html#1996" class="Bound">x</a> <a id="1998" class="Symbol">→</a> <a id="2000" href="Foundation.Prop.Logic.html#736" class="Function">∃</a> <a id="2002" href="Foundation.Function.Enumeration.PlainView.html#2002" class="Bound">n</a> <a id="2004" href="Foundation.Prop.Logic.html#736" class="Function">，</a> <a id="2006" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="2011" href="Foundation.Function.Enumeration.PlainView.html#2002" class="Bound">n</a> <a id="2013" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2015" href="Foundation.Function.Enumeration.PlainView.html#1996" class="Bound">x</a>
  <a id="2019" href="Foundation.Function.Enumeration.PlainView.html#1988" class="Function">wit</a> <a id="2023" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a> <a id="2025" class="Symbol">=</a> <a id="2027" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">𝟙.map</a> <a id="2033" href="Foundation.Function.Enumeration.PlainView.html#2055" class="Function">H</a> <a id="2035" class="Symbol">(</a><a id="2036" href="Foundation.Function.Enumeration.ListView.Base.html#2975" class="Field">Ⓛ.wit</a> <a id="2042" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a><a id="2043" class="Symbol">)</a> <a id="2045" class="Keyword">where</a>
    <a id="2055" href="Foundation.Function.Enumeration.PlainView.html#2055" class="Function">H</a> <a id="2057" class="Symbol">:</a> <a id="2059" href="Foundation.Function.Enumeration.ListView.Base.html#2501" class="Function">Ⓛ.Witness</a> <a id="2069" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2076" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a> <a id="2078" class="Symbol">→</a> <a id="2080" href="Foundation.Prelude.Builtin.html#1069" class="Function">Σ</a> <a id="2082" href="Foundation.Function.Enumeration.PlainView.html#2082" class="Bound">n</a> <a id="2084" href="Foundation.Prelude.Builtin.html#1069" class="Function">，</a> <a id="2086" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="2091" href="Foundation.Function.Enumeration.PlainView.html#2082" class="Bound">n</a> <a id="2093" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2095" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a>
    <a id="2101" href="Foundation.Function.Enumeration.PlainView.html#2055" class="Function">H</a> <a id="2103" class="Symbol">(</a><a id="2104" href="Foundation.Function.Enumeration.PlainView.html#2104" class="Bound">m</a> <a id="2106" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2108" href="Foundation.Function.Enumeration.PlainView.html#2108" class="Bound">Hm</a><a id="2110" class="Symbol">)</a> <a id="2112" class="Keyword">with</a> <a id="2117" href="Foundation.Relation.Nullary.Discrete.List.html#1433" class="Function">some[]⁻¹-intro</a> <a id="2132" href="Foundation.Function.Enumeration.PlainView.html#2108" class="Bound">Hm</a>
    <a id="2139" href="Foundation.Function.Enumeration.PlainView.html#2055" class="Function">H</a> <a id="2141" class="Symbol">(</a><a id="2142" href="Foundation.Function.Enumeration.PlainView.html#2142" class="Bound">m</a> <a id="2144" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2146" href="Foundation.Function.Enumeration.PlainView.html#2146" class="Bound">Hm</a><a id="2148" class="Symbol">)</a> <a id="2150" class="Symbol">|</a> <a id="2152" href="Foundation.Function.Enumeration.PlainView.html#2152" class="Bound">n</a> <a id="2154" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2156" href="Foundation.Function.Enumeration.PlainView.html#2156" class="Bound">Hn</a> <a id="2159" class="Keyword">with</a> <a id="2164" href="Foundation.Function.Enumeration.ListView.Base.html#1681" class="Function">cum-total</a> <a id="2174" href="Foundation.Function.Enumeration.ListView.Base.html#2949" class="Field">Ⓛ.cum</a> <a id="2180" href="Foundation.Function.Enumeration.PlainView.html#2142" class="Bound">m</a> <a id="2182" href="Foundation.Function.Enumeration.PlainView.html#2152" class="Bound">n</a>
      <a id="2190" class="Symbol">|</a> <a id="2192" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2199" href="Foundation.Function.Enumeration.PlainView.html#2152" class="Bound">n</a> <a id="2201" href="Foundation.Data.List.html#1338" class="Function Operator">[</a> <a id="2203" href="Foundation.Function.Enumeration.PlainView.html#1033" class="Bound Operator">l&gt;</a> <a id="2206" href="Foundation.Function.Enumeration.PlainView.html#2152" class="Bound">n</a> <a id="2208" href="Foundation.Data.List.html#1338" class="Function Operator">]⁻¹!≡</a>   <a id="2216" class="Comment">-- = H1 : Ⓛ.enum n [ n ]? ≡ some (enum n)</a>
      <a id="2264" class="Symbol">|</a> <a id="2266" href="Foundation.Relation.Nullary.Discrete.List.html#2273" class="Function">some[]⁻¹→some[]</a> <a id="2282" class="Symbol">(</a><a id="2283" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2290" href="Foundation.Function.Enumeration.PlainView.html#2142" class="Bound">m</a><a id="2291" class="Symbol">)</a> <a id="2293" href="Foundation.Function.Enumeration.PlainView.html#2156" class="Bound">Hn</a>   <a id="2298" class="Comment">-- = H2 : Ⓛ.enum m [ n ]? ≡ some x</a>
    <a id="2337" class="Symbol">...</a> <a id="2341" class="Symbol">|</a> <a id="2343" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="2348" class="Symbol">(</a><a id="2349" href="Foundation.Function.Enumeration.PlainView.html#2349" class="Bound">xs</a> <a id="2352" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2354" href="Foundation.Function.Enumeration.PlainView.html#2354" class="Bound">n≡m++</a><a id="2359" class="Symbol">)</a> <a id="2361" class="Symbol">|</a> <a id="2363" href="Foundation.Function.Enumeration.PlainView.html#2363" class="Bound">H1</a> <a id="2366" class="Symbol">|</a> <a id="2368" href="Foundation.Function.Enumeration.PlainView.html#2368" class="Bound">H2</a> <a id="2371" class="Symbol">=</a> <a id="2373" class="Bound">n</a> <a id="2375" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2377" href="Data.Maybe.Properties.html#1056" class="Function">some-inj</a> <a id="2386" class="Symbol">(</a>
      <a id="2394" href="Foundation.Prelude.Builtin.html#533" class="InductiveConstructor">some</a> <a id="2399" class="Symbol">(</a><a id="2400" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="2405" class="Bound">n</a><a id="2406" class="Symbol">)</a>           <a id="2418" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">≡˘⟨</a> <a id="2422" href="Foundation.Function.Enumeration.PlainView.html#2363" class="Bound">H1</a> <a id="2425" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">⟩</a>
      <a id="2433" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2440" class="Bound">n</a> <a id="2442" href="Foundation.Data.List.html#684" class="Function Operator">[</a> <a id="2444" class="Bound">n</a> <a id="2446" href="Foundation.Data.List.html#684" class="Function Operator">]?</a>         <a id="2457" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="2460" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="2465" href="Foundation.Data.List.html#684" class="Function Operator">_[</a> <a id="2468" class="Bound">n</a> <a id="2470" href="Foundation.Data.List.html#684" class="Function Operator">]?</a> <a id="2473" href="Foundation.Function.Enumeration.PlainView.html#2354" class="Bound">n≡m++</a> <a id="2479" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
      <a id="2487" class="Symbol">(</a><a id="2488" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2495" class="Bound">m</a> <a id="2497" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="2500" href="Foundation.Function.Enumeration.PlainView.html#2349" class="Bound">xs</a><a id="2502" class="Symbol">)</a> <a id="2504" href="Foundation.Data.List.html#684" class="Function Operator">[</a> <a id="2506" class="Bound">n</a> <a id="2508" href="Foundation.Data.List.html#684" class="Function Operator">]?</a> <a id="2511" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="2514" href="Foundation.Data.List.html#978" class="Function">++[]?</a> <a id="2520" class="Symbol">(</a><a id="2521" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2528" class="Bound">m</a><a id="2529" class="Symbol">)</a> <a id="2531" href="Foundation.Function.Enumeration.PlainView.html#2368" class="Bound">H2</a> <a id="2534" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
      <a id="2542" href="Foundation.Prelude.Builtin.html#533" class="InductiveConstructor">some</a> <a id="2547" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a>                  <a id="2566" href="Foundation.Prelude.Equality.html#1248" class="Function Operator">∎</a><a id="2567" class="Symbol">)</a>
    <a id="2573" class="Symbol">...</a> <a id="2577" class="Symbol">|</a> <a id="2579" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="2584" class="Symbol">(</a><a id="2585" href="Foundation.Function.Enumeration.PlainView.html#2585" class="Bound">xs</a> <a id="2588" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2590" href="Foundation.Function.Enumeration.PlainView.html#2590" class="Bound">m≡n++</a><a id="2595" class="Symbol">)</a> <a id="2597" class="Symbol">|</a> <a id="2599" href="Foundation.Function.Enumeration.PlainView.html#2599" class="Bound">H1</a> <a id="2602" class="Symbol">|</a> <a id="2604" href="Foundation.Function.Enumeration.PlainView.html#2604" class="Bound">H2</a> <a id="2607" class="Symbol">=</a> <a id="2609" class="Bound">n</a> <a id="2611" href="Foundation.Prelude.Builtin.html#870" class="InductiveConstructor Operator">,</a> <a id="2613" href="Data.Maybe.Properties.html#1056" class="Function">some-inj</a> <a id="2622" class="Symbol">(</a>
      <a id="2630" href="Foundation.Prelude.Builtin.html#533" class="InductiveConstructor">some</a> <a id="2635" class="Symbol">(</a><a id="2636" href="Foundation.Function.Enumeration.PlainView.html#1183" class="Function">enum</a> <a id="2641" class="Bound">n</a><a id="2642" class="Symbol">)</a>           <a id="2654" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">≡˘⟨</a> <a id="2658" href="Foundation.Data.List.html#978" class="Function">++[]?</a> <a id="2664" class="Symbol">(</a><a id="2665" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2672" class="Bound">n</a><a id="2673" class="Symbol">)</a> <a id="2675" href="Foundation.Function.Enumeration.PlainView.html#2599" class="Bound">H1</a> <a id="2678" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">⟩</a>
      <a id="2686" class="Symbol">(</a><a id="2687" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2694" class="Bound">n</a> <a id="2696" href="Data.List.Base.html#1950" class="Function Operator">++</a> <a id="2699" href="Foundation.Function.Enumeration.PlainView.html#2585" class="Bound">xs</a><a id="2701" class="Symbol">)</a> <a id="2703" href="Foundation.Data.List.html#684" class="Function Operator">[</a> <a id="2705" class="Bound">n</a> <a id="2707" href="Foundation.Data.List.html#684" class="Function Operator">]?</a> <a id="2710" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">≡˘⟨</a> <a id="2714" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="2719" href="Foundation.Data.List.html#684" class="Function Operator">_[</a> <a id="2722" class="Bound">n</a> <a id="2724" href="Foundation.Data.List.html#684" class="Function Operator">]?</a> <a id="2727" href="Foundation.Function.Enumeration.PlainView.html#2590" class="Bound">m≡n++</a> <a id="2733" href="Foundation.Prelude.Equality.html#1160" class="Function Operator">⟩</a>
      <a id="2741" href="Foundation.Function.Enumeration.ListView.Base.html#2933" class="Field">Ⓛ.enum</a> <a id="2748" class="Bound">m</a> <a id="2750" href="Foundation.Data.List.html#684" class="Function Operator">[</a> <a id="2752" class="Bound">n</a> <a id="2754" href="Foundation.Data.List.html#684" class="Function Operator">]?</a>         <a id="2765" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">≡⟨</a> <a id="2768" href="Foundation.Function.Enumeration.PlainView.html#2604" class="Bound">H2</a> <a id="2771" href="Foundation.Prelude.Equality.html#1089" class="Function Operator">⟩</a>
      <a id="2779" href="Foundation.Prelude.Builtin.html#533" class="InductiveConstructor">some</a> <a id="2784" href="Foundation.Function.Enumeration.PlainView.html#2023" class="Bound">x</a>                  <a id="2803" href="Foundation.Prelude.Equality.html#1248" class="Function Operator">∎</a><a id="2804" class="Symbol">)</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Function/Enumeration/PlainView.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/Foundation.Function.Enumeration.PlainView.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/foundation.enumeration.plainview">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
