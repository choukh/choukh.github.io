<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Foundation.Relation.Nullary.Discrete.Base</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#元语言-离散性-定义" id="toc-元语言-离散性-定义">元语言 ▸ 离散性 ▸ 定义</a></li>
  </ul>
</nav>

<main>
<h1 id="元语言-离散性-定义">元语言 ▸ 离散性 ▸ 定义</h1>
<p>离散性是类型具有的一种属性, 是直觉主义中特有的一种概念, 其定义依赖于可判定性 <code>Dec</code>.</p>
<pre class="Agda"><a id="115" class="Keyword">module</a> <a id="122" href="Foundation.Relation.Nullary.Discrete.Base.html" class="Module">Foundation.Relation.Nullary.Discrete.Base</a> <a id="164" class="Keyword">where</a>

<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Foundation.Prelude.html" class="Module">Foundation.Prelude</a>
<a id="202" class="Keyword">open</a> <a id="207" class="Keyword">import</a> <a id="214" href="Foundation.Relation.Nullary.Decidable.html" class="Module">Foundation.Relation.Nullary.Decidable</a>
</pre>
<p>标准库和Cubical库中都有离散性的定义, 我们把标准库中的叫做 <code>discreteⓢ</code>, 而把Cubical库中的叫做 <code>discrete🧊</code>. 除了形式上的微小差异, 它们大体上是等价的. 我们将建立它们之间的联系.</p>
<pre class="Agda"><a id="378" class="Keyword">open</a> <a id="383" class="Keyword">import</a> <a id="390" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="406" class="Keyword">public</a>
  <a id="415" class="Keyword">using</a> <a id="421" class="Symbol">()</a>
  <a id="426" class="Keyword">renaming</a> <a id="435" class="Symbol">(</a><a id="436" href="Relation.Binary.Definitions.html#6468" class="Function">DecidableEquality</a> <a id="454" class="Symbol">to</a> <a id="457" class="Function">discreteⓢ</a><a id="466" class="Symbol">)</a>

<a id="469" class="Keyword">open</a> <a id="474" class="Keyword">import</a> <a id="481" href="Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a> <a id="506" class="Symbol">as</a> <a id="509" class="Module">🧊</a>
  <a id="513" class="Keyword">using</a> <a id="519" class="Symbol">()</a>
  <a id="524" class="Keyword">renaming</a> <a id="533" class="Symbol">(</a>
    <a id="539" href="Cubical.Relation.Nullary.Base.html#1538" class="Function">Discrete</a> <a id="548" class="Symbol">to</a> <a id="551" class="Function">discrete🧊</a><a id="560" class="Symbol">;</a>
    <a id="566" href="Cubical.Relation.Nullary.Properties.html#6952" class="Function">Discrete→isSet</a> <a id="581" class="Symbol">to</a> <a id="584" class="Function">discrete🧊→isSet🧊</a>
  <a id="603" class="Symbol">)</a>
</pre>
<p><strong><u>定义</u></strong> 我们说一个类型是离散的, 当且仅当它的任意两个元素的相等都是可判定的.</p>
<pre class="Agda"><a id="discrete"></a><a id="669" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="678" class="Symbol">:</a> <a id="680" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="682" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a> <a id="684" class="Symbol">→</a> <a id="686" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="688" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a>
<a id="690" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="699" href="Foundation.Relation.Nullary.Discrete.Base.html#699" class="Bound">A</a> <a id="701" class="Symbol">=</a> <a id="703" class="Symbol">{</a><a id="704" href="Foundation.Relation.Nullary.Discrete.Base.html#704" class="Bound">x</a> <a id="706" href="Foundation.Relation.Nullary.Discrete.Base.html#706" class="Bound">y</a> <a id="708" class="Symbol">:</a> <a id="710" href="Foundation.Relation.Nullary.Discrete.Base.html#699" class="Bound">A</a><a id="711" class="Symbol">}</a> <a id="713" class="Symbol">→</a> <a id="715" href="Relation.Nullary.Decidable.Core.html#1478" class="Record">Dec</a> <a id="719" class="Symbol">(</a><a id="720" href="Foundation.Relation.Nullary.Discrete.Base.html#704" class="Bound">x</a> <a id="722" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="724" href="Foundation.Relation.Nullary.Discrete.Base.html#706" class="Bound">y</a><a id="725" class="Symbol">)</a>
</pre>
<p>该定义与标准库中的 <code>discreteⓢ</code> 相比只是多了参数的隐式化. 这主要是出于实用上的考虑, 我们希望类型的离散性能被声明为<a href="https://agda.readthedocs.io/en/v2.6.4.1/language/instance-arguments.html"><strong>实例 (instance)</strong></a>, 而这要求定义中不带任何显式参数.</p>
<p>以下函数建立了两种定义的联系, 实际上就是把隐参显式化了. 对于已经声明了实例的离散类型, 我们可以通过调用 <code>x ≟ y</code> 判定 <code>x</code> 是否等于 <code>y</code>.</p>
<pre class="Agda"><a id="_≟_"></a><a id="999" href="Foundation.Relation.Nullary.Discrete.Base.html#999" class="Function Operator">_≟_</a> <a id="1003" class="Symbol">:</a> <a id="1005" class="Symbol">⦃</a> <a id="1007" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1016" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1018" class="Symbol">⦄</a> <a id="1020" class="Symbol">→</a> <a id="1022" href="Foundation.Relation.Nullary.Discrete.Base.html#457" class="Function">discreteⓢ</a> <a id="1032" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="1034" href="Foundation.Relation.Nullary.Discrete.Base.html#999" class="Function Operator">_≟_</a> <a id="1038" class="Symbol">_</a> <a id="1040" class="Symbol">_</a> <a id="1042" class="Symbol">=</a> <a id="1044" href="Function.Base.html#4724" class="Function">it</a>
</pre>
<p>我们的定义与Cubical库中的定义也是逻辑等价的.</p>
<pre class="Agda"><a id="discrete→🧊"></a><a id="1088" href="Foundation.Relation.Nullary.Discrete.Base.html#1088" class="Function">discrete→🧊</a> <a id="1099" class="Symbol">:</a> <a id="1101" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1110" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1112" class="Symbol">→</a> <a id="1114" href="Foundation.Relation.Nullary.Discrete.Base.html#551" class="Function">discrete🧊</a> <a id="1124" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="1126" href="Foundation.Relation.Nullary.Discrete.Base.html#1088" class="Function">discrete→🧊</a> <a id="1137" href="Foundation.Relation.Nullary.Discrete.Base.html#1137" class="Bound">H</a> <a id="1139" class="Symbol">_</a> <a id="1141" class="Symbol">_</a> <a id="1143" class="Symbol">=</a> <a id="1145" href="Foundation.Relation.Nullary.Decidable.html#238" class="Function">Dec→🧊</a> <a id="1151" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1153" href="Foundation.Prelude.Equality.html#1354" class="Function">subst</a> <a id="1159" href="Relation.Nullary.Decidable.Core.html#1478" class="Record">Dec</a> <a id="1163" class="Symbol">(</a><a id="1164" href="Relation.Binary.PropositionalEquality.Core.html#1712" class="Function">sym</a> <a id="1168" href="Foundation.Prelude.Equality.html#2595" class="Function">Eq≡🧊</a><a id="1172" class="Symbol">)</a> <a id="1174" href="Foundation.Relation.Nullary.Discrete.Base.html#1137" class="Bound">H</a>

<a id="discrete←🧊"></a><a id="1177" href="Foundation.Relation.Nullary.Discrete.Base.html#1177" class="Function">discrete←🧊</a> <a id="1188" class="Symbol">:</a> <a id="1190" href="Foundation.Relation.Nullary.Discrete.Base.html#551" class="Function">discrete🧊</a> <a id="1200" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1202" class="Symbol">→</a> <a id="1204" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1213" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="1215" href="Foundation.Relation.Nullary.Discrete.Base.html#1177" class="Function">discrete←🧊</a> <a id="1226" href="Foundation.Relation.Nullary.Discrete.Base.html#1226" class="Bound">H</a> <a id="1228" class="Symbol">{</a><a id="1229" href="Foundation.Relation.Nullary.Discrete.Base.html#1229" class="Bound">x</a><a id="1230" class="Symbol">}</a> <a id="1232" class="Symbol">{</a><a id="1233" href="Foundation.Relation.Nullary.Discrete.Base.html#1233" class="Bound">y</a><a id="1234" class="Symbol">}</a> <a id="1236" class="Symbol">=</a> <a id="1238" href="Foundation.Relation.Nullary.Decidable.html#317" class="Function">Dec←🧊</a> <a id="1244" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1246" href="Foundation.Prelude.Equality.html#1354" class="Function">subst</a> <a id="1252" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">🧊.Dec</a> <a id="1258" href="Foundation.Prelude.Equality.html#2595" class="Function">Eq≡🧊</a> <a id="1263" class="Symbol">(</a><a id="1264" href="Foundation.Relation.Nullary.Discrete.Base.html#1226" class="Bound">H</a> <a id="1266" href="Foundation.Relation.Nullary.Discrete.Base.html#1229" class="Bound">x</a> <a id="1268" href="Foundation.Relation.Nullary.Discrete.Base.html#1233" class="Bound">y</a><a id="1269" class="Symbol">)</a>
</pre>
<p><strong><u>引理</u></strong> 如果一个类型是集合, 那么它的离散性是一个命题.<br />
<strong><u>证明</u></strong> 由可判定性的命题性即得. ∎</p>
<pre class="Agda"><a id="isPropDiscrete"></a><a id="1355" href="Foundation.Relation.Nullary.Discrete.Base.html#1355" class="Function">isPropDiscrete</a> <a id="1370" class="Symbol">:</a> <a id="1372" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1378" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1380" class="Symbol">→</a> <a id="1382" href="Foundation.Prelude.HLevel.html#555" class="Function">isProp</a> <a id="1389" class="Symbol">(</a><a id="1390" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1399" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a><a id="1400" class="Symbol">)</a>
<a id="1402" href="Foundation.Relation.Nullary.Discrete.Base.html#1355" class="Function">isPropDiscrete</a> <a id="1417" href="Foundation.Relation.Nullary.Discrete.Base.html#1417" class="Bound">H</a> <a id="1419" class="Symbol">=</a> <a id="1421" href="Foundation.Prelude.HLevel.html#2944" class="Function">isPropΠ̅2</a> <a id="1431" class="Symbol">λ</a> <a id="1433" href="Foundation.Relation.Nullary.Discrete.Base.html#1433" class="Bound">x</a> <a id="1435" href="Foundation.Relation.Nullary.Discrete.Base.html#1435" class="Bound">y</a> <a id="1437" class="Symbol">→</a> <a id="1439" href="Foundation.Relation.Nullary.Decidable.html#759" class="Function">isPropDec</a> <a id="1449" class="Symbol">(</a><a id="1450" href="Foundation.Relation.Nullary.Discrete.Base.html#1417" class="Bound">H</a> <a id="1452" href="Foundation.Relation.Nullary.Discrete.Base.html#1433" class="Bound">x</a> <a id="1454" href="Foundation.Relation.Nullary.Discrete.Base.html#1435" class="Bound">y</a><a id="1455" class="Symbol">)</a>
</pre>
<p><strong><u>引理</u></strong> 如果一个类型是离散的, 那么它是一个集合. <strong><u>证明</u></strong> 见Cubical库 <a href="https://agda.github.io/cubical/Cubical.Relation.Nullary.Properties.html#6952"><code>Discrete→isSet</code></a>. ∎</p>
<pre class="Agda"><a id="discreteSet"></a><a id="1631" href="Foundation.Relation.Nullary.Discrete.Base.html#1631" class="Function">discreteSet</a> <a id="1643" class="Symbol">:</a> <a id="1645" class="Symbol">⦃</a> <a id="1647" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a> <a id="1656" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a> <a id="1658" class="Symbol">⦄</a> <a id="1660" class="Symbol">→</a> <a id="1662" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="1668" href="Foundation.Prelude.Builtin.html#835" class="Generalizable">A</a>
<a id="1670" href="Foundation.Relation.Nullary.Discrete.Base.html#1631" class="Function">discreteSet</a> <a id="1682" class="Symbol">=</a> <a id="1684" href="Foundation.Prelude.HLevel.html#1703" class="Function">isSet←🧊</a> <a id="1692" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1694" href="Foundation.Relation.Nullary.Discrete.Base.html#584" class="Function">discrete🧊→isSet🧊</a> <a id="1711" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="1713" href="Foundation.Relation.Nullary.Discrete.Base.html#1088" class="Function">discrete→🧊</a> <a id="1724" href="Function.Base.html#4724" class="Function">it</a>
</pre>
<p><strong><u>注意</u></strong> 在经典语境下集合一定是离散的, 但在直觉主义 HoTT 中, 离散强于“集合”. 因此当我们要求某 <code>A</code> 是“离散集”的时候, 实际上只要求它是离散类型, 然后它自然是一个集合.</p>
<p><strong><u>约定</u></strong> 对于已经确立了离散性的类型, 我们直接把它当作集合来看待. 代码上是把离散性的证据放到括号 <code>⦃ ⦄</code> 中来声明, 并且统一使用 <code>discreteSet</code> 来说明这些被声明的离散类型是集合.</p>
<p><strong><u>定义</u></strong> 离散类型所组成的宇宙叫做离散集合宇宙, 记作 <code>𝔻 ℓ</code>, 也叫经典集合宇宙, 其中的类型都是集合.</p>
<pre class="Agda"><a id="𝔻"></a><a id="2024" href="Foundation.Relation.Nullary.Discrete.Base.html#2024" class="Function">𝔻</a> <a id="2026" class="Symbol">:</a> <a id="2028" class="Symbol">∀</a> <a id="2030" href="Foundation.Relation.Nullary.Discrete.Base.html#2030" class="Bound">ℓ</a> <a id="2032" class="Symbol">→</a> <a id="2034" href="Agda.Primitive.html#388" class="Primitive">𝕋</a> <a id="2036" class="Symbol">(</a><a id="2037" href="Foundation.Relation.Nullary.Discrete.Base.html#2030" class="Bound">ℓ</a> <a id="2039" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a><a id="2040" class="Symbol">)</a>
<a id="2042" href="Foundation.Relation.Nullary.Discrete.Base.html#2024" class="Function">𝔻</a> <a id="2044" href="Foundation.Relation.Nullary.Discrete.Base.html#2044" class="Bound">ℓ</a> <a id="2046" class="Symbol">=</a> <a id="2048" href="Cubical.Foundations.Structure.html#399" class="Function">TypeWithStr</a> <a id="2060" href="Foundation.Relation.Nullary.Discrete.Base.html#2044" class="Bound">ℓ</a> <a id="2062" href="Foundation.Relation.Nullary.Discrete.Base.html#669" class="Function">discrete</a>

<a id="𝔻₀"></a><a id="2072" href="Foundation.Relation.Nullary.Discrete.Base.html#2072" class="Function">𝔻₀</a> <a id="2075" class="Symbol">:</a> <a id="2077" href="Agda.Primitive.html#388" class="Primitive">𝕋₁</a>
<a id="2080" href="Foundation.Relation.Nullary.Discrete.Base.html#2072" class="Function">𝔻₀</a> <a id="2083" class="Symbol">=</a> <a id="2085" href="Foundation.Relation.Nullary.Discrete.Base.html#2024" class="Function">𝔻</a> <a id="2087" href="Agda.Primitive.html#915" class="Primitive">ℓ0</a>

<a id="isSetTyp𝔻"></a><a id="2091" href="Foundation.Relation.Nullary.Discrete.Base.html#2091" class="Function">isSetTyp𝔻</a> <a id="2101" class="Symbol">:</a> <a id="2103" class="Symbol">{</a><a id="2104" href="Foundation.Relation.Nullary.Discrete.Base.html#2104" class="Bound">𝗔</a> <a id="2106" class="Symbol">:</a> <a id="2108" href="Foundation.Relation.Nullary.Discrete.Base.html#2024" class="Function">𝔻</a> <a id="2110" href="Foundation.Prelude.Builtin.html#796" class="Generalizable">ℓ</a><a id="2111" class="Symbol">}</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="Foundation.Prelude.HLevel.html#889" class="Function">isSet</a> <a id="2121" class="Symbol">(</a><a id="2122" href="Cubical.Foundations.Structure.html#515" class="Function">typ</a> <a id="2126" href="Foundation.Relation.Nullary.Discrete.Base.html#2104" class="Bound">𝗔</a><a id="2127" class="Symbol">)</a>
<a id="2129" href="Foundation.Relation.Nullary.Discrete.Base.html#2091" class="Function">isSetTyp𝔻</a> <a id="2139" class="Symbol">{</a><a id="2140" href="Foundation.Relation.Nullary.Discrete.Base.html#2140" class="Bound">𝗔</a><a id="2141" class="Symbol">}</a> <a id="2143" class="Symbol">=</a> <a id="2145" href="Foundation.Relation.Nullary.Discrete.Base.html#1631" class="Function">discreteSet</a> <a id="2157" class="Symbol">⦃</a> <a id="2159" href="Cubical.Foundations.Structure.html#557" class="Function">str</a> <a id="2163" href="Foundation.Relation.Nullary.Discrete.Base.html#2140" class="Bound">𝗔</a> <a id="2165" class="Symbol">⦄</a>
</pre>
<hr />
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Relation/Nullary/Discrete/Base.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/Foundation.Relation.Nullary.Discrete.Base.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/foundation.discrete.base">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
