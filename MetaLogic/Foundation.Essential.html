<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Foundation.Essential</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title"></h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#元语言" id="toc-元语言">元语言</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#前奏" id="toc-前奏">前奏</a>
  <ul>
  <li><a href="#内置" id="toc-内置">内置</a></li>
  <li><a href="#函数" id="toc-函数">函数</a></li>
  <li><a href="#命题相等" id="toc-命题相等">命题相等</a></li>
  <li><a href="#同伦层级" id="toc-同伦层级">同伦层级</a></li>
  <li><a href="#其他" id="toc-其他">其他</a></li>
  </ul></li>
  <li><a href="#命题" id="toc-命题">命题</a>
  <ul>
  <li><a href="#命题截断" id="toc-命题截断">命题截断</a></li>
  <li><a href="#逻辑" id="toc-逻辑">逻辑</a></li>
  <li><a href="#逻辑等价" id="toc-逻辑等价">逻辑等价</a></li>
  <li><a href="#命题宇宙" id="toc-命题宇宙">命题宇宙</a></li>
  </ul></li>
  <li><a href="#集合" id="toc-集合">集合</a></li>
  <li><a href="#函数-1" id="toc-函数-1">函数</a></li>
  <li><a href="#数据类型" id="toc-数据类型">数据类型</a></li>
  <li><a href="#关系" id="toc-关系">关系</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="元语言">元语言</h1>
<h2 id="前言">前言</h2>
<p>我们的研究对象是一阶逻辑等形式语言, 我们将其称为对象语言. 同时, 为了表达有关对象语言的命题和证明, 我们需要一个不同于对象语言的外部语言, 这个外部语言称为元语言. 传统上, 一阶逻辑等的元语言通常采用原始递归算术 (PRA) 等“低级”算术语言. 这主要是出于建立自下而上的逻辑体系以及满足有限主义哲学需求的考虑. 然而, 我们这里并不考虑这些因素, 而是采用一种称为<a href="https://www.bananaspace.org/wiki/%E5%90%8C%E4%BC%A6%E7%B1%BB%E5%9E%8B%E8%AE%BA">同伦类型论 (HoTT)</a> 的“高级”语言作为元语言. 由于 HoTT 是一种更贴近数学实践的形式语言, 我们认为它可以在一定程度上兼顾形式上的严格与表达上的自然, 从而使完全形式化的讲义成为可能, 这也是我们的目标.</p>
<p>需要注意的是, HoTT 实际上是一系列理论的统称, 就像“集合论”有 ZFC, NBG, MK 等等一样. 本文具体使用的 HoTT 叫做 <a href="https://agda.readthedocs.io/en/v2.6.4/language/cubical.html">Cubical Agda</a>. 它非常严格, 以至于可以通过计算机来检查证明语句的正确性. 实际上它就是一种编程语言, 只不过其生态着重于数学证明而非软件应用. 借助 <a href="https://agda.readthedocs.io/en/latest/tools/literate-programming.html">Agda 的文学编程</a> 功能, <a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Essential.lagda.md">本 Markdown 文件</a> 实际上就是 Agda 源码, 可以直接做类型检查, 以检验证明语句的正确性. 基于这一特性, 我们实验性地采用以下编排方式: 非形式的自然语言与代码级的形式语言并行使用, 交替排列, 构成双重元语言, 以构筑对象语言. 我们会将 Agda 语句放在代码块中, 而正文的自然语言则可以认为是对这些代码的注释. 我们希望两种元语言可以相互解释, 互为补充.</p>
<p>当然, 这要求读者对 HoTT 和 Agda 都有一定的了解. 我们不会在本文中对这些内容进行详细的介绍, 而是假设读者已经具备了一定的基础. 如果读者对 HoTT 和 Agda 还不熟悉, 我们推荐读者阅读以下资料:</p>
<ul>
<li>HoTT入门: <a href="https://homotopytypetheory.org/book/">HoTT Book</a></li>
<li>Agda + 泛等基础入门: <a href="https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/">Introduction to Univalent Foundations of Mathematics with Agda</a></li>
<li>中文版快速参考: <a href="https://www.yuque.com/ocau/hset/ti2u9nvok36hmibm">Agda 泛等基础</a></li>
</ul>
<p>以下快速复习一遍元语言中可以谈论的基础概念, 后篇中将直接使用 (<code>import</code>) 它们而不再额外定义. 为了节省篇幅, 本篇也只是 <code>import</code> 更底层的已经定义好的模块, 请需要了解细节的读者自己查看<a href="https://github.com/choukh/MetaLogic/tree/main/src/Foundation">源码</a>. 简单来说, 这些模块只不过是对 <a href="https://github.com/agda/cubical">Cubical 标准库</a> 的重新封装, 以满足我们的特殊需求: 尽可能使用命题相等 (Propositional Equality) 而不是道路 (Path), 以方便我们的形式化, 因为我们不涉及高阶同伦概念.</p>
<pre class="Agda"><a id="1738" class="Keyword">module</a> <a id="1745" href="Foundation.Essential.html" class="Module">Foundation.Essential</a> <a id="1766" class="Keyword">where</a>
</pre>
<h2 id="前奏">前奏</h2>
<p>前奏 (Prelude) 是基础中的基础, 是定义其他基础概念所必须的基础概念, 以至于有些是原始概念, 如道路类型. 这些原始概念具体涉及到 Cubical 类型论的规则, 这里不深入其细节, 而只作为一个黑盒使用.</p>
<h3 id="内置">内置</h3>
<pre class="Agda"><a id="1911" class="Keyword">open</a> <a id="1916" class="Keyword">import</a> <a id="1923" href="Foundation.Prelude.Builtin.html" class="Module">Foundation.Prelude.Builtin</a> <a id="1950" class="Keyword">public</a>
</pre>
<p>内置 (Builtin) 模块主要包括带魔法 (编译器支持) 的一些原始概念, 如宇宙和道路类型等, 以及一些基本数据类型:</p>
<ul>
<li>宇宙: 类型宇宙 <code>𝕋</code>, 宇宙层级 <code>Level</code>, 零级宇宙 <code>0ℓ</code>, 后继宇宙 <code>_⁺</code>, 宇宙二元并 <code>_⊔_</code>, 宇宙提升 <code>Lift</code></li>
<li>同一性类型: 命题相等类型 <code>_≡_</code>, 道路类型 <code>_≡🧊_</code></li>
<li>基本数据类型: 单元类型 <code>⊤</code>, 布尔类型 <code>𝔹</code>, 自然数类型 <code>ℕ</code>, 列表 (有序不定长有限集合) 类型 <code>𝕃</code>, Σ类型 <code>Σ</code></li>
</ul>
<p>注意, 对某些相似概念的 Cubical 版本, 我们会在其名字中带上“🧊”, 以示区别. 此外, 我们对符号作如下约定:</p>
<ul>
<li>宇宙层级序号 <code>ℓ ℓ′ ℓ″ ℓ‴ ℓ⁗ ℓ₀ ℓ₁ ℓ₂ ℓ₃ ℓ₄ : Level</code></li>
<li>任意给定宇宙的类型 <code>A B C D T : 𝕋 ℓ</code></li>
<li>类型族 / 性质 / 一元关系 <code>P Q : A → 𝕋 ℓ</code></li>
<li>二元关系 <code>R S : A → B → 𝕋 ℓ</code></li>
<li>依值类型族 <code>P₂ Q₂ : (x : A) → P x → 𝕋 ℓ</code></li>
</ul>
<p>注意当我们说“任意给定”的时候指的是 arbitrary, 而对于 forall, 我们一定会说“所有”或“对任意”. 我们保留“谓词”这个名称给可以证明是命题的一元关系. 最后, 我们约定Σ类型 <code>Σ A (λ x → P)</code>, 即满足 <code>P</code> 的 <code>A</code>, 可以简记为 <code>Σ x ꞉ A ， P</code> 或者 <code>Σ x ， P</code>.</p>
<h3 id="函数">函数</h3>
<pre class="Agda"><a id="2634" class="Keyword">open</a> <a id="2639" class="Keyword">import</a> <a id="2646" href="Foundation.Prelude.Function.html" class="Module">Foundation.Prelude.Function</a> <a id="2674" class="Keyword">public</a>
</pre>
<p>前奏中的函数模块主要定义与函数有关的一些便利记法:</p>
<ul>
<li>恒等函数 <code>id = λ x → x</code></li>
<li>恒等函数性 <code>isId = λ f → ∀ x y → f x ≡ f y</code></li>
<li>函数复合 <code>f ∘ g = λ x → f (g x)</code>
<ul>
<li>二元 <code>f ∘₂ g = λ x y → f (g x y)</code></li>
<li>三元 <code>f ∘₃ g = λ x y z → f (g x y z)</code></li>
</ul></li>
<li>参数翻转 <code>flip = λ f x y → f y x</code></li>
<li>函数应用 <code>f $ x = f x</code>, 用于当参数本身是个函数应用时省略参数外层的括号</li>
</ul>
<h3 id="命题相等">命题相等</h3>
<pre class="Agda"><a id="2980" class="Keyword">open</a> <a id="2985" class="Keyword">import</a> <a id="2992" href="Foundation.Prelude.Equality.html" class="Module">Foundation.Prelude.Equality</a> <a id="3020" class="Keyword">public</a>
</pre>
<p>本模块给出了相等的基本性质:</p>
<ul>
<li>对称性 <code>sym</code>, 传递性 <code>_∙_</code>
<ul>
<li>注意自反性 <code>refl</code> 不需要专门给出, 它是相等类型的唯一构造子</li>
</ul></li>
<li>合同性 <code>cong : ∀ (f : A → B) {x y} → x ≡ y → f x ≡ f y</code>
<ul>
<li>二元 <code>cong2 : ∀ (f : A → B → C) {x y z w} → x ≡ y → z ≡ w → f x z ≡ f y w</code></li>
</ul></li>
<li>等量替换 <code>subst : (P : A → 𝕋 ℓ) {x y : A} → y ≡ x → P x → P y</code>
<ul>
<li>二元 <code>subst2 : (R : A → B → 𝕋 ℓ) {x y : A} {z w : B} → x ≡ y → z ≡ w → R x z → R y w</code></li>
</ul></li>
<li>函数外延性 <code>funExt : {P : A → 𝕋 ℓ} {f g : (x : A) → P x} → ((x : A) → f x ≡ g x) → f ≡ g</code>
<ul>
<li>二元 <code>funExt2 : {R : A → B → 𝕋 ℓ} {f g : (x : A) (y : B) → R x y} → ((x : A) (y : B) → f x y ≡ g x y) → f ≡ g</code></li>
</ul></li>
<li>函数外延性的逆 <code>funExt⁻ : {P : A → 𝕋 ℓ} {f g : (x : A) → P x} → f ≡ g → (x : A) → f x ≡ g x</code></li>
</ul>
<p>以及与同伦等价 <code>_≃_</code> 和同构 <code>_≅_</code> 相关的性质:</p>
<ul>
<li>同伦等价蕴含相等 <code>ua≃ : A ≃ B → A ≡ B</code></li>
<li>同构蕴含相等 <code>ua : A ≅ B → A ≡ B</code></li>
</ul>
<p>注意 ua 是泛等公理 (univalence axiom) 的缩写, 虽然在 Cubical 中它是定理, 出于历史原因仍记作 ua.</p>
<h3 id="同伦层级">同伦层级</h3>
<pre class="Agda"><a id="3864" class="Keyword">open</a> <a id="3869" class="Keyword">import</a> <a id="3876" href="Foundation.Prelude.HLevel.html" class="Module">Foundation.Prelude.HLevel</a> <a id="3902" class="Keyword">public</a>
</pre>
<p>如果说宇宙层级是类型宇宙 <code>𝕋 ℓ</code> 所具有的一种属性, 那么同伦层级 (hLevel) 则是类型 <code>A : 𝕋 ℓ</code> 所具有的一种属性. 我们只关心同伦层级为 1 和 2 的两种类型.</p>
<p>同伦层级为 1 的类型叫做命题, 该类类型的任意两个项都可证相等. “类型 <code>A</code> 是命题” 表达为 <code>isProp A</code>. 如所期待的那样, 类型 <code>isProp A</code> 也是一个命题, 即对任意 <code>A : 𝕋 ℓ</code> 可证 <code>isProp (isProp A)</code>. 我们也说 <code>isProp</code> 是一个谓词.</p>
<p>同伦层级为 2 的类型叫做集合, 该类类型的任意两个项的相等都是命题, 即给定两个项相等的任意两个证明, 这两个证明是相等的. “类型 <code>A</code> 是集合” 表达为 <code>isSet A</code>. 与 <code>isProp</code> 一样, <code>isSet</code> 也是一个谓词. 此外我们有 <code>isProp→isSet</code>, 即任意命题都是集合. 直观上, 由于命题的任意项都相等, 那么这些项之间的相等的方式也应该是相等的, 所以命题也是集合.</p>
<p>对于嵌套的Π类型, 不管嵌套多少次, 只要最后的目标是命题 (或集合), 那么整个嵌套Π类型也是命题 (或集合). 如果构成Σ类型的两边都是命题 (或集合), 那么这个Σ类型也是命题 (或集合).</p>
<h3 id="其他">其他</h3>
<pre class="Agda"><a id="4487" class="Keyword">open</a> <a id="4492" class="Keyword">import</a> <a id="4499" href="Foundation.Prelude.Misc.html" class="Module">Foundation.Prelude.Misc</a> <a id="4523" class="Keyword">public</a>
</pre>
<p>为了编码上的方便, 我们经常需要用 Agda 的反射机制定义的宏 <code>declareRecordIsoΣ</code> 将Σ类型与 record 类型相互转化. 我们把具有某种结构的类型宇宙叫做 <code>TypeWithStr</code>. 它其实就是一个Σ类型, 其左投影 <code>typ</code> 用于取得底类型, 右投影 <code>str</code> 用于取得底类型所带的结构.</p>
<h2 id="命题">命题</h2>
<p>元语言中需要能构造数学对象, 并且能谈论这些对象的性质. 前者由同伦层级为 2 的类型 (集合) 承担, 后者则由同伦层级为 1 的类型 (命题) 承担. 它们都是类型, 有统一的一些规则. 例如, 同样一个<strong>类型形成子 (type former)</strong> <code>→</code>, 作用于集合就成了函数, 作用于命题就成了蕴含. 本节将介绍关于命题的基本概念.</p>
<h3 id="命题截断">命题截断</h3>
<pre class="Agda"><a id="4897" class="Keyword">open</a> <a id="4902" class="Keyword">import</a> <a id="4909" href="Foundation.Prop.Truncation.html" class="Module">Foundation.Prop.Truncation</a> <a id="4936" class="Keyword">public</a>
</pre>
<p>命题截断 <code>∥_∥₁</code> 用于把一个可能不是命题的类型转化为命题. 命题截断是一个高阶归纳类型, 其构造子 <code>∣_∣₁</code> 用于构造命题截断的项, <code>is1</code> 用于证明命题截断后的类型的项确实都是相等的. 有以下常用引理:</p>
<ul>
<li><code>rec1</code> : 如果目标 <code>P</code> 是命题, 那么我们可以通过证明 <code>A → P</code> 来证明 <code>∥ A ∥₁ → P</code></li>
<li><code>rec1²</code> : 如果目标 <code>P</code> 是命题, 那么我们可以通过证明 <code>A → B → P</code> 来证明 <code>∥ A ∥₁ → ∥ B ∥₁ → P</code></li>
<li><code>map1</code> : 可以通过证明 <code>A → B</code> 来证明 <code>∥ A ∥₁ → ∥ B ∥₁</code></li>
<li><code>map1²</code> : 可以通过证明 <code>A → B → C</code> 来证明 <code>∥ A ∥₁ → ∥ B ∥₁ → ∥ C ∥₁</code></li>
<li><code>elim1</code> : <code>rec1</code> 的依值版本</li>
<li><code>elim1²</code> : <code>rec1²</code> 的依值版本</li>
</ul>
<h3 id="逻辑">逻辑</h3>
<pre class="Agda"><a id="5374" class="Keyword">open</a> <a id="5379" class="Keyword">import</a> <a id="5386" href="Foundation.Prop.Logic.html" class="Module">Foundation.Prop.Logic</a> <a id="5408" class="Keyword">public</a>
</pre>
<h4 id="无需截断">无需截断</h4>
<p>以下逻辑概念由相应的类型形成子直接承担, 而无需截断. 因为这些类型形成子作用于命题之上, 得到的类型也是命题.</p>
<ul>
<li>蕴含 <code>→</code>, 只要右边是命题就是命题</li>
<li>否定 <code>¬_</code>, 对任意类型都是命题</li>
<li>合取 <code>_×_</code>, 要求两边都是命题</li>
<li>全称量化 <code>∀ x →</code>, 只要右边是命题就是命题</li>
</ul>
<h4 id="析取">析取</h4>
<p>逻辑析取 <code>_∨_</code> 定义为<strong>和类型 (sum type)</strong> 的命题截断, 即 <code>A ∨ B = ∥ A ⊎ B ∥₁</code>. 因为和类型的项起码有两种 (左边或右边) 不同的构造方式, 但析取不关心具体是哪种, 所以必须要做命题截断, 以确保所有证明项都相等. 我们有析取的引入规则 <code>inl</code> 和 <code>inr</code>, 对于消去我们直接使用模式匹配.</p>
<p>注意对比合取. 我们不需要对积类型做命题截断以得到合取, 因为当 <code>_×_</code> 的两边都是命题的时候, 它的项只有一种构造方式, 所以它们之间的相等是自然成立的.</p>
<h4 id="存在量化">存在量化</h4>
<p>存在量化 <code>∃</code> 定义为<strong>Σ类型 (sigma type)</strong> 的命题截断, 即 <code>∃ A P = ∥ Σ A P ∥₁</code>. 因为Σ类型的项可能存在多种构造方式, 但存在量化不关心具体是哪种, 只要存在就行. 我们有存在量化的引入规则 <code>ex</code>, 对于消去我们直接使用模式匹配. 我们约定 <code>∃ A (λ x → P)</code> 可以简记为 <code>∃ x ꞉ A ， P</code> 或者 <code>∃ x ， P</code>.</p>
<h3 id="逻辑等价">逻辑等价</h3>
<pre class="Agda"><a id="6074" class="Keyword">open</a> <a id="6079" class="Keyword">import</a> <a id="6086" href="Foundation.Prop.Iff.html" class="Module">Foundation.Prop.Iff</a> <a id="6106" class="Keyword">public</a>
</pre>
<p>逻辑等价 <code>_↔︎_</code>, 也叫当且仅当 (iff), 定义为双向蕴含, 它是一个等价关系 (<code>↔︎-refl</code>, <code>↔︎-sym</code>, <code>↔︎-trans</code>). 只有当左右两边都是命题的时候, 逻辑等价才有意义. 此时, 它也是一个命题 (<code>isProp↔︎</code>).</p>
<p>注意, 我们把逻辑等价定义为了一个 record 类型, 必要时可以用宏转化为Σ类型. 该 record 类型的构造子 <code>⇒:_⇐:_</code> 充当了逻辑等价的引入规则, 消去规则则由 record 类型的投影 <code>.⇒</code> 和 <code>.⇐</code> 给出.</p>
<h3 id="命题宇宙">命题宇宙</h3>
<pre class="Agda"><a id="6384" class="Keyword">open</a> <a id="6389" class="Keyword">import</a> <a id="6396" href="Foundation.Prop.Universe.html" class="Module">Foundation.Prop.Universe</a> <a id="6421" class="Keyword">public</a>
</pre>
<p>命题宇宙 <code>ℙ ℓ</code> 定义为带命题结构 (<code>isProp</code>) 的类型宇宙 <code>𝕋 ℓ</code>, 即 <code>ℙ ℓ = TypeWithStr ℓ isProp</code>. 继承自类型宇宙的层级, 命题宇宙也分层级, 其中最底层记作 <code>ℙ₀</code>.</p>
<p>我们用粗体的<strong>命题</strong>指代命题宇宙的项, 以区分作为类型的命题. 我们约定使用 <code>𝗣 𝗤 𝗥</code> 等符号表示<strong>命题</strong>. “<strong>命题</strong> <code>𝗣</code> 成立”记作 <code>𝗣 holds</code>, 定义为左投影 <code>typ 𝗣</code>. 而右投影 <code>str 𝗣</code> 则说明了 <code>𝗣 holds</code> 确实是一个命题.</p>
<p>以下是<strong>命题</strong>的一些实例和性质:</p>
<ul>
<li>恒假<strong>命题</strong> <code>⊥ₚ</code>, 定义为 <code>⊥ , isProp⊥</code>, 因为 <code>⊥</code> 是一个命题</li>
<li>恒真<strong>命题</strong> <code>⊤ₚ</code>, 定义为 <code>⊤ , isProp⊤</code>, 因为 <code>⊤</code> 是一个命题</li>
<li>任意层级的命题宇宙 <code>ℙ ℓ</code> 本身是一个集合, 该性质记作 <code>isSetℙ</code></li>
<li>命题外延性 <code>propExt : isProp A → isProp B → A ↔︎ B → A ≡ B</code></li>
<li><strong>命题</strong>外延性 <code>ℙExt : 𝗣 holds ↔︎ 𝗤 holds → 𝗣 ≡ 𝗤</code></li>
<li>命题截断外延性 <code>propTruncExt : A ↔︎ B → ∥ A ∥₁ ≡ ∥ B ∥₁</code></li>
<li><strong>命题</strong>截断外延性 <code>ℙTruncExt : A ↔︎ B → ∥ A ∥ₚ ≡ ∥ B ∥ₚ</code></li>
</ul>
<p>其中<strong>命题</strong>截断 <code>∥ A ∥ₚ</code> 定义为 <code>∥ A ∥₁ , is1</code>.</p>
<h2 id="集合">集合</h2>
<pre class="Agda"><a id="7114" class="Keyword">open</a> <a id="7119" class="Keyword">import</a> <a id="7126" href="Foundation.Set.Powerset.html" class="Module">Foundation.Set.Powerset</a> <a id="7150" class="Keyword">public</a>
</pre>
<h2 id="函数-1">函数</h2>
<pre class="Agda"><a id="7177" class="Keyword">open</a> <a id="7182" class="Keyword">import</a> <a id="7189" href="Foundation.Function.Bundles.html" class="Module">Foundation.Function.Bundles</a> <a id="7217" class="Keyword">public</a>
<a id="7224" class="Keyword">open</a> <a id="7229" class="Keyword">import</a> <a id="7236" href="Foundation.Function.Sequance.html" class="Module">Foundation.Function.Sequance</a> <a id="7265" class="Keyword">public</a>
</pre>
<h2 id="数据类型">数据类型</h2>
<pre class="Agda"><a id="7294" class="Keyword">open</a> <a id="7299" class="Keyword">import</a> <a id="7306" href="Foundation.Data.Empty.html" class="Module">Foundation.Data.Empty</a> <a id="7328" class="Keyword">public</a>
<a id="7335" class="Keyword">open</a> <a id="7340" class="Keyword">import</a> <a id="7347" href="Foundation.Data.Unit.html" class="Module">Foundation.Data.Unit</a> <a id="7368" class="Keyword">public</a>
<a id="7375" class="Keyword">open</a> <a id="7380" class="Keyword">import</a> <a id="7387" href="Foundation.Data.Bool.html" class="Module">Foundation.Data.Bool</a> <a id="7408" class="Keyword">public</a>
<a id="7415" class="Keyword">open</a> <a id="7420" class="Keyword">import</a> <a id="7427" href="Foundation.Data.Nat.html" class="Module">Foundation.Data.Nat</a> <a id="7447" class="Keyword">public</a>
<a id="7454" class="Keyword">open</a> <a id="7459" class="Keyword">import</a> <a id="7466" href="Foundation.Data.Sigma.html" class="Module">Foundation.Data.Sigma</a> <a id="7488" class="Keyword">public</a>
<a id="7495" class="Keyword">open</a> <a id="7500" class="Keyword">import</a> <a id="7507" href="Foundation.Data.Sum.html" class="Module">Foundation.Data.Sum</a> <a id="7527" class="Keyword">public</a>
<a id="7534" class="Keyword">open</a> <a id="7539" class="Keyword">import</a> <a id="7546" href="Foundation.Data.List.html" class="Module">Foundation.Data.List</a> <a id="7567" class="Keyword">public</a>
<a id="7574" class="Keyword">open</a> <a id="7579" class="Keyword">import</a> <a id="7586" href="Foundation.Data.Vec.html" class="Module">Foundation.Data.Vec</a> <a id="7606" class="Keyword">public</a>
</pre>
<h2 id="关系">关系</h2>
<pre class="Agda"><a id="7633" class="Keyword">open</a> <a id="7638" class="Keyword">import</a> <a id="7645" href="Foundation.Relation.Nullary.Negation.html" class="Module">Foundation.Relation.Nullary.Negation</a> <a id="7682" class="Keyword">public</a>
<a id="7689" class="Keyword">open</a> <a id="7694" class="Keyword">import</a> <a id="7701" href="Foundation.Relation.Nullary.Decidable.html" class="Module">Foundation.Relation.Nullary.Decidable</a> <a id="7739" class="Keyword">public</a>
<a id="7746" class="Keyword">open</a> <a id="7751" class="Keyword">import</a> <a id="7758" href="Foundation.Relation.Nullary.Discrete.html" class="Module">Foundation.Relation.Nullary.Discrete</a> <a id="7795" class="Keyword">public</a>

<a id="7803" class="Keyword">open</a> <a id="7808" class="Keyword">import</a> <a id="7815" href="Foundation.Relation.Unary.Countable.html" class="Module">Foundation.Relation.Unary.Countable</a> <a id="7851" class="Keyword">public</a>
<a id="7858" class="Keyword">open</a> <a id="7863" class="Keyword">import</a> <a id="7870" href="Foundation.Relation.Unary.Enumerable.html" class="Module">Foundation.Relation.Unary.Enumerable</a> <a id="7907" class="Symbol">as</a> <a id="7910" class="Module">E</a> <a id="7912" class="Keyword">public</a>
<a id="7919" class="Keyword">open</a> <a id="7924" href="Foundation.Relation.Unary.Enumerable.html#2090" class="Module">E.ListView</a> <a id="7935" class="Keyword">public</a>
</pre>
<blockquote>
<p>知识共享许可协议: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC-BY-NC-SA 4.0</a><br />
<a href="https://github.com/choukh/MetaLogic/blob/main/src/Foundation/Essential.lagda.md">GitHub</a> | <a href="https://choukh.github.io/MetaLogic/Foundation.Essential.html">GitHub Pages</a> | <a href="https://www.yuque.com/ocau/metalogic/foundation.essential">语雀</a><br />
交流Q群: 893531731</p>
</blockquote>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
