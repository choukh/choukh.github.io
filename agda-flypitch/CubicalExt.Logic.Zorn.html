<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda佐恩引理</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda佐恩引理</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda佐恩引理" id="toc-agda佐恩引理">Agda佐恩引理</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#序理论" id="toc-序理论">序理论</a>
  <ul>
  <li><a href="#偏序" id="toc-偏序">偏序</a></li>
  <li><a href="#无界" id="toc-无界">无界</a></li>
  <li><a href="#最大元" id="toc-最大元">最大元</a></li>
  <li><a href="#链" id="toc-链">链</a></li>
  <li><a href="#上界" id="toc-上界">上界</a></li>
  <li><a href="#上确界" id="toc-上确界">上确界</a></li>
  <li><a href="#佐恩引理的表述" id="toc-佐恩引理的表述">佐恩引理的表述</a></li>
  </ul></li>
  <li><a href="#链集的链" id="toc-链集的链">链集的链</a>
  <ul>
  <li><a href="#偏序-1" id="toc-偏序-1">偏序</a></li>
  <li><a href="#上确界-1" id="toc-上确界-1">上确界</a></li>
  <li><a href="#后继性" id="toc-后继性">后继性</a></li>
  </ul></li>
  <li><a href="#构造矛盾" id="toc-构造矛盾">构造矛盾</a>
  <ul>
  <li><a href="#归纳构造塔" id="toc-归纳构造塔">归纳构造”塔”</a></li>
  <li><a href="#塔也是链" id="toc-塔也是链">“塔”也是链</a></li>
  <li><a href="#矛盾" id="toc-矛盾">矛盾</a></li>
  </ul></li>
  <li><a href="#选择公理" id="toc-选择公理">选择公理</a></li>
  <li><a href="#佐恩引理的证明" id="toc-佐恩引理的证明">佐恩引理的证明</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda佐恩引理">Agda佐恩引理</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-flypitch/blob/main/src/CubicalExt/Logic/Zorn.lagda.md">Zorn.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-flypitch/CubicalExt.Logic.Zorn.html">Zorn.html</a><br />
改编自: Coq <a href="https://github.com/coq-community/zorns-lemma/blob/master/ZornsLemma.v">ZornsLemma.v</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>佐恩引理是经典数学中最基础的定理之一. 然而, 作为直觉主义数学的前沿之一, 同伦类型论 (HoTT) 在经典领域的扩展并未获得太多研究关注. 本文旨在填补这一空白, 我们将在同伦类型论的框架下展示对佐恩引理这一经典定理的证明. 尽管本文的内容可以被视为 Agda 代码的注释, 我们仍然力求使其内容对于不熟悉 Agda 语言的读者也能理解其中的主要思路, 但前提是读者需要了解同伦类型论的基本概念. 例如我们会涉及到 <strong>命题截断 (propositional truncation)</strong> 和 <strong>命题宇宙调整</strong> (propositional resizing) 等概念, 需要读者对它们有一些基本了解.</p>
<p>我们工作在无公理的 cubical 环境中, 而选择公理将作为参数引入. 这里说的 cubical 指立方类型论 (cubical type theory), 它是同伦类型论的一种实现.</p>
<pre class="Agda"><a id="848" class="Symbol">{-#</a> <a id="852" class="Keyword">OPTIONS</a> <a id="860" class="Pragma">--cubical</a> <a id="870" class="Pragma">--safe</a> <a id="877" class="Symbol">#-}</a>
<a id="881" class="Symbol">{-#</a> <a id="885" class="Keyword">OPTIONS</a> <a id="893" class="Pragma">--lossy-unification</a> <a id="913" class="Symbol">#-}</a>

<a id="918" class="Keyword">module</a> <a id="925" href="CubicalExt.Logic.Zorn.html" class="Module">CubicalExt.Logic.Zorn</a> <a id="947" class="Keyword">where</a>
</pre>
<p>首先, 我们需要导入 Cubical 标准库模块. 同伦类型论 (乃至其立方类型论实现) 以其对”相等”这一基础概念的复杂诠释而广为人知. 在某些情况下 (如单集的定义中), 我们将使用立方类型论的 <code>Id</code> 类型, 因其可以便捷地进行模式匹配. 然而, 在大部分情况下, 我们更倾向于使用路径 <code>Path</code> 类型.</p>
<pre class="Agda"><a id="1126" class="Keyword">open</a> <a id="1131" class="Keyword">import</a> <a id="1138" href="Cubical.Core.Id.html" class="Module">Cubical.Core.Id</a> <a id="1154" class="Keyword">using</a> <a id="1160" class="Symbol">(</a><a id="1161" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="1167" class="Symbol">)</a>
<a id="1169" class="Keyword">open</a> <a id="1174" class="Keyword">import</a> <a id="1181" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="1209" class="Keyword">hiding</a> <a id="1216" class="Symbol">(</a><a id="1217" href="Cubical.Core.Primitives.html#403" class="Primitive">_∧_</a><a id="1220" class="Symbol">;</a> <a id="1222" href="Cubical.Core.Primitives.html#452" class="Primitive">_∨_</a><a id="1225" class="Symbol">)</a>
<a id="1227" class="Keyword">open</a> <a id="1232" class="Keyword">import</a> <a id="1239" href="Cubical.Foundations.HLevels.html" class="Module">Cubical.Foundations.HLevels</a>
<a id="1267" class="Keyword">open</a> <a id="1272" class="Keyword">import</a> <a id="1279" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a> <a id="1311" class="Keyword">using</a> <a id="1317" class="Symbol">(</a><a id="1318" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a><a id="1321" class="Symbol">)</a>
<a id="1323" class="Keyword">open</a> <a id="1328" class="Keyword">import</a> <a id="1335" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="1354" class="Symbol">as</a> <a id="1357" class="Module">⊥</a> <a id="1359" class="Keyword">using</a> <a id="1365" class="Symbol">(</a><a id="1366" href="Cubical.Data.Empty.Base.html#145" class="Datatype">⊥</a><a id="1367" class="Symbol">;</a> <a id="1369" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a><a id="1376" class="Symbol">)</a>
<a id="1378" class="Keyword">open</a> <a id="1383" class="Keyword">import</a> <a id="1390" href="Cubical.Data.Sigma.html" class="Module">Cubical.Data.Sigma</a> <a id="1409" class="Keyword">using</a> <a id="1415" class="Symbol">(</a><a id="1416" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃-syntax</a><a id="1424" class="Symbol">;</a> <a id="1426" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a><a id="1432" class="Symbol">;</a> <a id="1434" href="Cubical.Data.Sigma.Properties.html#2119" class="Function">PathPΣ</a><a id="1440" class="Symbol">)</a>
<a id="1442" class="Keyword">import</a> <a id="1449" href="Cubical.Data.Sum.html" class="Module">Cubical.Data.Sum</a> <a id="1466" class="Symbol">as</a> <a id="1469" class="Module">⊎</a>
<a id="1471" class="Keyword">open</a> <a id="1476" class="Keyword">import</a> <a id="1483" href="Cubical.HITs.PropositionalTruncation.html" class="Module">Cubical.HITs.PropositionalTruncation</a> <a id="1520" class="Keyword">using</a> <a id="1526" class="Symbol">(</a><a id="1527" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥_∥₁</a><a id="1531" class="Symbol">;</a> <a id="1533" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="1537" class="Symbol">;</a> <a id="1539" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a><a id="1546" class="Symbol">;</a> <a id="1548" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a><a id="1551" class="Symbol">;</a> <a id="1553" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a><a id="1557" class="Symbol">;</a> <a id="1559" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a><a id="1562" class="Symbol">)</a>
<a id="1564" class="Keyword">open</a> <a id="1569" class="Keyword">import</a> <a id="1576" href="Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a> <a id="1601" class="Keyword">using</a> <a id="1607" class="Symbol">(</a><a id="1608" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬_</a><a id="1610" class="Symbol">;</a> <a id="1612" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a><a id="1615" class="Symbol">;</a> <a id="1617" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a><a id="1620" class="Symbol">;</a> <a id="1622" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a><a id="1624" class="Symbol">)</a>
<a id="1626" class="Keyword">open</a> <a id="1631" class="Keyword">import</a> <a id="1638" href="Cubical.Relation.Binary.html" class="Module">Cubical.Relation.Binary</a>
<a id="1662" class="Keyword">open</a> <a id="1667" href="Cubical.Relation.Binary.Base.html#1455" class="Module">BinaryRelation</a>
</pre>
<p>以下是我们按照标准库风格额外编写的前置模块. 这些模块主要涉及经典逻辑和集合论的基本概念. 我们预设读者对这些概念有深入的理解, 因此不会再逐一进行解释.</p>
<pre class="Agda"><a id="1774" class="Keyword">open</a> <a id="1779" class="Keyword">import</a> <a id="1786" href="CubicalExt.Axiom.Choice.html" class="Module">CubicalExt.Axiom.Choice</a>
<a id="1810" class="Keyword">open</a> <a id="1815" class="Keyword">import</a> <a id="1822" href="CubicalExt.Axiom.ExcludedMiddle.html" class="Module">CubicalExt.Axiom.ExcludedMiddle</a>
<a id="1854" class="Keyword">open</a> <a id="1859" class="Keyword">import</a> <a id="1866" href="CubicalExt.Foundations.Powerset%252A.html" class="Module">CubicalExt.Foundations.Powerset*</a> <a id="1899" class="Keyword">hiding</a> <a id="1906" class="Symbol">(</a><a id="1907" href="CubicalExt.Foundations.Powerset%252A.html#1657" class="Function">U</a><a id="1908" class="Symbol">)</a>
<a id="1910" class="Keyword">open</a> <a id="1915" class="Keyword">import</a> <a id="1922" href="CubicalExt.Foundations.Function.html" class="Module">CubicalExt.Foundations.Function</a> <a id="1954" class="Keyword">using</a> <a id="1960" class="Symbol">(</a><a id="1961" href="Cubical.Foundations.Function.html#653" class="Function Operator">_∘_</a><a id="1964" class="Symbol">;</a> <a id="1966" href="Cubical.Foundations.Function.html#527" class="Function Operator">_$_</a><a id="1969" class="Symbol">;</a> <a id="1971" href="CubicalExt.Foundations.Function.html#739" class="Function">it</a><a id="1973" class="Symbol">)</a>
<a id="1975" class="Keyword">open</a> <a id="1980" class="Keyword">import</a> <a id="1987" href="CubicalExt.Functions.Logic.html" class="Module">CubicalExt.Functions.Logic</a> <a id="2014" class="Keyword">using</a> <a id="2020" class="Symbol">(</a><a id="2021" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥_∥ₚ</a><a id="2025" class="Symbol">;</a> <a id="2027" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">_∧_</a><a id="2030" class="Symbol">;</a> <a id="2032" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">_∨_</a><a id="2035" class="Symbol">;</a> <a id="2037" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a><a id="2040" class="Symbol">;</a> <a id="2042" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a><a id="2045" class="Symbol">;</a> <a id="2047" href="CubicalExt.Functions.Logic.html#620" class="Function">∨-elimˡ</a><a id="2054" class="Symbol">;</a> <a id="2056" href="CubicalExt.Functions.Logic.html#750" class="Function">∨-elimʳ</a><a id="2063" class="Symbol">)</a>
</pre>
<p>如果在后续的内容中出现了以下列出的变量, 但没有提前进行声明, 请理解为它们已作为隐式参数被引入，并具备以下规定的类型.</p>
<pre class="Agda"><a id="2140" class="Keyword">private</a> <a id="2148" class="Keyword">variable</a>
  <a id="2159" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a> <a id="2161" href="CubicalExt.Logic.Zorn.html#2161" class="Generalizable">u</a> <a id="2163" href="CubicalExt.Logic.Zorn.html#2163" class="Generalizable">r</a> <a id="2165" class="Symbol">:</a> <a id="2167" href="Agda.Primitive.html#591" class="Postulate">Level</a>
  <a id="2175" href="CubicalExt.Logic.Zorn.html#2175" class="Generalizable">U</a> <a id="2177" class="Symbol">:</a> <a id="2179" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2184" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a>
  <a id="2188" href="CubicalExt.Logic.Zorn.html#2188" class="Generalizable">A</a> <a id="2190" class="Symbol">:</a> <a id="2192" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="2194" href="CubicalExt.Logic.Zorn.html#2175" class="Generalizable">U</a> <a id="2196" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a>
</pre>
<p>其中 <code>Level</code> 是宇宙等级, <code>𝒫 U ℓ</code> 表示 <code>U</code> 的位于 <code>ℓ</code> 宇宙的幂集. 在后文中我们将假设排中律, 这将导致命题宇宙坍塌到一层. 从而幂集将不再有宇宙等级的区分, 使其更接近于传统意义上的幂集.</p>
<h2 id="序理论">序理论</h2>
<p>佐恩引理的表述需要序理论的基本概念. 我们将在本节中对这些概念进行简要的回顾. 给定类型 <code>U</code> 及其上的二元关系 <code>R</code>.</p>
<pre class="Agda"><a id="2394" class="Keyword">module</a> <a id="Order"></a><a id="2401" href="CubicalExt.Logic.Zorn.html#2401" class="Module">Order</a> <a id="2407" class="Symbol">{</a><a id="2408" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="2410" class="Symbol">:</a> <a id="2412" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2417" href="CubicalExt.Logic.Zorn.html#2161" class="Generalizable">u</a><a id="2418" class="Symbol">}</a> <a id="2420" class="Symbol">(</a><a id="2421" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a> <a id="2423" class="Symbol">:</a> <a id="2425" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="2429" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="2431" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="2433" href="CubicalExt.Logic.Zorn.html#2163" class="Generalizable">r</a><a id="2434" class="Symbol">)</a> <a id="2436" class="Keyword">where</a>
</pre>
<h3 id="偏序">偏序</h3>
<p>如果 <code>R</code> 取值到命题, 并且满足自反, 反对称和传递性, 则称 <code>R</code> 是偏序 (partial order).</p>
<pre class="Agda">  <a id="Order.isPo"></a><a id="2525" href="CubicalExt.Logic.Zorn.html#2525" class="Function">isPo</a> <a id="2530" class="Symbol">:</a> <a id="2532" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2537" class="Symbol">_</a>
  <a id="2541" href="CubicalExt.Logic.Zorn.html#2525" class="Function">isPo</a> <a id="2546" class="Symbol">=</a> <a id="2548" href="Cubical.Relation.Binary.Base.html#2245" class="Function">isPropValued</a> <a id="2561" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a> <a id="2563" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="2565" href="Cubical.Relation.Binary.Base.html#1523" class="Function">isRefl</a> <a id="2572" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a> <a id="2574" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="2576" href="Cubical.Relation.Binary.Base.html#1645" class="Function">isAntisym</a> <a id="2586" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a> <a id="2588" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="2590" href="Cubical.Relation.Binary.Base.html#1726" class="Function">isTrans</a> <a id="2598" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a>
</pre>
<p>如果 <code>R</code> 是偏序且 <code>U</code> 是集合, 则称 <code>U</code> 为偏序集.</p>
<pre class="Agda">  <a id="Order.isPoset"></a><a id="2650" href="CubicalExt.Logic.Zorn.html#2650" class="Function">isPoset</a> <a id="2658" class="Symbol">:</a> <a id="2660" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2665" class="Symbol">_</a>
  <a id="2669" href="CubicalExt.Logic.Zorn.html#2650" class="Function">isPoset</a> <a id="2677" class="Symbol">=</a> <a id="2679" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="2685" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="2687" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="2689" href="CubicalExt.Logic.Zorn.html#2525" class="Function">isPo</a>
</pre>
<h3 id="无界">无界</h3>
<p>我们又用中缀符号 <code>≤</code> 表示 <code>R</code> 关系.</p>
<pre class="Agda">  <a id="2742" class="Keyword">private</a> <a id="Order._≤_"></a><a id="2750" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">_≤_</a> <a id="2754" class="Symbol">=</a> <a id="2756" href="CubicalExt.Logic.Zorn.html#2421" class="Bound">R</a>
</pre>
<p>我们说 <code>U</code> 在 <code>R</code> 关系下是无界的, 当且仅当从任意 <code>x : U</code> 都能得到一个 <code>y : U</code> 严格大于 <code>x</code>.</p>
<pre class="Agda">  <a id="Order.unbound"></a><a id="2838" href="CubicalExt.Logic.Zorn.html#2838" class="Function">unbound</a> <a id="2846" class="Symbol">:</a> <a id="2848" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2853" class="Symbol">_</a>
  <a id="2857" href="CubicalExt.Logic.Zorn.html#2838" class="Function">unbound</a> <a id="2865" class="Symbol">=</a> <a id="2867" class="Symbol">∀</a> <a id="2869" href="CubicalExt.Logic.Zorn.html#2869" class="Bound">x</a> <a id="2871" class="Symbol">→</a> <a id="2873" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="2876" href="CubicalExt.Logic.Zorn.html#2876" class="Bound">y</a> <a id="2878" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="2880" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="2882" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="2884" href="CubicalExt.Logic.Zorn.html#2869" class="Bound">x</a> <a id="2886" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="2888" href="CubicalExt.Logic.Zorn.html#2876" class="Bound">y</a> <a id="2890" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="2892" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="2894" href="CubicalExt.Logic.Zorn.html#2869" class="Bound">x</a> <a id="2896" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2898" href="CubicalExt.Logic.Zorn.html#2876" class="Bound">y</a>
</pre>
<p>我们说 <code>U</code> 在 <code>R</code> 关系下是后继的, 当且仅当它是无界的, 且见证无界的那个 <code>y</code> 刚好比 <code>x</code> 大, 也就是说它们之间没有其他元素.</p>
<pre class="Agda">  <a id="Order.successive"></a><a id="2990" href="CubicalExt.Logic.Zorn.html#2990" class="Function">successive</a> <a id="3001" class="Symbol">:</a> <a id="3003" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3008" class="Symbol">_</a>
  <a id="3012" href="CubicalExt.Logic.Zorn.html#2990" class="Function">successive</a> <a id="3023" class="Symbol">=</a> <a id="3025" class="Symbol">∀</a> <a id="3027" href="CubicalExt.Logic.Zorn.html#3027" class="Bound">x</a> <a id="3029" class="Symbol">→</a> <a id="3031" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3034" href="CubicalExt.Logic.Zorn.html#3034" class="Bound">y</a> <a id="3036" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3038" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3040" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3042" href="CubicalExt.Logic.Zorn.html#3027" class="Bound">x</a> <a id="3044" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3046" href="CubicalExt.Logic.Zorn.html#3034" class="Bound">y</a> <a id="3048" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="3050" class="Symbol">(</a><a id="3051" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="3053" href="CubicalExt.Logic.Zorn.html#3027" class="Bound">x</a> <a id="3055" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3057" href="CubicalExt.Logic.Zorn.html#3034" class="Bound">y</a><a id="3058" class="Symbol">)</a> <a id="3060" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="3062" class="Symbol">∀</a> <a id="3064" href="CubicalExt.Logic.Zorn.html#3064" class="Bound">z</a> <a id="3066" class="Symbol">→</a> <a id="3068" href="CubicalExt.Logic.Zorn.html#3027" class="Bound">x</a> <a id="3070" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3072" href="CubicalExt.Logic.Zorn.html#3064" class="Bound">z</a> <a id="3074" class="Symbol">→</a> <a id="3076" href="CubicalExt.Logic.Zorn.html#3064" class="Bound">z</a> <a id="3078" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3080" href="CubicalExt.Logic.Zorn.html#3034" class="Bound">y</a> <a id="3082" class="Symbol">→</a> <a id="3084" href="CubicalExt.Logic.Zorn.html#3064" class="Bound">z</a> <a id="3086" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3088" href="CubicalExt.Logic.Zorn.html#3027" class="Bound">x</a> <a id="3090" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="3092" href="CubicalExt.Logic.Zorn.html#3064" class="Bound">z</a> <a id="3094" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3096" href="CubicalExt.Logic.Zorn.html#3034" class="Bound">y</a>
</pre>
<h3 id="最大元">最大元</h3>
<p>对任意大于等于 <code>m</code> 的元素, 如果它其实都等于 <code>m</code>, 那么称 <code>m</code> 是 <code>U</code> 的最大元.</p>
<pre class="Agda">  <a id="Order.maximum"></a><a id="3174" href="CubicalExt.Logic.Zorn.html#3174" class="Function">maximum</a> <a id="3182" class="Symbol">:</a> <a id="3184" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3186" class="Symbol">→</a> <a id="3188" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3193" class="Symbol">_</a>
  <a id="3197" href="CubicalExt.Logic.Zorn.html#3174" class="Function">maximum</a> <a id="3205" href="CubicalExt.Logic.Zorn.html#3205" class="Bound">m</a> <a id="3207" class="Symbol">=</a> <a id="3209" class="Symbol">∀</a> <a id="3211" href="CubicalExt.Logic.Zorn.html#3211" class="Bound">x</a> <a id="3213" class="Symbol">→</a> <a id="3215" href="CubicalExt.Logic.Zorn.html#3205" class="Bound">m</a> <a id="3217" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3219" href="CubicalExt.Logic.Zorn.html#3211" class="Bound">x</a> <a id="3221" class="Symbol">→</a> <a id="3223" href="CubicalExt.Logic.Zorn.html#3205" class="Bound">m</a> <a id="3225" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3227" href="CubicalExt.Logic.Zorn.html#3211" class="Bound">x</a>
</pre>
<p>注意无界与存在最大元是不相容的.</p>
<h3 id="链">链</h3>
<p>现在, 考虑 <code>U</code> 的子集 <code>A</code>, 如果其中的任意两个元素都可以比较大小, 我们就说 <code>A</code> 是链, 也叫 <code>U</code> 的全序子集.</p>
<pre class="Agda">  <a id="Order.isChain"></a><a id="3337" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="3345" class="Symbol">:</a> <a id="3347" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="3349" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3351" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a> <a id="3353" class="Symbol">→</a> <a id="3355" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3360" class="Symbol">_</a>
  <a id="3364" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="3372" href="CubicalExt.Logic.Zorn.html#3372" class="Bound">A</a> <a id="3374" class="Symbol">=</a> <a id="3376" class="Symbol">∀</a> <a id="3378" href="CubicalExt.Logic.Zorn.html#3378" class="Bound">x</a> <a id="3380" href="CubicalExt.Logic.Zorn.html#3380" class="Bound">y</a> <a id="3382" class="Symbol">→</a> <a id="3384" href="CubicalExt.Logic.Zorn.html#3378" class="Bound">x</a> <a id="3386" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="3388" href="CubicalExt.Logic.Zorn.html#3372" class="Bound">A</a> <a id="3390" class="Symbol">→</a> <a id="3392" href="CubicalExt.Logic.Zorn.html#3380" class="Bound">y</a> <a id="3394" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="3396" href="CubicalExt.Logic.Zorn.html#3372" class="Bound">A</a> <a id="3398" class="Symbol">→</a> <a id="3400" href="CubicalExt.Logic.Zorn.html#3378" class="Bound">x</a> <a id="3402" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3404" href="CubicalExt.Logic.Zorn.html#3380" class="Bound">y</a> <a id="3406" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="3408" href="CubicalExt.Logic.Zorn.html#3380" class="Bound">y</a> <a id="3410" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3412" href="CubicalExt.Logic.Zorn.html#3378" class="Bound">x</a>
</pre>
<p>注意 <code>∨</code> 是和类型 <code>⊎</code> 的命题截断, 从而保证了”某某是链”是一个命题. 后面要用到这一性质.</p>
<pre class="Agda">  <a id="Order.isPropIsChain"></a><a id="3482" href="CubicalExt.Logic.Zorn.html#3482" class="Function">isPropIsChain</a> <a id="3496" class="Symbol">:</a> <a id="3498" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3505" class="Symbol">(</a><a id="3506" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="3514" href="CubicalExt.Logic.Zorn.html#2188" class="Generalizable">A</a><a id="3515" class="Symbol">)</a>
  <a id="3519" href="CubicalExt.Logic.Zorn.html#3482" class="Function">isPropIsChain</a> <a id="3533" class="Symbol">=</a> <a id="3535" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="3544" class="Symbol">λ</a> <a id="3546" href="CubicalExt.Logic.Zorn.html#3546" class="Bound">_</a> <a id="3548" href="CubicalExt.Logic.Zorn.html#3548" class="Bound">_</a> <a id="3550" class="Symbol">→</a> <a id="3552" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="3561" class="Symbol">λ</a> <a id="3563" href="CubicalExt.Logic.Zorn.html#3563" class="Bound">_</a> <a id="3565" href="CubicalExt.Logic.Zorn.html#3565" class="Bound">_</a> <a id="3567" class="Symbol">→</a> <a id="3569" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
</pre>
<h3 id="上界">上界</h3>
<p>给定 <code>A</code> 和 <code>ub : U</code>, 如果 <code>ub</code> 比 <code>A</code> 的任意元素都要大, 则称 <code>ub</code> 是 <code>A</code> 的上界. 注意上界不一定在 <code>A</code> 中.</p>
<pre class="Agda">  <a id="Order.upperBound"></a><a id="3679" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="3690" class="Symbol">:</a> <a id="3692" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="3694" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3696" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a> <a id="3698" class="Symbol">→</a> <a id="3700" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3702" class="Symbol">→</a> <a id="3704" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3709" class="Symbol">_</a>
  <a id="3713" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="3724" href="CubicalExt.Logic.Zorn.html#3724" class="Bound">A</a> <a id="3726" href="CubicalExt.Logic.Zorn.html#3726" class="Bound">ub</a> <a id="3729" class="Symbol">=</a> <a id="3731" class="Symbol">∀</a> <a id="3733" href="CubicalExt.Logic.Zorn.html#3733" class="Bound">x</a> <a id="3735" class="Symbol">→</a> <a id="3737" href="CubicalExt.Logic.Zorn.html#3733" class="Bound">x</a> <a id="3739" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="3741" href="CubicalExt.Logic.Zorn.html#3724" class="Bound">A</a> <a id="3743" class="Symbol">→</a> <a id="3745" href="CubicalExt.Logic.Zorn.html#3733" class="Bound">x</a> <a id="3747" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="3749" href="CubicalExt.Logic.Zorn.html#3726" class="Bound">ub</a>
</pre>
<p>由以上定义, “所有链都可以找到上界”表述如下.</p>
<pre class="Agda">  <a id="Order.allChainHasUb"></a><a id="3793" href="CubicalExt.Logic.Zorn.html#3793" class="Function">allChainHasUb</a> <a id="3807" class="Symbol">=</a> <a id="3809" class="Symbol">∀</a> <a id="3811" class="Symbol">{</a><a id="3812" href="CubicalExt.Logic.Zorn.html#3812" class="Bound">ℓ</a><a id="3813" class="Symbol">}</a> <a id="3815" class="Symbol">(</a><a id="3816" href="CubicalExt.Logic.Zorn.html#3816" class="Bound">A</a> <a id="3818" class="Symbol">:</a> <a id="3820" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="3822" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3824" href="CubicalExt.Logic.Zorn.html#3812" class="Bound">ℓ</a><a id="3825" class="Symbol">)</a> <a id="3827" class="Symbol">→</a> <a id="3829" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="3837" href="CubicalExt.Logic.Zorn.html#3816" class="Bound">A</a> <a id="3839" class="Symbol">→</a> <a id="3841" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3844" href="CubicalExt.Logic.Zorn.html#3844" class="Bound">ub</a> <a id="3847" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3849" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3851" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3853" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="3864" href="CubicalExt.Logic.Zorn.html#3816" class="Bound">A</a> <a id="3866" href="CubicalExt.Logic.Zorn.html#3844" class="Bound">ub</a>
</pre>
<h3 id="上确界">上确界</h3>
<p>给定 <code>A</code> 和 <code>sup : U</code>, 如果 <code>sup</code> 是 <code>A</code> 的最小上界, 则称 <code>sup</code> 是 <code>A</code> 的上确界. 注意上确界也不一定在 <code>A</code> 中.</p>
<pre class="Agda">  <a id="Order.supremum"></a><a id="3975" href="CubicalExt.Logic.Zorn.html#3975" class="Function">supremum</a> <a id="3984" class="Symbol">:</a> <a id="3986" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="3988" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3990" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a> <a id="3992" class="Symbol">→</a> <a id="3994" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="3996" class="Symbol">→</a> <a id="3998" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4003" class="Symbol">_</a>
  <a id="4007" href="CubicalExt.Logic.Zorn.html#3975" class="Function">supremum</a> <a id="4016" href="CubicalExt.Logic.Zorn.html#4016" class="Bound">A</a> <a id="4018" href="CubicalExt.Logic.Zorn.html#4018" class="Bound">sup</a> <a id="4022" class="Symbol">=</a> <a id="4024" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="4035" href="CubicalExt.Logic.Zorn.html#4016" class="Bound">A</a> <a id="4037" href="CubicalExt.Logic.Zorn.html#4018" class="Bound">sup</a> <a id="4041" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="4043" class="Symbol">∀</a> <a id="4045" href="CubicalExt.Logic.Zorn.html#4045" class="Bound">ub</a> <a id="4048" class="Symbol">→</a> <a id="4050" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="4061" href="CubicalExt.Logic.Zorn.html#4016" class="Bound">A</a> <a id="4063" href="CubicalExt.Logic.Zorn.html#4045" class="Bound">ub</a> <a id="4066" class="Symbol">→</a> <a id="4068" href="CubicalExt.Logic.Zorn.html#4018" class="Bound">sup</a> <a id="4072" href="CubicalExt.Logic.Zorn.html#2750" class="Function Operator">≤</a> <a id="4074" href="CubicalExt.Logic.Zorn.html#4045" class="Bound">ub</a>
</pre>
<p>由以上定义, “所有链都可以找到上确界”表述如下.</p>
<pre class="Agda">  <a id="Order.allChainHasSup"></a><a id="4119" href="CubicalExt.Logic.Zorn.html#4119" class="Function">allChainHasSup</a> <a id="4134" class="Symbol">=</a> <a id="4136" class="Symbol">∀</a> <a id="4138" class="Symbol">{</a><a id="4139" href="CubicalExt.Logic.Zorn.html#4139" class="Bound">ℓ</a><a id="4140" class="Symbol">}</a> <a id="4142" class="Symbol">(</a><a id="4143" href="CubicalExt.Logic.Zorn.html#4143" class="Bound">A</a> <a id="4145" class="Symbol">:</a> <a id="4147" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="4149" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="4151" href="CubicalExt.Logic.Zorn.html#4139" class="Bound">ℓ</a><a id="4152" class="Symbol">)</a> <a id="4154" class="Symbol">→</a> <a id="4156" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="4164" href="CubicalExt.Logic.Zorn.html#4143" class="Bound">A</a> <a id="4166" class="Symbol">→</a> <a id="4168" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="4171" href="CubicalExt.Logic.Zorn.html#4171" class="Bound">sup</a> <a id="4175" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="4177" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="4179" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="4181" href="CubicalExt.Logic.Zorn.html#3975" class="Function">supremum</a> <a id="4190" href="CubicalExt.Logic.Zorn.html#4143" class="Bound">A</a> <a id="4192" href="CubicalExt.Logic.Zorn.html#4171" class="Bound">sup</a>
</pre>
<h3 id="佐恩引理的表述">佐恩引理的表述</h3>
<p>经过以上的概念铺垫, 我们现在可以正式阐述佐恩引理. 佐恩引理是说: 对任意偏序集 <code>U</code>, 如果 <code>U</code> 中所有的链都能<strong>找到</strong>上界, 那么 <code>U</code> 中<strong>存在</strong>一个最大元.</p>
<pre class="Agda">  <a id="Order.Zorn"></a><a id="4317" href="CubicalExt.Logic.Zorn.html#4317" class="Function">Zorn</a> <a id="4322" class="Symbol">=</a> <a id="4324" href="CubicalExt.Logic.Zorn.html#2650" class="Function">isPoset</a> <a id="4332" class="Symbol">→</a> <a id="4334" href="CubicalExt.Logic.Zorn.html#3793" class="Function">allChainHasUb</a> <a id="4348" class="Symbol">→</a> <a id="4350" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="4353" href="CubicalExt.Logic.Zorn.html#4353" class="Bound">m</a> <a id="4355" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="4357" href="CubicalExt.Logic.Zorn.html#2408" class="Bound">U</a> <a id="4359" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="4361" href="CubicalExt.Logic.Zorn.html#3174" class="Function">maximum</a> <a id="4369" href="CubicalExt.Logic.Zorn.html#4353" class="Bound">m</a>
</pre>
<p>需要注意的是, 我们仅将 <code>Σ</code> 的命题截断 <code>∃</code> 称为<em>存在</em>, 而对于 <code>Σ</code>, 我们会用诸如<em>找到</em>, <em>取到</em>, <em>得到</em>等表述. “存在”不一定能”取到”, 但能”取到”则一定”存在”. 我们尽量避免使用 <em>有</em> 这种模糊的说法.</p>
<p>当然, 佐恩引理的表述可以进一步强化为”对任意偏序集 <code>U</code>, 如果 <code>U</code> 中所有的链都<strong>存在</strong>上确界, 那么 <code>U</code> 中<strong>存在</strong>一个最大元”. 只需要用命题截断的 <code>rec</code>, 就可以证明前者蕴含后者. 然而, 我们习惯避免在前提中使用截断, 等到需要时再用 <code>rec</code> 得到截断版本.</p>
<p>佐恩引理的证明思路中反直觉的地方是我们并非直接考虑链本身, 而是考虑由所有链构成的集合在包含关系下构成的链.</p>
<h2 id="链集的链">链集的链</h2>
<p>现在, 假设排中律, 并给定偏序 <code>≤</code>.</p>
<pre class="Agda"><a id="4746" class="Keyword">module</a> <a id="Chain"></a><a id="4753" href="CubicalExt.Logic.Zorn.html#4753" class="Module">Chain</a> <a id="4759" class="Symbol">⦃</a> <a id="4761" href="CubicalExt.Logic.Zorn.html#4761" class="Bound">em</a> <a id="4764" class="Symbol">:</a> <a id="4766" class="Symbol">∀</a> <a id="4768" class="Symbol">{</a><a id="4769" href="CubicalExt.Logic.Zorn.html#4769" class="Bound">ℓ</a><a id="4770" class="Symbol">}</a> <a id="4772" class="Symbol">→</a> <a id="4774" href="CubicalExt.Axiom.ExcludedMiddle.html#460" class="Function">EM</a> <a id="4777" href="CubicalExt.Logic.Zorn.html#4769" class="Bound">ℓ</a> <a id="4779" class="Symbol">⦄</a> <a id="4781" class="Symbol">{</a><a id="4782" href="CubicalExt.Logic.Zorn.html#4782" class="Bound">U</a> <a id="4784" class="Symbol">:</a> <a id="4786" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4791" href="CubicalExt.Logic.Zorn.html#2161" class="Generalizable">u</a><a id="4792" class="Symbol">}</a> <a id="4794" class="Symbol">(</a><a id="4795" href="CubicalExt.Logic.Zorn.html#4795" class="Bound Operator">_≤_</a> <a id="4799" class="Symbol">:</a> <a id="4801" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="4805" href="CubicalExt.Logic.Zorn.html#4782" class="Bound">U</a> <a id="4807" href="CubicalExt.Logic.Zorn.html#4782" class="Bound">U</a> <a id="4809" href="CubicalExt.Logic.Zorn.html#2163" class="Generalizable">r</a><a id="4810" class="Symbol">)</a> <a id="4812" class="Keyword">where</a>
  <a id="4820" class="Keyword">open</a> <a id="4825" class="Keyword">import</a> <a id="4832" href="CubicalExt.Logic.Classical.html" class="Module">CubicalExt.Logic.Classical</a>
  <a id="4861" class="Keyword">open</a> <a id="4866" class="Keyword">module</a> <a id="Chain.≤"></a><a id="4873" href="CubicalExt.Logic.Zorn.html#4873" class="Module">≤</a> <a id="4875" class="Symbol">=</a> <a id="4877" href="CubicalExt.Logic.Zorn.html#2401" class="Module">Order</a> <a id="4883" href="CubicalExt.Logic.Zorn.html#4795" class="Bound Operator">_≤_</a>
</pre>
<p>我们把 <code>U</code> 的子集 <code>A</code> 配备上链条件所得到的类型 <code>Chain</code> 叫做链集.</p>
<pre class="Agda">  <a id="Chain.Chain"></a><a id="4946" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="4952" class="Symbol">:</a> <a id="4954" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4959" class="Symbol">_</a>
  <a id="4963" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="4969" class="Symbol">=</a> <a id="4971" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="4974" href="CubicalExt.Logic.Zorn.html#4974" class="Bound">A</a> <a id="4976" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="4978" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="4980" href="CubicalExt.Logic.Zorn.html#4782" class="Bound">U</a> <a id="4982" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a> <a id="4989" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="4991" href="CubicalExt.Logic.Zorn.html#3337" class="Function">≤.isChain</a> <a id="5001" href="CubicalExt.Logic.Zorn.html#4974" class="Bound">A</a>
</pre>
<p>可以证明 <code>Chain</code> 是集合.</p>
<pre class="Agda">  <a id="5037" href="CubicalExt.Logic.Zorn.html#5037" class="Function">_</a> <a id="5039" class="Symbol">:</a> <a id="5041" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="5047" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a>
  <a id="5055" class="Symbol">_</a> <a id="5057" class="Symbol">=</a> <a id="5059" href="Cubical.Foundations.HLevels.html#12848" class="Function">isSetΣ</a> <a id="5066" class="Symbol">(</a><a id="5067" href="Cubical.Foundations.HLevels.html#17906" class="Function">isSetΠ</a> <a id="5074" class="Symbol">λ</a> <a id="5076" href="CubicalExt.Logic.Zorn.html#5076" class="Bound">_</a> <a id="5078" class="Symbol">→</a> <a id="5080" href="Cubical.Foundations.HLevels.html#22223" class="Function">isSetHProp</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">λ</a> <a id="5094" href="CubicalExt.Logic.Zorn.html#5094" class="Bound">_</a> <a id="5096" class="Symbol">→</a> <a id="5098" href="Cubical.Foundations.Prelude.html#18523" class="Function">isProp→isSet</a> <a id="5111" href="CubicalExt.Logic.Zorn.html#3482" class="Function">isPropIsChain</a>
</pre>
<h3 id="偏序-1">偏序</h3>
<p>定义链集上的二元关系 <code>⪯</code> 为链之间的包含关系.</p>
<pre class="Agda">  <a id="Chain._⪯_"></a><a id="5175" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a> <a id="5179" class="Symbol">:</a> <a id="5181" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="5185" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="5191" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="5197" href="CubicalExt.Logic.Zorn.html#4791" class="Bound">u</a>
  <a id="5201" href="CubicalExt.Logic.Zorn.html#5201" class="Bound">a</a> <a id="5203" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">⪯</a> <a id="5205" href="CubicalExt.Logic.Zorn.html#5205" class="Bound">b</a> <a id="5207" class="Symbol">=</a> <a id="5209" href="CubicalExt.Logic.Zorn.html#5201" class="Bound">a</a> <a id="5211" class="Symbol">.</a><a id="5212" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="5216" href="CubicalExt.Foundations.Powerset%252A.html#2159" class="Function Operator">⊆</a> <a id="5218" href="CubicalExt.Logic.Zorn.html#5205" class="Bound">b</a> <a id="5220" class="Symbol">.</a><a id="5221" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p>由于集合的包含关系是偏序, 所以 <code>⪯</code> 也是偏序.</p>
<pre class="Agda">  <a id="Chain.⪯-prop"></a><a id="5268" href="CubicalExt.Logic.Zorn.html#5268" class="Function">⪯-prop</a> <a id="5275" class="Symbol">:</a> <a id="5277" href="Cubical.Relation.Binary.Base.html#2245" class="Function">isPropValued</a> <a id="5290" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a>
  <a id="5296" href="CubicalExt.Logic.Zorn.html#5268" class="Function">⪯-prop</a> <a id="5303" class="Symbol">_</a> <a id="5305" class="Symbol">_</a> <a id="5307" class="Symbol">=</a> <a id="5309" href="CubicalExt.Foundations.Powerset%252A.html#2221" class="Function">⊆-isProp</a> <a id="5318" class="Symbol">_</a> <a id="5320" class="Symbol">_</a>

  <a id="Chain.⪯-refl"></a><a id="5325" href="CubicalExt.Logic.Zorn.html#5325" class="Function">⪯-refl</a> <a id="5332" class="Symbol">:</a> <a id="5334" href="Cubical.Relation.Binary.Base.html#1523" class="Function">isRefl</a> <a id="5341" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a>
  <a id="5347" href="CubicalExt.Logic.Zorn.html#5325" class="Function">⪯-refl</a> <a id="5354" class="Symbol">=</a> <a id="5356" href="CubicalExt.Foundations.Powerset%252A.html#2343" class="Function">⊆-refl</a> <a id="5363" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="5365" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>

  <a id="Chain.⪯-antisym"></a><a id="5372" href="CubicalExt.Logic.Zorn.html#5372" class="Function">⪯-antisym</a> <a id="5382" class="Symbol">:</a> <a id="5384" href="Cubical.Relation.Binary.Base.html#1645" class="Function">isAntisym</a> <a id="5394" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a>
  <a id="5400" href="CubicalExt.Logic.Zorn.html#5372" class="Function">⪯-antisym</a> <a id="5410" class="Symbol">_</a> <a id="5412" class="Symbol">_</a> <a id="5414" href="CubicalExt.Logic.Zorn.html#5414" class="Bound">H₁</a> <a id="5417" href="CubicalExt.Logic.Zorn.html#5417" class="Bound">H₂</a> <a id="5420" class="Symbol">=</a> <a id="5422" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="5429" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5431" href="CubicalExt.Foundations.Powerset%252A.html#3114" class="Function">⊆-antisym</a> <a id="5441" class="Symbol">_</a> <a id="5443" class="Symbol">_</a> <a id="5445" href="CubicalExt.Logic.Zorn.html#5414" class="Bound">H₁</a> <a id="5448" href="CubicalExt.Logic.Zorn.html#5417" class="Bound">H₂</a> <a id="5451" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5453" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="5461" class="Symbol">(</a><a id="5462" href="CubicalExt.Logic.Zorn.html#3482" class="Function">≤.isPropIsChain</a> <a id="5478" class="Symbol">_</a> <a id="5480" class="Symbol">_)</a>

  <a id="Chain.⪯-trans"></a><a id="5486" href="CubicalExt.Logic.Zorn.html#5486" class="Function">⪯-trans</a> <a id="5494" class="Symbol">:</a> <a id="5496" href="Cubical.Relation.Binary.Base.html#1726" class="Function">isTrans</a> <a id="5504" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a>
  <a id="5510" href="CubicalExt.Logic.Zorn.html#5486" class="Function">⪯-trans</a> <a id="5518" class="Symbol">_</a> <a id="5520" class="Symbol">_</a> <a id="5522" class="Symbol">_</a> <a id="5524" href="CubicalExt.Logic.Zorn.html#5524" class="Bound">H₁</a> <a id="5527" href="CubicalExt.Logic.Zorn.html#5527" class="Bound">H₂</a> <a id="5530" href="CubicalExt.Logic.Zorn.html#5530" class="Bound">x∈</a> <a id="5533" class="Symbol">=</a> <a id="5535" href="CubicalExt.Logic.Zorn.html#5527" class="Bound">H₂</a> <a id="5538" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5540" href="CubicalExt.Logic.Zorn.html#5524" class="Bound">H₁</a> <a id="5543" href="CubicalExt.Logic.Zorn.html#5530" class="Bound">x∈</a>

  <a id="5549" class="Keyword">open</a> <a id="5554" class="Keyword">module</a> <a id="Chain.⪯"></a><a id="5561" href="CubicalExt.Logic.Zorn.html#5561" class="Module">⪯</a> <a id="5563" class="Symbol">=</a> <a id="5565" href="CubicalExt.Logic.Zorn.html#2401" class="Module">Order</a> <a id="5571" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">_⪯_</a>

  <a id="Chain.⪯-po"></a><a id="5578" href="CubicalExt.Logic.Zorn.html#5578" class="Function">⪯-po</a> <a id="5583" class="Symbol">:</a> <a id="5585" href="CubicalExt.Logic.Zorn.html#2525" class="Function">⪯.isPo</a>
  <a id="5594" href="CubicalExt.Logic.Zorn.html#5578" class="Function">⪯-po</a> <a id="5599" class="Symbol">=</a> <a id="5601" href="CubicalExt.Logic.Zorn.html#5268" class="Function">⪯-prop</a> <a id="5608" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5610" href="CubicalExt.Logic.Zorn.html#5325" class="Function">⪯-refl</a> <a id="5617" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5619" href="CubicalExt.Logic.Zorn.html#5372" class="Function">⪯-antisym</a> <a id="5629" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5631" href="CubicalExt.Logic.Zorn.html#5486" class="Function">⪯-trans</a>
</pre>
<p>现在我们有了两个偏序, 一个是 <code>U</code> 上的 <code>≤</code>, 一个是链集上的 <code>⪯</code>. 为避免混淆, 接下来我们会对相关概念加上 <code>≤</code> 或 <code>⪯</code> 前缀, 来指明该概念所涉及的偏序.</p>
<h3 id="上确界-1">上确界</h3>
<p>现在考虑链集的链. 注意, 尽管链集中的每个元素都是 ≤-链, 但这里我们说的是由链集中的元素组成的 ⪯-链.</p>
<p>对任意 ⪯-链 <code>A</code>, 我们可以找到其上确界, 只需取 <code>A</code> 中所有 ≤-链的”并”. 也就是说, 并作为一个集合, 其中的任意 <code>x</code>, 都需要存在一条 ≤-链 <code>a₁</code> 容纳它, 且 <code>a₁</code> 作为链集的一个元素 <code>a</code>, 必须在 <code>A</code> 中.</p>
<p>需要注意的是, <code>Chain</code> 的定义仅接受 <code>U</code> 的位于最低宇宙的子集, 为了使我们这里定义的并确实具有 <code>Chain</code> 类型, 需要将上述”并”<strong>调整</strong> (<code>Resize</code>) 到最低宇宙. 由于我们假设了排中律, 这是可以做到的. 关于具体的方法, 读者可以点击代码中的 <code>Resize</code> 查看其定义.</p>
<p>关于<strong>命题宇宙调整</strong> (propositional resizing), 以下摘自 GPT4:</p>
<blockquote>
<p>在类型论中，propositional resizing 是一个复杂的概念，涉及到如何处理命题的“大小”。这主要在同伦类型论（Homotopy Type Theory, HoTT）中出现。在类型论中，我们可以把命题看作类型，证明看作这些类型的元素。但是，不同的命题可能对应不同”大小”的类型。例如，存在性命题可能需要一个大的类型（比如，所有的自然数），而其他命题可能只需要一个小的类型（比如，真或假）。propositional resizing 就是允许我们在不改变命题的逻辑含义的情况下，改变它所对应的类型的大小。具体来说，如果我们有一个命题 P 对应的类型在一个大的类型中，而我们希望在一个小的类型中使用它，那么我们就可以使用 propositional resizing 来“缩小”它。在实际应用中，propositional resizing 能够帮助我们更灵活地处理命题和证明，特别是在处理那些涉及到无穷集合的问题时。</p>
</blockquote>
<pre class="Agda">  <a id="Chain.sup"></a><a id="6567" href="CubicalExt.Logic.Zorn.html#6567" class="Function">sup</a> <a id="6571" class="Symbol">:</a> <a id="6573" class="Symbol">(</a><a id="6574" href="CubicalExt.Logic.Zorn.html#6574" class="Bound">A</a> <a id="6576" class="Symbol">:</a> <a id="6578" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="6580" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="6586" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a><a id="6587" class="Symbol">)</a> <a id="6589" class="Symbol">→</a> <a id="6591" href="CubicalExt.Logic.Zorn.html#3337" class="Function">⪯.isChain</a> <a id="6601" href="CubicalExt.Logic.Zorn.html#6574" class="Bound">A</a> <a id="6603" class="Symbol">→</a> <a id="6605" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a>
  <a id="6613" href="CubicalExt.Logic.Zorn.html#6567" class="Function">sup</a> <a id="6617" href="CubicalExt.Logic.Zorn.html#6617" class="Bound">A</a> <a id="6619" href="CubicalExt.Logic.Zorn.html#6619" class="Bound">isChainA</a> <a id="6628" class="Symbol">=</a> <a id="6630" href="CubicalExt.Logic.Classical.html#1917" class="Function">Resize</a> <a id="6637" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="6639" class="Symbol">(λ</a> <a id="6642" href="CubicalExt.Logic.Zorn.html#6642" class="Bound">x</a> <a id="6644" class="Symbol">→</a> <a id="6646" class="Symbol">(</a><a id="6647" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="6650" href="CubicalExt.Logic.Zorn.html#6650" class="Bound">a</a><a id="6651" class="Symbol">@(</a><a id="6653" href="CubicalExt.Logic.Zorn.html#6653" class="Bound">a₁</a> <a id="6656" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6658" class="Symbol">_</a> <a id="6660" class="Symbol">)</a> <a id="6662" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="6664" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="6670" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="6672" href="CubicalExt.Logic.Zorn.html#6642" class="Bound">x</a> <a id="6674" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="6676" href="CubicalExt.Logic.Zorn.html#6653" class="Bound">a₁</a> <a id="6679" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="6681" href="CubicalExt.Logic.Zorn.html#6650" class="Bound">a</a> <a id="6683" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="6685" href="CubicalExt.Logic.Zorn.html#6617" class="Bound">A</a><a id="6686" class="Symbol">)</a> <a id="6688" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6690" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a><a id="6697" class="Symbol">)</a> <a id="6699" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a>
</pre>
<p>为了保证”并”具有 <code>Chain</code> 类型, 我们还需要说明它是一个 ≤-链. 根据定义, “并”中的任意元素都在某个 ≤-链中, 且该 ≤-链又在 <code>A</code> 中. 由于 <code>A</code> 是 ⪯-链, “并”中的任意两个元素都可以找到一个共同的 ≤-链容纳它, 因此它们可以比较大小, 这也就说明了”并”同样是 ≤-链.</p>
<pre class="Agda">    <a id="6874" class="Symbol">λ</a> <a id="6876" href="CubicalExt.Logic.Zorn.html#6876" class="Bound">x</a> <a id="6878" href="CubicalExt.Logic.Zorn.html#6878" class="Bound">y</a> <a id="6880" href="CubicalExt.Logic.Zorn.html#6880" class="Bound">x∈</a> <a id="6883" href="CubicalExt.Logic.Zorn.html#6883" class="Bound">y∈</a> <a id="6886" class="Symbol">→</a> <a id="6888" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="6893" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="6907" class="Symbol">(λ{</a> <a id="6911" class="Symbol">(</a><a id="6912" href="CubicalExt.Logic.Zorn.html#6912" class="Bound">a</a> <a id="6914" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6916" href="CubicalExt.Logic.Zorn.html#6916" class="Bound">x∈a</a> <a id="6920" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6922" href="CubicalExt.Logic.Zorn.html#6922" class="Bound">a∈A</a><a id="6925" class="Symbol">)</a> <a id="6927" class="Symbol">(</a><a id="6928" href="CubicalExt.Logic.Zorn.html#6928" class="Bound">b</a> <a id="6930" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6932" href="CubicalExt.Logic.Zorn.html#6932" class="Bound">y∈b</a> <a id="6936" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6938" href="CubicalExt.Logic.Zorn.html#6938" class="Bound">b∈A</a><a id="6941" class="Symbol">)</a> <a id="6943" class="Symbol">→</a> <a id="6945" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="6949" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
        <a id="6965" class="Symbol">(λ{</a> <a id="6969" class="Symbol">(</a><a id="6970" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="6976" href="CubicalExt.Logic.Zorn.html#6976" class="Bound">a⪯b</a><a id="6979" class="Symbol">)</a> <a id="6981" class="Symbol">→</a> <a id="6983" href="CubicalExt.Logic.Zorn.html#6928" class="Bound">b</a> <a id="6985" class="Symbol">.</a><a id="6986" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="6990" href="CubicalExt.Logic.Zorn.html#6876" class="Bound">x</a> <a id="6992" href="CubicalExt.Logic.Zorn.html#6878" class="Bound">y</a> <a id="6994" class="Symbol">(</a><a id="6995" href="CubicalExt.Logic.Zorn.html#6976" class="Bound">a⪯b</a> <a id="6999" href="CubicalExt.Logic.Zorn.html#6916" class="Bound">x∈a</a><a id="7002" class="Symbol">)</a> <a id="7004" href="CubicalExt.Logic.Zorn.html#6932" class="Bound">y∈b</a>
          <a id="7018" class="Symbol">;</a> <a id="7020" class="Symbol">(</a><a id="7021" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="7027" href="CubicalExt.Logic.Zorn.html#7027" class="Bound">b⪯a</a><a id="7030" class="Symbol">)</a> <a id="7032" class="Symbol">→</a> <a id="7034" href="CubicalExt.Logic.Zorn.html#6912" class="Bound">a</a> <a id="7036" class="Symbol">.</a><a id="7037" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7041" href="CubicalExt.Logic.Zorn.html#6876" class="Bound">x</a> <a id="7043" href="CubicalExt.Logic.Zorn.html#6878" class="Bound">y</a> <a id="7045" href="CubicalExt.Logic.Zorn.html#6916" class="Bound">x∈a</a> <a id="7049" class="Symbol">(</a><a id="7050" href="CubicalExt.Logic.Zorn.html#7027" class="Bound">b⪯a</a> <a id="7054" href="CubicalExt.Logic.Zorn.html#6932" class="Bound">y∈b</a><a id="7057" class="Symbol">)</a> <a id="7059" class="Symbol">})</a>
        <a id="7070" class="Symbol">(</a><a id="7071" href="CubicalExt.Logic.Zorn.html#6619" class="Bound">isChainA</a> <a id="7080" href="CubicalExt.Logic.Zorn.html#6912" class="Bound">a</a> <a id="7082" href="CubicalExt.Logic.Zorn.html#6928" class="Bound">b</a> <a id="7084" href="CubicalExt.Logic.Zorn.html#6922" class="Bound">a∈A</a> <a id="7088" href="CubicalExt.Logic.Zorn.html#6938" class="Bound">b∈A</a><a id="7091" class="Symbol">)})</a>
      <a id="7101" class="Symbol">(</a><a id="7102" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="7111" href="CubicalExt.Logic.Zorn.html#6880" class="Bound">x∈</a><a id="7113" class="Symbol">)</a> <a id="7115" class="Symbol">(</a><a id="7116" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="7125" href="CubicalExt.Logic.Zorn.html#6883" class="Bound">y∈</a><a id="7127" class="Symbol">)</a>
</pre>
<p>下面的代码证明上面说的”并”确实是上确界. 由集合论知识, 集族的并显然是 ⊆-序的上确界. 这里不再赘述.</p>
<pre class="Agda">  <a id="Chain.suphood"></a><a id="7200" href="CubicalExt.Logic.Zorn.html#7200" class="Function">suphood</a> <a id="7208" class="Symbol">:</a> <a id="7210" class="Symbol">(</a><a id="7211" href="CubicalExt.Logic.Zorn.html#7211" class="Bound">A</a> <a id="7213" class="Symbol">:</a> <a id="7215" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="7217" href="CubicalExt.Logic.Zorn.html#4946" class="Function">Chain</a> <a id="7223" href="CubicalExt.Logic.Zorn.html#2159" class="Generalizable">ℓ</a><a id="7224" class="Symbol">)</a> <a id="7226" class="Symbol">(</a><a id="7227" href="CubicalExt.Logic.Zorn.html#7227" class="Bound">isChainA</a> <a id="7236" class="Symbol">:</a> <a id="7238" href="CubicalExt.Logic.Zorn.html#3337" class="Function">⪯.isChain</a> <a id="7248" href="CubicalExt.Logic.Zorn.html#7211" class="Bound">A</a><a id="7249" class="Symbol">)</a> <a id="7251" class="Symbol">→</a> <a id="7253" href="CubicalExt.Logic.Zorn.html#3975" class="Function">⪯.supremum</a> <a id="7264" href="CubicalExt.Logic.Zorn.html#7211" class="Bound">A</a> <a id="7266" class="Symbol">(</a><a id="7267" href="CubicalExt.Logic.Zorn.html#6567" class="Function">sup</a> <a id="7271" href="CubicalExt.Logic.Zorn.html#7211" class="Bound">A</a> <a id="7273" href="CubicalExt.Logic.Zorn.html#7227" class="Bound">isChainA</a><a id="7281" class="Symbol">)</a>
  <a id="7285" href="CubicalExt.Logic.Zorn.html#7200" class="Function">suphood</a> <a id="7293" href="CubicalExt.Logic.Zorn.html#7293" class="Bound">A</a> <a id="7295" href="CubicalExt.Logic.Zorn.html#7295" class="Bound">isChainA</a> <a id="7304" class="Symbol">=</a> <a id="7306" class="Symbol">(λ</a> <a id="7309" class="Symbol">{</a> <a id="7311" href="CubicalExt.Logic.Zorn.html#7311" class="Bound">a</a> <a id="7313" href="CubicalExt.Logic.Zorn.html#7313" class="Bound">a∈A</a> <a id="7317" href="CubicalExt.Logic.Zorn.html#7317" class="Bound">x∈a₁</a> <a id="7322" class="Symbol">→</a> <a id="7324" href="CubicalExt.Logic.Classical.html#1984" class="Function">resize</a> <a id="7331" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="7333" href="CubicalExt.Logic.Zorn.html#7311" class="Bound">a</a> <a id="7335" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7337" href="CubicalExt.Logic.Zorn.html#7317" class="Bound">x∈a₁</a> <a id="7342" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7344" href="CubicalExt.Logic.Zorn.html#7313" class="Bound">a∈A</a> <a id="7348" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="7351" class="Symbol">})</a> <a id="7354" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a>
    <a id="7360" class="Symbol">λ</a> <a id="7362" href="CubicalExt.Logic.Zorn.html#7362" class="Bound">ub</a> <a id="7365" href="CubicalExt.Logic.Zorn.html#7365" class="Bound">ubhood</a> <a id="7372" href="CubicalExt.Logic.Zorn.html#7372" class="Bound">x∈sup</a> <a id="7378" class="Symbol">→</a> <a id="7380" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="7384" class="Symbol">(</a><a id="7385" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="7394" class="Symbol">(</a><a id="7395" href="CubicalExt.Logic.Zorn.html#7362" class="Bound">ub</a> <a id="7398" class="Symbol">.</a><a id="7399" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="7402" class="Symbol">)</a> <a id="7404" class="Symbol">_)</a>
      <a id="7413" class="Symbol">(λ{</a> <a id="7417" class="Symbol">(</a><a id="7418" href="CubicalExt.Logic.Zorn.html#7418" class="Bound">a</a> <a id="7420" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7422" href="CubicalExt.Logic.Zorn.html#7422" class="Bound">x∈a₁</a> <a id="7427" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7429" href="CubicalExt.Logic.Zorn.html#7429" class="Bound">a∈A</a><a id="7432" class="Symbol">)</a> <a id="7434" class="Symbol">→</a> <a id="7436" href="CubicalExt.Logic.Zorn.html#7365" class="Bound">ubhood</a> <a id="7443" href="CubicalExt.Logic.Zorn.html#7418" class="Bound">a</a> <a id="7445" href="CubicalExt.Logic.Zorn.html#7429" class="Bound">a∈A</a> <a id="7449" href="CubicalExt.Logic.Zorn.html#7422" class="Bound">x∈a₁</a> <a id="7454" class="Symbol">})</a>
      <a id="7463" class="Symbol">(</a><a id="7464" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="7473" href="CubicalExt.Logic.Zorn.html#7372" class="Bound">x∈sup</a><a id="7478" class="Symbol">)</a>
</pre>
<p>至此, 我们证明了链集中的任意链都能找到上确界.</p>
<pre class="Agda">  <a id="Chain.⪯-allChainHasSup"></a><a id="7517" href="CubicalExt.Logic.Zorn.html#7517" class="Function">⪯-allChainHasSup</a> <a id="7534" class="Symbol">:</a> <a id="7536" href="CubicalExt.Logic.Zorn.html#4119" class="Function">⪯.allChainHasSup</a>
  <a id="7555" href="CubicalExt.Logic.Zorn.html#7517" class="Function">⪯-allChainHasSup</a> <a id="7572" href="CubicalExt.Logic.Zorn.html#7572" class="Bound">A</a> <a id="7574" href="CubicalExt.Logic.Zorn.html#7574" class="Bound">isChainA</a> <a id="7583" class="Symbol">=</a> <a id="7585" href="CubicalExt.Logic.Zorn.html#6567" class="Function">sup</a> <a id="7589" href="CubicalExt.Logic.Zorn.html#7572" class="Bound">A</a> <a id="7591" href="CubicalExt.Logic.Zorn.html#7574" class="Bound">isChainA</a> <a id="7600" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7602" href="CubicalExt.Logic.Zorn.html#7200" class="Function">suphood</a> <a id="7610" href="CubicalExt.Logic.Zorn.html#7572" class="Bound">A</a> <a id="7612" href="CubicalExt.Logic.Zorn.html#7574" class="Bound">isChainA</a>
</pre>
<h3 id="后继性">后继性</h3>
<p>接下来我们将证明一个关键的引理. 它的前两个前提与佐恩引理相同, 第三个前提则是对佐恩引理结论的否定, 我们将在最后一节使用选择公理来证明这一点. 最后, 我们将采用反证法来证明佐恩引理, 只需将下面引理的结论与上一小节所证明的事实结合起来找到矛盾即可.</p>
<p>先回到该引理的证明, 要找到给定的 <code>a : Chain</code> 的后继. 具体地, 有五个子目标: 给出后继 <code>a'</code>; 说明它小于等于 <code>a</code>; 说明它不等于 <code>a</code>; 说明 <code>a</code> 与 <code>a'</code> 之间没有其他元素.</p>
<pre class="Agda">  <a id="Chain.⪯-successvie"></a><a id="7883" href="CubicalExt.Logic.Zorn.html#7883" class="Function">⪯-successvie</a> <a id="7896" class="Symbol">:</a> <a id="7898" href="CubicalExt.Logic.Zorn.html#2650" class="Function">≤.isPoset</a> <a id="7908" class="Symbol">→</a> <a id="7910" href="CubicalExt.Logic.Zorn.html#3793" class="Function">≤.allChainHasUb</a> <a id="7926" class="Symbol">→</a> <a id="7928" href="CubicalExt.Logic.Zorn.html#2838" class="Function">≤.unbound</a> <a id="7938" class="Symbol">→</a> <a id="7940" href="CubicalExt.Logic.Zorn.html#2990" class="Function">⪯.successive</a>
  <a id="7955" href="CubicalExt.Logic.Zorn.html#7883" class="Function">⪯-successvie</a> <a id="7968" class="Symbol">(</a><a id="7969" href="CubicalExt.Logic.Zorn.html#7969" class="Bound">Uset</a> <a id="7974" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7976" href="CubicalExt.Logic.Zorn.html#7976" class="Bound">≤-po</a><a id="7980" class="Symbol">)</a> <a id="7982" href="CubicalExt.Logic.Zorn.html#7982" class="Bound">hasUb</a> <a id="7988" href="CubicalExt.Logic.Zorn.html#7988" class="Bound">unbnd</a> <a id="7994" href="CubicalExt.Logic.Zorn.html#7994" class="Bound">a</a><a id="7995" class="Symbol">@(</a><a id="7997" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="7999" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8001" href="CubicalExt.Logic.Zorn.html#8001" class="Bound">isChainA</a><a id="8009" class="Symbol">)</a> <a id="8011" class="Symbol">=</a> <a id="8013" href="CubicalExt.Logic.Zorn.html#9236" class="Function">a&#39;</a> <a id="8016" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8018" href="CubicalExt.Logic.Classical.html#1984" class="Function">resize</a> <a id="8025" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="8027" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="8031" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8033" href="CubicalExt.Logic.Zorn.html#9350" class="Function">a≢a&#39;</a> <a id="8038" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8040" href="CubicalExt.Logic.Zorn.html#9684" class="Function">noMid</a> <a id="8046" class="Keyword">where</a>
</pre>
<p>由前提, <code>≤</code> 自反, 反对称且传递.</p>
<pre class="Agda">    <a id="8091" href="CubicalExt.Logic.Zorn.html#8091" class="Function">≤-refl</a>    <a id="8101" class="Symbol">=</a> <a id="8103" href="CubicalExt.Logic.Zorn.html#7976" class="Bound">≤-po</a> <a id="8108" class="Symbol">.</a><a id="8109" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8113" class="Symbol">.</a><a id="8114" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8122" href="CubicalExt.Logic.Zorn.html#8122" class="Function">≤-antisym</a> <a id="8132" class="Symbol">=</a> <a id="8134" href="CubicalExt.Logic.Zorn.html#7976" class="Bound">≤-po</a> <a id="8139" class="Symbol">.</a><a id="8140" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8144" class="Symbol">.</a><a id="8145" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8149" class="Symbol">.</a><a id="8150" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8158" href="CubicalExt.Logic.Zorn.html#8158" class="Function">≤-trans</a>   <a id="8168" class="Symbol">=</a> <a id="8170" href="CubicalExt.Logic.Zorn.html#7976" class="Bound">≤-po</a> <a id="8175" class="Symbol">.</a><a id="8176" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8180" class="Symbol">.</a><a id="8181" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8185" class="Symbol">.</a><a id="8186" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<p>将 <code>a</code> 分解为 <code>U</code> 的子集 <code>A</code> 以及它是 ≤-链的证据 <code>isChainA</code>. 由于 <code>A</code> 是 ≤-链, 由前提, 它有上界 <code>ub</code>. 又 <code>U</code> ≤-无界, 所以有比 <code>ub</code> 更大的 <code>ub'</code>.</p>
<pre class="Agda">    <a id="8317" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a>        <a id="8327" class="Symbol">=</a> <a id="8329" href="CubicalExt.Logic.Zorn.html#7982" class="Bound">hasUb</a> <a id="8335" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="8337" href="CubicalExt.Logic.Zorn.html#8001" class="Bound">isChainA</a> <a id="8346" class="Symbol">.</a><a id="8347" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8355" href="CubicalExt.Logic.Zorn.html#8355" class="Function">ubhood</a>    <a id="8365" class="Symbol">=</a> <a id="8367" href="CubicalExt.Logic.Zorn.html#7982" class="Bound">hasUb</a> <a id="8373" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="8375" href="CubicalExt.Logic.Zorn.html#8001" class="Bound">isChainA</a> <a id="8384" class="Symbol">.</a><a id="8385" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
    <a id="8393" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a>       <a id="8403" class="Symbol">=</a> <a id="8405" href="CubicalExt.Logic.Zorn.html#7988" class="Bound">unbnd</a> <a id="8411" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="8414" class="Symbol">.</a><a id="8415" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8423" href="CubicalExt.Logic.Zorn.html#8423" class="Function">ub≤</a>       <a id="8433" class="Symbol">=</a> <a id="8435" href="CubicalExt.Logic.Zorn.html#7988" class="Bound">unbnd</a> <a id="8441" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="8444" class="Symbol">.</a><a id="8445" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8449" class="Symbol">.</a><a id="8450" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8458" href="CubicalExt.Logic.Zorn.html#8458" class="Function">ub≢</a>       <a id="8468" class="Symbol">=</a> <a id="8470" href="CubicalExt.Logic.Zorn.html#7988" class="Bound">unbnd</a> <a id="8476" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="8479" class="Symbol">.</a><a id="8480" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a><a id="8483" class="Symbol">.</a> <a id="8485" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<p>现在, 取 <code>A</code> 中元素与 <code>ub</code> 所组成的集合, 记作 <code>A ⨭ ub</code>, 命名为 <code>A'</code>, 并调整到最低宇宙. 注意, 这里的 <code>⨭</code> 运算要求全集 <code>U</code> 是集合.</p>
<pre class="Agda">    <a id="8596" class="Keyword">open</a> <a id="8601" href="CubicalExt.Foundations.Powerset%252A.html#4190" class="Module">SetBased</a> <a id="8610" href="CubicalExt.Logic.Zorn.html#7969" class="Bound">Uset</a> <a id="8615" class="Keyword">using</a> <a id="8621" class="Symbol">(</a><a id="8622" href="CubicalExt.Foundations.Powerset%252A.html#4431" class="Function Operator">_⨭_</a><a id="8625" class="Symbol">)</a>
    <a id="8631" href="CubicalExt.Logic.Zorn.html#8631" class="Function">A&#39;</a> <a id="8634" class="Symbol">=</a> <a id="8636" href="CubicalExt.Logic.Classical.html#1917" class="Function">Resize</a> <a id="8643" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="8645" class="Symbol">(</a><a id="8646" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="8648" href="CubicalExt.Foundations.Powerset%252A.html#4431" class="Function Operator">⨭</a> <a id="8650" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a><a id="8653" class="Symbol">)</a>
</pre>
<p>由于 <code>ub'</code> 比 <code>A</code> 中元素都大, 所以把它加进 <code>A</code> 后可以与 <code>A</code> 中所有元素比出大小, 所以 <code>A'</code> 也是 ≤-链.</p>
<pre class="Agda">    <a id="8742" href="CubicalExt.Logic.Zorn.html#8742" class="Function">isChainA&#39;</a> <a id="8752" class="Symbol">:</a> <a id="8754" href="CubicalExt.Logic.Zorn.html#3337" class="Function">≤.isChain</a> <a id="8764" href="CubicalExt.Logic.Zorn.html#8631" class="Function">A&#39;</a>
    <a id="8771" href="CubicalExt.Logic.Zorn.html#8742" class="Function">isChainA&#39;</a> <a id="8781" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="8783" href="CubicalExt.Logic.Zorn.html#8783" class="Bound">y</a> <a id="8785" href="CubicalExt.Logic.Zorn.html#8785" class="Bound">x∈</a> <a id="8788" href="CubicalExt.Logic.Zorn.html#8788" class="Bound">y∈</a> <a id="8791" class="Symbol">=</a> <a id="8793" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="8798" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="8812" class="Symbol">(λ{</a> <a id="8816" class="Symbol">(</a><a id="8817" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8823" href="CubicalExt.Logic.Zorn.html#8823" class="Bound">x∈A</a><a id="8826" class="Symbol">)</a>    <a id="8831" class="Symbol">(</a><a id="8832" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8838" href="CubicalExt.Logic.Zorn.html#8838" class="Bound">y∈A</a><a id="8841" class="Symbol">)</a>    <a id="8846" class="Symbol">→</a> <a id="8848" href="CubicalExt.Logic.Zorn.html#8001" class="Bound">isChainA</a> <a id="8857" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="8859" href="CubicalExt.Logic.Zorn.html#8783" class="Bound">y</a> <a id="8861" href="CubicalExt.Logic.Zorn.html#8823" class="Bound">x∈A</a> <a id="8865" href="CubicalExt.Logic.Zorn.html#8838" class="Bound">y∈A</a>
        <a id="8877" class="Symbol">;</a> <a id="8879" class="Symbol">(</a><a id="8880" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8886" href="CubicalExt.Logic.Zorn.html#8886" class="Bound">x∈A</a><a id="8889" class="Symbol">)</a>    <a id="8894" class="Symbol">(</a><a id="8895" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8901" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8907" class="Symbol">)</a> <a id="8909" class="Symbol">→</a> <a id="8911" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="8915" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8917" href="CubicalExt.Logic.Zorn.html#8158" class="Function">≤-trans</a> <a id="8925" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="8927" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="8930" href="CubicalExt.Logic.Zorn.html#8783" class="Bound">y</a> <a id="8932" class="Symbol">(</a><a id="8933" href="CubicalExt.Logic.Zorn.html#8355" class="Function">ubhood</a> <a id="8940" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="8942" href="CubicalExt.Logic.Zorn.html#8886" class="Bound">x∈A</a><a id="8945" class="Symbol">)</a> <a id="8947" href="CubicalExt.Logic.Zorn.html#8423" class="Function">ub≤</a>
        <a id="8959" class="Symbol">;</a> <a id="8961" class="Symbol">(</a><a id="8962" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8968" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8974" class="Symbol">)</a> <a id="8976" class="Symbol">(</a><a id="8977" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8983" href="CubicalExt.Logic.Zorn.html#8983" class="Bound">y∈A</a><a id="8986" class="Symbol">)</a>    <a id="8991" class="Symbol">→</a> <a id="8993" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="8997" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8999" href="CubicalExt.Logic.Zorn.html#8158" class="Function">≤-trans</a> <a id="9007" href="CubicalExt.Logic.Zorn.html#8783" class="Bound">y</a> <a id="9009" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="9012" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="9014" class="Symbol">(</a><a id="9015" href="CubicalExt.Logic.Zorn.html#8355" class="Function">ubhood</a> <a id="9022" href="CubicalExt.Logic.Zorn.html#8783" class="Bound">y</a> <a id="9024" href="CubicalExt.Logic.Zorn.html#8983" class="Bound">y∈A</a><a id="9027" class="Symbol">)</a> <a id="9029" href="CubicalExt.Logic.Zorn.html#8423" class="Function">ub≤</a>
        <a id="9041" class="Symbol">;</a> <a id="9043" class="Symbol">(</a><a id="9044" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="9050" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="9056" class="Symbol">)</a> <a id="9058" class="Symbol">(</a><a id="9059" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="9065" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="9071" class="Symbol">)</a> <a id="9073" class="Symbol">→</a> <a id="9075" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="9079" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9081" href="CubicalExt.Logic.Zorn.html#8091" class="Function">≤-refl</a> <a id="9088" href="CubicalExt.Logic.Zorn.html#8781" class="Bound">x</a> <a id="9090" class="Symbol">})</a>
      <a id="9099" class="Symbol">(</a><a id="9100" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="9109" href="CubicalExt.Logic.Zorn.html#8785" class="Bound">x∈</a><a id="9111" class="Symbol">)</a> <a id="9113" class="Symbol">(</a><a id="9114" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="9123" href="CubicalExt.Logic.Zorn.html#8788" class="Bound">y∈</a><a id="9125" class="Symbol">)</a>
</pre>
<p><code>A'</code> 配备上它是 ≤-链的证据 <code>isChainA'</code> 得到 <code>a' : Chain</code>. 我们宣称 <code>a'</code> 就是所需后继. 显然 <code>A ⊆ A'</code>, 所以 <code>a ⪯ a'</code>.</p>
<pre class="Agda">    <a id="9236" href="CubicalExt.Logic.Zorn.html#9236" class="Function">a&#39;</a> <a id="9239" class="Symbol">=</a> <a id="9241" href="CubicalExt.Logic.Zorn.html#8631" class="Function">A&#39;</a> <a id="9244" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9246" href="CubicalExt.Logic.Zorn.html#8742" class="Function">isChainA&#39;</a>
</pre>
<p>由于 <code>ub'</code> 比 <code>A</code> 中所有元素都大, 所以它不在 <code>A</code> 中, 所以 <code>A</code> 与 <code>A'</code> 不同, 这就说明了 <code>a</code> 与 <code>a'</code> 不同.</p>
<pre class="Agda">    <a id="9350" href="CubicalExt.Logic.Zorn.html#9350" class="Function">a≢a&#39;</a> <a id="9355" class="Symbol">:</a> <a id="9357" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="9359" href="CubicalExt.Logic.Zorn.html#7994" class="Bound">a</a> <a id="9361" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9363" href="CubicalExt.Logic.Zorn.html#9236" class="Function">a&#39;</a>
    <a id="9370" href="CubicalExt.Logic.Zorn.html#9350" class="Function">a≢a&#39;</a> <a id="9375" href="CubicalExt.Logic.Zorn.html#9375" class="Bound">eq</a> <a id="9378" class="Symbol">=</a> <a id="9380" class="Keyword">let</a> <a id="9384" href="CubicalExt.Logic.Zorn.html#9384" class="Bound">eq</a> <a id="9387" class="Symbol">=</a> <a id="9389" href="Cubical.Data.Sigma.Properties.html#2119" class="Function">PathPΣ</a> <a id="9396" href="CubicalExt.Logic.Zorn.html#9375" class="Bound">eq</a> <a id="9399" class="Symbol">.</a><a id="9400" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="9404" class="Keyword">in</a>
      <a id="9413" href="CubicalExt.Logic.Zorn.html#8458" class="Function">ub≢</a> <a id="9417" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9419" href="CubicalExt.Logic.Zorn.html#8122" class="Function">≤-antisym</a> <a id="9429" href="CubicalExt.Logic.Zorn.html#8317" class="Function">ub</a> <a id="9432" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a> <a id="9436" href="CubicalExt.Logic.Zorn.html#8423" class="Function">ub≤</a> <a id="9440" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9442" href="CubicalExt.Logic.Zorn.html#8355" class="Function">ubhood</a> <a id="9449" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a> <a id="9453" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a>
      <a id="9461" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="9467" class="Symbol">(</a><a id="9468" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a> <a id="9472" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈_</a><a id="9474" class="Symbol">)</a> <a id="9476" class="Symbol">(</a><a id="9477" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="9481" href="CubicalExt.Logic.Zorn.html#9384" class="Bound">eq</a><a id="9483" class="Symbol">)</a> <a id="9485" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9487" href="CubicalExt.Logic.Classical.html#1984" class="Function">resize</a> <a id="9494" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9496" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="9500" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a>
</pre>
<p>最后, 我们要说明 <code>a</code> 与 <code>a'</code> 之间没有其他元素. 给定 <code>b</code> 在 <code>a</code> 与 <code>a'</code> 之间, 我们说明 <code>b</code> 要么等于 <code>a</code>, 要么等于 <code>a'</code>. 将 <code>b</code> 分解为 <code>U</code> 的子集 <code>B</code> 以及它是 ≤-链的证据 <code>isChainB</code>. 现在, 用排中律讨论 <code>ub'</code> 是否在 <code>B</code> 中.</p>
<pre class="Agda">    <a id="9684" href="CubicalExt.Logic.Zorn.html#9684" class="Function">noMid</a> <a id="9690" class="Symbol">:</a> <a id="9692" class="Symbol">∀</a> <a id="9694" href="CubicalExt.Logic.Zorn.html#9694" class="Bound">b</a> <a id="9696" class="Symbol">→</a> <a id="9698" href="CubicalExt.Logic.Zorn.html#7994" class="Bound">a</a> <a id="9700" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">⪯</a> <a id="9702" href="CubicalExt.Logic.Zorn.html#9694" class="Bound">b</a> <a id="9704" class="Symbol">→</a> <a id="9706" href="CubicalExt.Logic.Zorn.html#9694" class="Bound">b</a> <a id="9708" href="CubicalExt.Logic.Zorn.html#5175" class="Function Operator">⪯</a> <a id="9710" href="CubicalExt.Logic.Zorn.html#9236" class="Function">a&#39;</a> <a id="9713" class="Symbol">→</a> <a id="9715" href="CubicalExt.Logic.Zorn.html#9694" class="Bound">b</a> <a id="9717" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9719" href="CubicalExt.Logic.Zorn.html#7994" class="Bound">a</a> <a id="9721" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="9723" href="CubicalExt.Logic.Zorn.html#9694" class="Bound">b</a> <a id="9725" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9727" href="CubicalExt.Logic.Zorn.html#9236" class="Function">a&#39;</a>
    <a id="9734" href="CubicalExt.Logic.Zorn.html#9684" class="Function">noMid</a> <a id="9740" href="CubicalExt.Logic.Zorn.html#9740" class="Bound">b</a><a id="9741" class="Symbol">@(</a><a id="9743" href="CubicalExt.Logic.Zorn.html#9743" class="Bound">B</a> <a id="9745" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9747" href="CubicalExt.Logic.Zorn.html#9747" class="Bound">isChainB</a><a id="9755" class="Symbol">)</a> <a id="9757" href="CubicalExt.Logic.Zorn.html#9757" class="Bound">A⊆B</a> <a id="9761" href="CubicalExt.Logic.Zorn.html#9761" class="Bound">B⊆A&#39;</a> <a id="9766" class="Keyword">with</a> <a id="9771" href="CubicalExt.Logic.Zorn.html#4761" class="Bound">em</a> <a id="9774" class="Symbol">⦃</a> <a id="9776" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="9785" href="CubicalExt.Logic.Zorn.html#9743" class="Bound">B</a> <a id="9787" href="CubicalExt.Logic.Zorn.html#8393" class="Function">ub&#39;</a> <a id="9791" class="Symbol">_</a> <a id="9793" class="Symbol">_</a> <a id="9795" class="Symbol">⦄</a>
</pre>
<ul>
<li>若 <code>ub' ∈ B</code>, 我们证 <code>b ≡ a'</code>, 只需证 <code>B ≡ A'</code>, 至于它们的 <code>isChain</code> 证据, 由于是命题, 必然相等. 我们用 <code>⊆</code> 的反自反性证明 <code>B ≡ A'</code>. 已知 <code>B ⊆ A'</code> 是前提, 只需证 <code>A' ⊆ B</code>. <code>A'</code> 中的元素要么是 <code>A</code> 中的元素, 要么是 <code>ub'</code>, 而 <code>A ⊆ B</code>, <code>ub' ∈ B</code>, 所以 <code>A' ⊆ B</code>.</li>
</ul>
<pre class="Agda">    <a id="10017" class="Symbol">...</a> <a id="10021" class="Symbol">|</a> <a id="10023" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="10027" href="CubicalExt.Logic.Zorn.html#10027" class="Bound">ub&#39;∈B</a> <a id="10033" class="Symbol">=</a> <a id="10035" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="10039" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10041" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="10048" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10050" href="CubicalExt.Foundations.Powerset%252A.html#3114" class="Function">⊆-antisym</a> <a id="10060" class="Bound">B</a> <a id="10062" href="CubicalExt.Logic.Zorn.html#8631" class="Function">A&#39;</a> <a id="10065" class="Bound">B⊆A&#39;</a> <a id="10070" href="CubicalExt.Logic.Zorn.html#10127" class="Function">A&#39;⊆B</a> <a id="10075" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10077" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="10085" class="Symbol">(</a><a id="10086" href="CubicalExt.Logic.Zorn.html#3482" class="Function">≤.isPropIsChain</a> <a id="10102" class="Symbol">_</a> <a id="10104" href="CubicalExt.Logic.Zorn.html#8742" class="Function">isChainA&#39;</a><a id="10113" class="Symbol">)</a>
      <a id="10121" class="Keyword">where</a> <a id="10127" href="CubicalExt.Logic.Zorn.html#10127" class="Function">A&#39;⊆B</a> <a id="10132" class="Symbol">:</a> <a id="10134" href="CubicalExt.Logic.Zorn.html#8631" class="Function">A&#39;</a> <a id="10137" href="CubicalExt.Foundations.Powerset%252A.html#2159" class="Function Operator">⊆</a> <a id="10139" class="Bound">B</a>
            <a id="10153" href="CubicalExt.Logic.Zorn.html#10127" class="Function">A&#39;⊆B</a> <a id="10158" href="CubicalExt.Logic.Zorn.html#10158" class="Bound">x∈A&#39;</a> <a id="10163" class="Symbol">=</a> <a id="10165" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="10169" class="Symbol">(</a><a id="10170" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="10179" class="Bound">B</a> <a id="10181" class="Symbol">_)</a>
              <a id="10198" class="Symbol">(λ{</a> <a id="10202" class="Symbol">(</a><a id="10203" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="10209" href="CubicalExt.Logic.Zorn.html#10209" class="Bound">x∈A</a><a id="10212" class="Symbol">)</a>    <a id="10217" class="Symbol">→</a> <a id="10219" class="Bound">A⊆B</a> <a id="10223" href="CubicalExt.Logic.Zorn.html#10209" class="Bound">x∈A</a>
                <a id="10243" class="Symbol">;</a> <a id="10245" class="Symbol">(</a><a id="10246" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="10252" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="10258" class="Symbol">)</a> <a id="10260" class="Symbol">→</a> <a id="10262" href="CubicalExt.Logic.Zorn.html#10027" class="Bound">ub&#39;∈B</a> <a id="10268" class="Symbol">})</a>
              <a id="10285" class="Symbol">(</a><a id="10286" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="10295" href="CubicalExt.Logic.Zorn.html#10158" class="Bound">x∈A&#39;</a><a id="10299" class="Symbol">)</a>
</pre>
<ul>
<li>若 <code>ub' ∉ B</code>, 我们证 <code>b ≡ a</code>, 只需证 <code>B ≡ A</code>. 同样用 <code>⊆</code> 的反自反性, 已知 <code>A ⊆ B</code> 是前提, 只需证 <code>B ⊆ A</code>. 由于 <code>B ⊆ A'</code>, <code>A'</code> 只比 <code>A</code> 多了一个元素 <code>ub'</code>, 而 <code>ub' ∉ B</code>, 所以 <code>B ⊆ A</code>.</li>
</ul>
<pre class="Agda">    <a id="10468" class="Symbol">...</a> <a id="10472" class="Symbol">|</a> <a id="10474" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a>  <a id="10478" href="CubicalExt.Logic.Zorn.html#10478" class="Bound">ub&#39;∉B</a> <a id="10484" class="Symbol">=</a> <a id="10486" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="10490" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10492" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="10499" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10501" href="CubicalExt.Foundations.Powerset%252A.html#3114" class="Function">⊆-antisym</a> <a id="10511" class="Bound">B</a> <a id="10513" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="10515" href="CubicalExt.Logic.Zorn.html#10574" class="Function">B⊆A</a> <a id="10519" class="Bound">A⊆B</a> <a id="10523" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10525" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="10533" class="Symbol">(</a><a id="10534" href="CubicalExt.Logic.Zorn.html#3482" class="Function">≤.isPropIsChain</a> <a id="10550" class="Symbol">_</a> <a id="10552" href="CubicalExt.Logic.Zorn.html#8001" class="Bound">isChainA</a><a id="10560" class="Symbol">)</a>
      <a id="10568" class="Keyword">where</a> <a id="10574" href="CubicalExt.Logic.Zorn.html#10574" class="Function">B⊆A</a> <a id="10578" class="Symbol">:</a> <a id="10580" class="Bound">B</a> <a id="10582" href="CubicalExt.Foundations.Powerset%252A.html#2159" class="Function Operator">⊆</a> <a id="10584" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a>
            <a id="10598" href="CubicalExt.Logic.Zorn.html#10574" class="Function">B⊆A</a> <a id="10602" href="CubicalExt.Logic.Zorn.html#10602" class="Bound">x∈B</a> <a id="10606" class="Symbol">=</a> <a id="10608" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="10612" class="Symbol">(</a><a id="10613" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="10622" href="CubicalExt.Logic.Zorn.html#7997" class="Bound">A</a> <a id="10624" class="Symbol">_)</a>
              <a id="10641" class="Symbol">(λ{</a> <a id="10645" class="Symbol">(</a><a id="10646" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="10652" href="CubicalExt.Logic.Zorn.html#10652" class="Bound">x∈A</a><a id="10655" class="Symbol">)</a>    <a id="10660" class="Symbol">→</a> <a id="10662" href="CubicalExt.Logic.Zorn.html#10652" class="Bound">x∈A</a>
                <a id="10682" class="Symbol">;</a> <a id="10684" class="Symbol">(</a><a id="10685" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="10691" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="10697" class="Symbol">)</a> <a id="10699" class="Symbol">→</a> <a id="10701" href="Cubical.Data.Empty.Base.html#187" class="Function">⊥.rec</a> <a id="10707" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10709" href="CubicalExt.Logic.Zorn.html#10478" class="Bound">ub&#39;∉B</a> <a id="10715" href="CubicalExt.Logic.Zorn.html#10602" class="Bound">x∈B</a> <a id="10719" class="Symbol">})</a>
              <a id="10736" class="Symbol">(</a><a id="10737" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="10746" class="Symbol">(</a><a id="10747" class="Bound">B⊆A&#39;</a> <a id="10752" href="CubicalExt.Logic.Zorn.html#10602" class="Bound">x∈B</a><a id="10755" class="Symbol">))</a>
</pre>
<p>至此, 我们证明了某个序在一定条件下同时满足 “任意链都能取上确界” 与 “任意元素都取后继”. 我们将证明, 这实际上是矛盾的.</p>
<h2 id="构造矛盾">构造矛盾</h2>
<p>假设排中律, 给定偏序 <code>≤</code>, 假设其任意链都能取上确界, 且任意元素都取后继.</p>
<pre class="Agda"><a id="10890" class="Keyword">module</a> <a id="Contra"></a><a id="10897" href="CubicalExt.Logic.Zorn.html#10897" class="Module">Contra</a> <a id="10904" class="Symbol">⦃</a> <a id="10906" href="CubicalExt.Logic.Zorn.html#10906" class="Bound">em</a> <a id="10909" class="Symbol">:</a> <a id="10911" class="Symbol">∀</a> <a id="10913" class="Symbol">{</a><a id="10914" href="CubicalExt.Logic.Zorn.html#10914" class="Bound">ℓ</a><a id="10915" class="Symbol">}</a> <a id="10917" class="Symbol">→</a> <a id="10919" href="CubicalExt.Axiom.ExcludedMiddle.html#460" class="Function">EM</a> <a id="10922" href="CubicalExt.Logic.Zorn.html#10914" class="Bound">ℓ</a> <a id="10924" class="Symbol">⦄</a> <a id="10926" class="Symbol">{</a><a id="10927" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="10929" class="Symbol">:</a> <a id="10931" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="10936" href="CubicalExt.Logic.Zorn.html#2161" class="Generalizable">u</a><a id="10937" class="Symbol">}</a> <a id="10939" class="Symbol">{</a><a id="10940" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">_≤_</a> <a id="10944" class="Symbol">:</a> <a id="10946" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="10950" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="10952" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="10954" href="CubicalExt.Logic.Zorn.html#2163" class="Generalizable">r</a><a id="10955" class="Symbol">}</a>
  <a id="10959" class="Symbol">(</a><a id="10960" href="CubicalExt.Logic.Zorn.html#10960" class="Bound">≤-po</a> <a id="10965" class="Symbol">:</a> <a id="10967" href="CubicalExt.Logic.Zorn.html#2525" class="Function">Order.isPo</a> <a id="10978" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">_≤_</a><a id="10981" class="Symbol">)</a> <a id="10983" class="Symbol">(</a><a id="10984" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="10991" class="Symbol">:</a> <a id="10993" href="CubicalExt.Logic.Zorn.html#4119" class="Function">Order.allChainHasSup</a> <a id="11014" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">_≤_</a><a id="11017" class="Symbol">)</a> <a id="11019" class="Symbol">(</a><a id="11020" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="11027" class="Symbol">:</a> <a id="11029" href="CubicalExt.Logic.Zorn.html#2990" class="Function">Order.successive</a> <a id="11046" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">_≤_</a><a id="11049" class="Symbol">)</a> <a id="11051" class="Keyword">where</a>
  <a id="11059" class="Keyword">open</a> <a id="11064" class="Keyword">import</a> <a id="11071" href="CubicalExt.Logic.Classical.html" class="Module">CubicalExt.Logic.Classical</a>
  <a id="11100" class="Keyword">open</a> <a id="11105" href="CubicalExt.Logic.Zorn.html#2401" class="Module">Order</a> <a id="11111" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">_≤_</a>
</pre>
<p>由前提, <code>≤</code> 取值到命题, 自反, 反对称且传递.</p>
<pre class="Agda">  <a id="11159" class="Keyword">private</a>
    <a id="Contra.≤-prop"></a><a id="11171" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a>    <a id="11181" class="Symbol">=</a> <a id="11183" href="CubicalExt.Logic.Zorn.html#10960" class="Bound">≤-po</a> <a id="11188" class="Symbol">.</a><a id="11189" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-refl"></a><a id="11197" href="CubicalExt.Logic.Zorn.html#11197" class="Function">≤-refl</a>    <a id="11207" class="Symbol">=</a> <a id="11209" href="CubicalExt.Logic.Zorn.html#10960" class="Bound">≤-po</a> <a id="11214" class="Symbol">.</a><a id="11215" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="11219" class="Symbol">.</a><a id="11220" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-antisym"></a><a id="11228" href="CubicalExt.Logic.Zorn.html#11228" class="Function">≤-antisym</a> <a id="11238" class="Symbol">=</a> <a id="11240" href="CubicalExt.Logic.Zorn.html#10960" class="Bound">≤-po</a> <a id="11245" class="Symbol">.</a><a id="11246" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="11250" class="Symbol">.</a><a id="11251" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="11255" class="Symbol">.</a><a id="11256" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-trans"></a><a id="11264" href="CubicalExt.Logic.Zorn.html#11264" class="Function">≤-trans</a>   <a id="11274" class="Symbol">=</a> <a id="11276" href="CubicalExt.Logic.Zorn.html#10960" class="Bound">≤-po</a> <a id="11281" class="Symbol">.</a><a id="11282" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="11286" class="Symbol">.</a><a id="11287" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="11291" class="Symbol">.</a><a id="11292" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
    <a id="11300" class="Keyword">instance</a>
      <a id="Contra.≤-propImplicit"></a><a id="11315" href="CubicalExt.Logic.Zorn.html#11315" class="Function">≤-propImplicit</a> <a id="11330" class="Symbol">:</a> <a id="11332" class="Symbol">{</a><a id="11333" href="CubicalExt.Logic.Zorn.html#11333" class="Bound">x</a> <a id="11335" href="CubicalExt.Logic.Zorn.html#11335" class="Bound">y</a> <a id="11337" class="Symbol">:</a> <a id="11339" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a><a id="11340" class="Symbol">}</a> <a id="11342" class="Symbol">→</a> <a id="11344" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="11359" class="Symbol">(</a><a id="11360" href="CubicalExt.Logic.Zorn.html#11333" class="Bound">x</a> <a id="11362" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="11364" href="CubicalExt.Logic.Zorn.html#11335" class="Bound">y</a><a id="11365" class="Symbol">)</a>
      <a id="11373" href="CubicalExt.Logic.Zorn.html#11315" class="Function">≤-propImplicit</a> <a id="11388" class="Symbol">=</a> <a id="11390" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a> <a id="11397" class="Symbol">_</a> <a id="11399" class="Symbol">_</a> <a id="11401" class="Symbol">_</a> <a id="11403" class="Symbol">_</a>
</pre>
<h3 id="归纳构造塔">归纳构造”塔”</h3>
<p>接下来的构造在集合论中一般用序数上的超限递归实现, 在类型论中我们用归纳类型. 我们将定义 <code>U</code> 的一个谓词, 命名为 <code>Tower</code>. 我们会把它截断为 <code>U</code> 的子集, 命名为 <code>TowerSetℓ</code>, 然后再调整到最低宇宙, 命名为 <code>TowerSet</code>.</p>
<pre class="Agda">  <a id="11567" class="Keyword">data</a> <a id="Contra.Tower"></a><a id="11572" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="11578" class="Symbol">:</a> <a id="11580" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="11582" class="Symbol">→</a> <a id="11584" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="11589" class="Symbol">(</a><a id="11590" href="Agda.Primitive.html#804" class="Primitive">ℓ-max</a> <a id="11596" class="Symbol">(</a><a id="11597" href="Agda.Primitive.html#774" class="Primitive">ℓ-suc</a> <a id="11603" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a><a id="11609" class="Symbol">)</a> <a id="11611" class="Symbol">(</a><a id="11612" href="Agda.Primitive.html#804" class="Primitive">ℓ-max</a> <a id="11618" href="CubicalExt.Logic.Zorn.html#10936" class="Bound">u</a> <a id="11620" href="CubicalExt.Logic.Zorn.html#10954" class="Bound">r</a><a id="11621" class="Symbol">))</a>
  <a id="Contra.TowerSetℓ"></a><a id="11626" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a> <a id="11636" class="Symbol">:</a> <a id="11638" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="11640" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="11642" class="Symbol">_</a>
  <a id="11646" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a> <a id="11656" href="CubicalExt.Logic.Zorn.html#11656" class="Bound">x</a> <a id="11658" class="Symbol">=</a> <a id="11660" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥</a> <a id="11662" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="11668" href="CubicalExt.Logic.Zorn.html#11656" class="Bound">x</a> <a id="11670" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥ₚ</a>
  <a id="Contra.TowerSet"></a><a id="11675" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a> <a id="11684" class="Symbol">:</a> <a id="11686" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="11688" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="11690" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a>
  <a id="11699" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a> <a id="11708" class="Symbol">=</a> <a id="11710" href="CubicalExt.Logic.Classical.html#1917" class="Function">Resize</a> <a id="11717" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="11719" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a>
</pre>
<p>现在归纳定义谓词 <code>Tower</code>:</p>
<ul>
<li>对任意 <code>x</code> 满足 <code>Tower</code>, <code>x</code> 的后继也满足 <code>Tower</code>.</li>
<li>对任意 <code>U</code> 的子集 <code>A</code>, 如果它包含于 <code>TowerSetℓ</code>, 且是链, 那么它的上确界也满足 <code>Tower</code>.</li>
</ul>
<pre class="Agda">  <a id="11870" class="Keyword">data</a> <a id="11875" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="11881" class="Keyword">where</a>
    <a id="Contra.Tower.includeSuc"></a><a id="11891" href="CubicalExt.Logic.Zorn.html#11891" class="InductiveConstructor">includeSuc</a> <a id="11902" class="Symbol">:</a> <a id="11904" class="Symbol">(</a><a id="11905" href="CubicalExt.Logic.Zorn.html#11905" class="Bound">x</a> <a id="11907" class="Symbol">:</a> <a id="11909" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a><a id="11910" class="Symbol">)</a> <a id="11912" class="Symbol">→</a> <a id="11914" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="11920" href="CubicalExt.Logic.Zorn.html#11905" class="Bound">x</a> <a id="11922" class="Symbol">→</a> <a id="11924" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="11930" class="Symbol">(</a><a id="11931" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="11938" href="CubicalExt.Logic.Zorn.html#11905" class="Bound">x</a> <a id="11940" class="Symbol">.</a><a id="11941" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="11944" class="Symbol">)</a>
    <a id="Contra.Tower.includeSup"></a><a id="11950" href="CubicalExt.Logic.Zorn.html#11950" class="InductiveConstructor">includeSup</a> <a id="11961" class="Symbol">:</a> <a id="11963" class="Symbol">(</a><a id="11964" href="CubicalExt.Logic.Zorn.html#11964" class="Bound">A</a> <a id="11966" class="Symbol">:</a> <a id="11968" href="CubicalExt.Foundations.Powerset%252A.html#1071" class="Function">𝒫</a> <a id="11970" href="CubicalExt.Logic.Zorn.html#10927" class="Bound">U</a> <a id="11972" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a><a id="11978" class="Symbol">)</a> <a id="11980" class="Symbol">→</a> <a id="11982" class="Symbol">(</a><a id="11983" href="CubicalExt.Logic.Zorn.html#11964" class="Bound">A</a> <a id="11985" href="CubicalExt.Foundations.Powerset%252A.html#2159" class="Function Operator">⊆</a> <a id="11987" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a><a id="11996" class="Symbol">)</a> <a id="11998" class="Symbol">→</a> <a id="12000" class="Symbol">(</a><a id="12001" href="CubicalExt.Logic.Zorn.html#12001" class="Bound">isChainA</a> <a id="12010" class="Symbol">:</a> <a id="12012" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="12020" href="CubicalExt.Logic.Zorn.html#11964" class="Bound">A</a><a id="12021" class="Symbol">)</a> <a id="12023" class="Symbol">→</a>
      <a id="12031" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="12037" class="Symbol">(</a><a id="12038" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="12045" href="CubicalExt.Logic.Zorn.html#11964" class="Bound">A</a> <a id="12047" href="CubicalExt.Logic.Zorn.html#12001" class="Bound">isChainA</a> <a id="12056" class="Symbol">.</a><a id="12057" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="12060" class="Symbol">)</a>
</pre>
<p>注意 <code>TowerSetℓ</code> 在 <code>Tower</code> 定义完成之前就被使用了. Agda 允许这种写法, 只要满足一定条件, 这里不展开.</p>
<h3 id="塔也是链">“塔”也是链</h3>
<p>接下来, 我们将证明任意两个满足 <code>Tower</code> 的元素都可以比较大小, 命名为 <code>isChainTower</code>. 一旦其证明完成, 就可以立即证明 <code>TowerSetℓ</code> 是链, 乃至 <code>TowerSet</code> 是链.</p>
<pre class="Agda">  <a id="Contra.isChainTower"></a><a id="12267" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="12280" class="Symbol">:</a> <a id="12282" class="Symbol">∀</a> <a id="12284" href="CubicalExt.Logic.Zorn.html#12284" class="Bound">x</a> <a id="12286" href="CubicalExt.Logic.Zorn.html#12286" class="Bound">y</a> <a id="12288" class="Symbol">→</a> <a id="12290" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="12296" href="CubicalExt.Logic.Zorn.html#12284" class="Bound">x</a> <a id="12298" class="Symbol">→</a> <a id="12300" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="12306" href="CubicalExt.Logic.Zorn.html#12286" class="Bound">y</a> <a id="12308" class="Symbol">→</a> <a id="12310" href="CubicalExt.Logic.Zorn.html#12284" class="Bound">x</a> <a id="12312" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="12314" href="CubicalExt.Logic.Zorn.html#12286" class="Bound">y</a> <a id="12316" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="12318" href="CubicalExt.Logic.Zorn.html#12286" class="Bound">y</a> <a id="12320" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="12322" href="CubicalExt.Logic.Zorn.html#12284" class="Bound">x</a>
  <a id="Contra.isChainTowerSetℓ"></a><a id="12326" href="CubicalExt.Logic.Zorn.html#12326" class="Function">isChainTowerSetℓ</a> <a id="12343" class="Symbol">:</a> <a id="12345" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="12353" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a>
  <a id="12365" href="CubicalExt.Logic.Zorn.html#12326" class="Function">isChainTowerSetℓ</a> <a id="12382" href="CubicalExt.Logic.Zorn.html#12382" class="Bound">x</a> <a id="12384" href="CubicalExt.Logic.Zorn.html#12384" class="Bound">y</a> <a id="12386" class="Symbol">=</a> <a id="12388" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="12393" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="12401" class="Symbol">(</a><a id="12402" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="12415" href="CubicalExt.Logic.Zorn.html#12382" class="Bound">x</a> <a id="12417" href="CubicalExt.Logic.Zorn.html#12384" class="Bound">y</a><a id="12418" class="Symbol">)</a>
  <a id="Contra.isChainTowerSet"></a><a id="12422" href="CubicalExt.Logic.Zorn.html#12422" class="Function">isChainTowerSet</a> <a id="12438" class="Symbol">:</a> <a id="12440" href="CubicalExt.Logic.Zorn.html#3337" class="Function">isChain</a> <a id="12448" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a>
  <a id="12459" href="CubicalExt.Logic.Zorn.html#12422" class="Function">isChainTowerSet</a> <a id="12475" href="CubicalExt.Logic.Zorn.html#12475" class="Bound">x</a> <a id="12477" href="CubicalExt.Logic.Zorn.html#12477" class="Bound">y</a> <a id="12479" href="CubicalExt.Logic.Zorn.html#12479" class="Bound">x∈</a> <a id="12482" href="CubicalExt.Logic.Zorn.html#12482" class="Bound">y∈</a> <a id="12485" class="Symbol">=</a> <a id="12487" href="CubicalExt.Logic.Zorn.html#12326" class="Function">isChainTowerSetℓ</a> <a id="12504" href="CubicalExt.Logic.Zorn.html#12475" class="Bound">x</a> <a id="12506" href="CubicalExt.Logic.Zorn.html#12477" class="Bound">y</a> <a id="12508" class="Symbol">(</a><a id="12509" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="12518" href="CubicalExt.Logic.Zorn.html#12479" class="Bound">x∈</a><a id="12520" class="Symbol">)</a> <a id="12522" class="Symbol">(</a><a id="12523" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="12532" href="CubicalExt.Logic.Zorn.html#12482" class="Bound">y∈</a><a id="12534" class="Symbol">)</a>
</pre>
<p>该命题的证明需要复杂的递归, 为了使结构更清晰, 我们写成互递归 (mutual recursion).</p>
<p>我们先证明结论的一个弱化版, 作为中间引理, 命名为 <code>almostChain</code>, 其证明会递归调用 <code>isChainTower</code>. 随后, 我们完成 <code>isChainTower</code> 的证明, 其中会递归调用 <code>almostChain</code>. Agda 会保证循环论证不会通过.</p>
<p>现在, 给定满足 <code>Tower</code> 条件的 <code>y</code>. 将 <code>y</code> 的后继记作 <code>y'</code>.</p>
<pre class="Agda">  <a id="12788" class="Keyword">module</a> <a id="12795" href="CubicalExt.Logic.Zorn.html#12795" class="Module">_</a> <a id="12797" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="12799" class="Symbol">(</a><a id="12800" href="CubicalExt.Logic.Zorn.html#12800" class="Bound">y∈</a> <a id="12803" class="Symbol">:</a> <a id="12805" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="12811" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a><a id="12812" class="Symbol">)</a> <a id="12814" class="Keyword">where</a>
    <a id="12824" class="Keyword">private</a> <a id="12832" href="CubicalExt.Logic.Zorn.html#12832" class="Function">y&#39;</a> <a id="12835" class="Symbol">=</a> <a id="12837" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="12844" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="12846" class="Symbol">.</a><a id="12847" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p><code>almostChain</code> 是说任意满足 <code>Tower</code> 条件的 <code>x</code> 要么小于等于 <code>y</code> 要么大于等于 <code>y'</code>.</p>
<pre class="Agda">    <a id="12930" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="12942" class="Symbol">:</a> <a id="12944" class="Symbol">∀</a> <a id="12946" href="CubicalExt.Logic.Zorn.html#12946" class="Bound">x</a> <a id="12948" class="Symbol">→</a> <a id="12950" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="12956" href="CubicalExt.Logic.Zorn.html#12946" class="Bound">x</a> <a id="12958" class="Symbol">→</a> <a id="12960" href="CubicalExt.Logic.Zorn.html#12946" class="Bound">x</a> <a id="12962" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="12964" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="12966" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="12968" href="CubicalExt.Logic.Zorn.html#12832" class="Function">y&#39;</a> <a id="12971" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="12973" href="CubicalExt.Logic.Zorn.html#12946" class="Bound">x</a>
</pre>
<p>这里又需要一个互递归命题 <code>almostChain'</code>: 任意属于 <code>TowerSetℓ</code> 的 <code>x</code> 要么小于等于 <code>y</code> 要么大于等于 <code>y'</code>. 它会在后面 <code>almostChain</code> 的证明里调用, 但是我们先调用 <code>almostChain</code> 来证明它. 这个证明通过对高阶归纳类型 (HIT) 进行模式匹配完成, 具体的技术细节这里不展开.</p>
<pre class="Agda">    <a id="13169" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="13182" class="Symbol">:</a> <a id="13184" class="Symbol">∀</a> <a id="13186" href="CubicalExt.Logic.Zorn.html#13186" class="Bound">x</a> <a id="13188" class="Symbol">→</a> <a id="13190" href="CubicalExt.Logic.Zorn.html#13186" class="Bound">x</a> <a id="13192" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="13194" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a> <a id="13204" class="Symbol">→</a> <a id="13206" href="CubicalExt.Logic.Zorn.html#13186" class="Bound">x</a> <a id="13208" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="13210" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="13212" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="13214" href="CubicalExt.Logic.Zorn.html#12832" class="Function">y&#39;</a> <a id="13217" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="13219" href="CubicalExt.Logic.Zorn.html#13186" class="Bound">x</a>
    <a id="13225" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="13238" href="CubicalExt.Logic.Zorn.html#13238" class="Bound">x</a> <a id="13240" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="13242" href="CubicalExt.Logic.Zorn.html#13242" class="Bound">x∈</a> <a id="13245" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="13248" class="Symbol">=</a> <a id="13250" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="13262" href="CubicalExt.Logic.Zorn.html#13238" class="Bound">x</a> <a id="13264" href="CubicalExt.Logic.Zorn.html#13242" class="Bound">x∈</a>
    <a id="13271" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="13284" href="CubicalExt.Logic.Zorn.html#13284" class="Bound">x</a> <a id="13286" class="Symbol">(</a><a id="13287" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="13295" href="CubicalExt.Logic.Zorn.html#13295" class="Bound">x∈₁</a> <a id="13299" href="CubicalExt.Logic.Zorn.html#13299" class="Bound">x∈₂</a> <a id="13303" href="CubicalExt.Logic.Zorn.html#13303" class="Bound">i</a><a id="13304" class="Symbol">)</a> <a id="13306" class="Symbol">=</a> <a id="13308" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="13316" class="Symbol">(</a><a id="13317" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="13330" href="CubicalExt.Logic.Zorn.html#13284" class="Bound">x</a> <a id="13332" href="CubicalExt.Logic.Zorn.html#13295" class="Bound">x∈₁</a><a id="13335" class="Symbol">)</a> <a id="13337" class="Symbol">(</a><a id="13338" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="13351" href="CubicalExt.Logic.Zorn.html#13284" class="Bound">x</a> <a id="13353" href="CubicalExt.Logic.Zorn.html#13299" class="Bound">x∈₂</a><a id="13356" class="Symbol">)</a> <a id="13358" href="CubicalExt.Logic.Zorn.html#13303" class="Bound">i</a>
</pre>
<p>回到 <code>almostChain</code> 的证明. 由 <code>Tower</code> 的定义, 前提归纳为两种情况.</p>
<ul>
<li><p><code>x</code> (这里重命名为 <code>x'</code>) 其实是某个满足 <code>Tower</code> 的 <code>x</code> 的后继. 这种情况下我们递归调用 <code>isChainTower</code> 讨论 <code>x'</code> 与 <code>y</code> 的大小, 再递归调用 <code>almostChain</code> 讨论 <code>x</code> 与 <code>y</code> 的大小, 分三种情况.</p>
<ul>
<li><code>x ≤ y</code> 且 <code>x' ≤ y</code>. 取目标的左边即证.</li>
<li><code>x ≤ y</code> 且 <code>y ≤ x'</code>. 由于 <code>x'</code> 是 <code>x</code> 的后继, 它们之间的 <code>y</code> 要么等于 <code>x</code>, 这时目标的右边 <code>x ≤ x'</code> 成立; 要么 <code>y</code> 等于 <code>x'</code>, 这时目标的左边 <code>x ≤ x'</code> 成立.</li>
<li><code>y' ≤ x</code>. 这时由传递性有 <code>y' ≤ x'</code>, 即目标右边.</li>
</ul></li>
</ul>
<pre class="Agda">    <a id="13761" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="13773" href="CubicalExt.Logic.Zorn.html#13773" class="Bound">x&#39;</a> <a id="13776" class="Symbol">(</a><a id="13777" href="CubicalExt.Logic.Zorn.html#11891" class="InductiveConstructor">includeSuc</a> <a id="13788" href="CubicalExt.Logic.Zorn.html#13788" class="Bound">x</a> <a id="13790" href="CubicalExt.Logic.Zorn.html#13790" class="Bound">x∈</a><a id="13792" class="Symbol">)</a> <a id="13794" class="Keyword">with</a> <a id="13799" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="13812" href="CubicalExt.Logic.Zorn.html#13773" class="Bound">x&#39;</a> <a id="13815" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="13817" class="Symbol">(</a><a id="13818" href="CubicalExt.Logic.Zorn.html#11891" class="InductiveConstructor">includeSuc</a> <a id="13829" href="CubicalExt.Logic.Zorn.html#13788" class="Bound">x</a> <a id="13831" href="CubicalExt.Logic.Zorn.html#13790" class="Bound">x∈</a><a id="13833" class="Symbol">)</a> <a id="13835" href="CubicalExt.Logic.Zorn.html#12800" class="Bound">y∈</a>
    <a id="13842" class="Symbol">...</a> <a id="13846" class="Symbol">|</a> <a id="13848" href="CubicalExt.Logic.Zorn.html#13848" class="Bound">IH</a> <a id="13851" class="Symbol">=</a> <a id="13853" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="13858" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="13872" class="Symbol">(λ{</a> <a id="13876" class="Symbol">(</a><a id="13877" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13883" href="CubicalExt.Logic.Zorn.html#13883" class="Bound">x≤y</a><a id="13886" class="Symbol">)</a> <a id="13888" class="Symbol">(</a><a id="13889" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13895" href="CubicalExt.Logic.Zorn.html#13895" class="Bound">x&#39;≤y</a><a id="13899" class="Symbol">)</a> <a id="13901" class="Symbol">→</a> <a id="13903" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="13907" href="CubicalExt.Logic.Zorn.html#13895" class="Bound">x&#39;≤y</a>
        <a id="13920" class="Symbol">;</a> <a id="13922" class="Symbol">(</a><a id="13923" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13929" href="CubicalExt.Logic.Zorn.html#13929" class="Bound">x≤y</a><a id="13932" class="Symbol">)</a> <a id="13934" class="Symbol">(</a><a id="13935" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="13941" href="CubicalExt.Logic.Zorn.html#13941" class="Bound">y≤x&#39;</a><a id="13945" class="Symbol">)</a> <a id="13947" class="Symbol">→</a> <a id="13949" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="13953" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
          <a id="13971" class="Symbol">(λ{</a> <a id="13975" class="Symbol">(</a><a id="13976" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13982" href="CubicalExt.Logic.Zorn.html#13982" class="Bound">y≡x</a><a id="13985" class="Symbol">)</a>  <a id="13988" class="Symbol">→</a> <a id="13990" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="13994" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="13996" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="14002" class="Symbol">(λ</a> <a id="14005" href="CubicalExt.Logic.Zorn.html#14005" class="Bound">x</a> <a id="14007" class="Symbol">→</a> <a id="14009" class="Symbol">_</a> <a id="14011" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="14013" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="14020" href="CubicalExt.Logic.Zorn.html#14005" class="Bound">x</a> <a id="14022" class="Symbol">.</a><a id="14023" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="14026" class="Symbol">)</a> <a id="14028" href="CubicalExt.Logic.Zorn.html#13982" class="Bound">y≡x</a> <a id="14032" class="Symbol">(</a><a id="14033" href="CubicalExt.Logic.Zorn.html#11197" class="Function">≤-refl</a> <a id="14040" class="Symbol">_)</a>
            <a id="14055" class="Symbol">;</a> <a id="14057" class="Symbol">(</a><a id="14058" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="14064" href="CubicalExt.Logic.Zorn.html#14064" class="Bound">y≡x&#39;</a><a id="14068" class="Symbol">)</a> <a id="14070" class="Symbol">→</a> <a id="14072" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="14076" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14078" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="14084" class="Symbol">(λ</a> <a id="14087" href="CubicalExt.Logic.Zorn.html#14087" class="Bound">x</a> <a id="14089" class="Symbol">→</a> <a id="14091" class="Symbol">_</a> <a id="14093" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="14095" href="CubicalExt.Logic.Zorn.html#14087" class="Bound">x</a><a id="14096" class="Symbol">)</a> <a id="14098" class="Symbol">(</a><a id="14099" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="14103" href="CubicalExt.Logic.Zorn.html#14064" class="Bound">y≡x&#39;</a><a id="14107" class="Symbol">)</a> <a id="14109" class="Symbol">(</a><a id="14110" href="CubicalExt.Logic.Zorn.html#11197" class="Function">≤-refl</a> <a id="14117" class="Symbol">_)</a> <a id="14120" class="Symbol">})</a>
          <a id="14133" class="Symbol">(</a><a id="14134" href="CubicalExt.Logic.Zorn.html#14287" class="Function">noMid</a> <a id="14140" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="14142" href="CubicalExt.Logic.Zorn.html#13929" class="Bound">x≤y</a> <a id="14146" href="CubicalExt.Logic.Zorn.html#13941" class="Bound">y≤x&#39;</a><a id="14150" class="Symbol">)</a>
        <a id="14160" class="Symbol">;</a> <a id="14162" class="Symbol">(</a><a id="14163" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="14169" href="CubicalExt.Logic.Zorn.html#14169" class="Bound">y&#39;≤x</a><a id="14173" class="Symbol">)</a> <a id="14175" class="Symbol">_</a> <a id="14177" class="Symbol">→</a> <a id="14179" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="14183" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14185" href="CubicalExt.Logic.Zorn.html#11264" class="Function">≤-trans</a> <a id="14193" href="CubicalExt.Logic.Zorn.html#12832" class="Function">y&#39;</a> <a id="14196" class="Bound">x</a> <a id="14198" class="Bound">x&#39;</a> <a id="14201" href="CubicalExt.Logic.Zorn.html#14169" class="Bound">y&#39;≤x</a> <a id="14206" href="CubicalExt.Logic.Zorn.html#14254" class="Function">x≤x&#39;</a> <a id="14211" class="Symbol">})</a>
      <a id="14220" class="Symbol">(</a><a id="14221" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="14233" class="Bound">x</a> <a id="14235" class="Bound">x∈</a><a id="14237" class="Symbol">)</a> <a id="14239" href="CubicalExt.Logic.Zorn.html#13848" class="Bound">IH</a> <a id="14242" class="Keyword">where</a>
      <a id="14254" href="CubicalExt.Logic.Zorn.html#14254" class="Function">x≤x&#39;</a>  <a id="14260" class="Symbol">=</a> <a id="14262" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="14269" class="Bound">x</a> <a id="14271" class="Symbol">.</a><a id="14272" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14276" class="Symbol">.</a><a id="14277" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
      <a id="14287" href="CubicalExt.Logic.Zorn.html#14287" class="Function">noMid</a> <a id="14293" class="Symbol">=</a> <a id="14295" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="14302" class="Bound">x</a> <a id="14304" class="Symbol">.</a><a id="14305" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14309" class="Symbol">.</a><a id="14310" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14314" class="Symbol">.</a><a id="14315" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<ul>
<li><p><code>x</code> 其实是 <code>TowerSetℓ</code> 的子集: 链 <code>A</code> 的上确界. 我们用排中律讨论 <code>y</code> 是不是 <code>A</code> 的上界.</p>
<ul>
<li><code>y</code> 是 <code>A</code> 的上界, 那么有 <code>x ≤ y</code>, 目标左边成立.</li>
<li><code>y</code> 不是 <code>A</code> 的上界, 那么有 <code>y</code> 与 <code>A</code> 的上确界 <code>x</code> 之间存在 (这里也用了排中律) 一个元素 <code>z</code> 满足 <code>y &lt; z</code> 且 <code>z ≤ x</code>. 由传递性, <code>y' ≤ x</code>, 即目标右边成立. 注意这里需要调用 <code>almostChain'</code> 以使用 “<code>A</code> 是 <code>TowerSetℓ</code> 的子集” 这一前提.</li>
</ul></li>
</ul>
<pre class="Agda">    <a id="14616" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="14628" href="CubicalExt.Logic.Zorn.html#14628" class="Bound">x</a> <a id="14630" class="Symbol">(</a><a id="14631" href="CubicalExt.Logic.Zorn.html#11950" class="InductiveConstructor">includeSup</a> <a id="14642" href="CubicalExt.Logic.Zorn.html#14642" class="Bound">A</a> <a id="14644" href="CubicalExt.Logic.Zorn.html#14644" class="Bound">A⊆</a> <a id="14647" href="CubicalExt.Logic.Zorn.html#14647" class="Bound">isChainA</a><a id="14655" class="Symbol">)</a> <a id="14657" class="Keyword">with</a> <a id="14662" href="CubicalExt.Logic.Zorn.html#10906" class="Bound">em</a> <a id="14665" class="Symbol">{</a><a id="14666" class="Argument">P</a> <a id="14668" class="Symbol">=</a> <a id="14670" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="14681" href="CubicalExt.Logic.Zorn.html#14642" class="Bound">A</a> <a id="14683" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a><a id="14684" class="Symbol">}</a>
    <a id="14690" class="Symbol">...</a> <a id="14694" class="Symbol">|</a> <a id="14696" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="14700" href="CubicalExt.Logic.Zorn.html#14700" class="Bound">p</a> <a id="14702" class="Symbol">=</a> <a id="14704" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="14708" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14710" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="14717" class="Bound">A</a> <a id="14719" class="Bound">isChainA</a> <a id="14728" class="Symbol">.</a><a id="14729" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14733" class="Symbol">.</a><a id="14734" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14738" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a> <a id="14740" href="CubicalExt.Logic.Zorn.html#14700" class="Bound">p</a>
    <a id="14746" class="Symbol">...</a> <a id="14750" class="Symbol">|</a> <a id="14752" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a> <a id="14755" href="CubicalExt.Logic.Zorn.html#14755" class="Bound">¬p</a> <a id="14758" class="Symbol">=</a> <a id="14760" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="14764" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14766" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="14770" class="Symbol">(</a><a id="14771" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a> <a id="14778" class="Symbol">_</a> <a id="14780" class="Symbol">_)</a>
      <a id="14789" class="Symbol">(λ{</a> <a id="14793" class="Symbol">(</a><a id="14794" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="14796" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14798" href="CubicalExt.Logic.Zorn.html#14798" class="Bound">¬ub</a><a id="14801" class="Symbol">)</a> <a id="14803" class="Symbol">→</a> <a id="14805" class="Keyword">let</a> <a id="14809" class="Symbol">(</a><a id="14810" href="CubicalExt.Logic.Zorn.html#14810" class="Bound">z∈A</a> <a id="14814" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14816" href="CubicalExt.Logic.Zorn.html#14816" class="Bound">¬z≤y</a><a id="14820" class="Symbol">)</a> <a id="14822" class="Symbol">=</a> <a id="14824" href="CubicalExt.Logic.Classical.html#2570" class="Function">¬→→∧</a> <a id="14829" class="Symbol">(</a><a id="14830" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="14832" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="14834" class="Bound">A</a><a id="14835" class="Symbol">)</a> <a id="14837" class="Symbol">⦃</a> <a id="14839" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="14848" class="Symbol">_</a> <a id="14850" class="Symbol">_</a> <a id="14852" class="Symbol">_</a> <a id="14854" class="Symbol">_</a> <a id="14856" class="Symbol">⦄</a> <a id="14858" class="Symbol">(</a><a id="14859" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="14861" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="14863" href="CubicalExt.Logic.Zorn.html#12797" class="Bound">y</a><a id="14864" class="Symbol">)</a> <a id="14866" href="CubicalExt.Logic.Zorn.html#14798" class="Bound">¬ub</a> <a id="14870" class="Keyword">in</a>
        <a id="14881" href="CubicalExt.Logic.Zorn.html#11264" class="Function">≤-trans</a> <a id="14889" href="CubicalExt.Logic.Zorn.html#12832" class="Function">y&#39;</a> <a id="14892" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="14894" class="Bound">x</a>
          <a id="14906" class="Symbol">(</a><a id="14907" href="CubicalExt.Functions.Logic.html#750" class="Function">∨-elimʳ</a> <a id="14915" class="Symbol">(</a><a id="14916" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a> <a id="14923" class="Symbol">_</a> <a id="14925" class="Symbol">_)</a> <a id="14928" class="Symbol">(</a><a id="14929" href="CubicalExt.Logic.Zorn.html#13169" class="Function">almostChain&#39;</a> <a id="14942" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="14944" class="Symbol">(</a><a id="14945" class="Bound">A⊆</a> <a id="14948" href="CubicalExt.Logic.Zorn.html#14810" class="Bound">z∈A</a><a id="14951" class="Symbol">))</a> <a id="14954" href="CubicalExt.Logic.Zorn.html#14816" class="Bound">¬z≤y</a><a id="14958" class="Symbol">)</a>
          <a id="14970" class="Symbol">(</a><a id="14971" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="14978" class="Bound">A</a> <a id="14980" class="Bound">isChainA</a> <a id="14989" class="Symbol">.</a><a id="14990" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14994" class="Symbol">.</a><a id="14995" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="14999" href="CubicalExt.Logic.Zorn.html#14794" class="Bound">z</a> <a id="15001" href="CubicalExt.Logic.Zorn.html#14810" class="Bound">z∈A</a><a id="15004" class="Symbol">)</a> <a id="15006" class="Symbol">})</a>
      <a id="15015" class="Symbol">(</a><a id="15016" href="CubicalExt.Logic.Classical.html#2732" class="Function">¬∀→∃¬</a> <a id="15022" href="CubicalExt.Logic.Zorn.html#14755" class="Bound">¬p</a><a id="15024" class="Symbol">)</a>
</pre>
<p>至此 <code>almostChain</code> 证毕. 与 <code>almostChain'</code> 类似地, 我们模式匹配高阶归纳类型先证明了 <code>isChainTower'</code>.</p>
<pre class="Agda">  <a id="Contra.isChainTower&#39;"></a><a id="15119" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="15133" class="Symbol">:</a> <a id="15135" class="Symbol">∀</a> <a id="15137" href="CubicalExt.Logic.Zorn.html#15137" class="Bound">x</a> <a id="15139" href="CubicalExt.Logic.Zorn.html#15139" class="Bound">y</a> <a id="15141" class="Symbol">→</a> <a id="15143" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="15149" href="CubicalExt.Logic.Zorn.html#15137" class="Bound">x</a> <a id="15151" class="Symbol">→</a> <a id="15153" href="CubicalExt.Logic.Zorn.html#15139" class="Bound">y</a> <a id="15155" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="15157" href="CubicalExt.Logic.Zorn.html#11626" class="Function">TowerSetℓ</a> <a id="15167" class="Symbol">→</a> <a id="15169" href="CubicalExt.Logic.Zorn.html#15137" class="Bound">x</a> <a id="15171" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="15173" href="CubicalExt.Logic.Zorn.html#15139" class="Bound">y</a> <a id="15175" href="CubicalExt.Functions.Logic.html#267" class="Function Operator">∨</a> <a id="15177" href="CubicalExt.Logic.Zorn.html#15139" class="Bound">y</a> <a id="15179" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="15181" href="CubicalExt.Logic.Zorn.html#15137" class="Bound">x</a>
  <a id="15185" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="15199" href="CubicalExt.Logic.Zorn.html#15199" class="Bound">x</a> <a id="15201" href="CubicalExt.Logic.Zorn.html#15201" class="Bound">y</a> <a id="15203" href="CubicalExt.Logic.Zorn.html#15203" class="Bound">x∈</a> <a id="15206" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="15208" href="CubicalExt.Logic.Zorn.html#15208" class="Bound">y∈</a> <a id="15211" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="15214" class="Symbol">=</a> <a id="15216" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="15229" href="CubicalExt.Logic.Zorn.html#15199" class="Bound">x</a> <a id="15231" href="CubicalExt.Logic.Zorn.html#15201" class="Bound">y</a> <a id="15233" href="CubicalExt.Logic.Zorn.html#15203" class="Bound">x∈</a> <a id="15236" href="CubicalExt.Logic.Zorn.html#15208" class="Bound">y∈</a>
  <a id="15241" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="15255" href="CubicalExt.Logic.Zorn.html#15255" class="Bound">x</a> <a id="15257" href="CubicalExt.Logic.Zorn.html#15257" class="Bound">y</a> <a id="15259" href="CubicalExt.Logic.Zorn.html#15259" class="Bound">x∈</a> <a id="15262" class="Symbol">(</a><a id="15263" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="15271" href="CubicalExt.Logic.Zorn.html#15271" class="Bound">y∈₁</a> <a id="15275" href="CubicalExt.Logic.Zorn.html#15275" class="Bound">y∈₂</a> <a id="15279" href="CubicalExt.Logic.Zorn.html#15279" class="Bound">i</a><a id="15280" class="Symbol">)</a> <a id="15282" class="Symbol">=</a> <a id="15284" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="15292" class="Symbol">(</a><a id="15293" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="15307" href="CubicalExt.Logic.Zorn.html#15255" class="Bound">x</a> <a id="15309" href="CubicalExt.Logic.Zorn.html#15257" class="Bound">y</a> <a id="15311" href="CubicalExt.Logic.Zorn.html#15259" class="Bound">x∈</a> <a id="15314" href="CubicalExt.Logic.Zorn.html#15271" class="Bound">y∈₁</a><a id="15317" class="Symbol">)</a> <a id="15319" class="Symbol">(</a><a id="15320" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="15334" href="CubicalExt.Logic.Zorn.html#15255" class="Bound">x</a> <a id="15336" href="CubicalExt.Logic.Zorn.html#15257" class="Bound">y</a> <a id="15338" href="CubicalExt.Logic.Zorn.html#15259" class="Bound">x∈</a> <a id="15341" href="CubicalExt.Logic.Zorn.html#15275" class="Bound">y∈₂</a><a id="15344" class="Symbol">)</a> <a id="15346" href="CubicalExt.Logic.Zorn.html#15279" class="Bound">i</a>
</pre>
<p>回到 <code>isChainTower</code> 的证明. 由 <code>Tower</code> 的定义, 前提归纳为两种情况.</p>
<ul>
<li><p><code>y</code> (这里重命名为 <code>y'</code>) 其实是某个满足 <code>Tower</code> 的 <code>y</code> 的后继. 这种情况下我们递归调用 <code>almostChain</code>. 分两种情况.</p>
<ul>
<li><code>x ≤ y</code>. 由传递性, <code>x ≤ y'</code>, 即目标的左边成立.</li>
<li><code>y' ≤ x</code>. 目标的右边成立.</li>
</ul></li>
</ul>
<pre class="Agda">  <a id="15558" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="15571" href="CubicalExt.Logic.Zorn.html#15571" class="Bound">x</a> <a id="15573" href="CubicalExt.Logic.Zorn.html#15573" class="Bound">y&#39;</a> <a id="15576" href="CubicalExt.Logic.Zorn.html#15576" class="Bound">x∈</a> <a id="15579" class="Symbol">(</a><a id="15580" href="CubicalExt.Logic.Zorn.html#11891" class="InductiveConstructor">includeSuc</a> <a id="15591" href="CubicalExt.Logic.Zorn.html#15591" class="Bound">y</a> <a id="15593" href="CubicalExt.Logic.Zorn.html#15593" class="Bound">y∈</a><a id="15595" class="Symbol">)</a> <a id="15597" class="Symbol">=</a> <a id="15599" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="15603" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
    <a id="15615" class="Symbol">(λ{</a> <a id="15619" class="Symbol">(</a><a id="15620" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="15626" href="CubicalExt.Logic.Zorn.html#15626" class="Bound">x≤y</a><a id="15629" class="Symbol">)</a>  <a id="15632" class="Symbol">→</a> <a id="15634" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="15638" class="Symbol">(</a><a id="15639" href="CubicalExt.Logic.Zorn.html#11264" class="Function">≤-trans</a> <a id="15647" href="CubicalExt.Logic.Zorn.html#15571" class="Bound">x</a> <a id="15649" href="CubicalExt.Logic.Zorn.html#15591" class="Bound">y</a> <a id="15651" href="CubicalExt.Logic.Zorn.html#15573" class="Bound">y&#39;</a> <a id="15654" href="CubicalExt.Logic.Zorn.html#15626" class="Bound">x≤y</a> <a id="15658" href="CubicalExt.Logic.Zorn.html#15733" class="Function">y≤y&#39;</a><a id="15662" class="Symbol">)</a>
      <a id="15670" class="Symbol">;</a> <a id="15672" class="Symbol">(</a><a id="15673" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="15679" href="CubicalExt.Logic.Zorn.html#15679" class="Bound">y&#39;≤x</a><a id="15683" class="Symbol">)</a> <a id="15685" class="Symbol">→</a> <a id="15687" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="15691" href="CubicalExt.Logic.Zorn.html#15679" class="Bound">y&#39;≤x</a> <a id="15696" class="Symbol">})</a>
    <a id="15703" class="Symbol">(</a><a id="15704" href="CubicalExt.Logic.Zorn.html#12930" class="Function">almostChain</a> <a id="15716" href="CubicalExt.Logic.Zorn.html#15591" class="Bound">y</a> <a id="15718" href="CubicalExt.Logic.Zorn.html#15593" class="Bound">y∈</a> <a id="15721" href="CubicalExt.Logic.Zorn.html#15571" class="Bound">x</a> <a id="15723" href="CubicalExt.Logic.Zorn.html#15576" class="Bound">x∈</a><a id="15725" class="Symbol">)</a> <a id="15727" class="Keyword">where</a> <a id="15733" href="CubicalExt.Logic.Zorn.html#15733" class="Function">y≤y&#39;</a> <a id="15738" class="Symbol">=</a> <a id="15740" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="15747" href="CubicalExt.Logic.Zorn.html#15591" class="Bound">y</a> <a id="15749" class="Symbol">.</a><a id="15750" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15754" class="Symbol">.</a><a id="15755" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<ul>
<li><code>y</code> 其实是 <code>TowerSetℓ</code> 的子集: 链 <code>A</code> 的上确界. 这种情况与 <code>almostChain</code> 的相应情况相当类似, 只不过变量名字换了一下.</li>
</ul>
<pre class="Agda">  <a id="15858" href="CubicalExt.Logic.Zorn.html#12267" class="Function">isChainTower</a> <a id="15871" href="CubicalExt.Logic.Zorn.html#15871" class="Bound">x</a> <a id="15873" href="CubicalExt.Logic.Zorn.html#15873" class="Bound">y</a> <a id="15875" href="CubicalExt.Logic.Zorn.html#15875" class="Bound">x∈</a> <a id="15878" class="Symbol">(</a><a id="15879" href="CubicalExt.Logic.Zorn.html#11950" class="InductiveConstructor">includeSup</a> <a id="15890" href="CubicalExt.Logic.Zorn.html#15890" class="Bound">A</a> <a id="15892" href="CubicalExt.Logic.Zorn.html#15892" class="Bound">A⊆</a> <a id="15895" href="CubicalExt.Logic.Zorn.html#15895" class="Bound">isChainA</a><a id="15903" class="Symbol">)</a> <a id="15905" class="Keyword">with</a> <a id="15910" href="CubicalExt.Logic.Zorn.html#10906" class="Bound">em</a> <a id="15913" class="Symbol">{</a><a id="15914" class="Argument">P</a> <a id="15916" class="Symbol">=</a> <a id="15918" href="CubicalExt.Logic.Zorn.html#3679" class="Function">upperBound</a> <a id="15929" href="CubicalExt.Logic.Zorn.html#15890" class="Bound">A</a> <a id="15931" href="CubicalExt.Logic.Zorn.html#15871" class="Bound">x</a><a id="15932" class="Symbol">}</a>
  <a id="15936" class="Symbol">...</a> <a id="15940" class="Symbol">|</a> <a id="15942" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="15946" href="CubicalExt.Logic.Zorn.html#15946" class="Bound">p</a> <a id="15948" class="Symbol">=</a> <a id="15950" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="15954" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="15956" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="15963" class="Bound">A</a> <a id="15965" class="Bound">isChainA</a> <a id="15974" class="Symbol">.</a><a id="15975" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15979" class="Symbol">.</a><a id="15980" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15984" class="Bound">x</a> <a id="15986" href="CubicalExt.Logic.Zorn.html#15946" class="Bound">p</a>
  <a id="15990" class="Symbol">...</a> <a id="15994" class="Symbol">|</a> <a id="15996" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a> <a id="15999" href="CubicalExt.Logic.Zorn.html#15999" class="Bound">¬p</a> <a id="16002" class="Symbol">=</a> <a id="16004" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="16008" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="16010" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="16014" class="Symbol">(</a><a id="16015" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a> <a id="16022" class="Symbol">_</a> <a id="16024" class="Symbol">_)</a>
    <a id="16031" class="Symbol">(λ{</a> <a id="16035" class="Symbol">(</a><a id="16036" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16038" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="16040" href="CubicalExt.Logic.Zorn.html#16040" class="Bound">¬ub</a><a id="16043" class="Symbol">)</a> <a id="16045" class="Symbol">→</a> <a id="16047" class="Keyword">let</a> <a id="16051" class="Symbol">(</a><a id="16052" href="CubicalExt.Logic.Zorn.html#16052" class="Bound">z∈A</a> <a id="16056" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="16058" href="CubicalExt.Logic.Zorn.html#16058" class="Bound">¬z≤x</a><a id="16062" class="Symbol">)</a> <a id="16064" class="Symbol">=</a> <a id="16066" href="CubicalExt.Logic.Classical.html#2570" class="Function">¬→→∧</a> <a id="16071" class="Symbol">(</a><a id="16072" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16074" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="16076" class="Bound">A</a><a id="16077" class="Symbol">)</a> <a id="16079" class="Symbol">⦃</a> <a id="16081" href="CubicalExt.Foundations.Powerset%252A.html#2005" class="Function">∈-isProp</a> <a id="16090" class="Symbol">_</a> <a id="16092" class="Symbol">_</a> <a id="16094" class="Symbol">_</a> <a id="16096" class="Symbol">_</a> <a id="16098" class="Symbol">⦄</a> <a id="16100" class="Symbol">(</a><a id="16101" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16103" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="16105" class="Bound">x</a><a id="16106" class="Symbol">)</a> <a id="16108" href="CubicalExt.Logic.Zorn.html#16040" class="Bound">¬ub</a> <a id="16112" class="Keyword">in</a>
      <a id="16121" href="CubicalExt.Logic.Zorn.html#11264" class="Function">≤-trans</a> <a id="16129" class="Bound">x</a> <a id="16131" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16133" class="Bound">y</a>
        <a id="16143" class="Symbol">(</a><a id="16144" href="CubicalExt.Functions.Logic.html#620" class="Function">∨-elimˡ</a> <a id="16152" class="Symbol">(</a><a id="16153" href="CubicalExt.Logic.Zorn.html#11171" class="Function">≤-prop</a> <a id="16160" class="Symbol">_</a> <a id="16162" class="Symbol">_)</a> <a id="16165" class="Symbol">(</a><a id="16166" href="CubicalExt.Logic.Zorn.html#15119" class="Function">isChainTower&#39;</a> <a id="16180" class="Bound">x</a> <a id="16182" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16184" class="Bound">x∈</a> <a id="16187" class="Symbol">(</a><a id="16188" class="Bound">A⊆</a> <a id="16191" href="CubicalExt.Logic.Zorn.html#16052" class="Bound">z∈A</a><a id="16194" class="Symbol">))</a> <a id="16197" href="CubicalExt.Logic.Zorn.html#16058" class="Bound">¬z≤x</a><a id="16201" class="Symbol">)</a>
        <a id="16211" class="Symbol">(</a><a id="16212" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="16219" class="Bound">A</a> <a id="16221" class="Bound">isChainA</a> <a id="16230" class="Symbol">.</a><a id="16231" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16235" class="Symbol">.</a><a id="16236" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="16240" href="CubicalExt.Logic.Zorn.html#16036" class="Bound">z</a> <a id="16242" href="CubicalExt.Logic.Zorn.html#16052" class="Bound">z∈A</a><a id="16245" class="Symbol">)</a> <a id="16247" class="Symbol">})</a>
    <a id="16254" class="Symbol">(</a><a id="16255" href="CubicalExt.Logic.Classical.html#2732" class="Function">¬∀→∃¬</a> <a id="16261" href="CubicalExt.Logic.Zorn.html#15999" class="Bound">¬p</a><a id="16263" class="Symbol">)</a>
</pre>
<h3 id="矛盾">矛盾</h3>
<p>证明了 <code>TowerSet</code> 是链之后, 构造矛盾就非常简单了. 由前提, <code>TowerSet</code> 可以取到上确界 <code>sup</code>, 且 <code>sup</code> 可以取到后继 <code>suc</code>.</p>
<pre class="Agda">  <a id="Contra.Σsup"></a><a id="16375" href="CubicalExt.Logic.Zorn.html#16375" class="Function">Σsup</a> <a id="16380" class="Symbol">=</a> <a id="16382" href="CubicalExt.Logic.Zorn.html#10984" class="Bound">hasSup</a> <a id="16389" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a> <a id="16398" href="CubicalExt.Logic.Zorn.html#12422" class="Function">isChainTowerSet</a>
  <a id="Contra.sup"></a><a id="16416" href="CubicalExt.Logic.Zorn.html#16416" class="Function">sup</a> <a id="16420" class="Symbol">=</a> <a id="16422" href="CubicalExt.Logic.Zorn.html#16375" class="Function">Σsup</a> <a id="16427" class="Symbol">.</a><a id="16428" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.ubhood"></a><a id="16434" href="CubicalExt.Logic.Zorn.html#16434" class="Function">ubhood</a> <a id="16441" class="Symbol">=</a> <a id="16443" href="CubicalExt.Logic.Zorn.html#16375" class="Function">Σsup</a> <a id="16448" class="Symbol">.</a><a id="16449" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16453" class="Symbol">.</a><a id="16454" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>

  <a id="Contra.Σsuc"></a><a id="16461" href="CubicalExt.Logic.Zorn.html#16461" class="Function">Σsuc</a> <a id="16466" class="Symbol">=</a> <a id="16468" href="CubicalExt.Logic.Zorn.html#11020" class="Bound">hasSuc</a> <a id="16475" href="CubicalExt.Logic.Zorn.html#16416" class="Function">sup</a>
  <a id="Contra.suc"></a><a id="16481" href="CubicalExt.Logic.Zorn.html#16481" class="Function">suc</a> <a id="16485" class="Symbol">=</a> <a id="16487" href="CubicalExt.Logic.Zorn.html#16461" class="Function">Σsuc</a> <a id="16492" class="Symbol">.</a><a id="16493" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.sup≤suc"></a><a id="16499" href="CubicalExt.Logic.Zorn.html#16499" class="Function">sup≤suc</a> <a id="16507" class="Symbol">=</a> <a id="16509" href="CubicalExt.Logic.Zorn.html#16461" class="Function">Σsuc</a> <a id="16514" class="Symbol">.</a><a id="16515" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16519" class="Symbol">.</a><a id="16520" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.sup≢suc"></a><a id="16526" href="CubicalExt.Logic.Zorn.html#16526" class="Function">sup≢suc</a> <a id="16534" class="Symbol">=</a> <a id="16536" href="CubicalExt.Logic.Zorn.html#16461" class="Function">Σsuc</a> <a id="16541" class="Symbol">.</a><a id="16542" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16546" class="Symbol">.</a><a id="16547" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16551" class="Symbol">.</a><a id="16552" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p>按 <code>Tower</code> 的定义, <code>sup</code> 也满足它. 这里命题宇宙调整 (propositional resizing) 起了关键作用.</p>
<pre class="Agda">  <a id="Contra.sup∈Tower"></a><a id="16641" href="CubicalExt.Logic.Zorn.html#16641" class="Function">sup∈Tower</a> <a id="16651" class="Symbol">:</a> <a id="16653" href="CubicalExt.Logic.Zorn.html#11572" class="Datatype">Tower</a> <a id="16659" href="CubicalExt.Logic.Zorn.html#16416" class="Function">sup</a>
  <a id="16665" href="CubicalExt.Logic.Zorn.html#16641" class="Function">sup∈Tower</a> <a id="16675" class="Symbol">=</a> <a id="16677" href="CubicalExt.Logic.Zorn.html#11950" class="InductiveConstructor">includeSup</a> <a id="16688" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a> <a id="16697" href="CubicalExt.Logic.Classical.html#2099" class="Function">unresize</a> <a id="16706" href="CubicalExt.Logic.Zorn.html#12422" class="Function">isChainTowerSet</a>
</pre>
<p>这样, 按 <code>TowerSet</code> 的定义, <code>suc</code> 也在 <code>TowerSet</code> 里.</p>
<pre class="Agda">  <a id="Contra.suc∈TowerSet"></a><a id="16783" href="CubicalExt.Logic.Zorn.html#16783" class="Function">suc∈TowerSet</a> <a id="16796" class="Symbol">:</a> <a id="16798" href="CubicalExt.Logic.Zorn.html#16481" class="Function">suc</a> <a id="16802" href="CubicalExt.Foundations.Powerset%252A.html#1837" class="Function Operator">∈</a> <a id="16804" href="CubicalExt.Logic.Zorn.html#11675" class="Function">TowerSet</a>
  <a id="16815" href="CubicalExt.Logic.Zorn.html#16783" class="Function">suc∈TowerSet</a> <a id="16828" class="Symbol">=</a> <a id="16830" href="CubicalExt.Logic.Classical.html#1984" class="Function">resize</a> <a id="16837" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="16839" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="16843" class="Symbol">(</a><a id="16844" href="CubicalExt.Logic.Zorn.html#11891" class="InductiveConstructor">includeSuc</a> <a id="16855" href="CubicalExt.Logic.Zorn.html#16416" class="Function">sup</a><a id="16858" class="Symbol">)</a> <a id="16860" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="16862" href="CubicalExt.Logic.Zorn.html#16641" class="Function">sup∈Tower</a> <a id="16872" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>但是 <code>suc</code> 是 <code>sup</code> 的后继, 与 <code>sup</code> 是 <code>TowerSet</code> 的上确界矛盾.</p>
<pre class="Agda">  <a id="Contra.false"></a><a id="16942" href="CubicalExt.Logic.Zorn.html#16942" class="Function">false</a> <a id="16948" class="Symbol">:</a> <a id="16950" href="Cubical.Data.Empty.Base.html#145" class="Datatype">⊥</a>
  <a id="16954" href="CubicalExt.Logic.Zorn.html#16942" class="Function">false</a> <a id="16960" class="Symbol">=</a> <a id="16962" href="CubicalExt.Logic.Zorn.html#16526" class="Function">sup≢suc</a> <a id="16970" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="16972" href="CubicalExt.Logic.Zorn.html#11228" class="Function">≤-antisym</a> <a id="16982" class="Symbol">_</a> <a id="16984" class="Symbol">_</a> <a id="16986" href="CubicalExt.Logic.Zorn.html#16499" class="Function">sup≤suc</a> <a id="16994" href="CubicalExt.Logic.Zorn.html#17012" class="Function">suc≤sup</a> <a id="17002" class="Keyword">where</a>
    <a id="17012" href="CubicalExt.Logic.Zorn.html#17012" class="Function">suc≤sup</a> <a id="17020" class="Symbol">:</a> <a id="17022" href="CubicalExt.Logic.Zorn.html#16481" class="Function">suc</a> <a id="17026" href="CubicalExt.Logic.Zorn.html#10940" class="Bound Operator">≤</a> <a id="17028" href="CubicalExt.Logic.Zorn.html#16416" class="Function">sup</a>
    <a id="17036" href="CubicalExt.Logic.Zorn.html#17012" class="Function">suc≤sup</a> <a id="17044" class="Symbol">=</a> <a id="17046" href="CubicalExt.Logic.Zorn.html#16434" class="Function">ubhood</a> <a id="17053" href="CubicalExt.Logic.Zorn.html#16481" class="Function">suc</a> <a id="17057" href="CubicalExt.Logic.Zorn.html#16783" class="Function">suc∈TowerSet</a>
</pre>
<h2 id="选择公理">选择公理</h2>
<p>我们将假设如下形式的选择公理:</p>
<blockquote>
<p>非空集合的笛卡尔积非空</p>
</blockquote>
<p>在同伦类型论中表述为 :</p>
<p><code>(∀ x → ∥ B x ∥₁) → ∥ ∀ x → B x ∥₁</code></p>
<p>其中 <code>x</code> 具有类型 <code>A</code>, 而 <code>A</code> 和每个 <code>B x</code> 都是集合.</p>
<h2 id="佐恩引理的证明">佐恩引理的证明</h2>
<p>假设选择公理, 给定 <code>U</code> 上的二元关系 <code>≤</code>.</p>
<pre class="Agda"><a id="17255" class="Keyword">module</a> <a id="17262" href="CubicalExt.Logic.Zorn.html#17262" class="Module">_</a> <a id="17264" class="Symbol">(</a><a id="17265" href="CubicalExt.Logic.Zorn.html#17265" class="Bound">ac</a> <a id="17268" class="Symbol">:</a> <a id="17270" class="Symbol">∀</a> <a id="17272" class="Symbol">{</a><a id="17273" href="CubicalExt.Logic.Zorn.html#17273" class="Bound">ℓ</a> <a id="17275" href="CubicalExt.Logic.Zorn.html#17275" class="Bound">ℓ&#39;</a><a id="17277" class="Symbol">}</a> <a id="17279" class="Symbol">→</a> <a id="17281" href="CubicalExt.Axiom.Choice.html#1200" class="Function">AC</a> <a id="17284" href="CubicalExt.Logic.Zorn.html#17273" class="Bound">ℓ</a> <a id="17286" href="CubicalExt.Logic.Zorn.html#17275" class="Bound">ℓ&#39;</a><a id="17288" class="Symbol">)</a> <a id="17290" class="Symbol">{</a><a id="17291" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="17293" class="Symbol">:</a> <a id="17295" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="17300" href="CubicalExt.Logic.Zorn.html#2161" class="Generalizable">u</a><a id="17301" class="Symbol">}</a> <a id="17303" class="Symbol">{</a><a id="17304" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">_≤_</a> <a id="17308" class="Symbol">:</a> <a id="17310" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="17314" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="17316" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="17318" href="CubicalExt.Logic.Zorn.html#2163" class="Generalizable">r</a><a id="17319" class="Symbol">}</a> <a id="17321" class="Keyword">where</a>
  <a id="17329" class="Keyword">open</a> <a id="17334" class="Keyword">import</a> <a id="17341" href="CubicalExt.Logic.ClassicalChoice.html" class="Module">CubicalExt.Logic.ClassicalChoice</a> <a id="17374" href="CubicalExt.Logic.Zorn.html#17265" class="Bound">ac</a>
  <a id="17379" class="Keyword">open</a> <a id="17384" href="CubicalExt.Logic.Zorn.html#2401" class="Module">Order</a> <a id="17390" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">_≤_</a>
</pre>
<p>假设 <code>U</code> 是偏序集, 且不存在最大元, 我们证明 “<code>U</code> 无界” 的命题截断 <code>∥ unbound ∥₁</code> 成立. 不难发现, 目标具有适用于选择公理的形式. 选择公理要求 <code>U</code> 是集合, 且 <code>U</code> 配备上无界条件也是集合, 这些显然成立. 现在只需证对任意 <code>x</code> <strong>存在</strong> <code>y</code> 严格大于它.</p>
<pre class="Agda">  <a id="17567" href="CubicalExt.Logic.Zorn.html#17567" class="Function">noMaximum→unbound</a> <a id="17585" class="Symbol">:</a> <a id="17587" href="CubicalExt.Logic.Zorn.html#2650" class="Function">isPoset</a> <a id="17595" class="Symbol">→</a> <a id="17597" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="17599" class="Symbol">(</a><a id="17600" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="17603" href="CubicalExt.Logic.Zorn.html#17603" class="Bound">m</a> <a id="17605" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="17607" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="17609" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="17611" href="CubicalExt.Logic.Zorn.html#3174" class="Function">maximum</a> <a id="17619" href="CubicalExt.Logic.Zorn.html#17603" class="Bound">m</a><a id="17620" class="Symbol">)</a> <a id="17622" class="Symbol">→</a> <a id="17624" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="17626" href="CubicalExt.Logic.Zorn.html#2838" class="Function">unbound</a> <a id="17634" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
  <a id="17639" href="CubicalExt.Logic.Zorn.html#17567" class="Function">noMaximum→unbound</a> <a id="17657" href="CubicalExt.Logic.Zorn.html#17657" class="Bound">≤-poset</a> <a id="17665" href="CubicalExt.Logic.Zorn.html#17665" class="Bound">noMax</a> <a id="17671" class="Symbol">=</a> <a id="17673" href="CubicalExt.Logic.Zorn.html#17265" class="Bound">ac</a> <a id="17676" href="CubicalExt.Logic.Zorn.html#17698" class="Function">Uset</a> <a id="17681" href="CubicalExt.Logic.Zorn.html#17753" class="Function">Σset</a> <a id="17686" href="CubicalExt.Logic.Zorn.html#18384" class="Function">H</a> <a id="17688" class="Keyword">where</a>
    <a id="17698" href="CubicalExt.Logic.Zorn.html#17698" class="Function">Uset</a> <a id="17703" class="Symbol">=</a> <a id="17705" href="CubicalExt.Logic.Zorn.html#17657" class="Bound">≤-poset</a> <a id="17713" class="Symbol">.</a><a id="17714" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="17722" href="CubicalExt.Logic.Zorn.html#17722" class="Function">≤-prop</a> <a id="17729" class="Symbol">=</a> <a id="17731" href="CubicalExt.Logic.Zorn.html#17657" class="Bound">≤-poset</a> <a id="17739" class="Symbol">.</a><a id="17740" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="17744" class="Symbol">.</a><a id="17745" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="17753" href="CubicalExt.Logic.Zorn.html#17753" class="Function">Σset</a> <a id="17758" class="Symbol">:</a> <a id="17760" class="Symbol">∀</a> <a id="17762" href="CubicalExt.Logic.Zorn.html#17762" class="Bound">x</a> <a id="17764" class="Symbol">→</a> <a id="17766" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="17772" class="Symbol">(</a><a id="17773" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="17776" href="CubicalExt.Logic.Zorn.html#17776" class="Bound">x&#39;</a> <a id="17779" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="17781" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="17783" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="17785" class="Symbol">(</a><a id="17786" href="CubicalExt.Logic.Zorn.html#17762" class="Bound">x</a> <a id="17788" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">≤</a> <a id="17790" href="CubicalExt.Logic.Zorn.html#17776" class="Bound">x&#39;</a> <a id="17793" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="17795" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="17797" href="CubicalExt.Logic.Zorn.html#17762" class="Bound">x</a> <a id="17799" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="17801" href="CubicalExt.Logic.Zorn.html#17776" class="Bound">x&#39;</a><a id="17803" class="Symbol">))</a>
    <a id="17810" href="CubicalExt.Logic.Zorn.html#17753" class="Function">Σset</a> <a id="17815" class="Symbol">=</a> <a id="17817" class="Symbol">λ</a> <a id="17819" href="CubicalExt.Logic.Zorn.html#17819" class="Bound">_</a> <a id="17821" class="Symbol">→</a> <a id="17823" href="Cubical.Foundations.HLevels.html#12848" class="Function">isSetΣ</a> <a id="17830" href="CubicalExt.Logic.Zorn.html#17698" class="Function">Uset</a> <a id="17835" class="Symbol">λ</a> <a id="17837" href="CubicalExt.Logic.Zorn.html#17837" class="Bound">_</a> <a id="17839" class="Symbol">→</a> <a id="17841" href="Cubical.Foundations.Prelude.html#18523" class="Function">isProp→isSet</a> <a id="17854" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="17856" href="Cubical.Foundations.HLevels.html#12387" class="Function">isPropΣ</a> <a id="17864" class="Symbol">(</a><a id="17865" href="CubicalExt.Logic.Zorn.html#17722" class="Function">≤-prop</a> <a id="17872" class="Symbol">_</a> <a id="17874" class="Symbol">_)</a> <a id="17877" class="Symbol">λ</a> <a id="17879" href="CubicalExt.Logic.Zorn.html#17879" class="Bound">_</a> <a id="17881" class="Symbol">→</a> <a id="17883" href="Cubical.Foundations.HLevels.html#16363" class="Function">isPropΠ</a> <a id="17891" class="Symbol">λ</a> <a id="17893" href="CubicalExt.Logic.Zorn.html#17893" class="Bound">_</a> <a id="17895" class="Symbol">→</a> <a id="17897" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
</pre>
<p>注意 <code>≤</code> 和 <code>U</code> 上的 <code>≡</code> 都是命题. 这说明接下来证明涉及这些关系的目标时使用排中律是合法的.</p>
<pre class="Agda">    <a id="17978" class="Keyword">instance</a>
      <a id="17993" href="CubicalExt.Logic.Zorn.html#17993" class="Function">≤-propImplicit</a> <a id="18008" class="Symbol">:</a> <a id="18010" class="Symbol">{</a><a id="18011" href="CubicalExt.Logic.Zorn.html#18011" class="Bound">x</a> <a id="18013" href="CubicalExt.Logic.Zorn.html#18013" class="Bound">y</a> <a id="18015" class="Symbol">:</a> <a id="18017" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a><a id="18018" class="Symbol">}</a> <a id="18020" class="Symbol">→</a> <a id="18022" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="18037" class="Symbol">(</a><a id="18038" href="CubicalExt.Logic.Zorn.html#18011" class="Bound">x</a> <a id="18040" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">≤</a> <a id="18042" href="CubicalExt.Logic.Zorn.html#18013" class="Bound">y</a><a id="18043" class="Symbol">)</a>
      <a id="18051" href="CubicalExt.Logic.Zorn.html#17993" class="Function">≤-propImplicit</a> <a id="18066" class="Symbol">=</a> <a id="18068" href="CubicalExt.Logic.Zorn.html#17722" class="Function">≤-prop</a> <a id="18075" class="Symbol">_</a> <a id="18077" class="Symbol">_</a> <a id="18079" class="Symbol">_</a> <a id="18081" class="Symbol">_</a>
      <a id="18089" href="CubicalExt.Logic.Zorn.html#18089" class="Function">≡-propImplicit</a> <a id="18104" class="Symbol">:</a> <a id="18106" class="Symbol">{</a><a id="18107" href="CubicalExt.Logic.Zorn.html#18107" class="Bound">x</a> <a id="18109" href="CubicalExt.Logic.Zorn.html#18109" class="Bound">y</a> <a id="18111" class="Symbol">:</a> <a id="18113" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a><a id="18114" class="Symbol">}</a> <a id="18116" class="Symbol">→</a> <a id="18118" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="18133" class="Symbol">(</a><a id="18134" href="CubicalExt.Logic.Zorn.html#18107" class="Bound">x</a> <a id="18136" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18138" href="CubicalExt.Logic.Zorn.html#18109" class="Bound">y</a><a id="18139" class="Symbol">)</a>
      <a id="18147" href="CubicalExt.Logic.Zorn.html#18089" class="Function">≡-propImplicit</a> <a id="18162" class="Symbol">=</a> <a id="18164" href="CubicalExt.Logic.Zorn.html#17698" class="Function">Uset</a> <a id="18169" class="Symbol">_</a> <a id="18171" class="Symbol">_</a> <a id="18173" class="Symbol">_</a> <a id="18175" class="Symbol">_</a>
</pre>
<p>不存在最大元说明对任意 <code>x</code> 存在 <code>x'</code> 满足 <code>¬ (x ≤ x' → x ≡ x')</code>. 用排中律将这部分转化成 <code>x ≤ x' ∧ ¬ x ≡ x'</code> 就证明了 <code>x'</code> 严格大于 <code>x</code>.</p>
<pre class="Agda">    <a id="18297" href="CubicalExt.Logic.Zorn.html#18297" class="Function">H₀</a> <a id="18300" class="Symbol">:</a> <a id="18302" class="Symbol">∀</a> <a id="18304" href="CubicalExt.Logic.Zorn.html#18304" class="Bound">x</a> <a id="18306" class="Symbol">→</a> <a id="18308" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="18311" href="CubicalExt.Logic.Zorn.html#18311" class="Bound">x&#39;</a> <a id="18314" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="18316" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="18318" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="18320" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="18322" class="Symbol">(</a><a id="18323" href="CubicalExt.Logic.Zorn.html#18304" class="Bound">x</a> <a id="18325" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">≤</a> <a id="18327" href="CubicalExt.Logic.Zorn.html#18311" class="Bound">x&#39;</a> <a id="18330" class="Symbol">→</a> <a id="18332" href="CubicalExt.Logic.Zorn.html#18304" class="Bound">x</a> <a id="18334" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18336" href="CubicalExt.Logic.Zorn.html#18311" class="Bound">x&#39;</a><a id="18338" class="Symbol">)</a>
    <a id="18344" href="CubicalExt.Logic.Zorn.html#18297" class="Function">H₀</a> <a id="18347" href="CubicalExt.Logic.Zorn.html#18347" class="Bound">x</a> <a id="18349" class="Symbol">=</a> <a id="18351" href="CubicalExt.Logic.Classical.html#2732" class="Function">¬∀→∃¬</a> <a id="18357" class="Symbol">λ</a> <a id="18359" href="CubicalExt.Logic.Zorn.html#18359" class="Bound">H</a> <a id="18361" class="Symbol">→</a> <a id="18363" href="CubicalExt.Logic.Zorn.html#17665" class="Bound">noMax</a> <a id="18369" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="18371" href="CubicalExt.Logic.Zorn.html#18347" class="Bound">x</a> <a id="18373" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="18375" href="CubicalExt.Logic.Zorn.html#18359" class="Bound">H</a> <a id="18377" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
    <a id="18384" href="CubicalExt.Logic.Zorn.html#18384" class="Function">H</a> <a id="18386" class="Symbol">:</a> <a id="18388" class="Symbol">∀</a> <a id="18390" href="CubicalExt.Logic.Zorn.html#18390" class="Bound">x</a> <a id="18392" class="Symbol">→</a> <a id="18394" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="18397" href="CubicalExt.Logic.Zorn.html#18397" class="Bound">x&#39;</a> <a id="18400" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="18402" href="CubicalExt.Logic.Zorn.html#17291" class="Bound">U</a> <a id="18404" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="18406" class="Symbol">(</a><a id="18407" href="CubicalExt.Logic.Zorn.html#18390" class="Bound">x</a> <a id="18409" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">≤</a> <a id="18411" href="CubicalExt.Logic.Zorn.html#18397" class="Bound">x&#39;</a> <a id="18414" href="CubicalExt.Functions.Logic.html#289" class="Function Operator">∧</a> <a id="18416" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="18418" href="CubicalExt.Logic.Zorn.html#18390" class="Bound">x</a> <a id="18420" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18422" href="CubicalExt.Logic.Zorn.html#18397" class="Bound">x&#39;</a><a id="18424" class="Symbol">)</a>
    <a id="18430" href="CubicalExt.Logic.Zorn.html#18384" class="Function">H</a> <a id="18432" href="CubicalExt.Logic.Zorn.html#18432" class="Bound">x</a> <a id="18434" class="Symbol">=</a> <a id="18436" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18440" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="18448" class="Symbol">(λ</a> <a id="18451" class="Symbol">{</a> <a id="18453" class="Symbol">(</a><a id="18454" href="CubicalExt.Logic.Zorn.html#18454" class="Bound">x&#39;</a> <a id="18457" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="18459" href="CubicalExt.Logic.Zorn.html#18459" class="Bound">H</a><a id="18460" class="Symbol">)</a> <a id="18462" class="Symbol">→</a> <a id="18464" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="18466" href="CubicalExt.Logic.Zorn.html#18454" class="Bound">x&#39;</a> <a id="18469" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="18471" href="CubicalExt.Logic.Classical.html#2570" class="Function">¬→→∧</a> <a id="18476" class="Symbol">(</a><a id="18477" href="CubicalExt.Logic.Zorn.html#18432" class="Bound">x</a> <a id="18479" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">≤</a> <a id="18481" href="CubicalExt.Logic.Zorn.html#18454" class="Bound">x&#39;</a><a id="18483" class="Symbol">)</a> <a id="18485" class="Symbol">(</a><a id="18486" href="CubicalExt.Logic.Zorn.html#18432" class="Bound">x</a> <a id="18488" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18490" href="CubicalExt.Logic.Zorn.html#18454" class="Bound">x&#39;</a><a id="18492" class="Symbol">)</a> <a id="18494" href="CubicalExt.Logic.Zorn.html#18459" class="Bound">H</a> <a id="18496" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="18499" class="Symbol">})</a> <a id="18502" class="Symbol">(</a><a id="18503" href="CubicalExt.Logic.Zorn.html#18297" class="Function">H₀</a> <a id="18506" href="CubicalExt.Logic.Zorn.html#18432" class="Bound">x</a><a id="18507" class="Symbol">)</a>
</pre>
<p>最后佐恩引理的证明就非常简单了. 用反证法, 假设 <code>U</code> 没有最大元, 由上一条引理有 <code>∥ unbound ∥₁</code>. 这时只需 <code>rec</code> 到 <code>⊥</code>, 所以可以去掉截断, 拿到完整的 <code>unbound</code>. 这正好是 <code>⪯-successvie</code> 的前提, 于是我们可以证明链集的任意链都能取上界且链集是后继的. 由”塔”的构造我们知道这是矛盾的.</p>
<pre class="Agda">  <a id="18702" href="CubicalExt.Logic.Zorn.html#18702" class="Function">zorn</a> <a id="18707" class="Symbol">:</a> <a id="18709" href="CubicalExt.Logic.Zorn.html#4317" class="Function">Zorn</a>
  <a id="18716" href="CubicalExt.Logic.Zorn.html#18702" class="Function">zorn</a> <a id="18721" href="CubicalExt.Logic.Zorn.html#18721" class="Bound">≤-poset</a> <a id="18729" href="CubicalExt.Logic.Zorn.html#18729" class="Bound">hasUb</a> <a id="18735" class="Symbol">=</a> <a id="18737" href="CubicalExt.Logic.Classical.html#2237" class="Function">byContra</a> <a id="18746" class="Symbol">λ</a> <a id="18748" href="CubicalExt.Logic.Zorn.html#18748" class="Bound">noMax</a> <a id="18754" class="Symbol">→</a> <a id="18756" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18760" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
    <a id="18772" class="Symbol">(</a><a id="18773" href="CubicalExt.Logic.Zorn.html#16942" class="Function">Contra.false</a> <a id="18786" href="CubicalExt.Logic.Zorn.html#5578" class="Function">⪯-po</a> <a id="18791" href="CubicalExt.Logic.Zorn.html#7517" class="Function">⪯-allChainHasSup</a> <a id="18808" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="18810" href="CubicalExt.Logic.Zorn.html#7883" class="Function">⪯-successvie</a> <a id="18823" href="CubicalExt.Logic.Zorn.html#18721" class="Bound">≤-poset</a> <a id="18831" href="CubicalExt.Logic.Zorn.html#18729" class="Bound">hasUb</a><a id="18836" class="Symbol">)</a>
    <a id="18842" class="Symbol">(</a><a id="18843" href="CubicalExt.Logic.Zorn.html#17567" class="Function">noMaximum→unbound</a> <a id="18861" href="CubicalExt.Logic.Zorn.html#18721" class="Bound">≤-poset</a> <a id="18869" href="CubicalExt.Logic.Zorn.html#18748" class="Bound">noMax</a><a id="18874" class="Symbol">)</a>
    <a id="18880" class="Keyword">where</a> <a id="18886" class="Keyword">open</a> <a id="18891" href="CubicalExt.Logic.Zorn.html#4753" class="Module">Chain</a> <a id="18897" href="CubicalExt.Logic.Zorn.html#17304" class="Bound Operator">_≤_</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
