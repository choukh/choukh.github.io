<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda一阶逻辑(1) 语言</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Agda一阶逻辑(1) 语言</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda一阶逻辑1-语言" id="toc-agda一阶逻辑1-语言">Agda一阶逻辑(1) 语言</a></li>
  </ul>
</nav>

<main>
<h1 id="agda一阶逻辑1-语言">Agda一阶逻辑(1) 语言</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-flypitch/blob/main/src/FOL/Language.lagda.md">Language.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-flypitch/FOL.Language.html">Language.html</a></p>
</blockquote>
<p>本系列文章采用立方类型论作为元语言, 讨论一阶逻辑及其性质.</p>
<pre class="Agda"><a id="375" class="Symbol">{-#</a> <a id="379" class="Keyword">OPTIONS</a> <a id="387" class="Pragma">--cubical</a> <a id="397" class="Pragma">--safe</a> <a id="404" class="Symbol">#-}</a>
</pre>
<p>一阶逻辑是一种形式语言, 其语句由一些原始符号按一定的语法组合而成. 符号又分为逻辑符号和非逻辑符号. 本篇先讲非逻辑符号.</p>
<p>非逻辑符号分为函数符号和关系符号, 且它们都带有一个称为元数 (arity) 的属性. 例如, 元数为 2 的函数符号即用于表示二元函数. 特别地, 元数为零的函数又称为常量.</p>
<p>较传统的处理方式是给出所有可能的函数符号和关系符号. 即对任意元数 <span class="math inline">n</span>, 都有自然数多个函数符号</p>
<p><span class="math display">f^n_0,\ f^n_1,\ f^n_2,\ f^n_3,\ ...</span></p>
<p>以及自然数多个关系符号</p>
<p><span class="math display">R^n_0,\ R^n_1,\ R^n_2,\ R^n_3,\ ...</span></p>
<p>在这种处理下, 只有唯一一种一阶逻辑语言.</p>
<p>较现代的方式是根据最终要实现的一阶理论来指定该理论所需的非逻辑符号. 这些特定的符号以及它们的元数所组成的资料叫做理论的<strong>签名 (signature)</strong>. 在这种处理下, 每种签名都对应一种一阶逻辑语言, 因此签名又叫做<strong>语言 (language)</strong>, 语言的实例按惯例记作 ℒ. 由于一阶逻辑的其他部分都是参数化到语言的, 我们把它单独作为一个模块.</p>
<pre class="Agda"><a id="927" class="Keyword">module</a> <a id="934" href="FOL.Language.html" class="Module">FOL.Language</a> <a id="947" class="Keyword">where</a>
</pre>
<p>本篇只需要立方类型论的关于类型和宇宙的核心概念以及自然数.</p>
<pre class="Agda"><a id="997" class="Keyword">open</a> <a id="1002" class="Keyword">import</a> <a id="1009" href="Cubical.Core.Everything.html" class="Module">Cubical.Core.Everything</a> <a id="1033" class="Keyword">using</a> <a id="1039" class="Symbol">(</a><a id="1040" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="1044" class="Symbol">;</a> <a id="1046" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="1051" class="Symbol">;</a> <a id="1053" href="Agda.Primitive.html#774" class="Primitive">ℓ-suc</a><a id="1058" class="Symbol">)</a>
<a id="1060" class="Keyword">open</a> <a id="1065" class="Keyword">import</a> <a id="1072" href="Cubical.Data.Nat.html" class="Module">Cubical.Data.Nat</a> <a id="1089" class="Keyword">using</a> <a id="1095" class="Symbol">(</a><a id="1096" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1097" class="Symbol">)</a>
</pre>
<p><strong>定义 (语言)</strong> 由按元数分类的函数符号集族 <code>functions : ℕ → Type u</code> 以及按元数分类的关系符号集族 <code>relations : ℕ → Type u</code> 组成的资料叫做一阶逻辑的语言. 特别地, 常量集是元数为 0 的函数集.</p>
<pre class="Agda"><a id="1241" class="Keyword">variable</a>
  <a id="1252" href="FOL.Language.html#1252" class="Generalizable">u</a> <a id="1254" class="Symbol">:</a> <a id="1256" href="Agda.Primitive.html#591" class="Postulate">Level</a>

<a id="1263" class="Keyword">record</a> <a id="Language"></a><a id="1270" href="FOL.Language.html#1270" class="Record">Language</a> <a id="1279" class="Symbol">:</a> <a id="1281" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1286" class="Symbol">(</a><a id="1287" href="Agda.Primitive.html#774" class="Primitive">ℓ-suc</a> <a id="1293" href="FOL.Language.html#1293" class="Bound">u</a><a id="1294" class="Symbol">)</a> <a id="1296" class="Keyword">where</a>
  <a id="1304" class="Keyword">field</a>
    <a id="Language.functions"></a><a id="1314" href="FOL.Language.html#1314" class="Field">functions</a> <a id="1324" class="Symbol">:</a> <a id="1326" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1328" class="Symbol">→</a> <a id="1330" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1335" href="FOL.Language.html#1293" class="Bound">u</a>
    <a id="Language.relations"></a><a id="1341" href="FOL.Language.html#1341" class="Field">relations</a> <a id="1351" class="Symbol">:</a> <a id="1353" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1355" class="Symbol">→</a> <a id="1357" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1362" href="FOL.Language.html#1293" class="Bound">u</a>
  <a id="Language.Constant"></a><a id="1366" href="FOL.Language.html#1366" class="Function">Constant</a> <a id="1375" class="Symbol">=</a> <a id="1377" href="FOL.Language.html#1314" class="Field">functions</a> <a id="1387" class="Number">0</a>
</pre>
<p><strong>注意</strong> 我们约定 <code>u</code> 是语言专用的宇宙多态参数, 语言比符号集高一个宇宙.</p>
<p><strong>注意</strong> 我们采用 <code>Type</code> 编码了函数符号集以及关系符号集, 但一个 <code>Type</code> 不一定是集合, 此处也应该不需要做此限制. <!-- TODO 目前看来是这样, 如果需要的话回头再加上 --></p>
<p><strong>例</strong> 下面给出了语言的一个实例 <code>ℒ</code>, 它可以作为皮亚诺算术 (一种一阶理论) 的语言. 注意符号的元数被编码到了类型里面. 例如, 常量 <code>O</code> 的类型是 <code>func 0</code>, 后继函数 <code>S</code> 的类型是 <code>func 1</code>, 加法 <code>+</code> 以及乘法 <code>*</code> 的类型是 <code>func 2</code>, 小于关系 <code>&lt;</code> 的类型是 <code>rel 2</code>.</p>
<pre class="Agda"><a id="1723" class="Keyword">module</a> <a id="ExampleLanguagePA"></a><a id="1730" href="FOL.Language.html#1730" class="Module">ExampleLanguagePA</a> <a id="1748" class="Keyword">where</a>

  <a id="1757" class="Keyword">data</a> <a id="ExampleLanguagePA.func"></a><a id="1762" href="FOL.Language.html#1762" class="Datatype">func</a> <a id="1767" class="Symbol">:</a> <a id="1769" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1771" class="Symbol">→</a> <a id="1773" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1778" class="Keyword">where</a>
    <a id="ExampleLanguagePA.func.O"></a><a id="1788" href="FOL.Language.html#1788" class="InductiveConstructor">O</a> <a id="1790" class="Symbol">:</a> <a id="1792" href="FOL.Language.html#1762" class="Datatype">func</a> <a id="1797" class="Number">0</a>
    <a id="ExampleLanguagePA.func.S"></a><a id="1803" href="FOL.Language.html#1803" class="InductiveConstructor">S</a> <a id="1805" class="Symbol">:</a> <a id="1807" href="FOL.Language.html#1762" class="Datatype">func</a> <a id="1812" class="Number">1</a>
    <a id="ExampleLanguagePA.func.+"></a><a id="1818" href="FOL.Language.html#1818" class="InductiveConstructor">+</a> <a id="1820" class="Symbol">:</a> <a id="1822" href="FOL.Language.html#1762" class="Datatype">func</a> <a id="1827" class="Number">2</a>
    <a id="ExampleLanguagePA.func.*"></a><a id="1833" href="FOL.Language.html#1833" class="InductiveConstructor">*</a> <a id="1835" class="Symbol">:</a> <a id="1837" href="FOL.Language.html#1762" class="Datatype">func</a> <a id="1842" class="Number">2</a>

  <a id="1847" class="Keyword">data</a> <a id="ExampleLanguagePA.rel"></a><a id="1852" href="FOL.Language.html#1852" class="Datatype">rel</a> <a id="1856" class="Symbol">:</a> <a id="1858" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1860" class="Symbol">→</a> <a id="1862" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1867" class="Keyword">where</a>
    <a id="ExampleLanguagePA.rel.&lt;"></a><a id="1877" href="FOL.Language.html#1877" class="InductiveConstructor">&lt;</a> <a id="1879" class="Symbol">:</a> <a id="1881" href="FOL.Language.html#1852" class="Datatype">rel</a> <a id="1885" class="Number">2</a>

  <a id="ExampleLanguagePA.ℒ"></a><a id="1890" href="FOL.Language.html#1890" class="Function">ℒ</a> <a id="1892" class="Symbol">:</a> <a id="1894" href="FOL.Language.html#1270" class="Record">Language</a>
  <a id="1905" href="FOL.Language.html#1890" class="Function">ℒ</a> <a id="1907" class="Symbol">=</a> <a id="1909" class="Keyword">record</a>
    <a id="1920" class="Symbol">{</a> <a id="1922" href="FOL.Language.html#1314" class="Field">functions</a> <a id="1932" class="Symbol">=</a> <a id="1934" href="FOL.Language.html#1762" class="Datatype">func</a>
    <a id="1943" class="Symbol">;</a> <a id="1945" href="FOL.Language.html#1341" class="Field">relations</a> <a id="1955" class="Symbol">=</a> <a id="1957" href="FOL.Language.html#1852" class="Datatype">rel</a>
    <a id="1965" class="Symbol">}</a>
</pre>
<p>今后我们约定 <code>ℒ</code> 作为语言的实例的记号.</p>
<pre class="Agda"><a id="2000" class="Keyword">variable</a>
  <a id="2011" href="FOL.Language.html#2011" class="Generalizable">ℒ</a> <a id="2013" class="Symbol">:</a> <a id="2015" href="FOL.Language.html#1270" class="Record">Language</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
