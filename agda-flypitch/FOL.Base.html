<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda一阶逻辑(2) 项与公式</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda一阶逻辑(2) 项与公式</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda一阶逻辑2-项与公式" id="toc-agda一阶逻辑2-项与公式">Agda一阶逻辑(2) 项与公式</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  <li><a href="#符号优先级" id="toc-符号优先级">符号优先级</a></li>
  </ul></li>
  <li><a href="#项" id="toc-项">项</a></li>
  <li><a href="#公式" id="toc-公式">公式</a></li>
  <li><a href="#导出符号" id="toc-导出符号">导出符号</a></li>
  <li><a href="#变量提升" id="toc-变量提升">变量提升</a></li>
  <li><a href="#变量替换" id="toc-变量替换">变量替换</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda一阶逻辑2-项与公式">Agda一阶逻辑(2) 项与公式</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-flypitch/blob/main/src/FOL/Base.lagda.md">Base.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-flypitch/FOL.Base.html">Base.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本篇定义一阶逻辑的项与公式. 粗略类比, 如果说符号相当于字, 那么<strong>项 (term)</strong> 和<strong>公式 (formula)</strong> 则相当于词和句. 更准确地说, 项由变量与函数符号构成; 公式则由关系符号, 等号, 量化符号与连接符号等构成. 如上一篇所说, 本篇的所有内容都是参数化到语言的.</p>
<pre class="Agda"><a id="487" class="Symbol">{-#</a> <a id="491" class="Keyword">OPTIONS</a> <a id="499" class="Pragma">--cubical</a> <a id="509" class="Pragma">--safe</a> <a id="516" class="Symbol">#-}</a>

<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="546" class="Keyword">module</a> <a id="553" href="FOL.Base.html" class="Module">FOL.Base</a> <a id="562" class="Symbol">(</a><a id="563" href="FOL.Base.html#563" class="Bound">ℒ</a> <a id="565" class="Symbol">:</a> <a id="567" href="FOL.Language.html#1367" class="Record">Language</a> <a id="576" class="Symbol">{</a><a id="577" href="FOL.Language.html#1349" class="Generalizable">u</a><a id="578" class="Symbol">})</a> <a id="581" class="Keyword">where</a>
<a id="587" class="Keyword">open</a> <a id="592" href="FOL.Language.html#1367" class="Module">Language</a> <a id="601" href="FOL.Base.html#563" class="Bound">ℒ</a>
</pre>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="627" class="Keyword">open</a> <a id="632" class="Keyword">import</a> <a id="639" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>
<a id="661" class="Keyword">open</a> <a id="666" class="Keyword">import</a> <a id="673" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="701" class="Keyword">using</a> <a id="707" class="Symbol">(</a><a id="708" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="712" class="Symbol">)</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="735" class="Symbol">as</a> <a id="738" class="Module">ℕ</a> <a id="740" class="Keyword">using</a> <a id="746" class="Symbol">(</a><a id="747" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="748" class="Symbol">;</a> <a id="750" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="753" class="Symbol">;</a> <a id="755" href="Data.Nat.Base.html#3140" class="Primitive Operator">_∸_</a><a id="758" class="Symbol">;</a> <a id="760" href="Data.Nat.Properties.html#10637" class="Function Operator">_&lt;?_</a><a id="764" class="Symbol">)</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="798" class="Keyword">using</a> <a id="804" class="Symbol">(</a><a id="805" href="Data.Nat.Properties.html#10322" class="Function">&lt;-cmp</a><a id="810" class="Symbol">)</a>
<a id="812" class="Keyword">open</a> <a id="817" class="Keyword">import</a> <a id="824" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="833" class="Keyword">using</a> <a id="839" class="Symbol">(</a><a id="840" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a><a id="843" class="Symbol">;</a> <a id="845" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a><a id="847" class="Symbol">;</a> <a id="849" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">_∷_</a><a id="852" class="Symbol">)</a>
<a id="854" class="Keyword">open</a> <a id="859" class="Keyword">import</a> <a id="866" href="Function.html" class="Module">Function</a> <a id="875" class="Keyword">using</a> <a id="881" class="Symbol">(</a><a id="882" href="Function.Base.html#2003" class="Function Operator">_$_</a><a id="885" class="Symbol">)</a>
<a id="887" class="Keyword">open</a> <a id="892" class="Keyword">import</a> <a id="899" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="916" class="Keyword">using</a> <a id="922" class="Symbol">(</a><a id="923" href="Relation.Nullary.html#1520" class="Record">Dec</a><a id="926" class="Symbol">;</a> <a id="928" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a><a id="931" class="Symbol">;</a> <a id="933" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a><a id="935" class="Symbol">)</a>
<a id="937" class="Keyword">open</a> <a id="942" class="Keyword">import</a> <a id="949" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="965" class="Keyword">using</a> <a id="971" class="Symbol">(</a><a id="972" href="Relation.Binary.Definitions.html#2787" class="InductiveConstructor">tri&lt;</a><a id="976" class="Symbol">;</a> <a id="978" href="Relation.Binary.Definitions.html#2841" class="InductiveConstructor">tri≈</a><a id="982" class="Symbol">;</a> <a id="984" href="Relation.Binary.Definitions.html#2895" class="InductiveConstructor">tri&gt;</a><a id="988" class="Symbol">)</a>
</pre>
<h3 id="符号优先级">符号优先级</h3>
<pre class="Agda"><a id="1014" class="Keyword">infix</a> <a id="1020" class="Number">100</a> <a id="1024" href="FOL.Base.html#3367" class="Function Operator">~_</a>
<a id="1027" class="Keyword">infix</a> <a id="1033" class="Number">10</a> <a id="1036" href="FOL.Base.html#4129" class="Function Operator">_↑[_]_</a> <a id="1043" href="FOL.Base.html#4333" class="Function Operator">_↑_</a> <a id="1047" href="FOL.Base.html#4483" class="Function Operator">_↥[_]_</a> <a id="1054" href="FOL.Base.html#4770" class="Function Operator">_↥_</a> <a id="1058" href="FOL.Base.html#5914" class="Function Operator">_[_/_]</a>
<a id="1065" class="Keyword">infix</a> <a id="1071" class="Number">9</a> <a id="1073" href="FOL.Base.html#2792" class="InductiveConstructor Operator">_≈_</a>
<a id="1077" class="Keyword">infix</a> <a id="1083" class="Number">8</a> <a id="1085" href="FOL.Base.html#3603" class="Function Operator">_⇔_</a>
<a id="1089" class="Keyword">infix</a> <a id="1095" class="Number">7</a> <a id="1097" href="FOL.Base.html#2830" class="InductiveConstructor Operator">_⇒_</a>
<a id="1101" class="Keyword">infixr</a> <a id="1108" class="Number">6</a> <a id="1110" href="FOL.Base.html#3489" class="Function Operator">_∧_</a>
<a id="1114" class="Keyword">infixr</a> <a id="1121" class="Number">5</a> <a id="1123" href="FOL.Base.html#3548" class="Function Operator">_∨_</a>
</pre>
<h2 id="项">项</h2>
<p>与语言的处理类似地，我们把函数的元数编码进项的类型里：变量和常量是 <strong>0-项</strong>，n元函数是 <strong>n-项</strong>。此外，变量采用 <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin编码</a>，即把任意自然数当作变量。</p>
<p><strong>定义</strong> 归纳定义 l-项:</p>
<ul>
<li>对任意自然数 <code>n</code>，变量 <code>var n</code> 是 <code>0</code>-项.</li>
<li>对任意 <code>l</code> 元函数符号 <code>f</code>，函数 <code>func f</code> 是 <code>l</code>-项.</li>
<li>对任意 <code>suc l</code>-项 <code>t₁</code> 和任意 <code>0</code>-项 <code>t₂</code>，函数应用 <code>app t₁ t₂</code> 是 <code>l</code>-项.</li>
</ul>
<p>特别地，<code>0</code>-项简称项。</p>
<p>其中 <code>l</code> 可以看作是参数表的长度. 我们始终保留字母 l 来表示它.</p>
<pre class="Agda"><a id="1493" class="Keyword">variable</a>
  <a id="1504" href="FOL.Base.html#1504" class="Generalizable">l</a> <a id="1506" class="Symbol">:</a> <a id="1508" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>

<a id="1511" class="Keyword">data</a> <a id="Termₗ"></a><a id="1516" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1522" class="Symbol">:</a> <a id="1524" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1526" class="Symbol">→</a> <a id="1528" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1533" href="FOL.Base.html#577" class="Bound">u</a> <a id="1535" class="Keyword">where</a>
  <a id="Termₗ.var"></a><a id="1543" href="FOL.Base.html#1543" class="InductiveConstructor">var</a>  <a id="1548" class="Symbol">:</a> <a id="1550" class="Symbol">(</a><a id="1551" href="FOL.Base.html#1551" class="Bound">k</a> <a id="1553" class="Symbol">:</a> <a id="1555" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1556" class="Symbol">)</a> <a id="1558" class="Symbol">→</a> <a id="1560" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1566" class="Number">0</a>
  <a id="Termₗ.func"></a><a id="1570" href="FOL.Base.html#1570" class="InductiveConstructor">func</a> <a id="1575" class="Symbol">:</a> <a id="1577" class="Symbol">(</a><a id="1578" href="FOL.Base.html#1578" class="Bound">f</a> <a id="1580" class="Symbol">:</a> <a id="1582" href="FOL.Language.html#1411" class="Field">𝔉</a> <a id="1584" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="1585" class="Symbol">)</a> <a id="1587" class="Symbol">→</a> <a id="1589" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1595" href="FOL.Base.html#1504" class="Generalizable">l</a>
  <a id="Termₗ.app"></a><a id="1599" href="FOL.Base.html#1599" class="InductiveConstructor">app</a>  <a id="1604" class="Symbol">:</a> <a id="1606" class="Symbol">(</a><a id="1607" href="FOL.Base.html#1607" class="Bound">t₁</a> <a id="1610" class="Symbol">:</a> <a id="1612" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1618" class="Symbol">(</a><a id="1619" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1623" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="1624" class="Symbol">))</a> <a id="1627" class="Symbol">(</a><a id="1628" href="FOL.Base.html#1628" class="Bound">t₂</a> <a id="1631" class="Symbol">:</a> <a id="1633" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1639" class="Number">0</a><a id="1640" class="Symbol">)</a> <a id="1642" class="Symbol">→</a> <a id="1644" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1650" href="FOL.Base.html#1504" class="Generalizable">l</a>

<a id="Term"></a><a id="1653" href="FOL.Base.html#1653" class="Function">Term</a> <a id="1658" class="Symbol">=</a> <a id="1660" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1666" class="Number">0</a>
</pre>
<p>有时候我们希望把多元函数的参数全部应用上, 这时候可以用 <code>apps</code> 函数来实现.</p>
<pre class="Agda"><a id="apps"></a><a id="1725" href="FOL.Base.html#1725" class="Function">apps</a> <a id="1730" class="Symbol">:</a> <a id="1732" class="Symbol">(</a><a id="1733" href="FOL.Base.html#1733" class="Bound">t</a> <a id="1735" class="Symbol">:</a> <a id="1737" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="1743" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="1744" class="Symbol">)</a> <a id="1746" class="Symbol">(</a><a id="1747" href="FOL.Base.html#1747" class="Bound">ts</a> <a id="1750" class="Symbol">:</a> <a id="1752" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="1756" href="FOL.Base.html#1653" class="Function">Term</a> <a id="1761" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="1762" class="Symbol">)</a> <a id="1764" class="Symbol">→</a> <a id="1766" href="FOL.Base.html#1653" class="Function">Term</a>
<a id="1771" href="FOL.Base.html#1725" class="Function">apps</a> <a id="1776" href="FOL.Base.html#1776" class="Bound">t</a> <a id="1778" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a> <a id="1781" class="Symbol">=</a> <a id="1783" href="FOL.Base.html#1776" class="Bound">t</a>
<a id="1785" href="FOL.Base.html#1725" class="Function">apps</a> <a id="1790" href="FOL.Base.html#1790" class="Bound">f</a> <a id="1792" class="Symbol">(</a><a id="1793" href="FOL.Base.html#1793" class="Bound">t</a> <a id="1795" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="1797" href="FOL.Base.html#1797" class="Bound">ts</a><a id="1799" class="Symbol">)</a> <a id="1801" class="Symbol">=</a> <a id="1803" href="FOL.Base.html#1725" class="Function">apps</a> <a id="1808" class="Symbol">(</a><a id="1809" href="FOL.Base.html#1599" class="InductiveConstructor">app</a> <a id="1813" href="FOL.Base.html#1790" class="Bound">f</a> <a id="1815" href="FOL.Base.html#1793" class="Bound">t</a><a id="1816" class="Symbol">)</a> <a id="1818" href="FOL.Base.html#1797" class="Bound">ts</a>
</pre>
<h2 id="公式">公式</h2>
<p>n元关系在公式中的处理与n元函数在项中的处理类似, 我们把关系的元数编码进公式的类型里: n元关系是 <strong>n-公式</strong>.</p>
<p>至此, 非逻辑符号处理完毕. 接下来处理<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91#%E9%82%8F%E8%BC%AF%E7%AC%A6%E8%99%9F">逻辑符号</a>. 它们通常包括:</p>
<ol type="1">
<li>等号: = (≈)</li>
<li>量化符号:</li>
</ol>
<ul>
<li>全称量化: ∀ (∀’)</li>
<li>存在量化: ∃ (∃’)</li>
</ul>
<ol start="3" type="1">
<li>连接符号:</li>
</ol>
<ul>
<li>否定: ¬ (~)</li>
<li>蕴含: → (⇒)</li>
<li>等价: ↔︎ (⇔)</li>
<li>且: ∧</li>
<li>或: ∨</li>
</ul>
<p>括号中是为了避免与Agda元语言符号冲突而在本文中使用的符号.</p>
<p>这些符号不是独立的, 只需选取其中一些作为原始符号, 剩下的可以由它们推导出来. 不同的书根据不同的理由做出了不同的选取, 但得到的一阶逻辑系统基本是一样的. 我们根据Agda形式化的简便性 (具体会在后文逐渐体现), 选取等号 ≈, 蕴含 ⇒ , 全称量化 ∀’ 和恒假 ⊥ 作为原始符号.</p>
<p><strong>定义</strong> 归纳定义 l-公式:</p>
<ul>
<li>恒假 <code>⊥</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>l</code> 元关系符号 <code>r</code>，关系 <code>rel R</code> 是 <code>l</code>-公式.</li>
<li>对任意 <code>suc l</code>-公式 <code>φ</code> 和任意项 <code>t</code>，关系应用 <code>appᵣ φ t</code> 是 <code>l</code>-公式.</li>
<li>对任意项 <code>t₁</code> 和 <code>t₂</code>，等式 <code>t₁ ≈ t₂</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>0</code>-公式 <code>φ₁</code> 和任意 <code>0</code>-公式 <code>φ₂</code>，蕴含式 <code>φ₁ ⇒ φ₂</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>0</code>-公式 <code>φ</code>，全称量化式 <code>∀' φ</code> 是 <code>0</code>-公式.</li>
</ul>
<p>特别地, <code>0</code>-公式简称公式.</p>
<pre class="Agda"><a id="2646" class="Keyword">data</a> <a id="Formulaₗ"></a><a id="2651" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2660" class="Symbol">:</a> <a id="2662" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2664" class="Symbol">→</a> <a id="2666" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2671" href="FOL.Base.html#577" class="Bound">u</a> <a id="2673" class="Keyword">where</a>
  <a id="Formulaₗ.⊥"></a><a id="2681" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>     <a id="2687" class="Symbol">:</a> <a id="2689" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2698" class="Number">0</a>
  <a id="Formulaₗ.rel"></a><a id="2702" href="FOL.Base.html#2702" class="InductiveConstructor">rel</a>   <a id="2708" class="Symbol">:</a> <a id="2710" class="Symbol">(</a><a id="2711" href="FOL.Base.html#2711" class="Bound">R</a> <a id="2713" class="Symbol">:</a> <a id="2715" href="FOL.Language.html#1430" class="Field">ℜ</a> <a id="2717" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="2718" class="Symbol">)</a> <a id="2720" class="Symbol">→</a> <a id="2722" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2731" href="FOL.Base.html#1504" class="Generalizable">l</a>
  <a id="Formulaₗ.appᵣ"></a><a id="2735" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a>  <a id="2741" class="Symbol">:</a> <a id="2743" class="Symbol">(</a><a id="2744" href="FOL.Base.html#2744" class="Bound">φ</a> <a id="2746" class="Symbol">:</a> <a id="2748" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2757" class="Symbol">(</a><a id="2758" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2762" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="2763" class="Symbol">))</a> <a id="2766" class="Symbol">(</a><a id="2767" href="FOL.Base.html#2767" class="Bound">t</a> <a id="2769" class="Symbol">:</a> <a id="2771" href="FOL.Base.html#1653" class="Function">Term</a><a id="2775" class="Symbol">)</a> <a id="2777" class="Symbol">→</a> <a id="2779" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2788" href="FOL.Base.html#1504" class="Generalizable">l</a>
  <a id="Formulaₗ._≈_"></a><a id="2792" href="FOL.Base.html#2792" class="InductiveConstructor Operator">_≈_</a>   <a id="2798" class="Symbol">:</a> <a id="2800" class="Symbol">(</a><a id="2801" href="FOL.Base.html#2801" class="Bound">t₁</a> <a id="2804" href="FOL.Base.html#2804" class="Bound">t₂</a> <a id="2807" class="Symbol">:</a> <a id="2809" href="FOL.Base.html#1653" class="Function">Term</a><a id="2813" class="Symbol">)</a> <a id="2815" class="Symbol">→</a> <a id="2817" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2826" class="Number">0</a>
  <a id="Formulaₗ._⇒_"></a><a id="2830" href="FOL.Base.html#2830" class="InductiveConstructor Operator">_⇒_</a>   <a id="2836" class="Symbol">:</a> <a id="2838" class="Symbol">(</a><a id="2839" href="FOL.Base.html#2839" class="Bound">φ₁</a> <a id="2842" href="FOL.Base.html#2842" class="Bound">φ₂</a> <a id="2845" class="Symbol">:</a> <a id="2847" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2856" class="Number">0</a><a id="2857" class="Symbol">)</a> <a id="2859" class="Symbol">→</a> <a id="2861" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2870" class="Number">0</a>
  <a id="Formulaₗ.∀&#39;_"></a><a id="2874" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;_</a>   <a id="2880" class="Symbol">:</a> <a id="2882" class="Symbol">(</a><a id="2883" href="FOL.Base.html#2883" class="Bound">φ</a> <a id="2885" class="Symbol">:</a> <a id="2887" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2896" class="Number">0</a><a id="2897" class="Symbol">)</a> <a id="2899" class="Symbol">→</a> <a id="2901" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2910" class="Number">0</a>

<a id="Formula"></a><a id="2913" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="2921" class="Symbol">=</a> <a id="2923" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="2932" class="Number">0</a>
</pre>
<p>有时候我们希望把多元关系的参数全部应用上, 这时候可以用 <code>appsᵣ</code> 函数来实现.</p>
<pre class="Agda"><a id="appsᵣ"></a><a id="2992" href="FOL.Base.html#2992" class="Function">appsᵣ</a> <a id="2998" class="Symbol">:</a> <a id="3000" class="Symbol">(</a><a id="3001" href="FOL.Base.html#3001" class="Bound">φ</a> <a id="3003" class="Symbol">:</a> <a id="3005" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="3014" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="3015" class="Symbol">)</a> <a id="3017" class="Symbol">(</a><a id="3018" href="FOL.Base.html#3018" class="Bound">ts</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="3027" href="FOL.Base.html#1653" class="Function">Term</a> <a id="3032" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="3033" class="Symbol">)</a> <a id="3035" class="Symbol">→</a> <a id="3037" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3045" href="FOL.Base.html#2992" class="Function">appsᵣ</a> <a id="3051" href="FOL.Base.html#3051" class="Bound">φ</a> <a id="3053" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a> <a id="3056" class="Symbol">=</a> <a id="3058" href="FOL.Base.html#3051" class="Bound">φ</a>
<a id="3060" href="FOL.Base.html#2992" class="Function">appsᵣ</a> <a id="3066" href="FOL.Base.html#3066" class="Bound">φ</a> <a id="3068" class="Symbol">(</a><a id="3069" href="FOL.Base.html#3069" class="Bound">t</a> <a id="3071" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="3073" href="FOL.Base.html#3073" class="Bound">ts</a><a id="3075" class="Symbol">)</a> <a id="3077" class="Symbol">=</a> <a id="3079" href="FOL.Base.html#2992" class="Function">appsᵣ</a> <a id="3085" class="Symbol">(</a><a id="3086" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a> <a id="3091" href="FOL.Base.html#3066" class="Bound">φ</a> <a id="3093" href="FOL.Base.html#3069" class="Bound">t</a><a id="3094" class="Symbol">)</a> <a id="3096" href="FOL.Base.html#3073" class="Bound">ts</a>
</pre>
<p><strong>注意</strong> 我们将元数编码进类型里是为了省去所谓的<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F">合式公式 (well-formed formula，WFF)</a> 谓词. 任意 <code>φ : Formula</code> 都是合式公式, 类型正确性保证了 <code>φ</code> 的合式性.</p>
<h2 id="导出符号">导出符号</h2>
<p>仿照类型论的处理, φ 的否定定义为 φ 蕴含恒假. 而恒真则是恒假的否定. 由于我们的对象逻辑是经典逻辑, 所以可以这样方便地处理.</p>
<pre class="Agda"><a id="~_"></a><a id="3367" href="FOL.Base.html#3367" class="Function Operator">~_</a> <a id="3370" class="Symbol">:</a> <a id="3372" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3380" class="Symbol">→</a> <a id="3382" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3390" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3392" href="FOL.Base.html#3392" class="Bound">φ</a> <a id="3394" class="Symbol">=</a> <a id="3396" href="FOL.Base.html#3392" class="Bound">φ</a> <a id="3398" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="3400" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>

<a id="⊤"></a><a id="3403" href="FOL.Base.html#3403" class="Function">⊤</a> <a id="3405" class="Symbol">:</a> <a id="3407" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3415" href="FOL.Base.html#3403" class="Function">⊤</a> <a id="3417" class="Symbol">=</a> <a id="3419" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3421" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>
</pre>
<p>其他逻辑符号的定义也是同样地利用了经典逻辑的特性. 它们都可以在加了排中律的 Agda 中”证”出来.</p>
<pre class="Agda"><a id="_∧_"></a><a id="3489" href="FOL.Base.html#3489" class="Function Operator">_∧_</a> <a id="3493" class="Symbol">:</a> <a id="3495" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3503" class="Symbol">→</a> <a id="3505" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3513" class="Symbol">→</a> <a id="3515" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3523" href="FOL.Base.html#3523" class="Bound">φ₁</a> <a id="3526" href="FOL.Base.html#3489" class="Function Operator">∧</a> <a id="3528" href="FOL.Base.html#3528" class="Bound">φ₂</a> <a id="3531" class="Symbol">=</a> <a id="3533" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3535" class="Symbol">(</a><a id="3536" href="FOL.Base.html#3523" class="Bound">φ₁</a> <a id="3539" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="3541" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3543" href="FOL.Base.html#3528" class="Bound">φ₂</a><a id="3545" class="Symbol">)</a>

<a id="_∨_"></a><a id="3548" href="FOL.Base.html#3548" class="Function Operator">_∨_</a> <a id="3552" class="Symbol">:</a> <a id="3554" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3562" class="Symbol">→</a> <a id="3564" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3572" class="Symbol">→</a> <a id="3574" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3582" href="FOL.Base.html#3582" class="Bound">φ₁</a> <a id="3585" href="FOL.Base.html#3548" class="Function Operator">∨</a> <a id="3587" href="FOL.Base.html#3587" class="Bound">φ₂</a> <a id="3590" class="Symbol">=</a> <a id="3592" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3594" href="FOL.Base.html#3582" class="Bound">φ₁</a> <a id="3597" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="3599" href="FOL.Base.html#3587" class="Bound">φ₂</a>

<a id="_⇔_"></a><a id="3603" href="FOL.Base.html#3603" class="Function Operator">_⇔_</a> <a id="3607" class="Symbol">:</a> <a id="3609" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3617" class="Symbol">→</a> <a id="3619" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3627" class="Symbol">→</a> <a id="3629" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3637" href="FOL.Base.html#3637" class="Bound">φ₁</a> <a id="3640" href="FOL.Base.html#3603" class="Function Operator">⇔</a> <a id="3642" href="FOL.Base.html#3642" class="Bound">φ₂</a> <a id="3645" class="Symbol">=</a> <a id="3647" href="FOL.Base.html#3637" class="Bound">φ₁</a> <a id="3650" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="3652" href="FOL.Base.html#3642" class="Bound">φ₂</a> <a id="3655" href="FOL.Base.html#3489" class="Function Operator">∧</a> <a id="3657" href="FOL.Base.html#3642" class="Bound">φ₂</a> <a id="3660" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="3662" href="FOL.Base.html#3637" class="Bound">φ₁</a>

<a id="∃&#39;_"></a><a id="3666" href="FOL.Base.html#3666" class="Function Operator">∃&#39;_</a> <a id="3670" class="Symbol">:</a> <a id="3672" href="FOL.Base.html#2913" class="Function">Formula</a> <a id="3680" class="Symbol">→</a> <a id="3682" href="FOL.Base.html#2913" class="Function">Formula</a>
<a id="3690" href="FOL.Base.html#3666" class="Function Operator">∃&#39;</a> <a id="3693" href="FOL.Base.html#3693" class="Bound">φ</a> <a id="3695" class="Symbol">=</a> <a id="3697" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3699" class="Symbol">(</a><a id="3700" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;</a> <a id="3703" href="FOL.Base.html#3367" class="Function Operator">~</a> <a id="3705" href="FOL.Base.html#3693" class="Bound">φ</a><a id="3706" class="Symbol">)</a>
</pre>
<h2 id="变量提升">变量提升</h2>
<p>变量提升属于<a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin编码</a>方案的一部分, 用于处理量词的绑定, 具体会在后文中体现.</p>
<p>简单来说, 变量提升就是把变量符号表 <code>var : ℕ → Term</code> 的某一段去掉, 以剩下的变量符号来重新表达原来的项和公式. 例如, 对项 <code>t</code>, 从 <code>var m</code> 开始, 去掉 <code>n</code> 个符号, 就叫做将 <code>t</code> 从 <code>m</code> 提升 <code>n</code>, 记作 <code>t ↑[ m ] n</code>.</p>
<p>如果项 <code>t</code> 使用了变量 <code>var 0</code>, <code>var 1</code>, <code>var 2</code>, <code>var 3</code>, 那么 <code>t ↑[ 1 ] 2</code> 则会使用变量 <code>var 0</code>, <code>var 3</code>, <code>var 4</code>, <code>var 5</code>.</p>
<p>特别地, 如果 <code>m = 0</code>, 就叫做将 <code>t</code> 提升 <code>n</code>, 记作 <code>t ↑ n</code>.</p>
<pre class="Agda"><a id="_↑[_]_"></a><a id="4129" href="FOL.Base.html#4129" class="Function Operator">_↑[_]_</a> <a id="4136" class="Symbol">:</a> <a id="4138" class="Symbol">(</a><a id="4139" href="FOL.Base.html#4139" class="Bound">t</a> <a id="4141" class="Symbol">:</a> <a id="4143" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="4149" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="4150" class="Symbol">)</a> <a id="4152" class="Symbol">(</a><a id="4153" href="FOL.Base.html#4153" class="Bound">m</a> <a id="4155" href="FOL.Base.html#4155" class="Bound">n</a> <a id="4157" class="Symbol">:</a> <a id="4159" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4160" class="Symbol">)</a> <a id="4162" class="Symbol">→</a> <a id="4164" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="4170" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="4172" href="FOL.Base.html#1543" class="InductiveConstructor">var</a> <a id="4176" href="FOL.Base.html#4176" class="Bound">k</a>     <a id="4182" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4185" href="FOL.Base.html#4185" class="Bound">m</a> <a id="4187" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4189" href="FOL.Base.html#4189" class="Bound">n</a> <a id="4191" class="Keyword">with</a> <a id="4196" href="FOL.Base.html#4176" class="Bound">k</a> <a id="4198" href="Data.Nat.Properties.html#10637" class="Function Operator">&lt;?</a> <a id="4201" href="FOL.Base.html#4185" class="Bound">m</a>
<a id="4203" class="Symbol">...</a> <a id="4207" class="Symbol">|</a> <a id="4209" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="4213" class="Symbol">_</a> <a id="4215" class="Symbol">=</a> <a id="4217" href="FOL.Base.html#1543" class="InductiveConstructor">var</a> <a id="4221" class="Bound">k</a>
<a id="4223" class="Symbol">...</a> <a id="4227" class="Symbol">|</a> <a id="4229" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a>  <a id="4233" class="Symbol">_</a> <a id="4235" class="Symbol">=</a> <a id="4237" href="FOL.Base.html#1543" class="InductiveConstructor">var</a> <a id="4241" class="Symbol">(</a><a id="4242" class="Bound">k</a> <a id="4244" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">ℕ.+</a> <a id="4248" class="Bound">n</a><a id="4249" class="Symbol">)</a>
<a id="4251" href="FOL.Base.html#1570" class="InductiveConstructor">func</a> <a id="4256" href="FOL.Base.html#4256" class="Bound">f</a>    <a id="4261" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4264" href="FOL.Base.html#4264" class="Bound">m</a> <a id="4266" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4268" href="FOL.Base.html#4268" class="Bound">n</a> <a id="4270" class="Symbol">=</a> <a id="4272" href="FOL.Base.html#1570" class="InductiveConstructor">func</a> <a id="4277" href="FOL.Base.html#4256" class="Bound">f</a>
<a id="4279" href="FOL.Base.html#1599" class="InductiveConstructor">app</a> <a id="4283" href="FOL.Base.html#4283" class="Bound">t₁</a> <a id="4286" href="FOL.Base.html#4286" class="Bound">t₂</a> <a id="4289" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4292" href="FOL.Base.html#4292" class="Bound">m</a> <a id="4294" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4296" href="FOL.Base.html#4296" class="Bound">n</a> <a id="4298" class="Symbol">=</a> <a id="4300" href="FOL.Base.html#1599" class="InductiveConstructor">app</a> <a id="4304" class="Symbol">(</a><a id="4305" href="FOL.Base.html#4283" class="Bound">t₁</a> <a id="4308" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4311" href="FOL.Base.html#4292" class="Bound">m</a> <a id="4313" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4315" href="FOL.Base.html#4296" class="Bound">n</a><a id="4316" class="Symbol">)</a> <a id="4318" class="Symbol">(</a><a id="4319" href="FOL.Base.html#4286" class="Bound">t₂</a> <a id="4322" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4325" href="FOL.Base.html#4292" class="Bound">m</a> <a id="4327" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4329" href="FOL.Base.html#4296" class="Bound">n</a><a id="4330" class="Symbol">)</a>

<a id="_↑_"></a><a id="4333" href="FOL.Base.html#4333" class="Function Operator">_↑_</a> <a id="4337" class="Symbol">:</a> <a id="4339" class="Symbol">(</a><a id="4340" href="FOL.Base.html#4340" class="Bound">t</a> <a id="4342" class="Symbol">:</a> <a id="4344" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="4350" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="4351" class="Symbol">)</a> <a id="4353" class="Symbol">(</a><a id="4354" href="FOL.Base.html#4354" class="Bound">n</a> <a id="4356" class="Symbol">:</a> <a id="4358" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4359" class="Symbol">)</a> <a id="4361" class="Symbol">→</a> <a id="4363" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="4369" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="4371" href="FOL.Base.html#4371" class="Bound">t</a> <a id="4373" href="FOL.Base.html#4333" class="Function Operator">↑</a> <a id="4375" href="FOL.Base.html#4375" class="Bound">n</a> <a id="4377" class="Symbol">=</a> <a id="4379" href="FOL.Base.html#4371" class="Bound">t</a> <a id="4381" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4384" class="Number">0</a> <a id="4386" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4388" href="FOL.Base.html#4375" class="Bound">n</a>
</pre>
<p>对公式的变量提升基本上就是对其中的项进行变量提升, 或者是对公式中的公式递归地提升. 只是对于量词构造的公式, 保留一位变量不提升, 以作为量词的绑定变量.</p>
<pre class="Agda"><a id="_↥[_]_"></a><a id="4483" href="FOL.Base.html#4483" class="Function Operator">_↥[_]_</a> <a id="4490" class="Symbol">:</a> <a id="4492" class="Symbol">(</a><a id="4493" href="FOL.Base.html#4493" class="Bound">φ</a> <a id="4495" class="Symbol">:</a> <a id="4497" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="4506" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="4507" class="Symbol">)</a> <a id="4509" class="Symbol">(</a><a id="4510" href="FOL.Base.html#4510" class="Bound">m</a> <a id="4512" href="FOL.Base.html#4512" class="Bound">n</a> <a id="4514" class="Symbol">:</a> <a id="4516" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4517" class="Symbol">)</a> <a id="4519" class="Symbol">→</a> <a id="4521" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="4530" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="4532" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>         <a id="4542" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4545" href="FOL.Base.html#4545" class="Bound">m</a> <a id="4547" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4549" href="FOL.Base.html#4549" class="Bound">n</a> <a id="4551" class="Symbol">=</a> <a id="4553" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>
<a id="4555" href="FOL.Base.html#2702" class="InductiveConstructor">rel</a> <a id="4559" href="FOL.Base.html#4559" class="Bound">R</a>     <a id="4565" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4568" href="FOL.Base.html#4568" class="Bound">m</a> <a id="4570" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4572" href="FOL.Base.html#4572" class="Bound">n</a> <a id="4574" class="Symbol">=</a> <a id="4576" href="FOL.Base.html#2702" class="InductiveConstructor">rel</a> <a id="4580" href="FOL.Base.html#4559" class="Bound">R</a>
<a id="4582" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a> <a id="4587" href="FOL.Base.html#4587" class="Bound">φ</a> <a id="4589" href="FOL.Base.html#4589" class="Bound">t</a>  <a id="4592" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4595" href="FOL.Base.html#4595" class="Bound">m</a> <a id="4597" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4599" href="FOL.Base.html#4599" class="Bound">n</a> <a id="4601" class="Symbol">=</a> <a id="4603" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a> <a id="4608" class="Symbol">(</a><a id="4609" href="FOL.Base.html#4587" class="Bound">φ</a> <a id="4611" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4614" href="FOL.Base.html#4595" class="Bound">m</a> <a id="4616" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4618" href="FOL.Base.html#4599" class="Bound">n</a><a id="4619" class="Symbol">)</a> <a id="4621" class="Symbol">(</a><a id="4622" href="FOL.Base.html#4589" class="Bound">t</a> <a id="4624" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4627" href="FOL.Base.html#4595" class="Bound">m</a> <a id="4629" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4631" href="FOL.Base.html#4599" class="Bound">n</a><a id="4632" class="Symbol">)</a>
<a id="4634" class="Symbol">(</a><a id="4635" href="FOL.Base.html#4635" class="Bound">t₁</a> <a id="4638" href="FOL.Base.html#2792" class="InductiveConstructor Operator">≈</a> <a id="4640" href="FOL.Base.html#4640" class="Bound">t₂</a><a id="4642" class="Symbol">)</a> <a id="4644" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4647" href="FOL.Base.html#4647" class="Bound">m</a> <a id="4649" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4651" href="FOL.Base.html#4651" class="Bound">n</a> <a id="4653" class="Symbol">=</a> <a id="4655" href="FOL.Base.html#4635" class="Bound">t₁</a> <a id="4658" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4661" href="FOL.Base.html#4647" class="Bound">m</a> <a id="4663" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4665" href="FOL.Base.html#4651" class="Bound">n</a> <a id="4667" href="FOL.Base.html#2792" class="InductiveConstructor Operator">≈</a> <a id="4669" href="FOL.Base.html#4640" class="Bound">t₂</a> <a id="4672" href="FOL.Base.html#4129" class="Function Operator">↑[</a> <a id="4675" href="FOL.Base.html#4647" class="Bound">m</a> <a id="4677" href="FOL.Base.html#4129" class="Function Operator">]</a> <a id="4679" href="FOL.Base.html#4651" class="Bound">n</a>
<a id="4681" class="Symbol">(</a><a id="4682" href="FOL.Base.html#4682" class="Bound">φ₁</a> <a id="4685" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="4687" href="FOL.Base.html#4687" class="Bound">φ₂</a><a id="4689" class="Symbol">)</a> <a id="4691" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4694" href="FOL.Base.html#4694" class="Bound">m</a> <a id="4696" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4698" href="FOL.Base.html#4698" class="Bound">n</a> <a id="4700" class="Symbol">=</a> <a id="4702" href="FOL.Base.html#4682" class="Bound">φ₁</a> <a id="4705" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4708" href="FOL.Base.html#4694" class="Bound">m</a> <a id="4710" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4712" href="FOL.Base.html#4698" class="Bound">n</a> <a id="4714" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="4716" href="FOL.Base.html#4687" class="Bound">φ₂</a> <a id="4719" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4722" href="FOL.Base.html#4694" class="Bound">m</a> <a id="4724" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4726" href="FOL.Base.html#4698" class="Bound">n</a>
<a id="4728" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;</a> <a id="4731" href="FOL.Base.html#4731" class="Bound">φ</a>      <a id="4738" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4741" href="FOL.Base.html#4741" class="Bound">m</a> <a id="4743" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4745" href="FOL.Base.html#4745" class="Bound">n</a> <a id="4747" class="Symbol">=</a> <a id="4749" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;</a> <a id="4752" class="Symbol">(</a><a id="4753" href="FOL.Base.html#4731" class="Bound">φ</a> <a id="4755" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4758" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="4762" href="FOL.Base.html#4741" class="Bound">m</a> <a id="4764" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4766" href="FOL.Base.html#4745" class="Bound">n</a><a id="4767" class="Symbol">)</a>

<a id="_↥_"></a><a id="4770" href="FOL.Base.html#4770" class="Function Operator">_↥_</a> <a id="4774" class="Symbol">:</a> <a id="4776" class="Symbol">(</a><a id="4777" href="FOL.Base.html#4777" class="Bound">φ</a> <a id="4779" class="Symbol">:</a> <a id="4781" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="4790" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="4791" class="Symbol">)</a> <a id="4793" class="Symbol">(</a><a id="4794" href="FOL.Base.html#4794" class="Bound">n</a> <a id="4796" class="Symbol">:</a> <a id="4798" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4799" class="Symbol">)</a> <a id="4801" class="Symbol">→</a> <a id="4803" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="4812" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="4814" href="FOL.Base.html#4814" class="Bound">φ</a> <a id="4816" href="FOL.Base.html#4770" class="Function Operator">↥</a> <a id="4818" href="FOL.Base.html#4818" class="Bound">n</a> <a id="4820" class="Symbol">=</a> <a id="4822" href="FOL.Base.html#4814" class="Bound">φ</a> <a id="4824" href="FOL.Base.html#4483" class="Function Operator">↥[</a> <a id="4827" class="Number">0</a> <a id="4829" href="FOL.Base.html#4483" class="Function Operator">]</a> <a id="4831" href="FOL.Base.html#4818" class="Bound">n</a>
</pre>
<h2 id="变量替换">变量替换</h2>
<p>变量替换用于处理量词绑定变量的替换和等量的替换. 首先我们需要一个帮助函数, 往序列 <code>𝓋 : ℕ → A</code> 中插入指定的项 <code>s</code> 于指定的位置 <code>n</code>. 例如, 如果 <code>v</code> 是序列</p>
<p><code>t₀ t₁ t₂ t₃ t₄ t₅ t₆ t₇ ...</code></p>
<p>那么 <code>insert s into 𝓋 at 4</code> 就是序列</p>
<p><code>t₀ t₁ t₂ t₃ s t₄ t₅ t₆ t₇ ...</code></p>
<pre class="Agda"><a id="insert_into_at_"></a><a id="5046" href="FOL.Base.html#5046" class="Function Operator">insert_into_at_</a> <a id="5062" class="Symbol">:</a> <a id="5064" class="Symbol">∀</a> <a id="5066" class="Symbol">{</a><a id="5067" href="FOL.Base.html#5067" class="Bound">u</a><a id="5068" class="Symbol">}</a> <a id="5070" class="Symbol">{</a><a id="5071" href="FOL.Base.html#5071" class="Bound">A</a> <a id="5073" class="Symbol">:</a> <a id="5075" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5080" href="FOL.Base.html#5067" class="Bound">u</a><a id="5081" class="Symbol">}</a> <a id="5083" class="Symbol">(</a><a id="5084" href="FOL.Base.html#5084" class="Bound">s</a> <a id="5086" class="Symbol">:</a> <a id="5088" href="FOL.Base.html#5071" class="Bound">A</a><a id="5089" class="Symbol">)</a> <a id="5091" class="Symbol">(</a><a id="5092" href="FOL.Base.html#5092" class="Bound">𝓋</a> <a id="5094" class="Symbol">:</a> <a id="5096" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5098" class="Symbol">→</a> <a id="5100" href="FOL.Base.html#5071" class="Bound">A</a><a id="5101" class="Symbol">)</a> <a id="5103" class="Symbol">(</a><a id="5104" href="FOL.Base.html#5104" class="Bound">n</a> <a id="5106" class="Symbol">:</a> <a id="5108" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5109" class="Symbol">)</a> <a id="5111" class="Symbol">→</a> <a id="5113" class="Symbol">(</a><a id="5114" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5116" class="Symbol">→</a> <a id="5118" href="FOL.Base.html#5071" class="Bound">A</a><a id="5119" class="Symbol">)</a>
<a id="5121" class="Symbol">(</a><a id="5122" href="FOL.Base.html#5046" class="Function Operator">insert</a> <a id="5129" href="FOL.Base.html#5129" class="Bound">s</a> <a id="5131" href="FOL.Base.html#5046" class="Function Operator">into</a> <a id="5136" href="FOL.Base.html#5136" class="Bound">𝓋</a> <a id="5138" href="FOL.Base.html#5046" class="Function Operator">at</a> <a id="5141" href="FOL.Base.html#5141" class="Bound">n</a><a id="5142" class="Symbol">)</a> <a id="5144" href="FOL.Base.html#5144" class="Bound">k</a> <a id="5146" class="Keyword">with</a> <a id="5151" href="Data.Nat.Properties.html#10322" class="Function">&lt;-cmp</a> <a id="5157" href="FOL.Base.html#5144" class="Bound">k</a> <a id="5159" href="FOL.Base.html#5141" class="Bound">n</a>
<a id="5161" class="Symbol">...</a> <a id="5165" class="Symbol">|</a> <a id="5167" href="Relation.Binary.Definitions.html#2787" class="InductiveConstructor">tri&lt;</a> <a id="5172" class="Symbol">_</a> <a id="5174" class="Symbol">_</a> <a id="5176" class="Symbol">_</a> <a id="5178" class="Symbol">=</a> <a id="5180" class="Bound">𝓋</a> <a id="5182" class="Bound">k</a>
<a id="5184" class="Symbol">...</a> <a id="5188" class="Symbol">|</a> <a id="5190" href="Relation.Binary.Definitions.html#2841" class="InductiveConstructor">tri≈</a> <a id="5195" class="Symbol">_</a> <a id="5197" class="Symbol">_</a> <a id="5199" class="Symbol">_</a> <a id="5201" class="Symbol">=</a> <a id="5203" class="Bound">s</a>
<a id="5205" class="Symbol">...</a> <a id="5209" class="Symbol">|</a> <a id="5211" href="Relation.Binary.Definitions.html#2895" class="InductiveConstructor">tri&gt;</a> <a id="5216" class="Symbol">_</a> <a id="5218" class="Symbol">_</a> <a id="5220" class="Symbol">_</a> <a id="5222" class="Symbol">=</a> <a id="5224" class="Bound">𝓋</a> <a id="5226" class="Symbol">(</a><a id="5227" class="Bound">k</a> <a id="5229" href="Data.Nat.Base.html#3140" class="Primitive Operator">∸</a> <a id="5231" class="Number">1</a><a id="5232" class="Symbol">)</a>
</pre>
<p>将项 <code>t</code> 中的变量 <code>var n</code> (如果存在) 替换为项 <code>s</code> 后得到的项记作 <code>t [ s /ₜ n ]</code>. 如果项是变量 <code>var k</code>, 那么将变量符号表 <code>var</code> 改造成 <code>insert (s ↑ n) into var at n</code>, 再取其中的第 <code>k</code> 个. 如果项是函数应用, 那么递归地替换其中的项.</p>
<p>其中, <code>insert (s ↑ n) into var at n</code> 的意思是往 <code>var</code> 中插入 <code>s ↑ n</code> 于 <code>n</code> 处. 将 <code>s</code> 提升 <code>n</code> 是为了保证 <code>s</code> 中的变量不会与 <code>t</code> 中的变量冲突.</p>
<pre class="Agda"><a id="_[_/_]ᵥ"></a><a id="5524" href="FOL.Base.html#5524" class="Function Operator">_[_/_]ᵥ</a> <a id="5532" class="Symbol">:</a> <a id="5534" class="Symbol">∀</a> <a id="5536" class="Symbol">{</a><a id="5537" href="FOL.Base.html#5537" class="Bound">u</a><a id="5538" class="Symbol">}</a> <a id="5540" class="Symbol">{</a><a id="5541" href="FOL.Base.html#5541" class="Bound">A</a> <a id="5543" class="Symbol">:</a> <a id="5545" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5550" href="FOL.Base.html#5537" class="Bound">u</a><a id="5551" class="Symbol">}</a> <a id="5553" class="Symbol">(</a><a id="5554" href="FOL.Base.html#5554" class="Bound">𝓋</a> <a id="5556" class="Symbol">:</a> <a id="5558" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5560" class="Symbol">→</a> <a id="5562" href="FOL.Base.html#5541" class="Bound">A</a><a id="5563" class="Symbol">)</a> <a id="5565" class="Symbol">(</a><a id="5566" href="FOL.Base.html#5566" class="Bound">s</a> <a id="5568" class="Symbol">:</a> <a id="5570" href="FOL.Base.html#5541" class="Bound">A</a><a id="5571" class="Symbol">)</a> <a id="5573" class="Symbol">(</a><a id="5574" href="FOL.Base.html#5574" class="Bound">n</a> <a id="5576" class="Symbol">:</a> <a id="5578" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5579" class="Symbol">)</a> <a id="5581" class="Symbol">→</a> <a id="5583" class="Symbol">(</a><a id="5584" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5586" class="Symbol">→</a> <a id="5588" href="FOL.Base.html#5541" class="Bound">A</a><a id="5589" class="Symbol">)</a>
<a id="5591" href="FOL.Base.html#5591" class="Bound">𝓋</a> <a id="5593" href="FOL.Base.html#5524" class="Function Operator">[</a> <a id="5595" href="FOL.Base.html#5595" class="Bound">s</a> <a id="5597" href="FOL.Base.html#5524" class="Function Operator">/</a> <a id="5599" href="FOL.Base.html#5599" class="Bound">n</a> <a id="5601" href="FOL.Base.html#5524" class="Function Operator">]ᵥ</a> <a id="5604" class="Symbol">=</a> <a id="5606" href="FOL.Base.html#5046" class="Function Operator">insert</a> <a id="5613" href="FOL.Base.html#5595" class="Bound">s</a> <a id="5615" href="FOL.Base.html#5046" class="Function Operator">into</a> <a id="5620" href="FOL.Base.html#5591" class="Bound">𝓋</a> <a id="5622" href="FOL.Base.html#5046" class="Function Operator">at</a> <a id="5625" href="FOL.Base.html#5599" class="Bound">n</a>

<a id="_[_/_]ₜ"></a><a id="5628" href="FOL.Base.html#5628" class="Function Operator">_[_/_]ₜ</a> <a id="5636" class="Symbol">:</a> <a id="5638" class="Symbol">(</a><a id="5639" href="FOL.Base.html#5639" class="Bound">t</a> <a id="5641" class="Symbol">:</a> <a id="5643" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="5649" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="5650" class="Symbol">)</a> <a id="5652" class="Symbol">(</a><a id="5653" href="FOL.Base.html#5653" class="Bound">s</a> <a id="5655" class="Symbol">:</a> <a id="5657" href="FOL.Base.html#1653" class="Function">Term</a><a id="5661" class="Symbol">)</a> <a id="5663" class="Symbol">(</a><a id="5664" href="FOL.Base.html#5664" class="Bound">n</a> <a id="5666" class="Symbol">:</a> <a id="5668" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5669" class="Symbol">)</a> <a id="5671" class="Symbol">→</a> <a id="5673" href="FOL.Base.html#1516" class="Datatype">Termₗ</a> <a id="5679" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="5681" href="FOL.Base.html#1543" class="InductiveConstructor">var</a> <a id="5685" href="FOL.Base.html#5685" class="Bound">k</a>     <a id="5691" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="5693" href="FOL.Base.html#5693" class="Bound">s</a> <a id="5695" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="5697" href="FOL.Base.html#5697" class="Bound">n</a> <a id="5699" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a> <a id="5702" class="Symbol">=</a> <a id="5704" href="FOL.Base.html#1543" class="InductiveConstructor">var</a> <a id="5708" href="FOL.Base.html#5524" class="Function Operator">[</a> <a id="5710" class="Symbol">(</a><a id="5711" href="FOL.Base.html#5693" class="Bound">s</a> <a id="5713" href="FOL.Base.html#4333" class="Function Operator">↑</a> <a id="5715" href="FOL.Base.html#5697" class="Bound">n</a><a id="5716" class="Symbol">)</a> <a id="5718" href="FOL.Base.html#5524" class="Function Operator">/</a> <a id="5720" href="FOL.Base.html#5697" class="Bound">n</a> <a id="5722" href="FOL.Base.html#5524" class="Function Operator">]ᵥ</a> <a id="5725" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="5727" href="FOL.Base.html#5685" class="Bound">k</a>
<a id="5729" href="FOL.Base.html#1570" class="InductiveConstructor">func</a> <a id="5734" href="FOL.Base.html#5734" class="Bound">f</a>    <a id="5739" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="5741" href="FOL.Base.html#5741" class="Bound">s</a> <a id="5743" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="5745" href="FOL.Base.html#5745" class="Bound">n</a> <a id="5747" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a> <a id="5750" class="Symbol">=</a> <a id="5752" href="FOL.Base.html#1570" class="InductiveConstructor">func</a> <a id="5757" href="FOL.Base.html#5734" class="Bound">f</a>
<a id="5759" href="FOL.Base.html#1599" class="InductiveConstructor">app</a> <a id="5763" href="FOL.Base.html#5763" class="Bound">t₁</a> <a id="5766" href="FOL.Base.html#5766" class="Bound">t₂</a> <a id="5769" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="5771" href="FOL.Base.html#5771" class="Bound">s</a> <a id="5773" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="5775" href="FOL.Base.html#5775" class="Bound">n</a> <a id="5777" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a> <a id="5780" class="Symbol">=</a> <a id="5782" href="FOL.Base.html#1599" class="InductiveConstructor">app</a> <a id="5786" class="Symbol">(</a><a id="5787" href="FOL.Base.html#5763" class="Bound">t₁</a> <a id="5790" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="5792" href="FOL.Base.html#5771" class="Bound">s</a> <a id="5794" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="5796" href="FOL.Base.html#5775" class="Bound">n</a> <a id="5798" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a><a id="5800" class="Symbol">)</a> <a id="5802" class="Symbol">(</a><a id="5803" href="FOL.Base.html#5766" class="Bound">t₂</a> <a id="5806" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="5808" href="FOL.Base.html#5771" class="Bound">s</a> <a id="5810" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="5812" href="FOL.Base.html#5775" class="Bound">n</a> <a id="5814" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a><a id="5816" class="Symbol">)</a>
</pre>
<p>对公式的变量替换基本上就是对其中的项进行变量替换, 或者是对公式中的公式递归地替换. 只是对于量词构造的公式, 将替换的位置顺延一位, 因为首位是量词的绑定变量.</p>
<pre class="Agda"><a id="_[_/_]"></a><a id="5914" href="FOL.Base.html#5914" class="Function Operator">_[_/_]</a> <a id="5921" class="Symbol">:</a> <a id="5923" class="Symbol">(</a><a id="5924" href="FOL.Base.html#5924" class="Bound">φ</a> <a id="5926" class="Symbol">:</a> <a id="5928" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="5937" href="FOL.Base.html#1504" class="Generalizable">l</a><a id="5938" class="Symbol">)</a> <a id="5940" class="Symbol">(</a><a id="5941" href="FOL.Base.html#5941" class="Bound">s</a> <a id="5943" class="Symbol">:</a> <a id="5945" href="FOL.Base.html#1653" class="Function">Term</a><a id="5949" class="Symbol">)</a> <a id="5951" class="Symbol">(</a><a id="5952" href="FOL.Base.html#5952" class="Bound">n</a> <a id="5954" class="Symbol">:</a> <a id="5956" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5957" class="Symbol">)</a> <a id="5959" class="Symbol">→</a> <a id="5961" href="FOL.Base.html#2651" class="Datatype">Formulaₗ</a> <a id="5970" href="FOL.Base.html#1504" class="Generalizable">l</a>
<a id="5972" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>         <a id="5982" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="5984" href="FOL.Base.html#5984" class="Bound">s</a> <a id="5986" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="5988" href="FOL.Base.html#5988" class="Bound">n</a> <a id="5990" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="5992" class="Symbol">=</a> <a id="5994" href="FOL.Base.html#2681" class="InductiveConstructor">⊥</a>
<a id="5996" href="FOL.Base.html#2702" class="InductiveConstructor">rel</a> <a id="6000" href="FOL.Base.html#6000" class="Bound">R</a>     <a id="6006" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6008" href="FOL.Base.html#6008" class="Bound">s</a> <a id="6010" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6012" href="FOL.Base.html#6012" class="Bound">n</a> <a id="6014" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6016" class="Symbol">=</a> <a id="6018" href="FOL.Base.html#2702" class="InductiveConstructor">rel</a> <a id="6022" href="FOL.Base.html#6000" class="Bound">R</a>
<a id="6024" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a> <a id="6029" href="FOL.Base.html#6029" class="Bound">φ</a> <a id="6031" href="FOL.Base.html#6031" class="Bound">t</a>  <a id="6034" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6036" href="FOL.Base.html#6036" class="Bound">s</a> <a id="6038" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6040" href="FOL.Base.html#6040" class="Bound">n</a> <a id="6042" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6044" class="Symbol">=</a> <a id="6046" href="FOL.Base.html#2735" class="InductiveConstructor">appᵣ</a> <a id="6051" class="Symbol">(</a><a id="6052" href="FOL.Base.html#6029" class="Bound">φ</a> <a id="6054" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6056" href="FOL.Base.html#6036" class="Bound">s</a> <a id="6058" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6060" href="FOL.Base.html#6040" class="Bound">n</a> <a id="6062" href="FOL.Base.html#5914" class="Function Operator">]</a><a id="6063" class="Symbol">)</a> <a id="6065" class="Symbol">(</a><a id="6066" href="FOL.Base.html#6031" class="Bound">t</a> <a id="6068" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="6070" href="FOL.Base.html#6036" class="Bound">s</a> <a id="6072" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="6074" href="FOL.Base.html#6040" class="Bound">n</a> <a id="6076" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a><a id="6078" class="Symbol">)</a>
<a id="6080" class="Symbol">(</a><a id="6081" href="FOL.Base.html#6081" class="Bound">t₁</a> <a id="6084" href="FOL.Base.html#2792" class="InductiveConstructor Operator">≈</a> <a id="6086" href="FOL.Base.html#6086" class="Bound">t₂</a><a id="6088" class="Symbol">)</a> <a id="6090" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6092" href="FOL.Base.html#6092" class="Bound">s</a> <a id="6094" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6096" href="FOL.Base.html#6096" class="Bound">n</a> <a id="6098" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6100" class="Symbol">=</a> <a id="6102" href="FOL.Base.html#6081" class="Bound">t₁</a> <a id="6105" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="6107" href="FOL.Base.html#6092" class="Bound">s</a> <a id="6109" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="6111" href="FOL.Base.html#6096" class="Bound">n</a> <a id="6113" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a> <a id="6116" href="FOL.Base.html#2792" class="InductiveConstructor Operator">≈</a> <a id="6118" href="FOL.Base.html#6086" class="Bound">t₂</a> <a id="6121" href="FOL.Base.html#5628" class="Function Operator">[</a> <a id="6123" href="FOL.Base.html#6092" class="Bound">s</a> <a id="6125" href="FOL.Base.html#5628" class="Function Operator">/</a> <a id="6127" href="FOL.Base.html#6096" class="Bound">n</a> <a id="6129" href="FOL.Base.html#5628" class="Function Operator">]ₜ</a>
<a id="6132" class="Symbol">(</a><a id="6133" href="FOL.Base.html#6133" class="Bound">φ₁</a> <a id="6136" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="6138" href="FOL.Base.html#6138" class="Bound">φ₂</a><a id="6140" class="Symbol">)</a> <a id="6142" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6144" href="FOL.Base.html#6144" class="Bound">s</a> <a id="6146" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6148" href="FOL.Base.html#6148" class="Bound">n</a> <a id="6150" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6152" class="Symbol">=</a> <a id="6154" href="FOL.Base.html#6133" class="Bound">φ₁</a> <a id="6157" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6159" href="FOL.Base.html#6144" class="Bound">s</a> <a id="6161" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6163" href="FOL.Base.html#6148" class="Bound">n</a> <a id="6165" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6167" href="FOL.Base.html#2830" class="InductiveConstructor Operator">⇒</a> <a id="6169" href="FOL.Base.html#6138" class="Bound">φ₂</a> <a id="6172" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6174" href="FOL.Base.html#6144" class="Bound">s</a> <a id="6176" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6178" href="FOL.Base.html#6148" class="Bound">n</a> <a id="6180" href="FOL.Base.html#5914" class="Function Operator">]</a>
<a id="6182" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;</a> <a id="6185" href="FOL.Base.html#6185" class="Bound">φ</a>      <a id="6192" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6194" href="FOL.Base.html#6194" class="Bound">s</a> <a id="6196" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6198" href="FOL.Base.html#6198" class="Bound">n</a> <a id="6200" href="FOL.Base.html#5914" class="Function Operator">]</a> <a id="6202" class="Symbol">=</a> <a id="6204" href="FOL.Base.html#2874" class="InductiveConstructor Operator">∀&#39;</a> <a id="6207" class="Symbol">(</a><a id="6208" href="FOL.Base.html#6185" class="Bound">φ</a> <a id="6210" href="FOL.Base.html#5914" class="Function Operator">[</a> <a id="6212" href="FOL.Base.html#6194" class="Bound">s</a> <a id="6214" href="FOL.Base.html#5914" class="Function Operator">/</a> <a id="6216" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="6220" href="FOL.Base.html#6198" class="Bound">n</a> <a id="6222" href="FOL.Base.html#5914" class="Function Operator">]</a><a id="6223" class="Symbol">)</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
