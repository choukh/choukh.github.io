<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda一阶逻辑(2) 项与公式</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda一阶逻辑(2) 项与公式</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda一阶逻辑2-项与公式" id="toc-agda一阶逻辑2-项与公式">Agda一阶逻辑(2) 项与公式</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a>
  <ul>
  <li><a href="#标准库依赖" id="toc-标准库依赖">标准库依赖</a></li>
  <li><a href="#符号优先级" id="toc-符号优先级">符号优先级</a></li>
  </ul></li>
  <li><a href="#项" id="toc-项">项</a></li>
  <li><a href="#公式" id="toc-公式">公式</a></li>
  <li><a href="#导出符号" id="toc-导出符号">导出符号</a></li>
  <li><a href="#变量提升" id="toc-变量提升">变量提升</a></li>
  <li><a href="#变量替换" id="toc-变量替换">变量替换</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda一阶逻辑2-项与公式">Agda一阶逻辑(2) 项与公式</h1>
<blockquote>
<p>交流Q群: 893531731<br />
本文源码: <a href="https://github.com/choukh/agda-flypitch/blob/main/src/FOL/Base.lagda.md">Base.lagda.md</a><br />
高亮渲染: <a href="https://choukh.github.io/agda-flypitch/FOL.Base.html">Base.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本篇定义一阶逻辑的项与公式. 粗略类比, 如果说符号相当于字, 那么<strong>项 (term)</strong> 和<strong>公式 (formula)</strong> 则相当于词和句. 更准确地说, 项由变量与函数符号构成; 公式则由关系符号, 等号, 量化符号与连接符号等构成. 如上一篇所说, 本篇的所有内容都是参数化到语言的.</p>
<pre class="Agda"><a id="487" class="Symbol">{-#</a> <a id="491" class="Keyword">OPTIONS</a> <a id="499" class="Pragma">--cubical</a> <a id="509" class="Pragma">--safe</a> <a id="516" class="Symbol">#-}</a>

<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="FOL.Language.html" class="Module">FOL.Language</a>
<a id="546" class="Keyword">open</a> <a id="551" class="Keyword">import</a> <a id="558" href="CubicalExt.Axiom.ExcludedMiddle.html" class="Module">CubicalExt.Axiom.ExcludedMiddle</a>
<a id="590" class="Keyword">module</a> <a id="597" href="FOL.Base.html" class="Module">FOL.Base</a> <a id="606" class="Symbol">⦃</a> <a id="608" href="FOL.Base.html#608" class="Bound">_</a> <a id="610" class="Symbol">:</a> <a id="612" href="CubicalExt.Axiom.ExcludedMiddle.html#250" class="Function">EM</a> <a id="615" class="Symbol">⦄</a> <a id="617" class="Symbol">(</a><a id="618" href="FOL.Base.html#618" class="Bound">ℒ</a> <a id="620" class="Symbol">:</a> <a id="622" href="FOL.Language.html#1441" class="Record">Language</a> <a id="631" class="Symbol">{</a><a id="632" href="FOL.Language.html#1423" class="Generalizable">u</a><a id="633" class="Symbol">})</a> <a id="636" class="Keyword">where</a>
<a id="642" class="Keyword">open</a> <a id="647" href="FOL.Language.html#1441" class="Module">Language</a> <a id="656" href="FOL.Base.html#618" class="Bound">ℒ</a>
</pre>
<h3 id="标准库依赖">标准库依赖</h3>
<pre class="Agda"><a id="682" class="Keyword">open</a> <a id="687" class="Keyword">import</a> <a id="694" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>
<a id="716" class="Keyword">open</a> <a id="721" class="Keyword">import</a> <a id="728" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="756" class="Keyword">using</a> <a id="762" class="Symbol">(</a><a id="763" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="767" class="Symbol">)</a>
<a id="769" class="Keyword">open</a> <a id="774" class="Keyword">import</a> <a id="781" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="790" class="Symbol">as</a> <a id="793" class="Module">ℕ</a> <a id="795" class="Keyword">using</a> <a id="801" class="Symbol">(</a><a id="802" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="803" class="Symbol">;</a> <a id="805" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="808" class="Symbol">;</a> <a id="810" href="Data.Nat.Base.html#3140" class="Primitive Operator">_∸_</a><a id="813" class="Symbol">;</a> <a id="815" href="Data.Nat.Properties.html#10637" class="Function Operator">_&lt;?_</a><a id="819" class="Symbol">)</a>
<a id="821" class="Keyword">open</a> <a id="826" class="Keyword">import</a> <a id="833" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="853" class="Keyword">using</a> <a id="859" class="Symbol">(</a><a id="860" href="Data.Nat.Properties.html#10322" class="Function">&lt;-cmp</a><a id="865" class="Symbol">)</a>
<a id="867" class="Keyword">open</a> <a id="872" class="Keyword">import</a> <a id="879" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="888" class="Keyword">using</a> <a id="894" class="Symbol">(</a><a id="895" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a><a id="898" class="Symbol">;</a> <a id="900" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a><a id="902" class="Symbol">;</a> <a id="904" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">_∷_</a><a id="907" class="Symbol">)</a>
<a id="909" class="Keyword">open</a> <a id="914" class="Keyword">import</a> <a id="921" href="Function.html" class="Module">Function</a> <a id="930" class="Keyword">using</a> <a id="936" class="Symbol">(</a><a id="937" href="Function.Base.html#2003" class="Function Operator">_$_</a><a id="940" class="Symbol">)</a>
<a id="942" class="Keyword">open</a> <a id="947" class="Keyword">import</a> <a id="954" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="971" class="Keyword">using</a> <a id="977" class="Symbol">(</a><a id="978" href="Relation.Nullary.html#1520" class="Record">Dec</a><a id="981" class="Symbol">;</a> <a id="983" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a><a id="986" class="Symbol">;</a> <a id="988" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a><a id="990" class="Symbol">)</a>
<a id="992" class="Keyword">open</a> <a id="997" class="Keyword">import</a> <a id="1004" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="1020" class="Keyword">using</a> <a id="1026" class="Symbol">(</a><a id="1027" href="Relation.Binary.Definitions.html#2787" class="InductiveConstructor">tri&lt;</a><a id="1031" class="Symbol">;</a> <a id="1033" href="Relation.Binary.Definitions.html#2841" class="InductiveConstructor">tri≈</a><a id="1037" class="Symbol">;</a> <a id="1039" href="Relation.Binary.Definitions.html#2895" class="InductiveConstructor">tri&gt;</a><a id="1043" class="Symbol">)</a>
</pre>
<h3 id="符号优先级">符号优先级</h3>
<pre class="Agda"><a id="1069" class="Keyword">infix</a> <a id="1075" class="Number">100</a> <a id="1079" href="FOL.Base.html#3422" class="Function Operator">~_</a>
<a id="1082" class="Keyword">infix</a> <a id="1088" class="Number">10</a> <a id="1091" href="FOL.Base.html#4184" class="Function Operator">_↑[_]_</a> <a id="1098" href="FOL.Base.html#4388" class="Function Operator">_↑_</a> <a id="1102" href="FOL.Base.html#4538" class="Function Operator">_↥[_]_</a> <a id="1109" href="FOL.Base.html#4825" class="Function Operator">_↥_</a> <a id="1113" href="FOL.Base.html#5969" class="Function Operator">_[_/_]</a>
<a id="1120" class="Keyword">infix</a> <a id="1126" class="Number">9</a> <a id="1128" href="FOL.Base.html#2847" class="InductiveConstructor Operator">_≈_</a>
<a id="1132" class="Keyword">infix</a> <a id="1138" class="Number">8</a> <a id="1140" href="FOL.Base.html#3658" class="Function Operator">_⇔_</a>
<a id="1144" class="Keyword">infix</a> <a id="1150" class="Number">7</a> <a id="1152" href="FOL.Base.html#2885" class="InductiveConstructor Operator">_⇒_</a>
<a id="1156" class="Keyword">infixr</a> <a id="1163" class="Number">6</a> <a id="1165" href="FOL.Base.html#3544" class="Function Operator">_∧_</a>
<a id="1169" class="Keyword">infixr</a> <a id="1176" class="Number">5</a> <a id="1178" href="FOL.Base.html#3603" class="Function Operator">_∨_</a>
</pre>
<h2 id="项">项</h2>
<p>与语言的处理类似地，我们把函数的元数编码进项的类型里：变量和常量是 <strong>0-项</strong>，n元函数是 <strong>n-项</strong>。此外，变量采用 <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin编码</a>，即把任意自然数当作变量。</p>
<p><strong>定义</strong> 归纳定义 l-项:</p>
<ul>
<li>对任意自然数 <code>n</code>，变量 <code>var n</code> 是 <code>0</code>-项.</li>
<li>对任意 <code>l</code> 元函数符号 <code>f</code>，函数 <code>func f</code> 是 <code>l</code>-项.</li>
<li>对任意 <code>suc l</code>-项 <code>t₁</code> 和任意 <code>0</code>-项 <code>t₂</code>，函数应用 <code>app t₁ t₂</code> 是 <code>l</code>-项.</li>
</ul>
<p>特别地，<code>0</code>-项简称项。</p>
<p>其中 <code>l</code> 可以看作是参数表的长度. 我们始终保留字母 l 来表示它.</p>
<pre class="Agda"><a id="1548" class="Keyword">variable</a>
  <a id="1559" href="FOL.Base.html#1559" class="Generalizable">l</a> <a id="1561" class="Symbol">:</a> <a id="1563" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>

<a id="1566" class="Keyword">data</a> <a id="Termₗ"></a><a id="1571" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1577" class="Symbol">:</a> <a id="1579" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1581" class="Symbol">→</a> <a id="1583" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1588" href="FOL.Base.html#632" class="Bound">u</a> <a id="1590" class="Keyword">where</a>
  <a id="Termₗ.var"></a><a id="1598" href="FOL.Base.html#1598" class="InductiveConstructor">var</a>  <a id="1603" class="Symbol">:</a> <a id="1605" class="Symbol">(</a><a id="1606" href="FOL.Base.html#1606" class="Bound">k</a> <a id="1608" class="Symbol">:</a> <a id="1610" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1611" class="Symbol">)</a> <a id="1613" class="Symbol">→</a> <a id="1615" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1621" class="Number">0</a>
  <a id="Termₗ.func"></a><a id="1625" href="FOL.Base.html#1625" class="InductiveConstructor">func</a> <a id="1630" class="Symbol">:</a> <a id="1632" class="Symbol">(</a><a id="1633" href="FOL.Base.html#1633" class="Bound">f</a> <a id="1635" class="Symbol">:</a> <a id="1637" href="FOL.Language.html#1485" class="Field">𝔉</a> <a id="1639" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="1640" class="Symbol">)</a> <a id="1642" class="Symbol">→</a> <a id="1644" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1650" href="FOL.Base.html#1559" class="Generalizable">l</a>
  <a id="Termₗ.app"></a><a id="1654" href="FOL.Base.html#1654" class="InductiveConstructor">app</a>  <a id="1659" class="Symbol">:</a> <a id="1661" class="Symbol">(</a><a id="1662" href="FOL.Base.html#1662" class="Bound">t₁</a> <a id="1665" class="Symbol">:</a> <a id="1667" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1673" class="Symbol">(</a><a id="1674" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1678" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="1679" class="Symbol">))</a> <a id="1682" class="Symbol">(</a><a id="1683" href="FOL.Base.html#1683" class="Bound">t₂</a> <a id="1686" class="Symbol">:</a> <a id="1688" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1694" class="Number">0</a><a id="1695" class="Symbol">)</a> <a id="1697" class="Symbol">→</a> <a id="1699" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1705" href="FOL.Base.html#1559" class="Generalizable">l</a>

<a id="Term"></a><a id="1708" href="FOL.Base.html#1708" class="Function">Term</a> <a id="1713" class="Symbol">=</a> <a id="1715" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1721" class="Number">0</a>
</pre>
<p>有时候我们希望把多元函数的参数全部应用上, 这时候可以用 <code>apps</code> 函数来实现.</p>
<pre class="Agda"><a id="apps"></a><a id="1780" href="FOL.Base.html#1780" class="Function">apps</a> <a id="1785" class="Symbol">:</a> <a id="1787" class="Symbol">(</a><a id="1788" href="FOL.Base.html#1788" class="Bound">t</a> <a id="1790" class="Symbol">:</a> <a id="1792" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="1798" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="1799" class="Symbol">)</a> <a id="1801" class="Symbol">(</a><a id="1802" href="FOL.Base.html#1802" class="Bound">ts</a> <a id="1805" class="Symbol">:</a> <a id="1807" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="1811" href="FOL.Base.html#1708" class="Function">Term</a> <a id="1816" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="1817" class="Symbol">)</a> <a id="1819" class="Symbol">→</a> <a id="1821" href="FOL.Base.html#1708" class="Function">Term</a>
<a id="1826" href="FOL.Base.html#1780" class="Function">apps</a> <a id="1831" href="FOL.Base.html#1831" class="Bound">t</a> <a id="1833" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a> <a id="1836" class="Symbol">=</a> <a id="1838" href="FOL.Base.html#1831" class="Bound">t</a>
<a id="1840" href="FOL.Base.html#1780" class="Function">apps</a> <a id="1845" href="FOL.Base.html#1845" class="Bound">f</a> <a id="1847" class="Symbol">(</a><a id="1848" href="FOL.Base.html#1848" class="Bound">t</a> <a id="1850" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="1852" href="FOL.Base.html#1852" class="Bound">ts</a><a id="1854" class="Symbol">)</a> <a id="1856" class="Symbol">=</a> <a id="1858" href="FOL.Base.html#1780" class="Function">apps</a> <a id="1863" class="Symbol">(</a><a id="1864" href="FOL.Base.html#1654" class="InductiveConstructor">app</a> <a id="1868" href="FOL.Base.html#1845" class="Bound">f</a> <a id="1870" href="FOL.Base.html#1848" class="Bound">t</a><a id="1871" class="Symbol">)</a> <a id="1873" href="FOL.Base.html#1852" class="Bound">ts</a>
</pre>
<h2 id="公式">公式</h2>
<p>n元关系在公式中的处理与n元函数在项中的处理类似, 我们把关系的元数编码进公式的类型里: n元关系是 <strong>n-公式</strong>.</p>
<p>至此, 非逻辑符号处理完毕. 接下来处理<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91#%E9%82%8F%E8%BC%AF%E7%AC%A6%E8%99%9F">逻辑符号</a>. 它们通常包括:</p>
<ol type="1">
<li>等号: = (≈)</li>
<li>量化符号:</li>
</ol>
<ul>
<li>全称量化: ∀ (∀’)</li>
<li>存在量化: ∃ (∃’)</li>
</ul>
<ol start="3" type="1">
<li>连接符号:</li>
</ol>
<ul>
<li>否定: ¬ (~)</li>
<li>蕴含: → (⇒)</li>
<li>等价: ↔︎ (⇔)</li>
<li>且: ∧</li>
<li>或: ∨</li>
</ul>
<p>括号中是为了避免与Agda元语言符号冲突而在本文中使用的符号.</p>
<p>这些符号不是独立的, 只需选取其中一些作为原始符号, 剩下的可以由它们推导出来. 不同的书根据不同的理由做出了不同的选取, 但得到的一阶逻辑系统基本是一样的. 我们根据Agda形式化的简便性 (具体会在后文逐渐体现), 选取等号 ≈, 蕴含 ⇒ , 全称量化 ∀’ 和恒假 ⊥ 作为原始符号.</p>
<p><strong>定义</strong> 归纳定义 l-公式:</p>
<ul>
<li>恒假 <code>⊥</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>l</code> 元关系符号 <code>r</code>，关系 <code>rel R</code> 是 <code>l</code>-公式.</li>
<li>对任意 <code>suc l</code>-公式 <code>φ</code> 和任意项 <code>t</code>，关系应用 <code>appᵣ φ t</code> 是 <code>l</code>-公式.</li>
<li>对任意项 <code>t₁</code> 和 <code>t₂</code>，等式 <code>t₁ ≈ t₂</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>0</code>-公式 <code>φ₁</code> 和任意 <code>0</code>-公式 <code>φ₂</code>，蕴含式 <code>φ₁ ⇒ φ₂</code> 是 <code>0</code>-公式.</li>
<li>对任意 <code>0</code>-公式 <code>φ</code>，全称量化式 <code>∀' φ</code> 是 <code>0</code>-公式.</li>
</ul>
<p>特别地, <code>0</code>-公式简称公式.</p>
<pre class="Agda"><a id="2701" class="Keyword">data</a> <a id="Formulaₗ"></a><a id="2706" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2715" class="Symbol">:</a> <a id="2717" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2719" class="Symbol">→</a> <a id="2721" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2726" href="FOL.Base.html#632" class="Bound">u</a> <a id="2728" class="Keyword">where</a>
  <a id="Formulaₗ.⊥"></a><a id="2736" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>     <a id="2742" class="Symbol">:</a> <a id="2744" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2753" class="Number">0</a>
  <a id="Formulaₗ.rel"></a><a id="2757" href="FOL.Base.html#2757" class="InductiveConstructor">rel</a>   <a id="2763" class="Symbol">:</a> <a id="2765" class="Symbol">(</a><a id="2766" href="FOL.Base.html#2766" class="Bound">R</a> <a id="2768" class="Symbol">:</a> <a id="2770" href="FOL.Language.html#1504" class="Field">ℜ</a> <a id="2772" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="2773" class="Symbol">)</a> <a id="2775" class="Symbol">→</a> <a id="2777" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2786" href="FOL.Base.html#1559" class="Generalizable">l</a>
  <a id="Formulaₗ.appᵣ"></a><a id="2790" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a>  <a id="2796" class="Symbol">:</a> <a id="2798" class="Symbol">(</a><a id="2799" href="FOL.Base.html#2799" class="Bound">φ</a> <a id="2801" class="Symbol">:</a> <a id="2803" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2812" class="Symbol">(</a><a id="2813" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2817" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="2818" class="Symbol">))</a> <a id="2821" class="Symbol">(</a><a id="2822" href="FOL.Base.html#2822" class="Bound">t</a> <a id="2824" class="Symbol">:</a> <a id="2826" href="FOL.Base.html#1708" class="Function">Term</a><a id="2830" class="Symbol">)</a> <a id="2832" class="Symbol">→</a> <a id="2834" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2843" href="FOL.Base.html#1559" class="Generalizable">l</a>
  <a id="Formulaₗ._≈_"></a><a id="2847" href="FOL.Base.html#2847" class="InductiveConstructor Operator">_≈_</a>   <a id="2853" class="Symbol">:</a> <a id="2855" class="Symbol">(</a><a id="2856" href="FOL.Base.html#2856" class="Bound">t₁</a> <a id="2859" href="FOL.Base.html#2859" class="Bound">t₂</a> <a id="2862" class="Symbol">:</a> <a id="2864" href="FOL.Base.html#1708" class="Function">Term</a><a id="2868" class="Symbol">)</a> <a id="2870" class="Symbol">→</a> <a id="2872" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2881" class="Number">0</a>
  <a id="Formulaₗ._⇒_"></a><a id="2885" href="FOL.Base.html#2885" class="InductiveConstructor Operator">_⇒_</a>   <a id="2891" class="Symbol">:</a> <a id="2893" class="Symbol">(</a><a id="2894" href="FOL.Base.html#2894" class="Bound">φ₁</a> <a id="2897" href="FOL.Base.html#2897" class="Bound">φ₂</a> <a id="2900" class="Symbol">:</a> <a id="2902" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2911" class="Number">0</a><a id="2912" class="Symbol">)</a> <a id="2914" class="Symbol">→</a> <a id="2916" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2925" class="Number">0</a>
  <a id="Formulaₗ.∀&#39;_"></a><a id="2929" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;_</a>   <a id="2935" class="Symbol">:</a> <a id="2937" class="Symbol">(</a><a id="2938" href="FOL.Base.html#2938" class="Bound">φ</a> <a id="2940" class="Symbol">:</a> <a id="2942" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2951" class="Number">0</a><a id="2952" class="Symbol">)</a> <a id="2954" class="Symbol">→</a> <a id="2956" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2965" class="Number">0</a>

<a id="Formula"></a><a id="2968" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="2976" class="Symbol">=</a> <a id="2978" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="2987" class="Number">0</a>
</pre>
<p>有时候我们希望把多元关系的参数全部应用上, 这时候可以用 <code>appsᵣ</code> 函数来实现.</p>
<pre class="Agda"><a id="appsᵣ"></a><a id="3047" href="FOL.Base.html#3047" class="Function">appsᵣ</a> <a id="3053" class="Symbol">:</a> <a id="3055" class="Symbol">(</a><a id="3056" href="FOL.Base.html#3056" class="Bound">φ</a> <a id="3058" class="Symbol">:</a> <a id="3060" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="3069" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="3070" class="Symbol">)</a> <a id="3072" class="Symbol">(</a><a id="3073" href="FOL.Base.html#3073" class="Bound">ts</a> <a id="3076" class="Symbol">:</a> <a id="3078" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="3082" href="FOL.Base.html#1708" class="Function">Term</a> <a id="3087" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="3088" class="Symbol">)</a> <a id="3090" class="Symbol">→</a> <a id="3092" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3100" href="FOL.Base.html#3047" class="Function">appsᵣ</a> <a id="3106" href="FOL.Base.html#3106" class="Bound">φ</a> <a id="3108" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a> <a id="3111" class="Symbol">=</a> <a id="3113" href="FOL.Base.html#3106" class="Bound">φ</a>
<a id="3115" href="FOL.Base.html#3047" class="Function">appsᵣ</a> <a id="3121" href="FOL.Base.html#3121" class="Bound">φ</a> <a id="3123" class="Symbol">(</a><a id="3124" href="FOL.Base.html#3124" class="Bound">t</a> <a id="3126" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="3128" href="FOL.Base.html#3128" class="Bound">ts</a><a id="3130" class="Symbol">)</a> <a id="3132" class="Symbol">=</a> <a id="3134" href="FOL.Base.html#3047" class="Function">appsᵣ</a> <a id="3140" class="Symbol">(</a><a id="3141" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a> <a id="3146" href="FOL.Base.html#3121" class="Bound">φ</a> <a id="3148" href="FOL.Base.html#3124" class="Bound">t</a><a id="3149" class="Symbol">)</a> <a id="3151" href="FOL.Base.html#3128" class="Bound">ts</a>
</pre>
<p><strong>注意</strong> 我们将元数编码进类型里是为了省去所谓的<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F">合式公式 (well-formed formula，WFF)</a> 谓词. 任意 <code>φ : Formula</code> 都是合式公式, 类型正确性保证了 <code>φ</code> 的合式性.</p>
<h2 id="导出符号">导出符号</h2>
<p>仿照类型论的处理, φ 的否定定义为 φ 蕴含恒假. 而恒真则是恒假的否定. 由于我们的对象逻辑是经典逻辑, 所以可以这样方便地处理.</p>
<pre class="Agda"><a id="~_"></a><a id="3422" href="FOL.Base.html#3422" class="Function Operator">~_</a> <a id="3425" class="Symbol">:</a> <a id="3427" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3435" class="Symbol">→</a> <a id="3437" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3445" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3447" href="FOL.Base.html#3447" class="Bound">φ</a> <a id="3449" class="Symbol">=</a> <a id="3451" href="FOL.Base.html#3447" class="Bound">φ</a> <a id="3453" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="3455" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>

<a id="⊤"></a><a id="3458" href="FOL.Base.html#3458" class="Function">⊤</a> <a id="3460" class="Symbol">:</a> <a id="3462" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3470" href="FOL.Base.html#3458" class="Function">⊤</a> <a id="3472" class="Symbol">=</a> <a id="3474" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3476" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>
</pre>
<p>其他逻辑符号的定义也是同样地利用了经典逻辑的特性. 它们都可以在加了排中律的 Agda 中”证”出来.</p>
<pre class="Agda"><a id="_∧_"></a><a id="3544" href="FOL.Base.html#3544" class="Function Operator">_∧_</a> <a id="3548" class="Symbol">:</a> <a id="3550" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3558" class="Symbol">→</a> <a id="3560" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3568" class="Symbol">→</a> <a id="3570" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3578" href="FOL.Base.html#3578" class="Bound">φ₁</a> <a id="3581" href="FOL.Base.html#3544" class="Function Operator">∧</a> <a id="3583" href="FOL.Base.html#3583" class="Bound">φ₂</a> <a id="3586" class="Symbol">=</a> <a id="3588" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3590" class="Symbol">(</a><a id="3591" href="FOL.Base.html#3578" class="Bound">φ₁</a> <a id="3594" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="3596" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3598" href="FOL.Base.html#3583" class="Bound">φ₂</a><a id="3600" class="Symbol">)</a>

<a id="_∨_"></a><a id="3603" href="FOL.Base.html#3603" class="Function Operator">_∨_</a> <a id="3607" class="Symbol">:</a> <a id="3609" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3617" class="Symbol">→</a> <a id="3619" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3627" class="Symbol">→</a> <a id="3629" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3637" href="FOL.Base.html#3637" class="Bound">φ₁</a> <a id="3640" href="FOL.Base.html#3603" class="Function Operator">∨</a> <a id="3642" href="FOL.Base.html#3642" class="Bound">φ₂</a> <a id="3645" class="Symbol">=</a> <a id="3647" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3649" href="FOL.Base.html#3637" class="Bound">φ₁</a> <a id="3652" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="3654" href="FOL.Base.html#3642" class="Bound">φ₂</a>

<a id="_⇔_"></a><a id="3658" href="FOL.Base.html#3658" class="Function Operator">_⇔_</a> <a id="3662" class="Symbol">:</a> <a id="3664" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3672" class="Symbol">→</a> <a id="3674" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3682" class="Symbol">→</a> <a id="3684" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3692" href="FOL.Base.html#3692" class="Bound">φ₁</a> <a id="3695" href="FOL.Base.html#3658" class="Function Operator">⇔</a> <a id="3697" href="FOL.Base.html#3697" class="Bound">φ₂</a> <a id="3700" class="Symbol">=</a> <a id="3702" href="FOL.Base.html#3692" class="Bound">φ₁</a> <a id="3705" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="3707" href="FOL.Base.html#3697" class="Bound">φ₂</a> <a id="3710" href="FOL.Base.html#3544" class="Function Operator">∧</a> <a id="3712" href="FOL.Base.html#3697" class="Bound">φ₂</a> <a id="3715" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="3717" href="FOL.Base.html#3692" class="Bound">φ₁</a>

<a id="∃&#39;_"></a><a id="3721" href="FOL.Base.html#3721" class="Function Operator">∃&#39;_</a> <a id="3725" class="Symbol">:</a> <a id="3727" href="FOL.Base.html#2968" class="Function">Formula</a> <a id="3735" class="Symbol">→</a> <a id="3737" href="FOL.Base.html#2968" class="Function">Formula</a>
<a id="3745" href="FOL.Base.html#3721" class="Function Operator">∃&#39;</a> <a id="3748" href="FOL.Base.html#3748" class="Bound">φ</a> <a id="3750" class="Symbol">=</a> <a id="3752" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3754" class="Symbol">(</a><a id="3755" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;</a> <a id="3758" href="FOL.Base.html#3422" class="Function Operator">~</a> <a id="3760" href="FOL.Base.html#3748" class="Bound">φ</a><a id="3761" class="Symbol">)</a>
</pre>
<h2 id="变量提升">变量提升</h2>
<p>变量提升属于<a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin编码</a>方案的一部分, 用于处理量词的绑定, 具体会在后文中体现.</p>
<p>简单来说, 变量提升就是把变量符号表 <code>var : ℕ → Term</code> 的某一段去掉, 以剩下的变量符号来重新表达原来的项和公式. 例如, 对项 <code>t</code>, 从 <code>var m</code> 开始, 去掉 <code>n</code> 个符号, 就叫做将 <code>t</code> 从 <code>m</code> 提升 <code>n</code>, 记作 <code>t ↑[ m ] n</code>.</p>
<p>如果项 <code>t</code> 使用了变量 <code>var 0</code>, <code>var 1</code>, <code>var 2</code>, <code>var 3</code>, 那么 <code>t ↑[ 1 ] 2</code> 则会使用变量 <code>var 0</code>, <code>var 3</code>, <code>var 4</code>, <code>var 5</code>.</p>
<p>特别地, 如果 <code>m = 0</code>, 就叫做将 <code>t</code> 提升 <code>n</code>, 记作 <code>t ↑ n</code>.</p>
<pre class="Agda"><a id="_↑[_]_"></a><a id="4184" href="FOL.Base.html#4184" class="Function Operator">_↑[_]_</a> <a id="4191" class="Symbol">:</a> <a id="4193" class="Symbol">(</a><a id="4194" href="FOL.Base.html#4194" class="Bound">t</a> <a id="4196" class="Symbol">:</a> <a id="4198" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="4204" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="4205" class="Symbol">)</a> <a id="4207" class="Symbol">(</a><a id="4208" href="FOL.Base.html#4208" class="Bound">m</a> <a id="4210" href="FOL.Base.html#4210" class="Bound">n</a> <a id="4212" class="Symbol">:</a> <a id="4214" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4215" class="Symbol">)</a> <a id="4217" class="Symbol">→</a> <a id="4219" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="4225" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="4227" href="FOL.Base.html#1598" class="InductiveConstructor">var</a> <a id="4231" href="FOL.Base.html#4231" class="Bound">k</a>     <a id="4237" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4240" href="FOL.Base.html#4240" class="Bound">m</a> <a id="4242" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4244" href="FOL.Base.html#4244" class="Bound">n</a> <a id="4246" class="Keyword">with</a> <a id="4251" href="FOL.Base.html#4231" class="Bound">k</a> <a id="4253" href="Data.Nat.Properties.html#10637" class="Function Operator">&lt;?</a> <a id="4256" href="FOL.Base.html#4240" class="Bound">m</a>
<a id="4258" class="Symbol">...</a> <a id="4262" class="Symbol">|</a> <a id="4264" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="4268" class="Symbol">_</a> <a id="4270" class="Symbol">=</a> <a id="4272" href="FOL.Base.html#1598" class="InductiveConstructor">var</a> <a id="4276" class="Bound">k</a>
<a id="4278" class="Symbol">...</a> <a id="4282" class="Symbol">|</a> <a id="4284" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a>  <a id="4288" class="Symbol">_</a> <a id="4290" class="Symbol">=</a> <a id="4292" href="FOL.Base.html#1598" class="InductiveConstructor">var</a> <a id="4296" class="Symbol">(</a><a id="4297" class="Bound">k</a> <a id="4299" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">ℕ.+</a> <a id="4303" class="Bound">n</a><a id="4304" class="Symbol">)</a>
<a id="4306" href="FOL.Base.html#1625" class="InductiveConstructor">func</a> <a id="4311" href="FOL.Base.html#4311" class="Bound">f</a>    <a id="4316" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4319" href="FOL.Base.html#4319" class="Bound">m</a> <a id="4321" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4323" href="FOL.Base.html#4323" class="Bound">n</a> <a id="4325" class="Symbol">=</a> <a id="4327" href="FOL.Base.html#1625" class="InductiveConstructor">func</a> <a id="4332" href="FOL.Base.html#4311" class="Bound">f</a>
<a id="4334" href="FOL.Base.html#1654" class="InductiveConstructor">app</a> <a id="4338" href="FOL.Base.html#4338" class="Bound">t₁</a> <a id="4341" href="FOL.Base.html#4341" class="Bound">t₂</a> <a id="4344" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4347" href="FOL.Base.html#4347" class="Bound">m</a> <a id="4349" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4351" href="FOL.Base.html#4351" class="Bound">n</a> <a id="4353" class="Symbol">=</a> <a id="4355" href="FOL.Base.html#1654" class="InductiveConstructor">app</a> <a id="4359" class="Symbol">(</a><a id="4360" href="FOL.Base.html#4338" class="Bound">t₁</a> <a id="4363" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4366" href="FOL.Base.html#4347" class="Bound">m</a> <a id="4368" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4370" href="FOL.Base.html#4351" class="Bound">n</a><a id="4371" class="Symbol">)</a> <a id="4373" class="Symbol">(</a><a id="4374" href="FOL.Base.html#4341" class="Bound">t₂</a> <a id="4377" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4380" href="FOL.Base.html#4347" class="Bound">m</a> <a id="4382" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4384" href="FOL.Base.html#4351" class="Bound">n</a><a id="4385" class="Symbol">)</a>

<a id="_↑_"></a><a id="4388" href="FOL.Base.html#4388" class="Function Operator">_↑_</a> <a id="4392" class="Symbol">:</a> <a id="4394" class="Symbol">(</a><a id="4395" href="FOL.Base.html#4395" class="Bound">t</a> <a id="4397" class="Symbol">:</a> <a id="4399" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="4405" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="4406" class="Symbol">)</a> <a id="4408" class="Symbol">(</a><a id="4409" href="FOL.Base.html#4409" class="Bound">n</a> <a id="4411" class="Symbol">:</a> <a id="4413" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4414" class="Symbol">)</a> <a id="4416" class="Symbol">→</a> <a id="4418" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="4424" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="4426" href="FOL.Base.html#4426" class="Bound">t</a> <a id="4428" href="FOL.Base.html#4388" class="Function Operator">↑</a> <a id="4430" href="FOL.Base.html#4430" class="Bound">n</a> <a id="4432" class="Symbol">=</a> <a id="4434" href="FOL.Base.html#4426" class="Bound">t</a> <a id="4436" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4439" class="Number">0</a> <a id="4441" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4443" href="FOL.Base.html#4430" class="Bound">n</a>
</pre>
<p>对公式的变量提升基本上就是对其中的项进行变量提升, 或者是对公式中的公式递归地提升. 只是对于量词构造的公式, 保留一位变量不提升, 以作为量词的绑定变量.</p>
<pre class="Agda"><a id="_↥[_]_"></a><a id="4538" href="FOL.Base.html#4538" class="Function Operator">_↥[_]_</a> <a id="4545" class="Symbol">:</a> <a id="4547" class="Symbol">(</a><a id="4548" href="FOL.Base.html#4548" class="Bound">φ</a> <a id="4550" class="Symbol">:</a> <a id="4552" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="4561" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="4562" class="Symbol">)</a> <a id="4564" class="Symbol">(</a><a id="4565" href="FOL.Base.html#4565" class="Bound">m</a> <a id="4567" href="FOL.Base.html#4567" class="Bound">n</a> <a id="4569" class="Symbol">:</a> <a id="4571" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4572" class="Symbol">)</a> <a id="4574" class="Symbol">→</a> <a id="4576" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="4585" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="4587" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>         <a id="4597" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4600" href="FOL.Base.html#4600" class="Bound">m</a> <a id="4602" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4604" href="FOL.Base.html#4604" class="Bound">n</a> <a id="4606" class="Symbol">=</a> <a id="4608" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>
<a id="4610" href="FOL.Base.html#2757" class="InductiveConstructor">rel</a> <a id="4614" href="FOL.Base.html#4614" class="Bound">R</a>     <a id="4620" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4623" href="FOL.Base.html#4623" class="Bound">m</a> <a id="4625" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4627" href="FOL.Base.html#4627" class="Bound">n</a> <a id="4629" class="Symbol">=</a> <a id="4631" href="FOL.Base.html#2757" class="InductiveConstructor">rel</a> <a id="4635" href="FOL.Base.html#4614" class="Bound">R</a>
<a id="4637" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a> <a id="4642" href="FOL.Base.html#4642" class="Bound">φ</a> <a id="4644" href="FOL.Base.html#4644" class="Bound">t</a>  <a id="4647" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4650" href="FOL.Base.html#4650" class="Bound">m</a> <a id="4652" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4654" href="FOL.Base.html#4654" class="Bound">n</a> <a id="4656" class="Symbol">=</a> <a id="4658" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a> <a id="4663" class="Symbol">(</a><a id="4664" href="FOL.Base.html#4642" class="Bound">φ</a> <a id="4666" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4669" href="FOL.Base.html#4650" class="Bound">m</a> <a id="4671" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4673" href="FOL.Base.html#4654" class="Bound">n</a><a id="4674" class="Symbol">)</a> <a id="4676" class="Symbol">(</a><a id="4677" href="FOL.Base.html#4644" class="Bound">t</a> <a id="4679" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4682" href="FOL.Base.html#4650" class="Bound">m</a> <a id="4684" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4686" href="FOL.Base.html#4654" class="Bound">n</a><a id="4687" class="Symbol">)</a>
<a id="4689" class="Symbol">(</a><a id="4690" href="FOL.Base.html#4690" class="Bound">t₁</a> <a id="4693" href="FOL.Base.html#2847" class="InductiveConstructor Operator">≈</a> <a id="4695" href="FOL.Base.html#4695" class="Bound">t₂</a><a id="4697" class="Symbol">)</a> <a id="4699" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4702" href="FOL.Base.html#4702" class="Bound">m</a> <a id="4704" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4706" href="FOL.Base.html#4706" class="Bound">n</a> <a id="4708" class="Symbol">=</a> <a id="4710" href="FOL.Base.html#4690" class="Bound">t₁</a> <a id="4713" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4716" href="FOL.Base.html#4702" class="Bound">m</a> <a id="4718" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4720" href="FOL.Base.html#4706" class="Bound">n</a> <a id="4722" href="FOL.Base.html#2847" class="InductiveConstructor Operator">≈</a> <a id="4724" href="FOL.Base.html#4695" class="Bound">t₂</a> <a id="4727" href="FOL.Base.html#4184" class="Function Operator">↑[</a> <a id="4730" href="FOL.Base.html#4702" class="Bound">m</a> <a id="4732" href="FOL.Base.html#4184" class="Function Operator">]</a> <a id="4734" href="FOL.Base.html#4706" class="Bound">n</a>
<a id="4736" class="Symbol">(</a><a id="4737" href="FOL.Base.html#4737" class="Bound">φ₁</a> <a id="4740" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="4742" href="FOL.Base.html#4742" class="Bound">φ₂</a><a id="4744" class="Symbol">)</a> <a id="4746" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4749" href="FOL.Base.html#4749" class="Bound">m</a> <a id="4751" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4753" href="FOL.Base.html#4753" class="Bound">n</a> <a id="4755" class="Symbol">=</a> <a id="4757" href="FOL.Base.html#4737" class="Bound">φ₁</a> <a id="4760" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4763" href="FOL.Base.html#4749" class="Bound">m</a> <a id="4765" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4767" href="FOL.Base.html#4753" class="Bound">n</a> <a id="4769" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="4771" href="FOL.Base.html#4742" class="Bound">φ₂</a> <a id="4774" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4777" href="FOL.Base.html#4749" class="Bound">m</a> <a id="4779" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4781" href="FOL.Base.html#4753" class="Bound">n</a>
<a id="4783" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;</a> <a id="4786" href="FOL.Base.html#4786" class="Bound">φ</a>      <a id="4793" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4796" href="FOL.Base.html#4796" class="Bound">m</a> <a id="4798" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4800" href="FOL.Base.html#4800" class="Bound">n</a> <a id="4802" class="Symbol">=</a> <a id="4804" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;</a> <a id="4807" class="Symbol">(</a><a id="4808" href="FOL.Base.html#4786" class="Bound">φ</a> <a id="4810" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4813" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="4817" href="FOL.Base.html#4796" class="Bound">m</a> <a id="4819" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4821" href="FOL.Base.html#4800" class="Bound">n</a><a id="4822" class="Symbol">)</a>

<a id="_↥_"></a><a id="4825" href="FOL.Base.html#4825" class="Function Operator">_↥_</a> <a id="4829" class="Symbol">:</a> <a id="4831" class="Symbol">(</a><a id="4832" href="FOL.Base.html#4832" class="Bound">φ</a> <a id="4834" class="Symbol">:</a> <a id="4836" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="4845" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="4846" class="Symbol">)</a> <a id="4848" class="Symbol">(</a><a id="4849" href="FOL.Base.html#4849" class="Bound">n</a> <a id="4851" class="Symbol">:</a> <a id="4853" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4854" class="Symbol">)</a> <a id="4856" class="Symbol">→</a> <a id="4858" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="4867" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="4869" href="FOL.Base.html#4869" class="Bound">φ</a> <a id="4871" href="FOL.Base.html#4825" class="Function Operator">↥</a> <a id="4873" href="FOL.Base.html#4873" class="Bound">n</a> <a id="4875" class="Symbol">=</a> <a id="4877" href="FOL.Base.html#4869" class="Bound">φ</a> <a id="4879" href="FOL.Base.html#4538" class="Function Operator">↥[</a> <a id="4882" class="Number">0</a> <a id="4884" href="FOL.Base.html#4538" class="Function Operator">]</a> <a id="4886" href="FOL.Base.html#4873" class="Bound">n</a>
</pre>
<h2 id="变量替换">变量替换</h2>
<p>变量替换用于处理量词绑定变量的替换和等量的替换. 首先我们需要一个帮助函数, 往序列 <code>𝓋 : ℕ → A</code> 中插入指定的项 <code>s</code> 于指定的位置 <code>n</code>. 例如, 如果 <code>v</code> 是序列</p>
<p><code>t₀ t₁ t₂ t₃ t₄ t₅ t₆ t₇ ...</code></p>
<p>那么 <code>insert s into 𝓋 at 4</code> 就是序列</p>
<p><code>t₀ t₁ t₂ t₃ s t₄ t₅ t₆ t₇ ...</code></p>
<pre class="Agda"><a id="insert_into_at_"></a><a id="5101" href="FOL.Base.html#5101" class="Function Operator">insert_into_at_</a> <a id="5117" class="Symbol">:</a> <a id="5119" class="Symbol">∀</a> <a id="5121" class="Symbol">{</a><a id="5122" href="FOL.Base.html#5122" class="Bound">u</a><a id="5123" class="Symbol">}</a> <a id="5125" class="Symbol">{</a><a id="5126" href="FOL.Base.html#5126" class="Bound">A</a> <a id="5128" class="Symbol">:</a> <a id="5130" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5135" href="FOL.Base.html#5122" class="Bound">u</a><a id="5136" class="Symbol">}</a> <a id="5138" class="Symbol">(</a><a id="5139" href="FOL.Base.html#5139" class="Bound">s</a> <a id="5141" class="Symbol">:</a> <a id="5143" href="FOL.Base.html#5126" class="Bound">A</a><a id="5144" class="Symbol">)</a> <a id="5146" class="Symbol">(</a><a id="5147" href="FOL.Base.html#5147" class="Bound">𝓋</a> <a id="5149" class="Symbol">:</a> <a id="5151" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5153" class="Symbol">→</a> <a id="5155" href="FOL.Base.html#5126" class="Bound">A</a><a id="5156" class="Symbol">)</a> <a id="5158" class="Symbol">(</a><a id="5159" href="FOL.Base.html#5159" class="Bound">n</a> <a id="5161" class="Symbol">:</a> <a id="5163" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5164" class="Symbol">)</a> <a id="5166" class="Symbol">→</a> <a id="5168" class="Symbol">(</a><a id="5169" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5171" class="Symbol">→</a> <a id="5173" href="FOL.Base.html#5126" class="Bound">A</a><a id="5174" class="Symbol">)</a>
<a id="5176" class="Symbol">(</a><a id="5177" href="FOL.Base.html#5101" class="Function Operator">insert</a> <a id="5184" href="FOL.Base.html#5184" class="Bound">s</a> <a id="5186" href="FOL.Base.html#5101" class="Function Operator">into</a> <a id="5191" href="FOL.Base.html#5191" class="Bound">𝓋</a> <a id="5193" href="FOL.Base.html#5101" class="Function Operator">at</a> <a id="5196" href="FOL.Base.html#5196" class="Bound">n</a><a id="5197" class="Symbol">)</a> <a id="5199" href="FOL.Base.html#5199" class="Bound">k</a> <a id="5201" class="Keyword">with</a> <a id="5206" href="Data.Nat.Properties.html#10322" class="Function">&lt;-cmp</a> <a id="5212" href="FOL.Base.html#5199" class="Bound">k</a> <a id="5214" href="FOL.Base.html#5196" class="Bound">n</a>
<a id="5216" class="Symbol">...</a> <a id="5220" class="Symbol">|</a> <a id="5222" href="Relation.Binary.Definitions.html#2787" class="InductiveConstructor">tri&lt;</a> <a id="5227" class="Symbol">_</a> <a id="5229" class="Symbol">_</a> <a id="5231" class="Symbol">_</a> <a id="5233" class="Symbol">=</a> <a id="5235" class="Bound">𝓋</a> <a id="5237" class="Bound">k</a>
<a id="5239" class="Symbol">...</a> <a id="5243" class="Symbol">|</a> <a id="5245" href="Relation.Binary.Definitions.html#2841" class="InductiveConstructor">tri≈</a> <a id="5250" class="Symbol">_</a> <a id="5252" class="Symbol">_</a> <a id="5254" class="Symbol">_</a> <a id="5256" class="Symbol">=</a> <a id="5258" class="Bound">s</a>
<a id="5260" class="Symbol">...</a> <a id="5264" class="Symbol">|</a> <a id="5266" href="Relation.Binary.Definitions.html#2895" class="InductiveConstructor">tri&gt;</a> <a id="5271" class="Symbol">_</a> <a id="5273" class="Symbol">_</a> <a id="5275" class="Symbol">_</a> <a id="5277" class="Symbol">=</a> <a id="5279" class="Bound">𝓋</a> <a id="5281" class="Symbol">(</a><a id="5282" class="Bound">k</a> <a id="5284" href="Data.Nat.Base.html#3140" class="Primitive Operator">∸</a> <a id="5286" class="Number">1</a><a id="5287" class="Symbol">)</a>
</pre>
<p>将项 <code>t</code> 中的变量 <code>var n</code> (如果存在) 替换为项 <code>s</code> 后得到的项记作 <code>t [ s /ₜ n ]</code>. 如果项是变量 <code>var k</code>, 那么将变量符号表 <code>var</code> 改造成 <code>insert (s ↑ n) into var at n</code>, 再取其中的第 <code>k</code> 个. 如果项是函数应用, 那么递归地替换其中的项.</p>
<p>其中, <code>insert (s ↑ n) into var at n</code> 的意思是往 <code>var</code> 中插入 <code>s ↑ n</code> 于 <code>n</code> 处. 将 <code>s</code> 提升 <code>n</code> 是为了保证 <code>s</code> 中的变量不会与 <code>t</code> 中的变量冲突.</p>
<pre class="Agda"><a id="_[_/_]ᵥ"></a><a id="5579" href="FOL.Base.html#5579" class="Function Operator">_[_/_]ᵥ</a> <a id="5587" class="Symbol">:</a> <a id="5589" class="Symbol">∀</a> <a id="5591" class="Symbol">{</a><a id="5592" href="FOL.Base.html#5592" class="Bound">u</a><a id="5593" class="Symbol">}</a> <a id="5595" class="Symbol">{</a><a id="5596" href="FOL.Base.html#5596" class="Bound">A</a> <a id="5598" class="Symbol">:</a> <a id="5600" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5605" href="FOL.Base.html#5592" class="Bound">u</a><a id="5606" class="Symbol">}</a> <a id="5608" class="Symbol">(</a><a id="5609" href="FOL.Base.html#5609" class="Bound">𝓋</a> <a id="5611" class="Symbol">:</a> <a id="5613" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5615" class="Symbol">→</a> <a id="5617" href="FOL.Base.html#5596" class="Bound">A</a><a id="5618" class="Symbol">)</a> <a id="5620" class="Symbol">(</a><a id="5621" href="FOL.Base.html#5621" class="Bound">s</a> <a id="5623" class="Symbol">:</a> <a id="5625" href="FOL.Base.html#5596" class="Bound">A</a><a id="5626" class="Symbol">)</a> <a id="5628" class="Symbol">(</a><a id="5629" href="FOL.Base.html#5629" class="Bound">n</a> <a id="5631" class="Symbol">:</a> <a id="5633" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5634" class="Symbol">)</a> <a id="5636" class="Symbol">→</a> <a id="5638" class="Symbol">(</a><a id="5639" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="5641" class="Symbol">→</a> <a id="5643" href="FOL.Base.html#5596" class="Bound">A</a><a id="5644" class="Symbol">)</a>
<a id="5646" href="FOL.Base.html#5646" class="Bound">𝓋</a> <a id="5648" href="FOL.Base.html#5579" class="Function Operator">[</a> <a id="5650" href="FOL.Base.html#5650" class="Bound">s</a> <a id="5652" href="FOL.Base.html#5579" class="Function Operator">/</a> <a id="5654" href="FOL.Base.html#5654" class="Bound">n</a> <a id="5656" href="FOL.Base.html#5579" class="Function Operator">]ᵥ</a> <a id="5659" class="Symbol">=</a> <a id="5661" href="FOL.Base.html#5101" class="Function Operator">insert</a> <a id="5668" href="FOL.Base.html#5650" class="Bound">s</a> <a id="5670" href="FOL.Base.html#5101" class="Function Operator">into</a> <a id="5675" href="FOL.Base.html#5646" class="Bound">𝓋</a> <a id="5677" href="FOL.Base.html#5101" class="Function Operator">at</a> <a id="5680" href="FOL.Base.html#5654" class="Bound">n</a>

<a id="_[_/_]ₜ"></a><a id="5683" href="FOL.Base.html#5683" class="Function Operator">_[_/_]ₜ</a> <a id="5691" class="Symbol">:</a> <a id="5693" class="Symbol">(</a><a id="5694" href="FOL.Base.html#5694" class="Bound">t</a> <a id="5696" class="Symbol">:</a> <a id="5698" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="5704" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="5705" class="Symbol">)</a> <a id="5707" class="Symbol">(</a><a id="5708" href="FOL.Base.html#5708" class="Bound">s</a> <a id="5710" class="Symbol">:</a> <a id="5712" href="FOL.Base.html#1708" class="Function">Term</a><a id="5716" class="Symbol">)</a> <a id="5718" class="Symbol">(</a><a id="5719" href="FOL.Base.html#5719" class="Bound">n</a> <a id="5721" class="Symbol">:</a> <a id="5723" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5724" class="Symbol">)</a> <a id="5726" class="Symbol">→</a> <a id="5728" href="FOL.Base.html#1571" class="Datatype">Termₗ</a> <a id="5734" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="5736" href="FOL.Base.html#1598" class="InductiveConstructor">var</a> <a id="5740" href="FOL.Base.html#5740" class="Bound">k</a>     <a id="5746" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="5748" href="FOL.Base.html#5748" class="Bound">s</a> <a id="5750" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="5752" href="FOL.Base.html#5752" class="Bound">n</a> <a id="5754" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a> <a id="5757" class="Symbol">=</a> <a id="5759" href="FOL.Base.html#1598" class="InductiveConstructor">var</a> <a id="5763" href="FOL.Base.html#5579" class="Function Operator">[</a> <a id="5765" class="Symbol">(</a><a id="5766" href="FOL.Base.html#5748" class="Bound">s</a> <a id="5768" href="FOL.Base.html#4388" class="Function Operator">↑</a> <a id="5770" href="FOL.Base.html#5752" class="Bound">n</a><a id="5771" class="Symbol">)</a> <a id="5773" href="FOL.Base.html#5579" class="Function Operator">/</a> <a id="5775" href="FOL.Base.html#5752" class="Bound">n</a> <a id="5777" href="FOL.Base.html#5579" class="Function Operator">]ᵥ</a> <a id="5780" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="5782" href="FOL.Base.html#5740" class="Bound">k</a>
<a id="5784" href="FOL.Base.html#1625" class="InductiveConstructor">func</a> <a id="5789" href="FOL.Base.html#5789" class="Bound">f</a>    <a id="5794" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="5796" href="FOL.Base.html#5796" class="Bound">s</a> <a id="5798" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="5800" href="FOL.Base.html#5800" class="Bound">n</a> <a id="5802" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a> <a id="5805" class="Symbol">=</a> <a id="5807" href="FOL.Base.html#1625" class="InductiveConstructor">func</a> <a id="5812" href="FOL.Base.html#5789" class="Bound">f</a>
<a id="5814" href="FOL.Base.html#1654" class="InductiveConstructor">app</a> <a id="5818" href="FOL.Base.html#5818" class="Bound">t₁</a> <a id="5821" href="FOL.Base.html#5821" class="Bound">t₂</a> <a id="5824" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="5826" href="FOL.Base.html#5826" class="Bound">s</a> <a id="5828" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="5830" href="FOL.Base.html#5830" class="Bound">n</a> <a id="5832" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a> <a id="5835" class="Symbol">=</a> <a id="5837" href="FOL.Base.html#1654" class="InductiveConstructor">app</a> <a id="5841" class="Symbol">(</a><a id="5842" href="FOL.Base.html#5818" class="Bound">t₁</a> <a id="5845" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="5847" href="FOL.Base.html#5826" class="Bound">s</a> <a id="5849" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="5851" href="FOL.Base.html#5830" class="Bound">n</a> <a id="5853" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a><a id="5855" class="Symbol">)</a> <a id="5857" class="Symbol">(</a><a id="5858" href="FOL.Base.html#5821" class="Bound">t₂</a> <a id="5861" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="5863" href="FOL.Base.html#5826" class="Bound">s</a> <a id="5865" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="5867" href="FOL.Base.html#5830" class="Bound">n</a> <a id="5869" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a><a id="5871" class="Symbol">)</a>
</pre>
<p>对公式的变量替换基本上就是对其中的项进行变量替换, 或者是对公式中的公式递归地替换. 只是对于量词构造的公式, 将替换的位置顺延一位, 因为首位是量词的绑定变量.</p>
<pre class="Agda"><a id="_[_/_]"></a><a id="5969" href="FOL.Base.html#5969" class="Function Operator">_[_/_]</a> <a id="5976" class="Symbol">:</a> <a id="5978" class="Symbol">(</a><a id="5979" href="FOL.Base.html#5979" class="Bound">φ</a> <a id="5981" class="Symbol">:</a> <a id="5983" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="5992" href="FOL.Base.html#1559" class="Generalizable">l</a><a id="5993" class="Symbol">)</a> <a id="5995" class="Symbol">(</a><a id="5996" href="FOL.Base.html#5996" class="Bound">s</a> <a id="5998" class="Symbol">:</a> <a id="6000" href="FOL.Base.html#1708" class="Function">Term</a><a id="6004" class="Symbol">)</a> <a id="6006" class="Symbol">(</a><a id="6007" href="FOL.Base.html#6007" class="Bound">n</a> <a id="6009" class="Symbol">:</a> <a id="6011" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="6012" class="Symbol">)</a> <a id="6014" class="Symbol">→</a> <a id="6016" href="FOL.Base.html#2706" class="Datatype">Formulaₗ</a> <a id="6025" href="FOL.Base.html#1559" class="Generalizable">l</a>
<a id="6027" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>         <a id="6037" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6039" href="FOL.Base.html#6039" class="Bound">s</a> <a id="6041" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6043" href="FOL.Base.html#6043" class="Bound">n</a> <a id="6045" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6047" class="Symbol">=</a> <a id="6049" href="FOL.Base.html#2736" class="InductiveConstructor">⊥</a>
<a id="6051" href="FOL.Base.html#2757" class="InductiveConstructor">rel</a> <a id="6055" href="FOL.Base.html#6055" class="Bound">R</a>     <a id="6061" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6063" href="FOL.Base.html#6063" class="Bound">s</a> <a id="6065" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6067" href="FOL.Base.html#6067" class="Bound">n</a> <a id="6069" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6071" class="Symbol">=</a> <a id="6073" href="FOL.Base.html#2757" class="InductiveConstructor">rel</a> <a id="6077" href="FOL.Base.html#6055" class="Bound">R</a>
<a id="6079" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a> <a id="6084" href="FOL.Base.html#6084" class="Bound">φ</a> <a id="6086" href="FOL.Base.html#6086" class="Bound">t</a>  <a id="6089" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6091" href="FOL.Base.html#6091" class="Bound">s</a> <a id="6093" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6095" href="FOL.Base.html#6095" class="Bound">n</a> <a id="6097" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6099" class="Symbol">=</a> <a id="6101" href="FOL.Base.html#2790" class="InductiveConstructor">appᵣ</a> <a id="6106" class="Symbol">(</a><a id="6107" href="FOL.Base.html#6084" class="Bound">φ</a> <a id="6109" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6111" href="FOL.Base.html#6091" class="Bound">s</a> <a id="6113" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6115" href="FOL.Base.html#6095" class="Bound">n</a> <a id="6117" href="FOL.Base.html#5969" class="Function Operator">]</a><a id="6118" class="Symbol">)</a> <a id="6120" class="Symbol">(</a><a id="6121" href="FOL.Base.html#6086" class="Bound">t</a> <a id="6123" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="6125" href="FOL.Base.html#6091" class="Bound">s</a> <a id="6127" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="6129" href="FOL.Base.html#6095" class="Bound">n</a> <a id="6131" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a><a id="6133" class="Symbol">)</a>
<a id="6135" class="Symbol">(</a><a id="6136" href="FOL.Base.html#6136" class="Bound">t₁</a> <a id="6139" href="FOL.Base.html#2847" class="InductiveConstructor Operator">≈</a> <a id="6141" href="FOL.Base.html#6141" class="Bound">t₂</a><a id="6143" class="Symbol">)</a> <a id="6145" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6147" href="FOL.Base.html#6147" class="Bound">s</a> <a id="6149" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6151" href="FOL.Base.html#6151" class="Bound">n</a> <a id="6153" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6155" class="Symbol">=</a> <a id="6157" href="FOL.Base.html#6136" class="Bound">t₁</a> <a id="6160" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="6162" href="FOL.Base.html#6147" class="Bound">s</a> <a id="6164" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="6166" href="FOL.Base.html#6151" class="Bound">n</a> <a id="6168" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a> <a id="6171" href="FOL.Base.html#2847" class="InductiveConstructor Operator">≈</a> <a id="6173" href="FOL.Base.html#6141" class="Bound">t₂</a> <a id="6176" href="FOL.Base.html#5683" class="Function Operator">[</a> <a id="6178" href="FOL.Base.html#6147" class="Bound">s</a> <a id="6180" href="FOL.Base.html#5683" class="Function Operator">/</a> <a id="6182" href="FOL.Base.html#6151" class="Bound">n</a> <a id="6184" href="FOL.Base.html#5683" class="Function Operator">]ₜ</a>
<a id="6187" class="Symbol">(</a><a id="6188" href="FOL.Base.html#6188" class="Bound">φ₁</a> <a id="6191" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="6193" href="FOL.Base.html#6193" class="Bound">φ₂</a><a id="6195" class="Symbol">)</a> <a id="6197" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6199" href="FOL.Base.html#6199" class="Bound">s</a> <a id="6201" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6203" href="FOL.Base.html#6203" class="Bound">n</a> <a id="6205" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6207" class="Symbol">=</a> <a id="6209" href="FOL.Base.html#6188" class="Bound">φ₁</a> <a id="6212" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6214" href="FOL.Base.html#6199" class="Bound">s</a> <a id="6216" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6218" href="FOL.Base.html#6203" class="Bound">n</a> <a id="6220" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6222" href="FOL.Base.html#2885" class="InductiveConstructor Operator">⇒</a> <a id="6224" href="FOL.Base.html#6193" class="Bound">φ₂</a> <a id="6227" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6229" href="FOL.Base.html#6199" class="Bound">s</a> <a id="6231" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6233" href="FOL.Base.html#6203" class="Bound">n</a> <a id="6235" href="FOL.Base.html#5969" class="Function Operator">]</a>
<a id="6237" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;</a> <a id="6240" href="FOL.Base.html#6240" class="Bound">φ</a>      <a id="6247" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6249" href="FOL.Base.html#6249" class="Bound">s</a> <a id="6251" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6253" href="FOL.Base.html#6253" class="Bound">n</a> <a id="6255" href="FOL.Base.html#5969" class="Function Operator">]</a> <a id="6257" class="Symbol">=</a> <a id="6259" href="FOL.Base.html#2929" class="InductiveConstructor Operator">∀&#39;</a> <a id="6262" class="Symbol">(</a><a id="6263" href="FOL.Base.html#6240" class="Bound">φ</a> <a id="6265" href="FOL.Base.html#5969" class="Function Operator">[</a> <a id="6267" href="FOL.Base.html#6249" class="Bound">s</a> <a id="6269" href="FOL.Base.html#5969" class="Function Operator">/</a> <a id="6271" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="6275" href="FOL.Base.html#6253" class="Bound">n</a> <a id="6277" href="FOL.Base.html#5969" class="Function Operator">]</a><a id="6278" class="Symbol">)</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
